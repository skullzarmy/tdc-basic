// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
	// Save the require from previous bundle to this closure if any
	var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
	var nodeRequire = typeof require === 'function' && require;

	function newRequire(name, jumped) {
		if (!cache[name]) {
			if (!modules[name]) {
				// if we cannot find the module within our internal map or
				// cache jump to the current global require ie. the last bundle
				// that was added to the page.
				var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
				if (!jumped && currentRequire) {
					return currentRequire(name, true);
				}

				// If there are other bundles on this page the require from the
				// previous one is saved to 'previousRequire'. Repeat this as
				// many times as there are bundles until the module is found or
				// we exhaust the require chain.
				if (previousRequire) {
					return previousRequire(name, true);
				}

				// Try the node require function if it exists.
				if (nodeRequire && typeof name === 'string') {
					return nodeRequire(name);
				}

				var err = new Error("Cannot find module '" + name + "'");
				err.code = 'MODULE_NOT_FOUND';
				throw err;
			}

			localRequire.resolve = resolve;
			localRequire.cache = {};

			var module = (cache[name] = new newRequire.Module(name));

			modules[name][0].call(module.exports, localRequire, module, module.exports, this);
		}

		return cache[name].exports;

		function localRequire(x) {
			return newRequire(localRequire.resolve(x));
		}

		function resolve(x) {
			return modules[name][1][x] || x;
		}
	}

	function Module(moduleName) {
		this.id = moduleName;
		this.bundle = newRequire;
		this.exports = {};
	}

	newRequire.isParcelRequire = true;
	newRequire.Module = Module;
	newRequire.modules = modules;
	newRequire.cache = cache;
	newRequire.parent = previousRequire;
	newRequire.register = function (id, exports) {
		modules[id] = [
			function (require, module) {
				module.exports = exports;
			},
			{}
		];
	};

	var error;
	for (var i = 0; i < entry.length; i++) {
		try {
			newRequire(entry[i]);
		} catch (e) {
			// Save first error but execute all entries
			if (!error) {
				error = e;
			}
		}
	}

	if (entry.length) {
		// Expose entry point to Node, AMD or browser globals
		// Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
		var mainExports = newRequire(entry[entry.length - 1]);

		// CommonJS
		if (typeof exports === 'object' && typeof module !== 'undefined') {
			module.exports = mainExports;

			// RequireJS
		} else if (typeof define === 'function' && define.amd) {
			define(function () {
				return mainExports;
			});

			// <script>
		} else if (globalName) {
			this[globalName] = mainExports;
		}
	}

	// Override the current require with this new one
	parcelRequire = newRequire;

	if (error) {
		// throw error from earlier, _after updating parcelRequire_
		throw error;
	}

	return newRequire;
})(
	{
		'../node_modules/stream-http/lib/capability.js': [
			function (require, module, exports) {
				var global = arguments[3];
				exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream);

				exports.writableStream = isFunction(global.WritableStream);

				exports.abortController = isFunction(global.AbortController);

				exports.blobConstructor = false;
				try {
					new Blob([new ArrayBuffer(1)]);
					exports.blobConstructor = true;
				} catch (e) {}

				// The xhr request to example.com may violate some restrictive CSP configurations,
				// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
				// and assume support for certain features below.
				var xhr;
				function getXHR() {
					// Cache the xhr value
					if (xhr !== undefined) return xhr;

					if (global.XMLHttpRequest) {
						xhr = new global.XMLHttpRequest();
						// If XDomainRequest is available (ie only, where xhr might not work
						// cross domain), use the page location. Otherwise use example.com
						// Note: this doesn't actually make an http request.
						try {
							xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com');
						} catch (e) {
							xhr = null;
						}
					} else {
						// Service workers don't have XHR
						xhr = null;
					}
					return xhr;
				}

				function checkTypeSupport(type) {
					var xhr = getXHR();
					if (!xhr) return false;
					try {
						xhr.responseType = type;
						return xhr.responseType === type;
					} catch (e) {}
					return false;
				}

				// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
				// Safari 7.1 appears to have fixed this bug.
				var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined';
				var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice);

				// If fetch is supported, then arraybuffer will be supported too. Skip calling
				// checkTypeSupport(), since that calls getXHR().
				exports.arraybuffer = exports.fetch || (haveArrayBuffer && checkTypeSupport('arraybuffer'));

				// These next two tests unavoidably show warnings in Chrome. Since fetch will always
				// be used if it's available, just return false for these to avoid the warnings.
				exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream');
				exports.mozchunkedarraybuffer =
					!exports.fetch && haveArrayBuffer && checkTypeSupport('moz-chunked-arraybuffer');

				// If fetch is supported, then overrideMimeType will be supported too. Skip calling
				// getXHR().
				exports.overrideMimeType =
					exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false);

				exports.vbArray = isFunction(global.VBArray);

				function isFunction(value) {
					return typeof value === 'function';
				}

				xhr = null; // Help gc
			},
			{}
		],
		'../node_modules/inherits/inherits_browser.js': [
			function (require, module, exports) {
				if (typeof Object.create === 'function') {
					// implementation from standard node.js 'util' module
					module.exports = function inherits(ctor, superCtor) {
						if (superCtor) {
							ctor.super_ = superCtor;
							ctor.prototype = Object.create(superCtor.prototype, {
								constructor: {
									value: ctor,
									enumerable: false,
									writable: true,
									configurable: true
								}
							});
						}
					};
				} else {
					// old school shim for old browsers
					module.exports = function inherits(ctor, superCtor) {
						if (superCtor) {
							ctor.super_ = superCtor;
							var TempCtor = function () {};
							TempCtor.prototype = superCtor.prototype;
							ctor.prototype = new TempCtor();
							ctor.prototype.constructor = ctor;
						}
					};
				}
			},
			{}
		],
		'../node_modules/process/browser.js': [
			function (require, module, exports) {
				// shim for using process in browser
				var process = (module.exports = {}); // cached from whatever global is present so that test runners that stub it
				// don't break things.  But we need to wrap it in a try catch in case it is
				// wrapped in strict mode code which doesn't define any globals.  It's inside a
				// function because try/catches deoptimize in certain engines.

				var cachedSetTimeout;
				var cachedClearTimeout;

				function defaultSetTimout() {
					throw new Error('setTimeout has not been defined');
				}

				function defaultClearTimeout() {
					throw new Error('clearTimeout has not been defined');
				}

				(function () {
					try {
						if (typeof setTimeout === 'function') {
							cachedSetTimeout = setTimeout;
						} else {
							cachedSetTimeout = defaultSetTimout;
						}
					} catch (e) {
						cachedSetTimeout = defaultSetTimout;
					}

					try {
						if (typeof clearTimeout === 'function') {
							cachedClearTimeout = clearTimeout;
						} else {
							cachedClearTimeout = defaultClearTimeout;
						}
					} catch (e) {
						cachedClearTimeout = defaultClearTimeout;
					}
				})();

				function runTimeout(fun) {
					if (cachedSetTimeout === setTimeout) {
						//normal enviroments in sane situations
						return setTimeout(fun, 0);
					} // if setTimeout wasn't available but was latter defined

					if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
						cachedSetTimeout = setTimeout;
						return setTimeout(fun, 0);
					}

					try {
						// when when somebody has screwed with setTimeout but no I.E. maddness
						return cachedSetTimeout(fun, 0);
					} catch (e) {
						try {
							// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
							return cachedSetTimeout.call(null, fun, 0);
						} catch (e) {
							// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
							return cachedSetTimeout.call(this, fun, 0);
						}
					}
				}

				function runClearTimeout(marker) {
					if (cachedClearTimeout === clearTimeout) {
						//normal enviroments in sane situations
						return clearTimeout(marker);
					} // if clearTimeout wasn't available but was latter defined

					if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
						cachedClearTimeout = clearTimeout;
						return clearTimeout(marker);
					}

					try {
						// when when somebody has screwed with setTimeout but no I.E. maddness
						return cachedClearTimeout(marker);
					} catch (e) {
						try {
							// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
							return cachedClearTimeout.call(null, marker);
						} catch (e) {
							// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
							// Some versions of I.E. have different rules for clearTimeout vs setTimeout
							return cachedClearTimeout.call(this, marker);
						}
					}
				}

				var queue = [];
				var draining = false;
				var currentQueue;
				var queueIndex = -1;

				function cleanUpNextTick() {
					if (!draining || !currentQueue) {
						return;
					}

					draining = false;

					if (currentQueue.length) {
						queue = currentQueue.concat(queue);
					} else {
						queueIndex = -1;
					}

					if (queue.length) {
						drainQueue();
					}
				}

				function drainQueue() {
					if (draining) {
						return;
					}

					var timeout = runTimeout(cleanUpNextTick);
					draining = true;
					var len = queue.length;

					while (len) {
						currentQueue = queue;
						queue = [];

						while (++queueIndex < len) {
							if (currentQueue) {
								currentQueue[queueIndex].run();
							}
						}

						queueIndex = -1;
						len = queue.length;
					}

					currentQueue = null;
					draining = false;
					runClearTimeout(timeout);
				}

				process.nextTick = function (fun) {
					var args = new Array(arguments.length - 1);

					if (arguments.length > 1) {
						for (var i = 1; i < arguments.length; i++) {
							args[i - 1] = arguments[i];
						}
					}

					queue.push(new Item(fun, args));

					if (queue.length === 1 && !draining) {
						runTimeout(drainQueue);
					}
				}; // v8 likes predictible objects

				function Item(fun, array) {
					this.fun = fun;
					this.array = array;
				}

				Item.prototype.run = function () {
					this.fun.apply(null, this.array);
				};

				process.title = 'browser';
				process.env = {};
				process.argv = [];
				process.version = ''; // empty string to avoid regexp issues

				process.versions = {};

				function noop() {}

				process.on = noop;
				process.addListener = noop;
				process.once = noop;
				process.off = noop;
				process.removeListener = noop;
				process.removeAllListeners = noop;
				process.emit = noop;
				process.prependListener = noop;
				process.prependOnceListener = noop;

				process.listeners = function (name) {
					return [];
				};

				process.binding = function (name) {
					throw new Error('process.binding is not supported');
				};

				process.cwd = function () {
					return '/';
				};

				process.chdir = function (dir) {
					throw new Error('process.chdir is not supported');
				};

				process.umask = function () {
					return 0;
				};
			},
			{}
		],
		'../node_modules/process-nextick-args/index.js': [
			function (require, module, exports) {
				var process = require('process');
				('use strict');

				if (
					typeof process === 'undefined' ||
					!process.version ||
					process.version.indexOf('v0.') === 0 ||
					(process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0)
				) {
					module.exports = { nextTick: nextTick };
				} else {
					module.exports = process;
				}

				function nextTick(fn, arg1, arg2, arg3) {
					if (typeof fn !== 'function') {
						throw new TypeError('"callback" argument must be a function');
					}
					var len = arguments.length;
					var args, i;
					switch (len) {
						case 0:
						case 1:
							return process.nextTick(fn);
						case 2:
							return process.nextTick(function afterTickOne() {
								fn.call(null, arg1);
							});
						case 3:
							return process.nextTick(function afterTickTwo() {
								fn.call(null, arg1, arg2);
							});
						case 4:
							return process.nextTick(function afterTickThree() {
								fn.call(null, arg1, arg2, arg3);
							});
						default:
							args = new Array(len - 1);
							i = 0;
							while (i < args.length) {
								args[i++] = arguments[i];
							}
							return process.nextTick(function afterTick() {
								fn.apply(null, args);
							});
					}
				}
			},
			{ process: '../node_modules/process/browser.js' }
		],
		'../node_modules/isarray/index.js': [
			function (require, module, exports) {
				var toString = {}.toString;

				module.exports =
					Array.isArray ||
					function (arr) {
						return toString.call(arr) == '[object Array]';
					};
			},
			{}
		],
		'../node_modules/events/events.js': [
			function (require, module, exports) {
				// Copyright Joyent, Inc. and other Node contributors.
				//
				// Permission is hereby granted, free of charge, to any person obtaining a
				// copy of this software and associated documentation files (the
				// "Software"), to deal in the Software without restriction, including
				// without limitation the rights to use, copy, modify, merge, publish,
				// distribute, sublicense, and/or sell copies of the Software, and to permit
				// persons to whom the Software is furnished to do so, subject to the
				// following conditions:
				//
				// The above copyright notice and this permission notice shall be included
				// in all copies or substantial portions of the Software.
				//
				// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
				// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
				// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
				// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
				// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
				// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
				// USE OR OTHER DEALINGS IN THE SOFTWARE.
				'use strict';

				var R = typeof Reflect === 'object' ? Reflect : null;
				var ReflectApply =
					R && typeof R.apply === 'function'
						? R.apply
						: function ReflectApply(target, receiver, args) {
								return Function.prototype.apply.call(target, receiver, args);
						  };
				var ReflectOwnKeys;

				if (R && typeof R.ownKeys === 'function') {
					ReflectOwnKeys = R.ownKeys;
				} else if (Object.getOwnPropertySymbols) {
					ReflectOwnKeys = function ReflectOwnKeys(target) {
						return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
					};
				} else {
					ReflectOwnKeys = function ReflectOwnKeys(target) {
						return Object.getOwnPropertyNames(target);
					};
				}

				function ProcessEmitWarning(warning) {
					if (console && console.warn) console.warn(warning);
				}

				var NumberIsNaN =
					Number.isNaN ||
					function NumberIsNaN(value) {
						return value !== value;
					};

				function EventEmitter() {
					EventEmitter.init.call(this);
				}

				module.exports = EventEmitter; // Backwards-compat with node 0.10.x

				EventEmitter.EventEmitter = EventEmitter;
				EventEmitter.prototype._events = undefined;
				EventEmitter.prototype._eventsCount = 0;
				EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
				// added to it. This is a useful default which helps finding memory leaks.

				var defaultMaxListeners = 10;
				Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
					enumerable: true,
					get: function () {
						return defaultMaxListeners;
					},
					set: function (arg) {
						if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
							throw new RangeError(
								'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
									arg +
									'.'
							);
						}

						defaultMaxListeners = arg;
					}
				});

				EventEmitter.init = function () {
					if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
						this._events = Object.create(null);
						this._eventsCount = 0;
					}

					this._maxListeners = this._maxListeners || undefined;
				}; // Obviously not all Emitters should be limited to 10. This function allows
				// that to be increased. Set to zero for unlimited.

				EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
					if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
						throw new RangeError(
							'The value of "n" is out of range. It must be a non-negative number. Received ' +
								n +
								'.'
						);
					}

					this._maxListeners = n;
					return this;
				};

				function $getMaxListeners(that) {
					if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
					return that._maxListeners;
				}

				EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
					return $getMaxListeners(this);
				};

				EventEmitter.prototype.emit = function emit(type) {
					var args = [];

					for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

					var doError = type === 'error';
					var events = this._events;
					if (events !== undefined) doError = doError && events.error === undefined;
					else if (!doError) return false; // If there is no 'error' event listener then throw.

					if (doError) {
						var er;
						if (args.length > 0) er = args[0];

						if (er instanceof Error) {
							// Note: The comments on the `throw` lines are intentional, they show
							// up in Node's output if this results in an unhandled exception.
							throw er; // Unhandled 'error' event
						} // At least give some kind of context to the user

						var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
						err.context = er;
						throw err; // Unhandled 'error' event
					}

					var handler = events[type];
					if (handler === undefined) return false;

					if (typeof handler === 'function') {
						ReflectApply(handler, this, args);
					} else {
						var len = handler.length;
						var listeners = arrayClone(handler, len);

						for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
					}

					return true;
				};

				function _addListener(target, type, listener, prepend) {
					var m;
					var events;
					var existing;

					if (typeof listener !== 'function') {
						throw new TypeError(
							'The "listener" argument must be of type Function. Received type ' + typeof listener
						);
					}

					events = target._events;

					if (events === undefined) {
						events = target._events = Object.create(null);
						target._eventsCount = 0;
					} else {
						// To avoid recursion in the case that type === "newListener"! Before
						// adding it to the listeners, first emit "newListener".
						if (events.newListener !== undefined) {
							target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
							// this._events to be assigned to a new object

							events = target._events;
						}

						existing = events[type];
					}

					if (existing === undefined) {
						// Optimize the case of one listener. Don't need the extra array object.
						existing = events[type] = listener;
						++target._eventsCount;
					} else {
						if (typeof existing === 'function') {
							// Adding the second element, need to change to array.
							existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
						} else if (prepend) {
							existing.unshift(listener);
						} else {
							existing.push(listener);
						} // Check for listener leak

						m = $getMaxListeners(target);

						if (m > 0 && existing.length > m && !existing.warned) {
							existing.warned = true; // No error code for this since it is a Warning
							// eslint-disable-next-line no-restricted-syntax

							var w = new Error(
								'Possible EventEmitter memory leak detected. ' +
									existing.length +
									' ' +
									String(type) +
									' listeners ' +
									'added. Use emitter.setMaxListeners() to ' +
									'increase limit'
							);
							w.name = 'MaxListenersExceededWarning';
							w.emitter = target;
							w.type = type;
							w.count = existing.length;
							ProcessEmitWarning(w);
						}
					}

					return target;
				}

				EventEmitter.prototype.addListener = function addListener(type, listener) {
					return _addListener(this, type, listener, false);
				};

				EventEmitter.prototype.on = EventEmitter.prototype.addListener;

				EventEmitter.prototype.prependListener = function prependListener(type, listener) {
					return _addListener(this, type, listener, true);
				};

				function onceWrapper() {
					var args = [];

					for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);

					if (!this.fired) {
						this.target.removeListener(this.type, this.wrapFn);
						this.fired = true;
						ReflectApply(this.listener, this.target, args);
					}
				}

				function _onceWrap(target, type, listener) {
					var state = {
						fired: false,
						wrapFn: undefined,
						target: target,
						type: type,
						listener: listener
					};
					var wrapped = onceWrapper.bind(state);
					wrapped.listener = listener;
					state.wrapFn = wrapped;
					return wrapped;
				}

				EventEmitter.prototype.once = function once(type, listener) {
					if (typeof listener !== 'function') {
						throw new TypeError(
							'The "listener" argument must be of type Function. Received type ' + typeof listener
						);
					}

					this.on(type, _onceWrap(this, type, listener));
					return this;
				};

				EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
					if (typeof listener !== 'function') {
						throw new TypeError(
							'The "listener" argument must be of type Function. Received type ' + typeof listener
						);
					}

					this.prependListener(type, _onceWrap(this, type, listener));
					return this;
				}; // Emits a 'removeListener' event if and only if the listener was removed.

				EventEmitter.prototype.removeListener = function removeListener(type, listener) {
					var list, events, position, i, originalListener;

					if (typeof listener !== 'function') {
						throw new TypeError(
							'The "listener" argument must be of type Function. Received type ' + typeof listener
						);
					}

					events = this._events;
					if (events === undefined) return this;
					list = events[type];
					if (list === undefined) return this;

					if (list === listener || list.listener === listener) {
						if (--this._eventsCount === 0) this._events = Object.create(null);
						else {
							delete events[type];
							if (events.removeListener)
								this.emit('removeListener', type, list.listener || listener);
						}
					} else if (typeof list !== 'function') {
						position = -1;

						for (i = list.length - 1; i >= 0; i--) {
							if (list[i] === listener || list[i].listener === listener) {
								originalListener = list[i].listener;
								position = i;
								break;
							}
						}

						if (position < 0) return this;
						if (position === 0) list.shift();
						else {
							spliceOne(list, position);
						}
						if (list.length === 1) events[type] = list[0];
						if (events.removeListener !== undefined)
							this.emit('removeListener', type, originalListener || listener);
					}

					return this;
				};

				EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

				EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
					var listeners, events, i;
					events = this._events;
					if (events === undefined) return this; // not listening for removeListener, no need to emit

					if (events.removeListener === undefined) {
						if (arguments.length === 0) {
							this._events = Object.create(null);
							this._eventsCount = 0;
						} else if (events[type] !== undefined) {
							if (--this._eventsCount === 0) this._events = Object.create(null);
							else delete events[type];
						}

						return this;
					} // emit removeListener for all listeners on all events

					if (arguments.length === 0) {
						var keys = Object.keys(events);
						var key;

						for (i = 0; i < keys.length; ++i) {
							key = keys[i];
							if (key === 'removeListener') continue;
							this.removeAllListeners(key);
						}

						this.removeAllListeners('removeListener');
						this._events = Object.create(null);
						this._eventsCount = 0;
						return this;
					}

					listeners = events[type];

					if (typeof listeners === 'function') {
						this.removeListener(type, listeners);
					} else if (listeners !== undefined) {
						// LIFO order
						for (i = listeners.length - 1; i >= 0; i--) {
							this.removeListener(type, listeners[i]);
						}
					}

					return this;
				};

				function _listeners(target, type, unwrap) {
					var events = target._events;
					if (events === undefined) return [];
					var evlistener = events[type];
					if (evlistener === undefined) return [];
					if (typeof evlistener === 'function')
						return unwrap ? [evlistener.listener || evlistener] : [evlistener];
					return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
				}

				EventEmitter.prototype.listeners = function listeners(type) {
					return _listeners(this, type, true);
				};

				EventEmitter.prototype.rawListeners = function rawListeners(type) {
					return _listeners(this, type, false);
				};

				EventEmitter.listenerCount = function (emitter, type) {
					if (typeof emitter.listenerCount === 'function') {
						return emitter.listenerCount(type);
					} else {
						return listenerCount.call(emitter, type);
					}
				};

				EventEmitter.prototype.listenerCount = listenerCount;

				function listenerCount(type) {
					var events = this._events;

					if (events !== undefined) {
						var evlistener = events[type];

						if (typeof evlistener === 'function') {
							return 1;
						} else if (evlistener !== undefined) {
							return evlistener.length;
						}
					}

					return 0;
				}

				EventEmitter.prototype.eventNames = function eventNames() {
					return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
				};

				function arrayClone(arr, n) {
					var copy = new Array(n);

					for (var i = 0; i < n; ++i) copy[i] = arr[i];

					return copy;
				}

				function spliceOne(list, index) {
					for (; index + 1 < list.length; index++) list[index] = list[index + 1];

					list.pop();
				}

				function unwrapListeners(arr) {
					var ret = new Array(arr.length);

					for (var i = 0; i < ret.length; ++i) {
						ret[i] = arr[i].listener || arr[i];
					}

					return ret;
				}
			},
			{}
		],
		'../node_modules/readable-stream/lib/internal/streams/stream-browser.js': [
			function (require, module, exports) {
				module.exports = require('events').EventEmitter;
			},
			{ events: '../node_modules/events/events.js' }
		],
		'../node_modules/base64-js/index.js': [
			function (require, module, exports) {
				'use strict';

				exports.byteLength = byteLength;
				exports.toByteArray = toByteArray;
				exports.fromByteArray = fromByteArray;

				var lookup = [];
				var revLookup = [];
				var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

				var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
				for (var i = 0, len = code.length; i < len; ++i) {
					lookup[i] = code[i];
					revLookup[code.charCodeAt(i)] = i;
				}

				// Support decoding URL-safe base64 strings, as Node.js does.
				// See: https://en.wikipedia.org/wiki/Base64#URL_applications
				revLookup['-'.charCodeAt(0)] = 62;
				revLookup['_'.charCodeAt(0)] = 63;

				function getLens(b64) {
					var len = b64.length;

					if (len % 4 > 0) {
						throw new Error('Invalid string. Length must be a multiple of 4');
					}

					// Trim off extra bytes after placeholder bytes are found
					// See: https://github.com/beatgammit/base64-js/issues/42
					var validLen = b64.indexOf('=');
					if (validLen === -1) validLen = len;

					var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);

					return [validLen, placeHoldersLen];
				}

				// base64 is 4/3 + up to two characters of the original data
				function byteLength(b64) {
					var lens = getLens(b64);
					var validLen = lens[0];
					var placeHoldersLen = lens[1];
					return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
				}

				function _byteLength(b64, validLen, placeHoldersLen) {
					return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
				}

				function toByteArray(b64) {
					var tmp;
					var lens = getLens(b64);
					var validLen = lens[0];
					var placeHoldersLen = lens[1];

					var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

					var curByte = 0;

					// if there are placeholders, only get up to the last complete 4 chars
					var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

					var i;
					for (i = 0; i < len; i += 4) {
						tmp =
							(revLookup[b64.charCodeAt(i)] << 18) |
							(revLookup[b64.charCodeAt(i + 1)] << 12) |
							(revLookup[b64.charCodeAt(i + 2)] << 6) |
							revLookup[b64.charCodeAt(i + 3)];
						arr[curByte++] = (tmp >> 16) & 0xff;
						arr[curByte++] = (tmp >> 8) & 0xff;
						arr[curByte++] = tmp & 0xff;
					}

					if (placeHoldersLen === 2) {
						tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
						arr[curByte++] = tmp & 0xff;
					}

					if (placeHoldersLen === 1) {
						tmp =
							(revLookup[b64.charCodeAt(i)] << 10) |
							(revLookup[b64.charCodeAt(i + 1)] << 4) |
							(revLookup[b64.charCodeAt(i + 2)] >> 2);
						arr[curByte++] = (tmp >> 8) & 0xff;
						arr[curByte++] = tmp & 0xff;
					}

					return arr;
				}

				function tripletToBase64(num) {
					return (
						lookup[(num >> 18) & 0x3f] +
						lookup[(num >> 12) & 0x3f] +
						lookup[(num >> 6) & 0x3f] +
						lookup[num & 0x3f]
					);
				}

				function encodeChunk(uint8, start, end) {
					var tmp;
					var output = [];
					for (var i = start; i < end; i += 3) {
						tmp =
							((uint8[i] << 16) & 0xff0000) +
							((uint8[i + 1] << 8) & 0xff00) +
							(uint8[i + 2] & 0xff);
						output.push(tripletToBase64(tmp));
					}
					return output.join('');
				}

				function fromByteArray(uint8) {
					var tmp;
					var len = uint8.length;
					var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
					var parts = [];
					var maxChunkLength = 16383; // must be multiple of 3

					// go through the array every three bytes, we'll deal with trailing stuff later
					for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
						parts.push(
							encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength)
						);
					}

					// pad the end with zeros, but make sure to not forget the extra bytes
					if (extraBytes === 1) {
						tmp = uint8[len - 1];
						parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + '==');
					} else if (extraBytes === 2) {
						tmp = (uint8[len - 2] << 8) + uint8[len - 1];
						parts.push(
							lookup[tmp >> 10] + lookup[(tmp >> 4) & 0x3f] + lookup[(tmp << 2) & 0x3f] + '='
						);
					}

					return parts.join('');
				}
			},
			{}
		],
		'../node_modules/ieee754/index.js': [
			function (require, module, exports) {
				/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
				exports.read = function (buffer, offset, isLE, mLen, nBytes) {
					var e, m;
					var eLen = nBytes * 8 - mLen - 1;
					var eMax = (1 << eLen) - 1;
					var eBias = eMax >> 1;
					var nBits = -7;
					var i = isLE ? nBytes - 1 : 0;
					var d = isLE ? -1 : 1;
					var s = buffer[offset + i];

					i += d;

					e = s & ((1 << -nBits) - 1);
					s >>= -nBits;
					nBits += eLen;
					for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

					m = e & ((1 << -nBits) - 1);
					e >>= -nBits;
					nBits += mLen;
					for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

					if (e === 0) {
						e = 1 - eBias;
					} else if (e === eMax) {
						return m ? NaN : (s ? -1 : 1) * Infinity;
					} else {
						m = m + Math.pow(2, mLen);
						e = e - eBias;
					}
					return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
				};

				exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
					var e, m, c;
					var eLen = nBytes * 8 - mLen - 1;
					var eMax = (1 << eLen) - 1;
					var eBias = eMax >> 1;
					var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
					var i = isLE ? 0 : nBytes - 1;
					var d = isLE ? 1 : -1;
					var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

					value = Math.abs(value);

					if (isNaN(value) || value === Infinity) {
						m = isNaN(value) ? 1 : 0;
						e = eMax;
					} else {
						e = Math.floor(Math.log(value) / Math.LN2);
						if (value * (c = Math.pow(2, -e)) < 1) {
							e--;
							c *= 2;
						}
						if (e + eBias >= 1) {
							value += rt / c;
						} else {
							value += rt * Math.pow(2, 1 - eBias);
						}
						if (value * c >= 2) {
							e++;
							c /= 2;
						}

						if (e + eBias >= eMax) {
							m = 0;
							e = eMax;
						} else if (e + eBias >= 1) {
							m = (value * c - 1) * Math.pow(2, mLen);
							e = e + eBias;
						} else {
							m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
							e = 0;
						}
					}

					for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

					e = (e << mLen) | m;
					eLen += mLen;
					for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

					buffer[offset + i - d] |= s * 128;
				};
			},
			{}
		],
		'../node_modules/node-libs-browser/node_modules/buffer/index.js': [
			function (require, module, exports) {
				var global = arguments[3];
				/*!
				 * The buffer module from node.js, for the browser.
				 *
				 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
				 * @license  MIT
				 */
				/* eslint-disable no-proto */

				('use strict');

				var base64 = require('base64-js');
				var ieee754 = require('ieee754');
				var isArray = require('isarray');

				exports.Buffer = Buffer;
				exports.SlowBuffer = SlowBuffer;
				exports.INSPECT_MAX_BYTES = 50;

				/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
				Buffer.TYPED_ARRAY_SUPPORT =
					global.TYPED_ARRAY_SUPPORT !== undefined
						? global.TYPED_ARRAY_SUPPORT
						: typedArraySupport();

				/*
				 * Export kMaxLength after typed array support is determined.
				 */
				exports.kMaxLength = kMaxLength();

				function typedArraySupport() {
					try {
						var arr = new Uint8Array(1);
						arr.__proto__ = {
							__proto__: Uint8Array.prototype,
							foo: function () {
								return 42;
							}
						};
						return (
							arr.foo() === 42 && // typed array instances can be augmented
							typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
							arr.subarray(1, 1).byteLength === 0
						); // ie10 has broken `subarray`
					} catch (e) {
						return false;
					}
				}

				function kMaxLength() {
					return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
				}

				function createBuffer(that, length) {
					if (kMaxLength() < length) {
						throw new RangeError('Invalid typed array length');
					}
					if (Buffer.TYPED_ARRAY_SUPPORT) {
						// Return an augmented `Uint8Array` instance, for best performance
						that = new Uint8Array(length);
						that.__proto__ = Buffer.prototype;
					} else {
						// Fallback: Return an object instance of the Buffer class
						if (that === null) {
							that = new Buffer(length);
						}
						that.length = length;
					}

					return that;
				}

				/**
				 * The Buffer constructor returns instances of `Uint8Array` that have their
				 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
				 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
				 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
				 * returns a single octet.
				 *
				 * The `Uint8Array` prototype remains unmodified.
				 */

				function Buffer(arg, encodingOrOffset, length) {
					if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
						return new Buffer(arg, encodingOrOffset, length);
					}

					// Common case.
					if (typeof arg === 'number') {
						if (typeof encodingOrOffset === 'string') {
							throw new Error('If encoding is specified then the first argument must be a string');
						}
						return allocUnsafe(this, arg);
					}
					return from(this, arg, encodingOrOffset, length);
				}

				Buffer.poolSize = 8192; // not used by this implementation

				// TODO: Legacy, not needed anymore. Remove in next major version.
				Buffer._augment = function (arr) {
					arr.__proto__ = Buffer.prototype;
					return arr;
				};

				function from(that, value, encodingOrOffset, length) {
					if (typeof value === 'number') {
						throw new TypeError('"value" argument must not be a number');
					}

					if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
						return fromArrayBuffer(that, value, encodingOrOffset, length);
					}

					if (typeof value === 'string') {
						return fromString(that, value, encodingOrOffset);
					}

					return fromObject(that, value);
				}

				/**
				 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
				 * if value is a number.
				 * Buffer.from(str[, encoding])
				 * Buffer.from(array)
				 * Buffer.from(buffer)
				 * Buffer.from(arrayBuffer[, byteOffset[, length]])
				 **/
				Buffer.from = function (value, encodingOrOffset, length) {
					return from(null, value, encodingOrOffset, length);
				};

				if (Buffer.TYPED_ARRAY_SUPPORT) {
					Buffer.prototype.__proto__ = Uint8Array.prototype;
					Buffer.__proto__ = Uint8Array;
					if (
						typeof Symbol !== 'undefined' &&
						Symbol.species &&
						Buffer[Symbol.species] === Buffer
					) {
						// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
						Object.defineProperty(Buffer, Symbol.species, {
							value: null,
							configurable: true
						});
					}
				}

				function assertSize(size) {
					if (typeof size !== 'number') {
						throw new TypeError('"size" argument must be a number');
					} else if (size < 0) {
						throw new RangeError('"size" argument must not be negative');
					}
				}

				function alloc(that, size, fill, encoding) {
					assertSize(size);
					if (size <= 0) {
						return createBuffer(that, size);
					}
					if (fill !== undefined) {
						// Only pay attention to encoding if it's a string. This
						// prevents accidentally sending in a number that would
						// be interpretted as a start offset.
						return typeof encoding === 'string'
							? createBuffer(that, size).fill(fill, encoding)
							: createBuffer(that, size).fill(fill);
					}
					return createBuffer(that, size);
				}

				/**
				 * Creates a new filled Buffer instance.
				 * alloc(size[, fill[, encoding]])
				 **/
				Buffer.alloc = function (size, fill, encoding) {
					return alloc(null, size, fill, encoding);
				};

				function allocUnsafe(that, size) {
					assertSize(size);
					that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
					if (!Buffer.TYPED_ARRAY_SUPPORT) {
						for (var i = 0; i < size; ++i) {
							that[i] = 0;
						}
					}
					return that;
				}

				/**
				 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
				 * */
				Buffer.allocUnsafe = function (size) {
					return allocUnsafe(null, size);
				};
				/**
				 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
				 */
				Buffer.allocUnsafeSlow = function (size) {
					return allocUnsafe(null, size);
				};

				function fromString(that, string, encoding) {
					if (typeof encoding !== 'string' || encoding === '') {
						encoding = 'utf8';
					}

					if (!Buffer.isEncoding(encoding)) {
						throw new TypeError('"encoding" must be a valid string encoding');
					}

					var length = byteLength(string, encoding) | 0;
					that = createBuffer(that, length);

					var actual = that.write(string, encoding);

					if (actual !== length) {
						// Writing a hex string, for example, that contains invalid characters will
						// cause everything after the first invalid character to be ignored. (e.g.
						// 'abxxcd' will be treated as 'ab')
						that = that.slice(0, actual);
					}

					return that;
				}

				function fromArrayLike(that, array) {
					var length = array.length < 0 ? 0 : checked(array.length) | 0;
					that = createBuffer(that, length);
					for (var i = 0; i < length; i += 1) {
						that[i] = array[i] & 255;
					}
					return that;
				}

				function fromArrayBuffer(that, array, byteOffset, length) {
					array.byteLength; // this throws if `array` is not a valid ArrayBuffer

					if (byteOffset < 0 || array.byteLength < byteOffset) {
						throw new RangeError("'offset' is out of bounds");
					}

					if (array.byteLength < byteOffset + (length || 0)) {
						throw new RangeError("'length' is out of bounds");
					}

					if (byteOffset === undefined && length === undefined) {
						array = new Uint8Array(array);
					} else if (length === undefined) {
						array = new Uint8Array(array, byteOffset);
					} else {
						array = new Uint8Array(array, byteOffset, length);
					}

					if (Buffer.TYPED_ARRAY_SUPPORT) {
						// Return an augmented `Uint8Array` instance, for best performance
						that = array;
						that.__proto__ = Buffer.prototype;
					} else {
						// Fallback: Return an object instance of the Buffer class
						that = fromArrayLike(that, array);
					}
					return that;
				}

				function fromObject(that, obj) {
					if (Buffer.isBuffer(obj)) {
						var len = checked(obj.length) | 0;
						that = createBuffer(that, len);

						if (that.length === 0) {
							return that;
						}

						obj.copy(that, 0, 0, len);
						return that;
					}

					if (obj) {
						if (
							(typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer) ||
							'length' in obj
						) {
							if (typeof obj.length !== 'number' || isnan(obj.length)) {
								return createBuffer(that, 0);
							}
							return fromArrayLike(that, obj);
						}

						if (obj.type === 'Buffer' && isArray(obj.data)) {
							return fromArrayLike(that, obj.data);
						}
					}

					throw new TypeError(
						'First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.'
					);
				}

				function checked(length) {
					// Note: cannot use `length < kMaxLength()` here because that fails when
					// length is NaN (which is otherwise coerced to zero.)
					if (length >= kMaxLength()) {
						throw new RangeError(
							'Attempt to allocate Buffer larger than maximum ' +
								'size: 0x' +
								kMaxLength().toString(16) +
								' bytes'
						);
					}
					return length | 0;
				}

				function SlowBuffer(length) {
					if (+length != length) {
						// eslint-disable-line eqeqeq
						length = 0;
					}
					return Buffer.alloc(+length);
				}

				Buffer.isBuffer = function isBuffer(b) {
					return !!(b != null && b._isBuffer);
				};

				Buffer.compare = function compare(a, b) {
					if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
						throw new TypeError('Arguments must be Buffers');
					}

					if (a === b) return 0;

					var x = a.length;
					var y = b.length;

					for (var i = 0, len = Math.min(x, y); i < len; ++i) {
						if (a[i] !== b[i]) {
							x = a[i];
							y = b[i];
							break;
						}
					}

					if (x < y) return -1;
					if (y < x) return 1;
					return 0;
				};

				Buffer.isEncoding = function isEncoding(encoding) {
					switch (String(encoding).toLowerCase()) {
						case 'hex':
						case 'utf8':
						case 'utf-8':
						case 'ascii':
						case 'latin1':
						case 'binary':
						case 'base64':
						case 'ucs2':
						case 'ucs-2':
						case 'utf16le':
						case 'utf-16le':
							return true;
						default:
							return false;
					}
				};

				Buffer.concat = function concat(list, length) {
					if (!isArray(list)) {
						throw new TypeError('"list" argument must be an Array of Buffers');
					}

					if (list.length === 0) {
						return Buffer.alloc(0);
					}

					var i;
					if (length === undefined) {
						length = 0;
						for (i = 0; i < list.length; ++i) {
							length += list[i].length;
						}
					}

					var buffer = Buffer.allocUnsafe(length);
					var pos = 0;
					for (i = 0; i < list.length; ++i) {
						var buf = list[i];
						if (!Buffer.isBuffer(buf)) {
							throw new TypeError('"list" argument must be an Array of Buffers');
						}
						buf.copy(buffer, pos);
						pos += buf.length;
					}
					return buffer;
				};

				function byteLength(string, encoding) {
					if (Buffer.isBuffer(string)) {
						return string.length;
					}
					if (
						typeof ArrayBuffer !== 'undefined' &&
						typeof ArrayBuffer.isView === 'function' &&
						(ArrayBuffer.isView(string) || string instanceof ArrayBuffer)
					) {
						return string.byteLength;
					}
					if (typeof string !== 'string') {
						string = '' + string;
					}

					var len = string.length;
					if (len === 0) return 0;

					// Use a for loop to avoid recursion
					var loweredCase = false;
					for (;;) {
						switch (encoding) {
							case 'ascii':
							case 'latin1':
							case 'binary':
								return len;
							case 'utf8':
							case 'utf-8':
							case undefined:
								return utf8ToBytes(string).length;
							case 'ucs2':
							case 'ucs-2':
							case 'utf16le':
							case 'utf-16le':
								return len * 2;
							case 'hex':
								return len >>> 1;
							case 'base64':
								return base64ToBytes(string).length;
							default:
								if (loweredCase) return utf8ToBytes(string).length; // assume utf8
								encoding = ('' + encoding).toLowerCase();
								loweredCase = true;
						}
					}
				}
				Buffer.byteLength = byteLength;

				function slowToString(encoding, start, end) {
					var loweredCase = false;

					// No need to verify that "this.length <= MAX_UINT32" since it's a read-only
					// property of a typed array.

					// This behaves neither like String nor Uint8Array in that we set start/end
					// to their upper/lower bounds if the value passed is out of range.
					// undefined is handled specially as per ECMA-262 6th Edition,
					// Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
					if (start === undefined || start < 0) {
						start = 0;
					}
					// Return early if start > this.length. Done here to prevent potential uint32
					// coercion fail below.
					if (start > this.length) {
						return '';
					}

					if (end === undefined || end > this.length) {
						end = this.length;
					}

					if (end <= 0) {
						return '';
					}

					// Force coersion to uint32. This will also coerce falsey/NaN values to 0.
					end >>>= 0;
					start >>>= 0;

					if (end <= start) {
						return '';
					}

					if (!encoding) encoding = 'utf8';

					while (true) {
						switch (encoding) {
							case 'hex':
								return hexSlice(this, start, end);

							case 'utf8':
							case 'utf-8':
								return utf8Slice(this, start, end);

							case 'ascii':
								return asciiSlice(this, start, end);

							case 'latin1':
							case 'binary':
								return latin1Slice(this, start, end);

							case 'base64':
								return base64Slice(this, start, end);

							case 'ucs2':
							case 'ucs-2':
							case 'utf16le':
							case 'utf-16le':
								return utf16leSlice(this, start, end);

							default:
								if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
								encoding = (encoding + '').toLowerCase();
								loweredCase = true;
						}
					}
				}

				// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
				// Buffer instances.
				Buffer.prototype._isBuffer = true;

				function swap(b, n, m) {
					var i = b[n];
					b[n] = b[m];
					b[m] = i;
				}

				Buffer.prototype.swap16 = function swap16() {
					var len = this.length;
					if (len % 2 !== 0) {
						throw new RangeError('Buffer size must be a multiple of 16-bits');
					}
					for (var i = 0; i < len; i += 2) {
						swap(this, i, i + 1);
					}
					return this;
				};

				Buffer.prototype.swap32 = function swap32() {
					var len = this.length;
					if (len % 4 !== 0) {
						throw new RangeError('Buffer size must be a multiple of 32-bits');
					}
					for (var i = 0; i < len; i += 4) {
						swap(this, i, i + 3);
						swap(this, i + 1, i + 2);
					}
					return this;
				};

				Buffer.prototype.swap64 = function swap64() {
					var len = this.length;
					if (len % 8 !== 0) {
						throw new RangeError('Buffer size must be a multiple of 64-bits');
					}
					for (var i = 0; i < len; i += 8) {
						swap(this, i, i + 7);
						swap(this, i + 1, i + 6);
						swap(this, i + 2, i + 5);
						swap(this, i + 3, i + 4);
					}
					return this;
				};

				Buffer.prototype.toString = function toString() {
					var length = this.length | 0;
					if (length === 0) return '';
					if (arguments.length === 0) return utf8Slice(this, 0, length);
					return slowToString.apply(this, arguments);
				};

				Buffer.prototype.equals = function equals(b) {
					if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
					if (this === b) return true;
					return Buffer.compare(this, b) === 0;
				};

				Buffer.prototype.inspect = function inspect() {
					var str = '';
					var max = exports.INSPECT_MAX_BYTES;
					if (this.length > 0) {
						str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
						if (this.length > max) str += ' ... ';
					}
					return '<Buffer ' + str + '>';
				};

				Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
					if (!Buffer.isBuffer(target)) {
						throw new TypeError('Argument must be a Buffer');
					}

					if (start === undefined) {
						start = 0;
					}
					if (end === undefined) {
						end = target ? target.length : 0;
					}
					if (thisStart === undefined) {
						thisStart = 0;
					}
					if (thisEnd === undefined) {
						thisEnd = this.length;
					}

					if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
						throw new RangeError('out of range index');
					}

					if (thisStart >= thisEnd && start >= end) {
						return 0;
					}
					if (thisStart >= thisEnd) {
						return -1;
					}
					if (start >= end) {
						return 1;
					}

					start >>>= 0;
					end >>>= 0;
					thisStart >>>= 0;
					thisEnd >>>= 0;

					if (this === target) return 0;

					var x = thisEnd - thisStart;
					var y = end - start;
					var len = Math.min(x, y);

					var thisCopy = this.slice(thisStart, thisEnd);
					var targetCopy = target.slice(start, end);

					for (var i = 0; i < len; ++i) {
						if (thisCopy[i] !== targetCopy[i]) {
							x = thisCopy[i];
							y = targetCopy[i];
							break;
						}
					}

					if (x < y) return -1;
					if (y < x) return 1;
					return 0;
				};

				// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
				// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
				//
				// Arguments:
				// - buffer - a Buffer to search
				// - val - a string, Buffer, or number
				// - byteOffset - an index into `buffer`; will be clamped to an int32
				// - encoding - an optional encoding, relevant is val is a string
				// - dir - true for indexOf, false for lastIndexOf
				function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
					// Empty buffer means no match
					if (buffer.length === 0) return -1;

					// Normalize byteOffset
					if (typeof byteOffset === 'string') {
						encoding = byteOffset;
						byteOffset = 0;
					} else if (byteOffset > 0x7fffffff) {
						byteOffset = 0x7fffffff;
					} else if (byteOffset < -0x80000000) {
						byteOffset = -0x80000000;
					}
					byteOffset = +byteOffset; // Coerce to Number.
					if (isNaN(byteOffset)) {
						// byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
						byteOffset = dir ? 0 : buffer.length - 1;
					}

					// Normalize byteOffset: negative offsets start from the end of the buffer
					if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
					if (byteOffset >= buffer.length) {
						if (dir) return -1;
						else byteOffset = buffer.length - 1;
					} else if (byteOffset < 0) {
						if (dir) byteOffset = 0;
						else return -1;
					}

					// Normalize val
					if (typeof val === 'string') {
						val = Buffer.from(val, encoding);
					}

					// Finally, search either indexOf (if dir is true) or lastIndexOf
					if (Buffer.isBuffer(val)) {
						// Special case: looking for empty string/buffer always fails
						if (val.length === 0) {
							return -1;
						}
						return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
					} else if (typeof val === 'number') {
						val = val & 0xff; // Search for a byte value [0-255]
						if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
							if (dir) {
								return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
							} else {
								return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
							}
						}
						return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
					}

					throw new TypeError('val must be string, number or Buffer');
				}

				function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
					var indexSize = 1;
					var arrLength = arr.length;
					var valLength = val.length;

					if (encoding !== undefined) {
						encoding = String(encoding).toLowerCase();
						if (
							encoding === 'ucs2' ||
							encoding === 'ucs-2' ||
							encoding === 'utf16le' ||
							encoding === 'utf-16le'
						) {
							if (arr.length < 2 || val.length < 2) {
								return -1;
							}
							indexSize = 2;
							arrLength /= 2;
							valLength /= 2;
							byteOffset /= 2;
						}
					}

					function read(buf, i) {
						if (indexSize === 1) {
							return buf[i];
						} else {
							return buf.readUInt16BE(i * indexSize);
						}
					}

					var i;
					if (dir) {
						var foundIndex = -1;
						for (i = byteOffset; i < arrLength; i++) {
							if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
								if (foundIndex === -1) foundIndex = i;
								if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
							} else {
								if (foundIndex !== -1) i -= i - foundIndex;
								foundIndex = -1;
							}
						}
					} else {
						if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
						for (i = byteOffset; i >= 0; i--) {
							var found = true;
							for (var j = 0; j < valLength; j++) {
								if (read(arr, i + j) !== read(val, j)) {
									found = false;
									break;
								}
							}
							if (found) return i;
						}
					}

					return -1;
				}

				Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
					return this.indexOf(val, byteOffset, encoding) !== -1;
				};

				Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
					return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
				};

				Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
					return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
				};

				function hexWrite(buf, string, offset, length) {
					offset = Number(offset) || 0;
					var remaining = buf.length - offset;
					if (!length) {
						length = remaining;
					} else {
						length = Number(length);
						if (length > remaining) {
							length = remaining;
						}
					}

					// must be an even number of digits
					var strLen = string.length;
					if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

					if (length > strLen / 2) {
						length = strLen / 2;
					}
					for (var i = 0; i < length; ++i) {
						var parsed = parseInt(string.substr(i * 2, 2), 16);
						if (isNaN(parsed)) return i;
						buf[offset + i] = parsed;
					}
					return i;
				}

				function utf8Write(buf, string, offset, length) {
					return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
				}

				function asciiWrite(buf, string, offset, length) {
					return blitBuffer(asciiToBytes(string), buf, offset, length);
				}

				function latin1Write(buf, string, offset, length) {
					return asciiWrite(buf, string, offset, length);
				}

				function base64Write(buf, string, offset, length) {
					return blitBuffer(base64ToBytes(string), buf, offset, length);
				}

				function ucs2Write(buf, string, offset, length) {
					return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
				}

				Buffer.prototype.write = function write(string, offset, length, encoding) {
					// Buffer#write(string)
					if (offset === undefined) {
						encoding = 'utf8';
						length = this.length;
						offset = 0;
						// Buffer#write(string, encoding)
					} else if (length === undefined && typeof offset === 'string') {
						encoding = offset;
						length = this.length;
						offset = 0;
						// Buffer#write(string, offset[, length][, encoding])
					} else if (isFinite(offset)) {
						offset = offset | 0;
						if (isFinite(length)) {
							length = length | 0;
							if (encoding === undefined) encoding = 'utf8';
						} else {
							encoding = length;
							length = undefined;
						}
						// legacy write(string, encoding, offset, length) - remove in v0.13
					} else {
						throw new Error(
							'Buffer.write(string, encoding, offset[, length]) is no longer supported'
						);
					}

					var remaining = this.length - offset;
					if (length === undefined || length > remaining) length = remaining;

					if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
						throw new RangeError('Attempt to write outside buffer bounds');
					}

					if (!encoding) encoding = 'utf8';

					var loweredCase = false;
					for (;;) {
						switch (encoding) {
							case 'hex':
								return hexWrite(this, string, offset, length);

							case 'utf8':
							case 'utf-8':
								return utf8Write(this, string, offset, length);

							case 'ascii':
								return asciiWrite(this, string, offset, length);

							case 'latin1':
							case 'binary':
								return latin1Write(this, string, offset, length);

							case 'base64':
								// Warning: maxLength not taken into account in base64Write
								return base64Write(this, string, offset, length);

							case 'ucs2':
							case 'ucs-2':
							case 'utf16le':
							case 'utf-16le':
								return ucs2Write(this, string, offset, length);

							default:
								if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
								encoding = ('' + encoding).toLowerCase();
								loweredCase = true;
						}
					}
				};

				Buffer.prototype.toJSON = function toJSON() {
					return {
						type: 'Buffer',
						data: Array.prototype.slice.call(this._arr || this, 0)
					};
				};

				function base64Slice(buf, start, end) {
					if (start === 0 && end === buf.length) {
						return base64.fromByteArray(buf);
					} else {
						return base64.fromByteArray(buf.slice(start, end));
					}
				}

				function utf8Slice(buf, start, end) {
					end = Math.min(buf.length, end);
					var res = [];

					var i = start;
					while (i < end) {
						var firstByte = buf[i];
						var codePoint = null;
						var bytesPerSequence =
							firstByte > 0xef ? 4 : firstByte > 0xdf ? 3 : firstByte > 0xbf ? 2 : 1;

						if (i + bytesPerSequence <= end) {
							var secondByte, thirdByte, fourthByte, tempCodePoint;

							switch (bytesPerSequence) {
								case 1:
									if (firstByte < 0x80) {
										codePoint = firstByte;
									}
									break;
								case 2:
									secondByte = buf[i + 1];
									if ((secondByte & 0xc0) === 0x80) {
										tempCodePoint = ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f);
										if (tempCodePoint > 0x7f) {
											codePoint = tempCodePoint;
										}
									}
									break;
								case 3:
									secondByte = buf[i + 1];
									thirdByte = buf[i + 2];
									if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {
										tempCodePoint =
											((firstByte & 0xf) << 0xc) |
											((secondByte & 0x3f) << 0x6) |
											(thirdByte & 0x3f);
										if (
											tempCodePoint > 0x7ff &&
											(tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)
										) {
											codePoint = tempCodePoint;
										}
									}
									break;
								case 4:
									secondByte = buf[i + 1];
									thirdByte = buf[i + 2];
									fourthByte = buf[i + 3];
									if (
										(secondByte & 0xc0) === 0x80 &&
										(thirdByte & 0xc0) === 0x80 &&
										(fourthByte & 0xc0) === 0x80
									) {
										tempCodePoint =
											((firstByte & 0xf) << 0x12) |
											((secondByte & 0x3f) << 0xc) |
											((thirdByte & 0x3f) << 0x6) |
											(fourthByte & 0x3f);
										if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {
											codePoint = tempCodePoint;
										}
									}
							}
						}

						if (codePoint === null) {
							// we did not generate a valid codePoint so insert a
							// replacement char (U+FFFD) and advance only 1 byte
							codePoint = 0xfffd;
							bytesPerSequence = 1;
						} else if (codePoint > 0xffff) {
							// encode to utf16 (surrogate pair dance)
							codePoint -= 0x10000;
							res.push(((codePoint >>> 10) & 0x3ff) | 0xd800);
							codePoint = 0xdc00 | (codePoint & 0x3ff);
						}

						res.push(codePoint);
						i += bytesPerSequence;
					}

					return decodeCodePointsArray(res);
				}

				// Based on http://stackoverflow.com/a/22747272/680742, the browser with
				// the lowest limit is Chrome, with 0x10000 args.
				// We go 1 magnitude less, for safety
				var MAX_ARGUMENTS_LENGTH = 0x1000;

				function decodeCodePointsArray(codePoints) {
					var len = codePoints.length;
					if (len <= MAX_ARGUMENTS_LENGTH) {
						return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
					}

					// Decode in chunks to avoid "call stack size exceeded".
					var res = '';
					var i = 0;
					while (i < len) {
						res += String.fromCharCode.apply(
							String,
							codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH))
						);
					}
					return res;
				}

				function asciiSlice(buf, start, end) {
					var ret = '';
					end = Math.min(buf.length, end);

					for (var i = start; i < end; ++i) {
						ret += String.fromCharCode(buf[i] & 0x7f);
					}
					return ret;
				}

				function latin1Slice(buf, start, end) {
					var ret = '';
					end = Math.min(buf.length, end);

					for (var i = start; i < end; ++i) {
						ret += String.fromCharCode(buf[i]);
					}
					return ret;
				}

				function hexSlice(buf, start, end) {
					var len = buf.length;

					if (!start || start < 0) start = 0;
					if (!end || end < 0 || end > len) end = len;

					var out = '';
					for (var i = start; i < end; ++i) {
						out += toHex(buf[i]);
					}
					return out;
				}

				function utf16leSlice(buf, start, end) {
					var bytes = buf.slice(start, end);
					var res = '';
					for (var i = 0; i < bytes.length; i += 2) {
						res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
					}
					return res;
				}

				Buffer.prototype.slice = function slice(start, end) {
					var len = this.length;
					start = ~~start;
					end = end === undefined ? len : ~~end;

					if (start < 0) {
						start += len;
						if (start < 0) start = 0;
					} else if (start > len) {
						start = len;
					}

					if (end < 0) {
						end += len;
						if (end < 0) end = 0;
					} else if (end > len) {
						end = len;
					}

					if (end < start) end = start;

					var newBuf;
					if (Buffer.TYPED_ARRAY_SUPPORT) {
						newBuf = this.subarray(start, end);
						newBuf.__proto__ = Buffer.prototype;
					} else {
						var sliceLen = end - start;
						newBuf = new Buffer(sliceLen, undefined);
						for (var i = 0; i < sliceLen; ++i) {
							newBuf[i] = this[i + start];
						}
					}

					return newBuf;
				};

				/*
				 * Need to make sure that buffer isn't trying to write out of bounds.
				 */
				function checkOffset(offset, ext, length) {
					if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
					if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
				}

				Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
					offset = offset | 0;
					byteLength = byteLength | 0;
					if (!noAssert) checkOffset(offset, byteLength, this.length);

					var val = this[offset];
					var mul = 1;
					var i = 0;
					while (++i < byteLength && (mul *= 0x100)) {
						val += this[offset + i] * mul;
					}

					return val;
				};

				Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
					offset = offset | 0;
					byteLength = byteLength | 0;
					if (!noAssert) {
						checkOffset(offset, byteLength, this.length);
					}

					var val = this[offset + --byteLength];
					var mul = 1;
					while (byteLength > 0 && (mul *= 0x100)) {
						val += this[offset + --byteLength] * mul;
					}

					return val;
				};

				Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
					if (!noAssert) checkOffset(offset, 1, this.length);
					return this[offset];
				};

				Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
					if (!noAssert) checkOffset(offset, 2, this.length);
					return this[offset] | (this[offset + 1] << 8);
				};

				Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
					if (!noAssert) checkOffset(offset, 2, this.length);
					return (this[offset] << 8) | this[offset + 1];
				};

				Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
					if (!noAssert) checkOffset(offset, 4, this.length);

					return (
						(this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16)) +
						this[offset + 3] * 0x1000000
					);
				};

				Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
					if (!noAssert) checkOffset(offset, 4, this.length);

					return (
						this[offset] * 0x1000000 +
						((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3])
					);
				};

				Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
					offset = offset | 0;
					byteLength = byteLength | 0;
					if (!noAssert) checkOffset(offset, byteLength, this.length);

					var val = this[offset];
					var mul = 1;
					var i = 0;
					while (++i < byteLength && (mul *= 0x100)) {
						val += this[offset + i] * mul;
					}
					mul *= 0x80;

					if (val >= mul) val -= Math.pow(2, 8 * byteLength);

					return val;
				};

				Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
					offset = offset | 0;
					byteLength = byteLength | 0;
					if (!noAssert) checkOffset(offset, byteLength, this.length);

					var i = byteLength;
					var mul = 1;
					var val = this[offset + --i];
					while (i > 0 && (mul *= 0x100)) {
						val += this[offset + --i] * mul;
					}
					mul *= 0x80;

					if (val >= mul) val -= Math.pow(2, 8 * byteLength);

					return val;
				};

				Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
					if (!noAssert) checkOffset(offset, 1, this.length);
					if (!(this[offset] & 0x80)) return this[offset];
					return (0xff - this[offset] + 1) * -1;
				};

				Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
					if (!noAssert) checkOffset(offset, 2, this.length);
					var val = this[offset] | (this[offset + 1] << 8);
					return val & 0x8000 ? val | 0xffff0000 : val;
				};

				Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
					if (!noAssert) checkOffset(offset, 2, this.length);
					var val = this[offset + 1] | (this[offset] << 8);
					return val & 0x8000 ? val | 0xffff0000 : val;
				};

				Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
					if (!noAssert) checkOffset(offset, 4, this.length);

					return (
						this[offset] |
						(this[offset + 1] << 8) |
						(this[offset + 2] << 16) |
						(this[offset + 3] << 24)
					);
				};

				Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
					if (!noAssert) checkOffset(offset, 4, this.length);

					return (
						(this[offset] << 24) |
						(this[offset + 1] << 16) |
						(this[offset + 2] << 8) |
						this[offset + 3]
					);
				};

				Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
					if (!noAssert) checkOffset(offset, 4, this.length);
					return ieee754.read(this, offset, true, 23, 4);
				};

				Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
					if (!noAssert) checkOffset(offset, 4, this.length);
					return ieee754.read(this, offset, false, 23, 4);
				};

				Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
					if (!noAssert) checkOffset(offset, 8, this.length);
					return ieee754.read(this, offset, true, 52, 8);
				};

				Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
					if (!noAssert) checkOffset(offset, 8, this.length);
					return ieee754.read(this, offset, false, 52, 8);
				};

				function checkInt(buf, value, offset, ext, max, min) {
					if (!Buffer.isBuffer(buf))
						throw new TypeError('"buffer" argument must be a Buffer instance');
					if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
					if (offset + ext > buf.length) throw new RangeError('Index out of range');
				}

				Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
					value = +value;
					offset = offset | 0;
					byteLength = byteLength | 0;
					if (!noAssert) {
						var maxBytes = Math.pow(2, 8 * byteLength) - 1;
						checkInt(this, value, offset, byteLength, maxBytes, 0);
					}

					var mul = 1;
					var i = 0;
					this[offset] = value & 0xff;
					while (++i < byteLength && (mul *= 0x100)) {
						this[offset + i] = (value / mul) & 0xff;
					}

					return offset + byteLength;
				};

				Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
					value = +value;
					offset = offset | 0;
					byteLength = byteLength | 0;
					if (!noAssert) {
						var maxBytes = Math.pow(2, 8 * byteLength) - 1;
						checkInt(this, value, offset, byteLength, maxBytes, 0);
					}

					var i = byteLength - 1;
					var mul = 1;
					this[offset + i] = value & 0xff;
					while (--i >= 0 && (mul *= 0x100)) {
						this[offset + i] = (value / mul) & 0xff;
					}

					return offset + byteLength;
				};

				Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
					value = +value;
					offset = offset | 0;
					if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
					if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
					this[offset] = value & 0xff;
					return offset + 1;
				};

				function objectWriteUInt16(buf, value, offset, littleEndian) {
					if (value < 0) value = 0xffff + value + 1;
					for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
						buf[offset + i] =
							(value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
							((littleEndian ? i : 1 - i) * 8);
					}
				}

				Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
					value = +value;
					offset = offset | 0;
					if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
					if (Buffer.TYPED_ARRAY_SUPPORT) {
						this[offset] = value & 0xff;
						this[offset + 1] = value >>> 8;
					} else {
						objectWriteUInt16(this, value, offset, true);
					}
					return offset + 2;
				};

				Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
					value = +value;
					offset = offset | 0;
					if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
					if (Buffer.TYPED_ARRAY_SUPPORT) {
						this[offset] = value >>> 8;
						this[offset + 1] = value & 0xff;
					} else {
						objectWriteUInt16(this, value, offset, false);
					}
					return offset + 2;
				};

				function objectWriteUInt32(buf, value, offset, littleEndian) {
					if (value < 0) value = 0xffffffff + value + 1;
					for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
						buf[offset + i] = (value >>> ((littleEndian ? i : 3 - i) * 8)) & 0xff;
					}
				}

				Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
					value = +value;
					offset = offset | 0;
					if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
					if (Buffer.TYPED_ARRAY_SUPPORT) {
						this[offset + 3] = value >>> 24;
						this[offset + 2] = value >>> 16;
						this[offset + 1] = value >>> 8;
						this[offset] = value & 0xff;
					} else {
						objectWriteUInt32(this, value, offset, true);
					}
					return offset + 4;
				};

				Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
					value = +value;
					offset = offset | 0;
					if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
					if (Buffer.TYPED_ARRAY_SUPPORT) {
						this[offset] = value >>> 24;
						this[offset + 1] = value >>> 16;
						this[offset + 2] = value >>> 8;
						this[offset + 3] = value & 0xff;
					} else {
						objectWriteUInt32(this, value, offset, false);
					}
					return offset + 4;
				};

				Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
					value = +value;
					offset = offset | 0;
					if (!noAssert) {
						var limit = Math.pow(2, 8 * byteLength - 1);

						checkInt(this, value, offset, byteLength, limit - 1, -limit);
					}

					var i = 0;
					var mul = 1;
					var sub = 0;
					this[offset] = value & 0xff;
					while (++i < byteLength && (mul *= 0x100)) {
						if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
							sub = 1;
						}
						this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
					}

					return offset + byteLength;
				};

				Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
					value = +value;
					offset = offset | 0;
					if (!noAssert) {
						var limit = Math.pow(2, 8 * byteLength - 1);

						checkInt(this, value, offset, byteLength, limit - 1, -limit);
					}

					var i = byteLength - 1;
					var mul = 1;
					var sub = 0;
					this[offset + i] = value & 0xff;
					while (--i >= 0 && (mul *= 0x100)) {
						if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
							sub = 1;
						}
						this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
					}

					return offset + byteLength;
				};

				Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
					value = +value;
					offset = offset | 0;
					if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
					if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
					if (value < 0) value = 0xff + value + 1;
					this[offset] = value & 0xff;
					return offset + 1;
				};

				Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
					value = +value;
					offset = offset | 0;
					if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
					if (Buffer.TYPED_ARRAY_SUPPORT) {
						this[offset] = value & 0xff;
						this[offset + 1] = value >>> 8;
					} else {
						objectWriteUInt16(this, value, offset, true);
					}
					return offset + 2;
				};

				Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
					value = +value;
					offset = offset | 0;
					if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
					if (Buffer.TYPED_ARRAY_SUPPORT) {
						this[offset] = value >>> 8;
						this[offset + 1] = value & 0xff;
					} else {
						objectWriteUInt16(this, value, offset, false);
					}
					return offset + 2;
				};

				Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
					value = +value;
					offset = offset | 0;
					if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
					if (Buffer.TYPED_ARRAY_SUPPORT) {
						this[offset] = value & 0xff;
						this[offset + 1] = value >>> 8;
						this[offset + 2] = value >>> 16;
						this[offset + 3] = value >>> 24;
					} else {
						objectWriteUInt32(this, value, offset, true);
					}
					return offset + 4;
				};

				Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
					value = +value;
					offset = offset | 0;
					if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
					if (value < 0) value = 0xffffffff + value + 1;
					if (Buffer.TYPED_ARRAY_SUPPORT) {
						this[offset] = value >>> 24;
						this[offset + 1] = value >>> 16;
						this[offset + 2] = value >>> 8;
						this[offset + 3] = value & 0xff;
					} else {
						objectWriteUInt32(this, value, offset, false);
					}
					return offset + 4;
				};

				function checkIEEE754(buf, value, offset, ext, max, min) {
					if (offset + ext > buf.length) throw new RangeError('Index out of range');
					if (offset < 0) throw new RangeError('Index out of range');
				}

				function writeFloat(buf, value, offset, littleEndian, noAssert) {
					if (!noAssert) {
						checkIEEE754(buf, value, offset, 4, 3.4028234663852886e38, -3.4028234663852886e38);
					}
					ieee754.write(buf, value, offset, littleEndian, 23, 4);
					return offset + 4;
				}

				Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
					return writeFloat(this, value, offset, true, noAssert);
				};

				Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
					return writeFloat(this, value, offset, false, noAssert);
				};

				function writeDouble(buf, value, offset, littleEndian, noAssert) {
					if (!noAssert) {
						checkIEEE754(buf, value, offset, 8, 1.7976931348623157e308, -1.7976931348623157e308);
					}
					ieee754.write(buf, value, offset, littleEndian, 52, 8);
					return offset + 8;
				}

				Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
					return writeDouble(this, value, offset, true, noAssert);
				};

				Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
					return writeDouble(this, value, offset, false, noAssert);
				};

				// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
				Buffer.prototype.copy = function copy(target, targetStart, start, end) {
					if (!start) start = 0;
					if (!end && end !== 0) end = this.length;
					if (targetStart >= target.length) targetStart = target.length;
					if (!targetStart) targetStart = 0;
					if (end > 0 && end < start) end = start;

					// Copy 0 bytes; we're done
					if (end === start) return 0;
					if (target.length === 0 || this.length === 0) return 0;

					// Fatal error conditions
					if (targetStart < 0) {
						throw new RangeError('targetStart out of bounds');
					}
					if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
					if (end < 0) throw new RangeError('sourceEnd out of bounds');

					// Are we oob?
					if (end > this.length) end = this.length;
					if (target.length - targetStart < end - start) {
						end = target.length - targetStart + start;
					}

					var len = end - start;
					var i;

					if (this === target && start < targetStart && targetStart < end) {
						// descending copy from end
						for (i = len - 1; i >= 0; --i) {
							target[i + targetStart] = this[i + start];
						}
					} else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
						// ascending copy from start
						for (i = 0; i < len; ++i) {
							target[i + targetStart] = this[i + start];
						}
					} else {
						Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
					}

					return len;
				};

				// Usage:
				//    buffer.fill(number[, offset[, end]])
				//    buffer.fill(buffer[, offset[, end]])
				//    buffer.fill(string[, offset[, end]][, encoding])
				Buffer.prototype.fill = function fill(val, start, end, encoding) {
					// Handle string cases:
					if (typeof val === 'string') {
						if (typeof start === 'string') {
							encoding = start;
							start = 0;
							end = this.length;
						} else if (typeof end === 'string') {
							encoding = end;
							end = this.length;
						}
						if (val.length === 1) {
							var code = val.charCodeAt(0);
							if (code < 256) {
								val = code;
							}
						}
						if (encoding !== undefined && typeof encoding !== 'string') {
							throw new TypeError('encoding must be a string');
						}
						if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
							throw new TypeError('Unknown encoding: ' + encoding);
						}
					} else if (typeof val === 'number') {
						val = val & 255;
					}

					// Invalid ranges are not set to a default, so can range check early.
					if (start < 0 || this.length < start || this.length < end) {
						throw new RangeError('Out of range index');
					}

					if (end <= start) {
						return this;
					}

					start = start >>> 0;
					end = end === undefined ? this.length : end >>> 0;

					if (!val) val = 0;

					var i;
					if (typeof val === 'number') {
						for (i = start; i < end; ++i) {
							this[i] = val;
						}
					} else {
						var bytes = Buffer.isBuffer(val)
							? val
							: utf8ToBytes(new Buffer(val, encoding).toString());
						var len = bytes.length;
						for (i = 0; i < end - start; ++i) {
							this[i + start] = bytes[i % len];
						}
					}

					return this;
				};

				// HELPER FUNCTIONS
				// ================

				var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

				function base64clean(str) {
					// Node strips out invalid characters like \n and \t from the string, base64-js does not
					str = stringtrim(str).replace(INVALID_BASE64_RE, '');
					// Node converts strings with length < 2 to ''
					if (str.length < 2) return '';
					// Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
					while (str.length % 4 !== 0) {
						str = str + '=';
					}
					return str;
				}

				function stringtrim(str) {
					if (str.trim) return str.trim();
					return str.replace(/^\s+|\s+$/g, '');
				}

				function toHex(n) {
					if (n < 16) return '0' + n.toString(16);
					return n.toString(16);
				}

				function utf8ToBytes(string, units) {
					units = units || Infinity;
					var codePoint;
					var length = string.length;
					var leadSurrogate = null;
					var bytes = [];

					for (var i = 0; i < length; ++i) {
						codePoint = string.charCodeAt(i);

						// is surrogate component
						if (codePoint > 0xd7ff && codePoint < 0xe000) {
							// last char was a lead
							if (!leadSurrogate) {
								// no lead yet
								if (codePoint > 0xdbff) {
									// unexpected trail
									if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
									continue;
								} else if (i + 1 === length) {
									// unpaired lead
									if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
									continue;
								}

								// valid lead
								leadSurrogate = codePoint;

								continue;
							}

							// 2 leads in a row
							if (codePoint < 0xdc00) {
								if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
								leadSurrogate = codePoint;
								continue;
							}

							// valid surrogate pair
							codePoint = (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) + 0x10000;
						} else if (leadSurrogate) {
							// valid bmp char, but last char was a lead
							if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
						}

						leadSurrogate = null;

						// encode utf8
						if (codePoint < 0x80) {
							if ((units -= 1) < 0) break;
							bytes.push(codePoint);
						} else if (codePoint < 0x800) {
							if ((units -= 2) < 0) break;
							bytes.push((codePoint >> 0x6) | 0xc0, (codePoint & 0x3f) | 0x80);
						} else if (codePoint < 0x10000) {
							if ((units -= 3) < 0) break;
							bytes.push(
								(codePoint >> 0xc) | 0xe0,
								((codePoint >> 0x6) & 0x3f) | 0x80,
								(codePoint & 0x3f) | 0x80
							);
						} else if (codePoint < 0x110000) {
							if ((units -= 4) < 0) break;
							bytes.push(
								(codePoint >> 0x12) | 0xf0,
								((codePoint >> 0xc) & 0x3f) | 0x80,
								((codePoint >> 0x6) & 0x3f) | 0x80,
								(codePoint & 0x3f) | 0x80
							);
						} else {
							throw new Error('Invalid code point');
						}
					}

					return bytes;
				}

				function asciiToBytes(str) {
					var byteArray = [];
					for (var i = 0; i < str.length; ++i) {
						// Node's code seems to be doing this and not & 0x7F..
						byteArray.push(str.charCodeAt(i) & 0xff);
					}
					return byteArray;
				}

				function utf16leToBytes(str, units) {
					var c, hi, lo;
					var byteArray = [];
					for (var i = 0; i < str.length; ++i) {
						if ((units -= 2) < 0) break;

						c = str.charCodeAt(i);
						hi = c >> 8;
						lo = c % 256;
						byteArray.push(lo);
						byteArray.push(hi);
					}

					return byteArray;
				}

				function base64ToBytes(str) {
					return base64.toByteArray(base64clean(str));
				}

				function blitBuffer(src, dst, offset, length) {
					for (var i = 0; i < length; ++i) {
						if (i + offset >= dst.length || i >= src.length) break;
						dst[i + offset] = src[i];
					}
					return i;
				}

				function isnan(val) {
					return val !== val; // eslint-disable-line no-self-compare
				}
			},
			{
				'base64-js': '../node_modules/base64-js/index.js',
				ieee754: '../node_modules/ieee754/index.js',
				isarray: '../node_modules/isarray/index.js',
				buffer: '../node_modules/node-libs-browser/node_modules/buffer/index.js'
			}
		],
		'../node_modules/readable-stream/node_modules/safe-buffer/index.js': [
			function (require, module, exports) {
				/* eslint-disable node/no-deprecated-api */
				var buffer = require('buffer');
				var Buffer = buffer.Buffer;

				// alternative to using Object.keys for old browsers
				function copyProps(src, dst) {
					for (var key in src) {
						dst[key] = src[key];
					}
				}
				if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
					module.exports = buffer;
				} else {
					// Copy properties from require('buffer')
					copyProps(buffer, exports);
					exports.Buffer = SafeBuffer;
				}

				function SafeBuffer(arg, encodingOrOffset, length) {
					return Buffer(arg, encodingOrOffset, length);
				}

				// Copy static methods from Buffer
				copyProps(Buffer, SafeBuffer);

				SafeBuffer.from = function (arg, encodingOrOffset, length) {
					if (typeof arg === 'number') {
						throw new TypeError('Argument must not be a number');
					}
					return Buffer(arg, encodingOrOffset, length);
				};

				SafeBuffer.alloc = function (size, fill, encoding) {
					if (typeof size !== 'number') {
						throw new TypeError('Argument must be a number');
					}
					var buf = Buffer(size);
					if (fill !== undefined) {
						if (typeof encoding === 'string') {
							buf.fill(fill, encoding);
						} else {
							buf.fill(fill);
						}
					} else {
						buf.fill(0);
					}
					return buf;
				};

				SafeBuffer.allocUnsafe = function (size) {
					if (typeof size !== 'number') {
						throw new TypeError('Argument must be a number');
					}
					return Buffer(size);
				};

				SafeBuffer.allocUnsafeSlow = function (size) {
					if (typeof size !== 'number') {
						throw new TypeError('Argument must be a number');
					}
					return buffer.SlowBuffer(size);
				};
			},
			{ buffer: '../node_modules/node-libs-browser/node_modules/buffer/index.js' }
		],
		'../node_modules/core-util-is/lib/util.js': [
			function (require, module, exports) {
				var Buffer = require('buffer').Buffer;
				// Copyright Joyent, Inc. and other Node contributors.
				//
				// Permission is hereby granted, free of charge, to any person obtaining a
				// copy of this software and associated documentation files (the
				// "Software"), to deal in the Software without restriction, including
				// without limitation the rights to use, copy, modify, merge, publish,
				// distribute, sublicense, and/or sell copies of the Software, and to permit
				// persons to whom the Software is furnished to do so, subject to the
				// following conditions:
				//
				// The above copyright notice and this permission notice shall be included
				// in all copies or substantial portions of the Software.
				//
				// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
				// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
				// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
				// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
				// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
				// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
				// USE OR OTHER DEALINGS IN THE SOFTWARE.

				// NOTE: These type checking functions intentionally don't use `instanceof`
				// because it is fragile and can be easily faked with `Object.create()`.

				function isArray(arg) {
					if (Array.isArray) {
						return Array.isArray(arg);
					}
					return objectToString(arg) === '[object Array]';
				}
				exports.isArray = isArray;

				function isBoolean(arg) {
					return typeof arg === 'boolean';
				}
				exports.isBoolean = isBoolean;

				function isNull(arg) {
					return arg === null;
				}
				exports.isNull = isNull;

				function isNullOrUndefined(arg) {
					return arg == null;
				}
				exports.isNullOrUndefined = isNullOrUndefined;

				function isNumber(arg) {
					return typeof arg === 'number';
				}
				exports.isNumber = isNumber;

				function isString(arg) {
					return typeof arg === 'string';
				}
				exports.isString = isString;

				function isSymbol(arg) {
					return typeof arg === 'symbol';
				}
				exports.isSymbol = isSymbol;

				function isUndefined(arg) {
					return arg === void 0;
				}
				exports.isUndefined = isUndefined;

				function isRegExp(re) {
					return objectToString(re) === '[object RegExp]';
				}
				exports.isRegExp = isRegExp;

				function isObject(arg) {
					return typeof arg === 'object' && arg !== null;
				}
				exports.isObject = isObject;

				function isDate(d) {
					return objectToString(d) === '[object Date]';
				}
				exports.isDate = isDate;

				function isError(e) {
					return objectToString(e) === '[object Error]' || e instanceof Error;
				}
				exports.isError = isError;

				function isFunction(arg) {
					return typeof arg === 'function';
				}
				exports.isFunction = isFunction;

				function isPrimitive(arg) {
					return (
						arg === null ||
						typeof arg === 'boolean' ||
						typeof arg === 'number' ||
						typeof arg === 'string' ||
						typeof arg === 'symbol' || // ES6 symbol
						typeof arg === 'undefined'
					);
				}
				exports.isPrimitive = isPrimitive;

				exports.isBuffer = Buffer.isBuffer;

				function objectToString(o) {
					return Object.prototype.toString.call(o);
				}
			},
			{ buffer: '../node_modules/node-libs-browser/node_modules/buffer/index.js' }
		],
		'../node_modules/parcel-bundler/src/builtins/_empty.js': [
			function (require, module, exports) {},
			{}
		],
		'../node_modules/readable-stream/lib/internal/streams/BufferList.js': [
			function (require, module, exports) {
				'use strict';

				function _classCallCheck(instance, Constructor) {
					if (!(instance instanceof Constructor)) {
						throw new TypeError('Cannot call a class as a function');
					}
				}

				var Buffer = require('safe-buffer').Buffer;
				var util = require('util');

				function copyBuffer(src, target, offset) {
					src.copy(target, offset);
				}

				module.exports = (function () {
					function BufferList() {
						_classCallCheck(this, BufferList);

						this.head = null;
						this.tail = null;
						this.length = 0;
					}

					BufferList.prototype.push = function push(v) {
						var entry = { data: v, next: null };
						if (this.length > 0) this.tail.next = entry;
						else this.head = entry;
						this.tail = entry;
						++this.length;
					};

					BufferList.prototype.unshift = function unshift(v) {
						var entry = { data: v, next: this.head };
						if (this.length === 0) this.tail = entry;
						this.head = entry;
						++this.length;
					};

					BufferList.prototype.shift = function shift() {
						if (this.length === 0) return;
						var ret = this.head.data;
						if (this.length === 1) this.head = this.tail = null;
						else this.head = this.head.next;
						--this.length;
						return ret;
					};

					BufferList.prototype.clear = function clear() {
						this.head = this.tail = null;
						this.length = 0;
					};

					BufferList.prototype.join = function join(s) {
						if (this.length === 0) return '';
						var p = this.head;
						var ret = '' + p.data;
						while ((p = p.next)) {
							ret += s + p.data;
						}
						return ret;
					};

					BufferList.prototype.concat = function concat(n) {
						if (this.length === 0) return Buffer.alloc(0);
						if (this.length === 1) return this.head.data;
						var ret = Buffer.allocUnsafe(n >>> 0);
						var p = this.head;
						var i = 0;
						while (p) {
							copyBuffer(p.data, ret, i);
							i += p.data.length;
							p = p.next;
						}
						return ret;
					};

					return BufferList;
				})();

				if (util && util.inspect && util.inspect.custom) {
					module.exports.prototype[util.inspect.custom] = function () {
						var obj = util.inspect({ length: this.length });
						return this.constructor.name + ' ' + obj;
					};
				}
			},
			{
				'safe-buffer': '../node_modules/readable-stream/node_modules/safe-buffer/index.js',
				util: '../node_modules/parcel-bundler/src/builtins/_empty.js'
			}
		],
		'../node_modules/readable-stream/lib/internal/streams/destroy.js': [
			function (require, module, exports) {
				'use strict';

				/*<replacement>*/

				var pna = require('process-nextick-args');
				/*</replacement>*/

				// undocumented cb() API, needed for core, not for public API
				function destroy(err, cb) {
					var _this = this;

					var readableDestroyed = this._readableState && this._readableState.destroyed;
					var writableDestroyed = this._writableState && this._writableState.destroyed;

					if (readableDestroyed || writableDestroyed) {
						if (cb) {
							cb(err);
						} else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
							pna.nextTick(emitErrorNT, this, err);
						}
						return this;
					}

					// we set destroyed to true before firing error callbacks in order
					// to make it re-entrance safe in case destroy() is called within callbacks

					if (this._readableState) {
						this._readableState.destroyed = true;
					}

					// if this is a duplex stream mark the writable part as destroyed as well
					if (this._writableState) {
						this._writableState.destroyed = true;
					}

					this._destroy(err || null, function (err) {
						if (!cb && err) {
							pna.nextTick(emitErrorNT, _this, err);
							if (_this._writableState) {
								_this._writableState.errorEmitted = true;
							}
						} else if (cb) {
							cb(err);
						}
					});

					return this;
				}

				function undestroy() {
					if (this._readableState) {
						this._readableState.destroyed = false;
						this._readableState.reading = false;
						this._readableState.ended = false;
						this._readableState.endEmitted = false;
					}

					if (this._writableState) {
						this._writableState.destroyed = false;
						this._writableState.ended = false;
						this._writableState.ending = false;
						this._writableState.finished = false;
						this._writableState.errorEmitted = false;
					}
				}

				function emitErrorNT(self, err) {
					self.emit('error', err);
				}

				module.exports = {
					destroy: destroy,
					undestroy: undestroy
				};
			},
			{ 'process-nextick-args': '../node_modules/process-nextick-args/index.js' }
		],
		'../node_modules/util-deprecate/browser.js': [
			function (require, module, exports) {
				var global = arguments[3];

				/**
				 * Module exports.
				 */

				module.exports = deprecate;

				/**
				 * Mark that a method should not be used.
				 * Returns a modified function which warns once by default.
				 *
				 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
				 *
				 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
				 * will throw an Error when invoked.
				 *
				 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
				 * will invoke `console.trace()` instead of `console.error()`.
				 *
				 * @param {Function} fn - the function to deprecate
				 * @param {String} msg - the string to print to the console when `fn` is invoked
				 * @returns {Function} a new "deprecated" version of `fn`
				 * @api public
				 */

				function deprecate(fn, msg) {
					if (config('noDeprecation')) {
						return fn;
					}

					var warned = false;
					function deprecated() {
						if (!warned) {
							if (config('throwDeprecation')) {
								throw new Error(msg);
							} else if (config('traceDeprecation')) {
								console.trace(msg);
							} else {
								console.warn(msg);
							}
							warned = true;
						}
						return fn.apply(this, arguments);
					}

					return deprecated;
				}

				/**
				 * Checks `localStorage` for boolean values for the given `name`.
				 *
				 * @param {String} name
				 * @returns {Boolean}
				 * @api private
				 */

				function config(name) {
					// accessing global.localStorage can trigger a DOMException in sandboxed iframes
					try {
						if (!global.localStorage) return false;
					} catch (_) {
						return false;
					}
					var val = global.localStorage[name];
					if (null == val) return false;
					return String(val).toLowerCase() === 'true';
				}
			},
			{}
		],
		'../node_modules/readable-stream/lib/_stream_writable.js': [
			function (require, module, exports) {
				var process = require('process');

				var global = arguments[3];
				// Copyright Joyent, Inc. and other Node contributors.
				//
				// Permission is hereby granted, free of charge, to any person obtaining a
				// copy of this software and associated documentation files (the
				// "Software"), to deal in the Software without restriction, including
				// without limitation the rights to use, copy, modify, merge, publish,
				// distribute, sublicense, and/or sell copies of the Software, and to permit
				// persons to whom the Software is furnished to do so, subject to the
				// following conditions:
				//
				// The above copyright notice and this permission notice shall be included
				// in all copies or substantial portions of the Software.
				//
				// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
				// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
				// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
				// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
				// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
				// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
				// USE OR OTHER DEALINGS IN THE SOFTWARE.
				// A bit simpler than readable streams.
				// Implement an async ._write(chunk, encoding, cb), and it'll handle all
				// the drain event emission and buffering.
				('use strict');
				/*<replacement>*/

				var pna = require('process-nextick-args');
				/*</replacement>*/

				module.exports = Writable;
				/* <replacement> */

				function WriteReq(chunk, encoding, cb) {
					this.chunk = chunk;
					this.encoding = encoding;
					this.callback = cb;
					this.next = null;
				} // It seems a linked list but it is not
				// there will be only 2 of these for each stream

				function CorkedRequest(state) {
					var _this = this;

					this.next = null;
					this.entry = null;

					this.finish = function () {
						onCorkedFinish(_this, state);
					};
				}
				/* </replacement> */

				/*<replacement>*/

				var asyncWrite =
					!true && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1
						? setImmediate
						: pna.nextTick;
				/*</replacement>*/

				/*<replacement>*/

				var Duplex;
				/*</replacement>*/

				Writable.WritableState = WritableState;
				/*<replacement>*/

				var util = require('core-util-is');

				util.inherits = require('inherits');
				/*</replacement>*/

				/*<replacement>*/

				var internalUtil = {
					deprecate: require('util-deprecate')
				};
				/*</replacement>*/

				/*<replacement>*/

				var Stream = require('./internal/streams/stream');
				/*</replacement>*/

				/*<replacement>*/

				var Buffer = require('safe-buffer').Buffer;

				var OurUint8Array = global.Uint8Array || function () {};

				function _uint8ArrayToBuffer(chunk) {
					return Buffer.from(chunk);
				}

				function _isUint8Array(obj) {
					return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
				}
				/*</replacement>*/

				var destroyImpl = require('./internal/streams/destroy');

				util.inherits(Writable, Stream);

				function nop() {}

				function WritableState(options, stream) {
					Duplex = Duplex || require('./_stream_duplex');
					options = options || {}; // Duplex streams are both readable and writable, but share
					// the same options object.
					// However, some cases require setting options to different
					// values for the readable and the writable sides of the duplex stream.
					// These options can be provided separately as readableXXX and writableXXX.

					var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
					// contains buffers or objects.

					this.objectMode = !!options.objectMode;
					if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
					// Note: 0 is a valid value, means that we always return false if
					// the entire buffer is not flushed immediately on write()

					var hwm = options.highWaterMark;
					var writableHwm = options.writableHighWaterMark;
					var defaultHwm = this.objectMode ? 16 : 16 * 1024;
					if (hwm || hwm === 0) this.highWaterMark = hwm;
					else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
					else this.highWaterMark = defaultHwm; // cast to ints.

					this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called

					this.finalCalled = false; // drain event flag.

					this.needDrain = false; // at the start of calling end()

					this.ending = false; // when end() has been called, and returned

					this.ended = false; // when 'finish' is emitted

					this.finished = false; // has it been destroyed

					this.destroyed = false; // should we decode strings into buffers before passing to _write?
					// this is here so that some node-core streams can optimize string
					// handling at a lower level.

					var noDecode = options.decodeStrings === false;
					this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
					// encoding is 'binary' so we have to make this configurable.
					// Everything else in the universe uses 'utf8', though.

					this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
					// of how much we're waiting to get pushed to some underlying
					// socket or file.

					this.length = 0; // a flag to see when we're in the middle of a write.

					this.writing = false; // when true all writes will be buffered until .uncork() call

					this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
					// or on a later tick.  We set this to true at first, because any
					// actions that shouldn't happen until "later" should generally also
					// not happen before the first write call.

					this.sync = true; // a flag to know if we're processing previously buffered items, which
					// may call the _write() callback in the same tick, so that we don't
					// end up in an overlapped onwrite situation.

					this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

					this.onwrite = function (er) {
						onwrite(stream, er);
					}; // the callback that the user supplies to write(chunk,encoding,cb)

					this.writecb = null; // the amount that is being written when _write is called.

					this.writelen = 0;
					this.bufferedRequest = null;
					this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
					// this must be 0 before 'finish' can be emitted

					this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
					// This is relevant for synchronous Transform streams

					this.prefinished = false; // True if the error was already emitted and should not be thrown again

					this.errorEmitted = false; // count buffered requests

					this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
					// one allocated and free to use, and we maintain at most two

					this.corkedRequestsFree = new CorkedRequest(this);
				}

				WritableState.prototype.getBuffer = function getBuffer() {
					var current = this.bufferedRequest;
					var out = [];

					while (current) {
						out.push(current);
						current = current.next;
					}

					return out;
				};

				(function () {
					try {
						Object.defineProperty(WritableState.prototype, 'buffer', {
							get: internalUtil.deprecate(
								function () {
									return this.getBuffer();
								},
								'_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.',
								'DEP0003'
							)
						});
					} catch (_) {}
				})(); // Test _writableState for inheritance to account for Duplex streams,
				// whose prototype chain only points to Readable.

				var realHasInstance;

				if (
					typeof Symbol === 'function' &&
					Symbol.hasInstance &&
					typeof Function.prototype[Symbol.hasInstance] === 'function'
				) {
					realHasInstance = Function.prototype[Symbol.hasInstance];
					Object.defineProperty(Writable, Symbol.hasInstance, {
						value: function (object) {
							if (realHasInstance.call(this, object)) return true;
							if (this !== Writable) return false;
							return object && object._writableState instanceof WritableState;
						}
					});
				} else {
					realHasInstance = function (object) {
						return object instanceof this;
					};
				}

				function Writable(options) {
					Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
					// `realHasInstance` is necessary because using plain `instanceof`
					// would return false, as no `_writableState` property is attached.
					// Trying to use the custom `instanceof` for Writable here will also break the
					// Node.js LazyTransform implementation, which has a non-trivial getter for
					// `_writableState` that would lead to infinite recursion.

					if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
						return new Writable(options);
					}

					this._writableState = new WritableState(options, this); // legacy.

					this.writable = true;

					if (options) {
						if (typeof options.write === 'function') this._write = options.write;
						if (typeof options.writev === 'function') this._writev = options.writev;
						if (typeof options.destroy === 'function') this._destroy = options.destroy;
						if (typeof options.final === 'function') this._final = options.final;
					}

					Stream.call(this);
				} // Otherwise people can pipe Writable streams, which is just wrong.

				Writable.prototype.pipe = function () {
					this.emit('error', new Error('Cannot pipe, not readable'));
				};

				function writeAfterEnd(stream, cb) {
					var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

					stream.emit('error', er);
					pna.nextTick(cb, er);
				} // Checks that a user-supplied chunk is valid, especially for the particular
				// mode the stream is in. Currently this means that `null` is never accepted
				// and undefined/non-string values are only allowed in object mode.

				function validChunk(stream, state, chunk, cb) {
					var valid = true;
					var er = false;

					if (chunk === null) {
						er = new TypeError('May not write null values to stream');
					} else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
						er = new TypeError('Invalid non-string/buffer chunk');
					}

					if (er) {
						stream.emit('error', er);
						pna.nextTick(cb, er);
						valid = false;
					}

					return valid;
				}

				Writable.prototype.write = function (chunk, encoding, cb) {
					var state = this._writableState;
					var ret = false;

					var isBuf = !state.objectMode && _isUint8Array(chunk);

					if (isBuf && !Buffer.isBuffer(chunk)) {
						chunk = _uint8ArrayToBuffer(chunk);
					}

					if (typeof encoding === 'function') {
						cb = encoding;
						encoding = null;
					}

					if (isBuf) encoding = 'buffer';
					else if (!encoding) encoding = state.defaultEncoding;
					if (typeof cb !== 'function') cb = nop;
					if (state.ended) writeAfterEnd(this, cb);
					else if (isBuf || validChunk(this, state, chunk, cb)) {
						state.pendingcb++;
						ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
					}
					return ret;
				};

				Writable.prototype.cork = function () {
					var state = this._writableState;
					state.corked++;
				};

				Writable.prototype.uncork = function () {
					var state = this._writableState;

					if (state.corked) {
						state.corked--;
						if (
							!state.writing &&
							!state.corked &&
							!state.finished &&
							!state.bufferProcessing &&
							state.bufferedRequest
						)
							clearBuffer(this, state);
					}
				};

				Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
					// node::ParseEncoding() requires lower case.
					if (typeof encoding === 'string') encoding = encoding.toLowerCase();
					if (
						!(
							[
								'hex',
								'utf8',
								'utf-8',
								'ascii',
								'binary',
								'base64',
								'ucs2',
								'ucs-2',
								'utf16le',
								'utf-16le',
								'raw'
							].indexOf((encoding + '').toLowerCase()) > -1
						)
					)
						throw new TypeError('Unknown encoding: ' + encoding);
					this._writableState.defaultEncoding = encoding;
					return this;
				};

				function decodeChunk(state, chunk, encoding) {
					if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
						chunk = Buffer.from(chunk, encoding);
					}

					return chunk;
				}

				Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
					// making it explicit this property is not enumerable
					// because otherwise some prototype manipulation in
					// userland will fail
					enumerable: false,
					get: function () {
						return this._writableState.highWaterMark;
					}
				}); // if we're already writing something, then just put this
				// in the queue, and wait our turn.  Otherwise, call _write
				// If we return false, then we need a drain event, so set that flag.

				function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
					if (!isBuf) {
						var newChunk = decodeChunk(state, chunk, encoding);

						if (chunk !== newChunk) {
							isBuf = true;
							encoding = 'buffer';
							chunk = newChunk;
						}
					}

					var len = state.objectMode ? 1 : chunk.length;
					state.length += len;
					var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

					if (!ret) state.needDrain = true;

					if (state.writing || state.corked) {
						var last = state.lastBufferedRequest;
						state.lastBufferedRequest = {
							chunk: chunk,
							encoding: encoding,
							isBuf: isBuf,
							callback: cb,
							next: null
						};

						if (last) {
							last.next = state.lastBufferedRequest;
						} else {
							state.bufferedRequest = state.lastBufferedRequest;
						}

						state.bufferedRequestCount += 1;
					} else {
						doWrite(stream, state, false, len, chunk, encoding, cb);
					}

					return ret;
				}

				function doWrite(stream, state, writev, len, chunk, encoding, cb) {
					state.writelen = len;
					state.writecb = cb;
					state.writing = true;
					state.sync = true;
					if (writev) stream._writev(chunk, state.onwrite);
					else stream._write(chunk, encoding, state.onwrite);
					state.sync = false;
				}

				function onwriteError(stream, state, sync, er, cb) {
					--state.pendingcb;

					if (sync) {
						// defer the callback if we are being called synchronously
						// to avoid piling up things on the stack
						pna.nextTick(cb, er); // this can emit finish, and it will always happen
						// after error

						pna.nextTick(finishMaybe, stream, state);
						stream._writableState.errorEmitted = true;
						stream.emit('error', er);
					} else {
						// the caller expect this to happen before if
						// it is async
						cb(er);
						stream._writableState.errorEmitted = true;
						stream.emit('error', er); // this can emit finish, but finish must
						// always follow error

						finishMaybe(stream, state);
					}
				}

				function onwriteStateUpdate(state) {
					state.writing = false;
					state.writecb = null;
					state.length -= state.writelen;
					state.writelen = 0;
				}

				function onwrite(stream, er) {
					var state = stream._writableState;
					var sync = state.sync;
					var cb = state.writecb;
					onwriteStateUpdate(state);
					if (er) onwriteError(stream, state, sync, er, cb);
					else {
						// Check if we're actually ready to finish, but don't emit yet
						var finished = needFinish(state);

						if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
							clearBuffer(stream, state);
						}

						if (sync) {
							/*<replacement>*/
							asyncWrite(afterWrite, stream, state, finished, cb);
							/*</replacement>*/
						} else {
							afterWrite(stream, state, finished, cb);
						}
					}
				}

				function afterWrite(stream, state, finished, cb) {
					if (!finished) onwriteDrain(stream, state);
					state.pendingcb--;
					cb();
					finishMaybe(stream, state);
				} // Must force callback to be called on nextTick, so that we don't
				// emit 'drain' before the write() consumer gets the 'false' return
				// value, and has a chance to attach a 'drain' listener.

				function onwriteDrain(stream, state) {
					if (state.length === 0 && state.needDrain) {
						state.needDrain = false;
						stream.emit('drain');
					}
				} // if there's something in the buffer waiting, then process it

				function clearBuffer(stream, state) {
					state.bufferProcessing = true;
					var entry = state.bufferedRequest;

					if (stream._writev && entry && entry.next) {
						// Fast case, write everything using _writev()
						var l = state.bufferedRequestCount;
						var buffer = new Array(l);
						var holder = state.corkedRequestsFree;
						holder.entry = entry;
						var count = 0;
						var allBuffers = true;

						while (entry) {
							buffer[count] = entry;
							if (!entry.isBuf) allBuffers = false;
							entry = entry.next;
							count += 1;
						}

						buffer.allBuffers = allBuffers;
						doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
						// as the hot path ends with doWrite

						state.pendingcb++;
						state.lastBufferedRequest = null;

						if (holder.next) {
							state.corkedRequestsFree = holder.next;
							holder.next = null;
						} else {
							state.corkedRequestsFree = new CorkedRequest(state);
						}

						state.bufferedRequestCount = 0;
					} else {
						// Slow case, write chunks one-by-one
						while (entry) {
							var chunk = entry.chunk;
							var encoding = entry.encoding;
							var cb = entry.callback;
							var len = state.objectMode ? 1 : chunk.length;
							doWrite(stream, state, false, len, chunk, encoding, cb);
							entry = entry.next;
							state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
							// it means that we need to wait until it does.
							// also, that means that the chunk and cb are currently
							// being processed, so move the buffer counter past them.

							if (state.writing) {
								break;
							}
						}

						if (entry === null) state.lastBufferedRequest = null;
					}

					state.bufferedRequest = entry;
					state.bufferProcessing = false;
				}

				Writable.prototype._write = function (chunk, encoding, cb) {
					cb(new Error('_write() is not implemented'));
				};

				Writable.prototype._writev = null;

				Writable.prototype.end = function (chunk, encoding, cb) {
					var state = this._writableState;

					if (typeof chunk === 'function') {
						cb = chunk;
						chunk = null;
						encoding = null;
					} else if (typeof encoding === 'function') {
						cb = encoding;
						encoding = null;
					}

					if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

					if (state.corked) {
						state.corked = 1;
						this.uncork();
					} // ignore unnecessary end() calls.

					if (!state.ending && !state.finished) endWritable(this, state, cb);
				};

				function needFinish(state) {
					return (
						state.ending &&
						state.length === 0 &&
						state.bufferedRequest === null &&
						!state.finished &&
						!state.writing
					);
				}

				function callFinal(stream, state) {
					stream._final(function (err) {
						state.pendingcb--;

						if (err) {
							stream.emit('error', err);
						}

						state.prefinished = true;
						stream.emit('prefinish');
						finishMaybe(stream, state);
					});
				}

				function prefinish(stream, state) {
					if (!state.prefinished && !state.finalCalled) {
						if (typeof stream._final === 'function') {
							state.pendingcb++;
							state.finalCalled = true;
							pna.nextTick(callFinal, stream, state);
						} else {
							state.prefinished = true;
							stream.emit('prefinish');
						}
					}
				}

				function finishMaybe(stream, state) {
					var need = needFinish(state);

					if (need) {
						prefinish(stream, state);

						if (state.pendingcb === 0) {
							state.finished = true;
							stream.emit('finish');
						}
					}

					return need;
				}

				function endWritable(stream, state, cb) {
					state.ending = true;
					finishMaybe(stream, state);

					if (cb) {
						if (state.finished) pna.nextTick(cb);
						else stream.once('finish', cb);
					}

					state.ended = true;
					stream.writable = false;
				}

				function onCorkedFinish(corkReq, state, err) {
					var entry = corkReq.entry;
					corkReq.entry = null;

					while (entry) {
						var cb = entry.callback;
						state.pendingcb--;
						cb(err);
						entry = entry.next;
					}

					if (state.corkedRequestsFree) {
						state.corkedRequestsFree.next = corkReq;
					} else {
						state.corkedRequestsFree = corkReq;
					}
				}

				Object.defineProperty(Writable.prototype, 'destroyed', {
					get: function () {
						if (this._writableState === undefined) {
							return false;
						}

						return this._writableState.destroyed;
					},
					set: function (value) {
						// we ignore the value if the stream
						// has not been initialized yet
						if (!this._writableState) {
							return;
						} // backward compatibility, the user is explicitly
						// managing destroyed

						this._writableState.destroyed = value;
					}
				});
				Writable.prototype.destroy = destroyImpl.destroy;
				Writable.prototype._undestroy = destroyImpl.undestroy;

				Writable.prototype._destroy = function (err, cb) {
					this.end();
					cb(err);
				};
			},
			{
				'process-nextick-args': '../node_modules/process-nextick-args/index.js',
				'core-util-is': '../node_modules/core-util-is/lib/util.js',
				inherits: '../node_modules/inherits/inherits_browser.js',
				'util-deprecate': '../node_modules/util-deprecate/browser.js',
				'./internal/streams/stream':
					'../node_modules/readable-stream/lib/internal/streams/stream-browser.js',
				'safe-buffer': '../node_modules/readable-stream/node_modules/safe-buffer/index.js',
				'./internal/streams/destroy':
					'../node_modules/readable-stream/lib/internal/streams/destroy.js',
				'./_stream_duplex': '../node_modules/readable-stream/lib/_stream_duplex.js',
				process: '../node_modules/process/browser.js'
			}
		],
		'../node_modules/readable-stream/lib/_stream_duplex.js': [
			function (require, module, exports) {
				// Copyright Joyent, Inc. and other Node contributors.
				//
				// Permission is hereby granted, free of charge, to any person obtaining a
				// copy of this software and associated documentation files (the
				// "Software"), to deal in the Software without restriction, including
				// without limitation the rights to use, copy, modify, merge, publish,
				// distribute, sublicense, and/or sell copies of the Software, and to permit
				// persons to whom the Software is furnished to do so, subject to the
				// following conditions:
				//
				// The above copyright notice and this permission notice shall be included
				// in all copies or substantial portions of the Software.
				//
				// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
				// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
				// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
				// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
				// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
				// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
				// USE OR OTHER DEALINGS IN THE SOFTWARE.

				// a duplex stream is just a stream that is both readable and writable.
				// Since JS doesn't have multiple prototypal inheritance, this class
				// prototypally inherits from Readable, and then parasitically from
				// Writable.

				'use strict';

				/*<replacement>*/

				var pna = require('process-nextick-args');
				/*</replacement>*/

				/*<replacement>*/
				var objectKeys =
					Object.keys ||
					function (obj) {
						var keys = [];
						for (var key in obj) {
							keys.push(key);
						}
						return keys;
					};
				/*</replacement>*/

				module.exports = Duplex;

				/*<replacement>*/
				var util = require('core-util-is');
				util.inherits = require('inherits');
				/*</replacement>*/

				var Readable = require('./_stream_readable');
				var Writable = require('./_stream_writable');

				util.inherits(Duplex, Readable);

				{
					// avoid scope creep, the keys array can then be collected
					var keys = objectKeys(Writable.prototype);
					for (var v = 0; v < keys.length; v++) {
						var method = keys[v];
						if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
					}
				}

				function Duplex(options) {
					if (!(this instanceof Duplex)) return new Duplex(options);

					Readable.call(this, options);
					Writable.call(this, options);

					if (options && options.readable === false) this.readable = false;

					if (options && options.writable === false) this.writable = false;

					this.allowHalfOpen = true;
					if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

					this.once('end', onend);
				}

				Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
					// making it explicit this property is not enumerable
					// because otherwise some prototype manipulation in
					// userland will fail
					enumerable: false,
					get: function () {
						return this._writableState.highWaterMark;
					}
				});

				// the no-half-open enforcer
				function onend() {
					// if we allow half-open state, or if the writable side ended,
					// then we're ok.
					if (this.allowHalfOpen || this._writableState.ended) return;

					// no more data can be written.
					// But allow more writes to happen in this tick.
					pna.nextTick(onEndNT, this);
				}

				function onEndNT(self) {
					self.end();
				}

				Object.defineProperty(Duplex.prototype, 'destroyed', {
					get: function () {
						if (this._readableState === undefined || this._writableState === undefined) {
							return false;
						}
						return this._readableState.destroyed && this._writableState.destroyed;
					},
					set: function (value) {
						// we ignore the value if the stream
						// has not been initialized yet
						if (this._readableState === undefined || this._writableState === undefined) {
							return;
						}

						// backward compatibility, the user is explicitly
						// managing destroyed
						this._readableState.destroyed = value;
						this._writableState.destroyed = value;
					}
				});

				Duplex.prototype._destroy = function (err, cb) {
					this.push(null);
					this.end();

					pna.nextTick(cb, err);
				};
			},
			{
				'process-nextick-args': '../node_modules/process-nextick-args/index.js',
				'core-util-is': '../node_modules/core-util-is/lib/util.js',
				inherits: '../node_modules/inherits/inherits_browser.js',
				'./_stream_readable': '../node_modules/readable-stream/lib/_stream_readable.js',
				'./_stream_writable': '../node_modules/readable-stream/lib/_stream_writable.js'
			}
		],
		'../node_modules/string_decoder/node_modules/safe-buffer/index.js': [
			function (require, module, exports) {
				/* eslint-disable node/no-deprecated-api */
				var buffer = require('buffer');
				var Buffer = buffer.Buffer;

				// alternative to using Object.keys for old browsers
				function copyProps(src, dst) {
					for (var key in src) {
						dst[key] = src[key];
					}
				}
				if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
					module.exports = buffer;
				} else {
					// Copy properties from require('buffer')
					copyProps(buffer, exports);
					exports.Buffer = SafeBuffer;
				}

				function SafeBuffer(arg, encodingOrOffset, length) {
					return Buffer(arg, encodingOrOffset, length);
				}

				// Copy static methods from Buffer
				copyProps(Buffer, SafeBuffer);

				SafeBuffer.from = function (arg, encodingOrOffset, length) {
					if (typeof arg === 'number') {
						throw new TypeError('Argument must not be a number');
					}
					return Buffer(arg, encodingOrOffset, length);
				};

				SafeBuffer.alloc = function (size, fill, encoding) {
					if (typeof size !== 'number') {
						throw new TypeError('Argument must be a number');
					}
					var buf = Buffer(size);
					if (fill !== undefined) {
						if (typeof encoding === 'string') {
							buf.fill(fill, encoding);
						} else {
							buf.fill(fill);
						}
					} else {
						buf.fill(0);
					}
					return buf;
				};

				SafeBuffer.allocUnsafe = function (size) {
					if (typeof size !== 'number') {
						throw new TypeError('Argument must be a number');
					}
					return Buffer(size);
				};

				SafeBuffer.allocUnsafeSlow = function (size) {
					if (typeof size !== 'number') {
						throw new TypeError('Argument must be a number');
					}
					return buffer.SlowBuffer(size);
				};
			},
			{ buffer: '../node_modules/node-libs-browser/node_modules/buffer/index.js' }
		],
		'../node_modules/string_decoder/lib/string_decoder.js': [
			function (require, module, exports) {
				// Copyright Joyent, Inc. and other Node contributors.
				//
				// Permission is hereby granted, free of charge, to any person obtaining a
				// copy of this software and associated documentation files (the
				// "Software"), to deal in the Software without restriction, including
				// without limitation the rights to use, copy, modify, merge, publish,
				// distribute, sublicense, and/or sell copies of the Software, and to permit
				// persons to whom the Software is furnished to do so, subject to the
				// following conditions:
				//
				// The above copyright notice and this permission notice shall be included
				// in all copies or substantial portions of the Software.
				//
				// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
				// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
				// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
				// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
				// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
				// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
				// USE OR OTHER DEALINGS IN THE SOFTWARE.

				'use strict';

				/*<replacement>*/

				var Buffer = require('safe-buffer').Buffer;
				/*</replacement>*/

				var isEncoding =
					Buffer.isEncoding ||
					function (encoding) {
						encoding = '' + encoding;
						switch (encoding && encoding.toLowerCase()) {
							case 'hex':
							case 'utf8':
							case 'utf-8':
							case 'ascii':
							case 'binary':
							case 'base64':
							case 'ucs2':
							case 'ucs-2':
							case 'utf16le':
							case 'utf-16le':
							case 'raw':
								return true;
							default:
								return false;
						}
					};

				function _normalizeEncoding(enc) {
					if (!enc) return 'utf8';
					var retried;
					while (true) {
						switch (enc) {
							case 'utf8':
							case 'utf-8':
								return 'utf8';
							case 'ucs2':
							case 'ucs-2':
							case 'utf16le':
							case 'utf-16le':
								return 'utf16le';
							case 'latin1':
							case 'binary':
								return 'latin1';
							case 'base64':
							case 'ascii':
							case 'hex':
								return enc;
							default:
								if (retried) return; // undefined
								enc = ('' + enc).toLowerCase();
								retried = true;
						}
					}
				}

				// Do not cache `Buffer.isEncoding` when checking encoding names as some
				// modules monkey-patch it to support additional encodings
				function normalizeEncoding(enc) {
					var nenc = _normalizeEncoding(enc);
					if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc)))
						throw new Error('Unknown encoding: ' + enc);
					return nenc || enc;
				}

				// StringDecoder provides an interface for efficiently splitting a series of
				// buffers into a series of JS strings without breaking apart multi-byte
				// characters.
				exports.StringDecoder = StringDecoder;
				function StringDecoder(encoding) {
					this.encoding = normalizeEncoding(encoding);
					var nb;
					switch (this.encoding) {
						case 'utf16le':
							this.text = utf16Text;
							this.end = utf16End;
							nb = 4;
							break;
						case 'utf8':
							this.fillLast = utf8FillLast;
							nb = 4;
							break;
						case 'base64':
							this.text = base64Text;
							this.end = base64End;
							nb = 3;
							break;
						default:
							this.write = simpleWrite;
							this.end = simpleEnd;
							return;
					}
					this.lastNeed = 0;
					this.lastTotal = 0;
					this.lastChar = Buffer.allocUnsafe(nb);
				}

				StringDecoder.prototype.write = function (buf) {
					if (buf.length === 0) return '';
					var r;
					var i;
					if (this.lastNeed) {
						r = this.fillLast(buf);
						if (r === undefined) return '';
						i = this.lastNeed;
						this.lastNeed = 0;
					} else {
						i = 0;
					}
					if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
					return r || '';
				};

				StringDecoder.prototype.end = utf8End;

				// Returns only complete characters in a Buffer
				StringDecoder.prototype.text = utf8Text;

				// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
				StringDecoder.prototype.fillLast = function (buf) {
					if (this.lastNeed <= buf.length) {
						buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
						return this.lastChar.toString(this.encoding, 0, this.lastTotal);
					}
					buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
					this.lastNeed -= buf.length;
				};

				// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
				// continuation byte. If an invalid byte is detected, -2 is returned.
				function utf8CheckByte(byte) {
					if (byte <= 0x7f) return 0;
					else if (byte >> 5 === 0x06) return 2;
					else if (byte >> 4 === 0x0e) return 3;
					else if (byte >> 3 === 0x1e) return 4;
					return byte >> 6 === 0x02 ? -1 : -2;
				}

				// Checks at most 3 bytes at the end of a Buffer in order to detect an
				// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
				// needed to complete the UTF-8 character (if applicable) are returned.
				function utf8CheckIncomplete(self, buf, i) {
					var j = buf.length - 1;
					if (j < i) return 0;
					var nb = utf8CheckByte(buf[j]);
					if (nb >= 0) {
						if (nb > 0) self.lastNeed = nb - 1;
						return nb;
					}
					if (--j < i || nb === -2) return 0;
					nb = utf8CheckByte(buf[j]);
					if (nb >= 0) {
						if (nb > 0) self.lastNeed = nb - 2;
						return nb;
					}
					if (--j < i || nb === -2) return 0;
					nb = utf8CheckByte(buf[j]);
					if (nb >= 0) {
						if (nb > 0) {
							if (nb === 2) nb = 0;
							else self.lastNeed = nb - 3;
						}
						return nb;
					}
					return 0;
				}

				// Validates as many continuation bytes for a multi-byte UTF-8 character as
				// needed or are available. If we see a non-continuation byte where we expect
				// one, we "replace" the validated continuation bytes we've seen so far with
				// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
				// behavior. The continuation byte check is included three times in the case
				// where all of the continuation bytes for a character exist in the same buffer.
				// It is also done this way as a slight performance increase instead of using a
				// loop.
				function utf8CheckExtraBytes(self, buf, p) {
					if ((buf[0] & 0xc0) !== 0x80) {
						self.lastNeed = 0;
						return '\ufffd';
					}
					if (self.lastNeed > 1 && buf.length > 1) {
						if ((buf[1] & 0xc0) !== 0x80) {
							self.lastNeed = 1;
							return '\ufffd';
						}
						if (self.lastNeed > 2 && buf.length > 2) {
							if ((buf[2] & 0xc0) !== 0x80) {
								self.lastNeed = 2;
								return '\ufffd';
							}
						}
					}
				}

				// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
				function utf8FillLast(buf) {
					var p = this.lastTotal - this.lastNeed;
					var r = utf8CheckExtraBytes(this, buf, p);
					if (r !== undefined) return r;
					if (this.lastNeed <= buf.length) {
						buf.copy(this.lastChar, p, 0, this.lastNeed);
						return this.lastChar.toString(this.encoding, 0, this.lastTotal);
					}
					buf.copy(this.lastChar, p, 0, buf.length);
					this.lastNeed -= buf.length;
				}

				// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
				// partial character, the character's bytes are buffered until the required
				// number of bytes are available.
				function utf8Text(buf, i) {
					var total = utf8CheckIncomplete(this, buf, i);
					if (!this.lastNeed) return buf.toString('utf8', i);
					this.lastTotal = total;
					var end = buf.length - (total - this.lastNeed);
					buf.copy(this.lastChar, 0, end);
					return buf.toString('utf8', i, end);
				}

				// For UTF-8, a replacement character is added when ending on a partial
				// character.
				function utf8End(buf) {
					var r = buf && buf.length ? this.write(buf) : '';
					if (this.lastNeed) return r + '\ufffd';
					return r;
				}

				// UTF-16LE typically needs two bytes per character, but even if we have an even
				// number of bytes available, we need to check if we end on a leading/high
				// surrogate. In that case, we need to wait for the next two bytes in order to
				// decode the last character properly.
				function utf16Text(buf, i) {
					if ((buf.length - i) % 2 === 0) {
						var r = buf.toString('utf16le', i);
						if (r) {
							var c = r.charCodeAt(r.length - 1);
							if (c >= 0xd800 && c <= 0xdbff) {
								this.lastNeed = 2;
								this.lastTotal = 4;
								this.lastChar[0] = buf[buf.length - 2];
								this.lastChar[1] = buf[buf.length - 1];
								return r.slice(0, -1);
							}
						}
						return r;
					}
					this.lastNeed = 1;
					this.lastTotal = 2;
					this.lastChar[0] = buf[buf.length - 1];
					return buf.toString('utf16le', i, buf.length - 1);
				}

				// For UTF-16LE we do not explicitly append special replacement characters if we
				// end on a partial character, we simply let v8 handle that.
				function utf16End(buf) {
					var r = buf && buf.length ? this.write(buf) : '';
					if (this.lastNeed) {
						var end = this.lastTotal - this.lastNeed;
						return r + this.lastChar.toString('utf16le', 0, end);
					}
					return r;
				}

				function base64Text(buf, i) {
					var n = (buf.length - i) % 3;
					if (n === 0) return buf.toString('base64', i);
					this.lastNeed = 3 - n;
					this.lastTotal = 3;
					if (n === 1) {
						this.lastChar[0] = buf[buf.length - 1];
					} else {
						this.lastChar[0] = buf[buf.length - 2];
						this.lastChar[1] = buf[buf.length - 1];
					}
					return buf.toString('base64', i, buf.length - n);
				}

				function base64End(buf) {
					var r = buf && buf.length ? this.write(buf) : '';
					if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
					return r;
				}

				// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
				function simpleWrite(buf) {
					return buf.toString(this.encoding);
				}

				function simpleEnd(buf) {
					return buf && buf.length ? this.write(buf) : '';
				}
			},
			{ 'safe-buffer': '../node_modules/string_decoder/node_modules/safe-buffer/index.js' }
		],
		'../node_modules/readable-stream/lib/_stream_readable.js': [
			function (require, module, exports) {
				var global = arguments[3];
				var process = require('process');
				// Copyright Joyent, Inc. and other Node contributors.
				//
				// Permission is hereby granted, free of charge, to any person obtaining a
				// copy of this software and associated documentation files (the
				// "Software"), to deal in the Software without restriction, including
				// without limitation the rights to use, copy, modify, merge, publish,
				// distribute, sublicense, and/or sell copies of the Software, and to permit
				// persons to whom the Software is furnished to do so, subject to the
				// following conditions:
				//
				// The above copyright notice and this permission notice shall be included
				// in all copies or substantial portions of the Software.
				//
				// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
				// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
				// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
				// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
				// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
				// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
				// USE OR OTHER DEALINGS IN THE SOFTWARE.

				('use strict');

				/*<replacement>*/

				var pna = require('process-nextick-args');
				/*</replacement>*/

				module.exports = Readable;

				/*<replacement>*/
				var isArray = require('isarray');
				/*</replacement>*/

				/*<replacement>*/
				var Duplex;
				/*</replacement>*/

				Readable.ReadableState = ReadableState;

				/*<replacement>*/
				var EE = require('events').EventEmitter;

				var EElistenerCount = function (emitter, type) {
					return emitter.listeners(type).length;
				};
				/*</replacement>*/

				/*<replacement>*/
				var Stream = require('./internal/streams/stream');
				/*</replacement>*/

				/*<replacement>*/

				var Buffer = require('safe-buffer').Buffer;
				var OurUint8Array = global.Uint8Array || function () {};
				function _uint8ArrayToBuffer(chunk) {
					return Buffer.from(chunk);
				}
				function _isUint8Array(obj) {
					return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
				}

				/*</replacement>*/

				/*<replacement>*/
				var util = require('core-util-is');
				util.inherits = require('inherits');
				/*</replacement>*/

				/*<replacement>*/
				var debugUtil = require('util');
				var debug = void 0;
				if (debugUtil && debugUtil.debuglog) {
					debug = debugUtil.debuglog('stream');
				} else {
					debug = function () {};
				}
				/*</replacement>*/

				var BufferList = require('./internal/streams/BufferList');
				var destroyImpl = require('./internal/streams/destroy');
				var StringDecoder;

				util.inherits(Readable, Stream);

				var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

				function prependListener(emitter, event, fn) {
					// Sadly this is not cacheable as some libraries bundle their own
					// event emitter implementation with them.
					if (typeof emitter.prependListener === 'function')
						return emitter.prependListener(event, fn);

					// This is a hack to make sure that our error handler is attached before any
					// userland ones.  NEVER DO THIS. This is here only because this code needs
					// to continue to work with older versions of Node.js that do not include
					// the prependListener() method. The goal is to eventually remove this hack.
					if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
					else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);
					else emitter._events[event] = [fn, emitter._events[event]];
				}

				function ReadableState(options, stream) {
					Duplex = Duplex || require('./_stream_duplex');

					options = options || {};

					// Duplex streams are both readable and writable, but share
					// the same options object.
					// However, some cases require setting options to different
					// values for the readable and the writable sides of the duplex stream.
					// These options can be provided separately as readableXXX and writableXXX.
					var isDuplex = stream instanceof Duplex;

					// object stream flag. Used to make read(n) ignore n and to
					// make all the buffer merging and length checks go away
					this.objectMode = !!options.objectMode;

					if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

					// the point at which it stops calling _read() to fill the buffer
					// Note: 0 is a valid value, means "don't call _read preemptively ever"
					var hwm = options.highWaterMark;
					var readableHwm = options.readableHighWaterMark;
					var defaultHwm = this.objectMode ? 16 : 16 * 1024;

					if (hwm || hwm === 0) this.highWaterMark = hwm;
					else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
					else this.highWaterMark = defaultHwm;

					// cast to ints.
					this.highWaterMark = Math.floor(this.highWaterMark);

					// A linked list is used to store data chunks instead of an array because the
					// linked list can remove elements from the beginning faster than
					// array.shift()
					this.buffer = new BufferList();
					this.length = 0;
					this.pipes = null;
					this.pipesCount = 0;
					this.flowing = null;
					this.ended = false;
					this.endEmitted = false;
					this.reading = false;

					// a flag to be able to tell if the event 'readable'/'data' is emitted
					// immediately, or on a later tick.  We set this to true at first, because
					// any actions that shouldn't happen until "later" should generally also
					// not happen before the first read call.
					this.sync = true;

					// whenever we return null, then we set a flag to say
					// that we're awaiting a 'readable' event emission.
					this.needReadable = false;
					this.emittedReadable = false;
					this.readableListening = false;
					this.resumeScheduled = false;

					// has it been destroyed
					this.destroyed = false;

					// Crypto is kind of old and crusty.  Historically, its default string
					// encoding is 'binary' so we have to make this configurable.
					// Everything else in the universe uses 'utf8', though.
					this.defaultEncoding = options.defaultEncoding || 'utf8';

					// the number of writers that are awaiting a drain event in .pipe()s
					this.awaitDrain = 0;

					// if true, a maybeReadMore has been scheduled
					this.readingMore = false;

					this.decoder = null;
					this.encoding = null;
					if (options.encoding) {
						if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
						this.decoder = new StringDecoder(options.encoding);
						this.encoding = options.encoding;
					}
				}

				function Readable(options) {
					Duplex = Duplex || require('./_stream_duplex');

					if (!(this instanceof Readable)) return new Readable(options);

					this._readableState = new ReadableState(options, this);

					// legacy
					this.readable = true;

					if (options) {
						if (typeof options.read === 'function') this._read = options.read;

						if (typeof options.destroy === 'function') this._destroy = options.destroy;
					}

					Stream.call(this);
				}

				Object.defineProperty(Readable.prototype, 'destroyed', {
					get: function () {
						if (this._readableState === undefined) {
							return false;
						}
						return this._readableState.destroyed;
					},
					set: function (value) {
						// we ignore the value if the stream
						// has not been initialized yet
						if (!this._readableState) {
							return;
						}

						// backward compatibility, the user is explicitly
						// managing destroyed
						this._readableState.destroyed = value;
					}
				});

				Readable.prototype.destroy = destroyImpl.destroy;
				Readable.prototype._undestroy = destroyImpl.undestroy;
				Readable.prototype._destroy = function (err, cb) {
					this.push(null);
					cb(err);
				};

				// Manually shove something into the read() buffer.
				// This returns true if the highWaterMark has not been hit yet,
				// similar to how Writable.write() returns true if you should
				// write() some more.
				Readable.prototype.push = function (chunk, encoding) {
					var state = this._readableState;
					var skipChunkCheck;

					if (!state.objectMode) {
						if (typeof chunk === 'string') {
							encoding = encoding || state.defaultEncoding;
							if (encoding !== state.encoding) {
								chunk = Buffer.from(chunk, encoding);
								encoding = '';
							}
							skipChunkCheck = true;
						}
					} else {
						skipChunkCheck = true;
					}

					return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
				};

				// Unshift should *always* be something directly out of read()
				Readable.prototype.unshift = function (chunk) {
					return readableAddChunk(this, chunk, null, true, false);
				};

				function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
					var state = stream._readableState;
					if (chunk === null) {
						state.reading = false;
						onEofChunk(stream, state);
					} else {
						var er;
						if (!skipChunkCheck) er = chunkInvalid(state, chunk);
						if (er) {
							stream.emit('error', er);
						} else if (state.objectMode || (chunk && chunk.length > 0)) {
							if (
								typeof chunk !== 'string' &&
								!state.objectMode &&
								Object.getPrototypeOf(chunk) !== Buffer.prototype
							) {
								chunk = _uint8ArrayToBuffer(chunk);
							}

							if (addToFront) {
								if (state.endEmitted)
									stream.emit('error', new Error('stream.unshift() after end event'));
								else addChunk(stream, state, chunk, true);
							} else if (state.ended) {
								stream.emit('error', new Error('stream.push() after EOF'));
							} else {
								state.reading = false;
								if (state.decoder && !encoding) {
									chunk = state.decoder.write(chunk);
									if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
									else maybeReadMore(stream, state);
								} else {
									addChunk(stream, state, chunk, false);
								}
							}
						} else if (!addToFront) {
							state.reading = false;
						}
					}

					return needMoreData(state);
				}

				function addChunk(stream, state, chunk, addToFront) {
					if (state.flowing && state.length === 0 && !state.sync) {
						stream.emit('data', chunk);
						stream.read(0);
					} else {
						// update the buffer info.
						state.length += state.objectMode ? 1 : chunk.length;
						if (addToFront) state.buffer.unshift(chunk);
						else state.buffer.push(chunk);

						if (state.needReadable) emitReadable(stream);
					}
					maybeReadMore(stream, state);
				}

				function chunkInvalid(state, chunk) {
					var er;
					if (
						!_isUint8Array(chunk) &&
						typeof chunk !== 'string' &&
						chunk !== undefined &&
						!state.objectMode
					) {
						er = new TypeError('Invalid non-string/buffer chunk');
					}
					return er;
				}

				// if it's past the high water mark, we can push in some more.
				// Also, if we have no data yet, we can stand some
				// more bytes.  This is to work around cases where hwm=0,
				// such as the repl.  Also, if the push() triggered a
				// readable event, and the user called read(largeNumber) such that
				// needReadable was set, then we ought to push more, so that another
				// 'readable' event will be triggered.
				function needMoreData(state) {
					return (
						!state.ended &&
						(state.needReadable || state.length < state.highWaterMark || state.length === 0)
					);
				}

				Readable.prototype.isPaused = function () {
					return this._readableState.flowing === false;
				};

				// backwards compatibility.
				Readable.prototype.setEncoding = function (enc) {
					if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
					this._readableState.decoder = new StringDecoder(enc);
					this._readableState.encoding = enc;
					return this;
				};

				// Don't raise the hwm > 8MB
				var MAX_HWM = 0x800000;
				function computeNewHighWaterMark(n) {
					if (n >= MAX_HWM) {
						n = MAX_HWM;
					} else {
						// Get the next highest power of 2 to prevent increasing hwm excessively in
						// tiny amounts
						n--;
						n |= n >>> 1;
						n |= n >>> 2;
						n |= n >>> 4;
						n |= n >>> 8;
						n |= n >>> 16;
						n++;
					}
					return n;
				}

				// This function is designed to be inlinable, so please take care when making
				// changes to the function body.
				function howMuchToRead(n, state) {
					if (n <= 0 || (state.length === 0 && state.ended)) return 0;
					if (state.objectMode) return 1;
					if (n !== n) {
						// Only flow one buffer at a time
						if (state.flowing && state.length) return state.buffer.head.data.length;
						else return state.length;
					}
					// If we're asking for more than the current hwm, then raise the hwm.
					if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
					if (n <= state.length) return n;
					// Don't have enough
					if (!state.ended) {
						state.needReadable = true;
						return 0;
					}
					return state.length;
				}

				// you can override either this method, or the async _read(n) below.
				Readable.prototype.read = function (n) {
					debug('read', n);
					n = parseInt(n, 10);
					var state = this._readableState;
					var nOrig = n;

					if (n !== 0) state.emittedReadable = false;

					// if we're doing read(0) to trigger a readable event, but we
					// already have a bunch of data in the buffer, then just trigger
					// the 'readable' event and move on.
					if (
						n === 0 &&
						state.needReadable &&
						(state.length >= state.highWaterMark || state.ended)
					) {
						debug('read: emitReadable', state.length, state.ended);
						if (state.length === 0 && state.ended) endReadable(this);
						else emitReadable(this);
						return null;
					}

					n = howMuchToRead(n, state);

					// if we've ended, and we're now clear, then finish it up.
					if (n === 0 && state.ended) {
						if (state.length === 0) endReadable(this);
						return null;
					}

					// All the actual chunk generation logic needs to be
					// *below* the call to _read.  The reason is that in certain
					// synthetic stream cases, such as passthrough streams, _read
					// may be a completely synchronous operation which may change
					// the state of the read buffer, providing enough data when
					// before there was *not* enough.
					//
					// So, the steps are:
					// 1. Figure out what the state of things will be after we do
					// a read from the buffer.
					//
					// 2. If that resulting state will trigger a _read, then call _read.
					// Note that this may be asynchronous, or synchronous.  Yes, it is
					// deeply ugly to write APIs this way, but that still doesn't mean
					// that the Readable class should behave improperly, as streams are
					// designed to be sync/async agnostic.
					// Take note if the _read call is sync or async (ie, if the read call
					// has returned yet), so that we know whether or not it's safe to emit
					// 'readable' etc.
					//
					// 3. Actually pull the requested chunks out of the buffer and return.

					// if we need a readable event, then we need to do some reading.
					var doRead = state.needReadable;
					debug('need readable', doRead);

					// if we currently have less than the highWaterMark, then also read some
					if (state.length === 0 || state.length - n < state.highWaterMark) {
						doRead = true;
						debug('length less than watermark', doRead);
					}

					// however, if we've ended, then there's no point, and if we're already
					// reading, then it's unnecessary.
					if (state.ended || state.reading) {
						doRead = false;
						debug('reading or ended', doRead);
					} else if (doRead) {
						debug('do read');
						state.reading = true;
						state.sync = true;
						// if the length is currently zero, then we *need* a readable event.
						if (state.length === 0) state.needReadable = true;
						// call internal read method
						this._read(state.highWaterMark);
						state.sync = false;
						// If _read pushed data synchronously, then `reading` will be false,
						// and we need to re-evaluate how much data we can return to the user.
						if (!state.reading) n = howMuchToRead(nOrig, state);
					}

					var ret;
					if (n > 0) ret = fromList(n, state);
					else ret = null;

					if (ret === null) {
						state.needReadable = true;
						n = 0;
					} else {
						state.length -= n;
					}

					if (state.length === 0) {
						// If we have nothing in the buffer, then we want to know
						// as soon as we *do* get something into the buffer.
						if (!state.ended) state.needReadable = true;

						// If we tried to read() past the EOF, then emit end on the next tick.
						if (nOrig !== n && state.ended) endReadable(this);
					}

					if (ret !== null) this.emit('data', ret);

					return ret;
				};

				function onEofChunk(stream, state) {
					if (state.ended) return;
					if (state.decoder) {
						var chunk = state.decoder.end();
						if (chunk && chunk.length) {
							state.buffer.push(chunk);
							state.length += state.objectMode ? 1 : chunk.length;
						}
					}
					state.ended = true;

					// emit 'readable' now to make sure it gets picked up.
					emitReadable(stream);
				}

				// Don't emit readable right away in sync mode, because this can trigger
				// another read() call => stack overflow.  This way, it might trigger
				// a nextTick recursion warning, but that's not so bad.
				function emitReadable(stream) {
					var state = stream._readableState;
					state.needReadable = false;
					if (!state.emittedReadable) {
						debug('emitReadable', state.flowing);
						state.emittedReadable = true;
						if (state.sync) pna.nextTick(emitReadable_, stream);
						else emitReadable_(stream);
					}
				}

				function emitReadable_(stream) {
					debug('emit readable');
					stream.emit('readable');
					flow(stream);
				}

				// at this point, the user has presumably seen the 'readable' event,
				// and called read() to consume some data.  that may have triggered
				// in turn another _read(n) call, in which case reading = true if
				// it's in progress.
				// However, if we're not ended, or reading, and the length < hwm,
				// then go ahead and try to read some more preemptively.
				function maybeReadMore(stream, state) {
					if (!state.readingMore) {
						state.readingMore = true;
						pna.nextTick(maybeReadMore_, stream, state);
					}
				}

				function maybeReadMore_(stream, state) {
					var len = state.length;
					while (
						!state.reading &&
						!state.flowing &&
						!state.ended &&
						state.length < state.highWaterMark
					) {
						debug('maybeReadMore read 0');
						stream.read(0);
						if (len === state.length)
							// didn't get any data, stop spinning.
							break;
						else len = state.length;
					}
					state.readingMore = false;
				}

				// abstract method.  to be overridden in specific implementation classes.
				// call cb(er, data) where data is <= n in length.
				// for virtual (non-string, non-buffer) streams, "length" is somewhat
				// arbitrary, and perhaps not very meaningful.
				Readable.prototype._read = function (n) {
					this.emit('error', new Error('_read() is not implemented'));
				};

				Readable.prototype.pipe = function (dest, pipeOpts) {
					var src = this;
					var state = this._readableState;

					switch (state.pipesCount) {
						case 0:
							state.pipes = dest;
							break;
						case 1:
							state.pipes = [state.pipes, dest];
							break;
						default:
							state.pipes.push(dest);
							break;
					}
					state.pipesCount += 1;
					debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

					var doEnd =
						(!pipeOpts || pipeOpts.end !== false) &&
						dest !== process.stdout &&
						dest !== process.stderr;

					var endFn = doEnd ? onend : unpipe;
					if (state.endEmitted) pna.nextTick(endFn);
					else src.once('end', endFn);

					dest.on('unpipe', onunpipe);
					function onunpipe(readable, unpipeInfo) {
						debug('onunpipe');
						if (readable === src) {
							if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
								unpipeInfo.hasUnpiped = true;
								cleanup();
							}
						}
					}

					function onend() {
						debug('onend');
						dest.end();
					}

					// when the dest drains, it reduces the awaitDrain counter
					// on the source.  This would be more elegant with a .once()
					// handler in flow(), but adding and removing repeatedly is
					// too slow.
					var ondrain = pipeOnDrain(src);
					dest.on('drain', ondrain);

					var cleanedUp = false;
					function cleanup() {
						debug('cleanup');
						// cleanup event handlers once the pipe is broken
						dest.removeListener('close', onclose);
						dest.removeListener('finish', onfinish);
						dest.removeListener('drain', ondrain);
						dest.removeListener('error', onerror);
						dest.removeListener('unpipe', onunpipe);
						src.removeListener('end', onend);
						src.removeListener('end', unpipe);
						src.removeListener('data', ondata);

						cleanedUp = true;

						// if the reader is waiting for a drain event from this
						// specific writer, then it would cause it to never start
						// flowing again.
						// So, if this is awaiting a drain, then we just call it now.
						// If we don't know, then assume that we are waiting for one.
						if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
							ondrain();
					}

					// If the user pushes more data while we're writing to dest then we'll end up
					// in ondata again. However, we only want to increase awaitDrain once because
					// dest will only emit one 'drain' event for the multiple writes.
					// => Introduce a guard on increasing awaitDrain.
					var increasedAwaitDrain = false;
					src.on('data', ondata);
					function ondata(chunk) {
						debug('ondata');
						increasedAwaitDrain = false;
						var ret = dest.write(chunk);
						if (false === ret && !increasedAwaitDrain) {
							// If the user unpiped during `dest.write()`, it is possible
							// to get stuck in a permanently paused state if that write
							// also returned false.
							// => Check whether `dest` is still a piping destination.
							if (
								((state.pipesCount === 1 && state.pipes === dest) ||
									(state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1)) &&
								!cleanedUp
							) {
								debug('false write response, pause', src._readableState.awaitDrain);
								src._readableState.awaitDrain++;
								increasedAwaitDrain = true;
							}
							src.pause();
						}
					}

					// if the dest has an error, then stop piping into it.
					// however, don't suppress the throwing behavior for this.
					function onerror(er) {
						debug('onerror', er);
						unpipe();
						dest.removeListener('error', onerror);
						if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
					}

					// Make sure our error handler is attached before userland ones.
					prependListener(dest, 'error', onerror);

					// Both close and finish should trigger unpipe, but only once.
					function onclose() {
						dest.removeListener('finish', onfinish);
						unpipe();
					}
					dest.once('close', onclose);
					function onfinish() {
						debug('onfinish');
						dest.removeListener('close', onclose);
						unpipe();
					}
					dest.once('finish', onfinish);

					function unpipe() {
						debug('unpipe');
						src.unpipe(dest);
					}

					// tell the dest that it's being piped to
					dest.emit('pipe', src);

					// start the flow if it hasn't been started already.
					if (!state.flowing) {
						debug('pipe resume');
						src.resume();
					}

					return dest;
				};

				function pipeOnDrain(src) {
					return function () {
						var state = src._readableState;
						debug('pipeOnDrain', state.awaitDrain);
						if (state.awaitDrain) state.awaitDrain--;
						if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
							state.flowing = true;
							flow(src);
						}
					};
				}

				Readable.prototype.unpipe = function (dest) {
					var state = this._readableState;
					var unpipeInfo = { hasUnpiped: false };

					// if we're not piping anywhere, then do nothing.
					if (state.pipesCount === 0) return this;

					// just one destination.  most common case.
					if (state.pipesCount === 1) {
						// passed in one, but it's not the right one.
						if (dest && dest !== state.pipes) return this;

						if (!dest) dest = state.pipes;

						// got a match.
						state.pipes = null;
						state.pipesCount = 0;
						state.flowing = false;
						if (dest) dest.emit('unpipe', this, unpipeInfo);
						return this;
					}

					// slow case. multiple pipe destinations.

					if (!dest) {
						// remove all.
						var dests = state.pipes;
						var len = state.pipesCount;
						state.pipes = null;
						state.pipesCount = 0;
						state.flowing = false;

						for (var i = 0; i < len; i++) {
							dests[i].emit('unpipe', this, unpipeInfo);
						}
						return this;
					}

					// try to find the right one.
					var index = indexOf(state.pipes, dest);
					if (index === -1) return this;

					state.pipes.splice(index, 1);
					state.pipesCount -= 1;
					if (state.pipesCount === 1) state.pipes = state.pipes[0];

					dest.emit('unpipe', this, unpipeInfo);

					return this;
				};

				// set up data events if they are asked for
				// Ensure readable listeners eventually get something
				Readable.prototype.on = function (ev, fn) {
					var res = Stream.prototype.on.call(this, ev, fn);

					if (ev === 'data') {
						// Start flowing on next tick if stream isn't explicitly paused
						if (this._readableState.flowing !== false) this.resume();
					} else if (ev === 'readable') {
						var state = this._readableState;
						if (!state.endEmitted && !state.readableListening) {
							state.readableListening = state.needReadable = true;
							state.emittedReadable = false;
							if (!state.reading) {
								pna.nextTick(nReadingNextTick, this);
							} else if (state.length) {
								emitReadable(this);
							}
						}
					}

					return res;
				};
				Readable.prototype.addListener = Readable.prototype.on;

				function nReadingNextTick(self) {
					debug('readable nexttick read 0');
					self.read(0);
				}

				// pause() and resume() are remnants of the legacy readable stream API
				// If the user uses them, then switch into old mode.
				Readable.prototype.resume = function () {
					var state = this._readableState;
					if (!state.flowing) {
						debug('resume');
						state.flowing = true;
						resume(this, state);
					}
					return this;
				};

				function resume(stream, state) {
					if (!state.resumeScheduled) {
						state.resumeScheduled = true;
						pna.nextTick(resume_, stream, state);
					}
				}

				function resume_(stream, state) {
					if (!state.reading) {
						debug('resume read 0');
						stream.read(0);
					}

					state.resumeScheduled = false;
					state.awaitDrain = 0;
					stream.emit('resume');
					flow(stream);
					if (state.flowing && !state.reading) stream.read(0);
				}

				Readable.prototype.pause = function () {
					debug('call pause flowing=%j', this._readableState.flowing);
					if (false !== this._readableState.flowing) {
						debug('pause');
						this._readableState.flowing = false;
						this.emit('pause');
					}
					return this;
				};

				function flow(stream) {
					var state = stream._readableState;
					debug('flow', state.flowing);
					while (state.flowing && stream.read() !== null) {}
				}

				// wrap an old-style stream as the async data source.
				// This is *not* part of the readable stream interface.
				// It is an ugly unfortunate mess of history.
				Readable.prototype.wrap = function (stream) {
					var _this = this;

					var state = this._readableState;
					var paused = false;

					stream.on('end', function () {
						debug('wrapped end');
						if (state.decoder && !state.ended) {
							var chunk = state.decoder.end();
							if (chunk && chunk.length) _this.push(chunk);
						}

						_this.push(null);
					});

					stream.on('data', function (chunk) {
						debug('wrapped data');
						if (state.decoder) chunk = state.decoder.write(chunk);

						// don't skip over falsy values in objectMode
						if (state.objectMode && (chunk === null || chunk === undefined)) return;
						else if (!state.objectMode && (!chunk || !chunk.length)) return;

						var ret = _this.push(chunk);
						if (!ret) {
							paused = true;
							stream.pause();
						}
					});

					// proxy all the other methods.
					// important when wrapping filters and duplexes.
					for (var i in stream) {
						if (this[i] === undefined && typeof stream[i] === 'function') {
							this[i] = (function (method) {
								return function () {
									return stream[method].apply(stream, arguments);
								};
							})(i);
						}
					}

					// proxy certain important events.
					for (var n = 0; n < kProxyEvents.length; n++) {
						stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
					}

					// when we try to consume some more bytes, simply unpause the
					// underlying stream.
					this._read = function (n) {
						debug('wrapped _read', n);
						if (paused) {
							paused = false;
							stream.resume();
						}
					};

					return this;
				};

				Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
					// making it explicit this property is not enumerable
					// because otherwise some prototype manipulation in
					// userland will fail
					enumerable: false,
					get: function () {
						return this._readableState.highWaterMark;
					}
				});

				// exposed for testing purposes only.
				Readable._fromList = fromList;

				// Pluck off n bytes from an array of buffers.
				// Length is the combined lengths of all the buffers in the list.
				// This function is designed to be inlinable, so please take care when making
				// changes to the function body.
				function fromList(n, state) {
					// nothing buffered
					if (state.length === 0) return null;

					var ret;
					if (state.objectMode) ret = state.buffer.shift();
					else if (!n || n >= state.length) {
						// read it all, truncate the list
						if (state.decoder) ret = state.buffer.join('');
						else if (state.buffer.length === 1) ret = state.buffer.head.data;
						else ret = state.buffer.concat(state.length);
						state.buffer.clear();
					} else {
						// read part of list
						ret = fromListPartial(n, state.buffer, state.decoder);
					}

					return ret;
				}

				// Extracts only enough buffered data to satisfy the amount requested.
				// This function is designed to be inlinable, so please take care when making
				// changes to the function body.
				function fromListPartial(n, list, hasStrings) {
					var ret;
					if (n < list.head.data.length) {
						// slice is the same for buffers and strings
						ret = list.head.data.slice(0, n);
						list.head.data = list.head.data.slice(n);
					} else if (n === list.head.data.length) {
						// first chunk is a perfect match
						ret = list.shift();
					} else {
						// result spans more than one buffer
						ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
					}
					return ret;
				}

				// Copies a specified amount of characters from the list of buffered data
				// chunks.
				// This function is designed to be inlinable, so please take care when making
				// changes to the function body.
				function copyFromBufferString(n, list) {
					var p = list.head;
					var c = 1;
					var ret = p.data;
					n -= ret.length;
					while ((p = p.next)) {
						var str = p.data;
						var nb = n > str.length ? str.length : n;
						if (nb === str.length) ret += str;
						else ret += str.slice(0, n);
						n -= nb;
						if (n === 0) {
							if (nb === str.length) {
								++c;
								if (p.next) list.head = p.next;
								else list.head = list.tail = null;
							} else {
								list.head = p;
								p.data = str.slice(nb);
							}
							break;
						}
						++c;
					}
					list.length -= c;
					return ret;
				}

				// Copies a specified amount of bytes from the list of buffered data chunks.
				// This function is designed to be inlinable, so please take care when making
				// changes to the function body.
				function copyFromBuffer(n, list) {
					var ret = Buffer.allocUnsafe(n);
					var p = list.head;
					var c = 1;
					p.data.copy(ret);
					n -= p.data.length;
					while ((p = p.next)) {
						var buf = p.data;
						var nb = n > buf.length ? buf.length : n;
						buf.copy(ret, ret.length - n, 0, nb);
						n -= nb;
						if (n === 0) {
							if (nb === buf.length) {
								++c;
								if (p.next) list.head = p.next;
								else list.head = list.tail = null;
							} else {
								list.head = p;
								p.data = buf.slice(nb);
							}
							break;
						}
						++c;
					}
					list.length -= c;
					return ret;
				}

				function endReadable(stream) {
					var state = stream._readableState;

					// If we get here before consuming all the bytes, then that is a
					// bug in node.  Should never happen.
					if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

					if (!state.endEmitted) {
						state.ended = true;
						pna.nextTick(endReadableNT, state, stream);
					}
				}

				function endReadableNT(state, stream) {
					// Check that we didn't get one last unshift.
					if (!state.endEmitted && state.length === 0) {
						state.endEmitted = true;
						stream.readable = false;
						stream.emit('end');
					}
				}

				function indexOf(xs, x) {
					for (var i = 0, l = xs.length; i < l; i++) {
						if (xs[i] === x) return i;
					}
					return -1;
				}
			},
			{
				'process-nextick-args': '../node_modules/process-nextick-args/index.js',
				isarray: '../node_modules/isarray/index.js',
				events: '../node_modules/events/events.js',
				'./internal/streams/stream':
					'../node_modules/readable-stream/lib/internal/streams/stream-browser.js',
				'safe-buffer': '../node_modules/readable-stream/node_modules/safe-buffer/index.js',
				'core-util-is': '../node_modules/core-util-is/lib/util.js',
				inherits: '../node_modules/inherits/inherits_browser.js',
				util: '../node_modules/parcel-bundler/src/builtins/_empty.js',
				'./internal/streams/BufferList':
					'../node_modules/readable-stream/lib/internal/streams/BufferList.js',
				'./internal/streams/destroy':
					'../node_modules/readable-stream/lib/internal/streams/destroy.js',
				'./_stream_duplex': '../node_modules/readable-stream/lib/_stream_duplex.js',
				'string_decoder/': '../node_modules/string_decoder/lib/string_decoder.js',
				process: '../node_modules/process/browser.js'
			}
		],
		'../node_modules/readable-stream/lib/_stream_transform.js': [
			function (require, module, exports) {
				// Copyright Joyent, Inc. and other Node contributors.
				//
				// Permission is hereby granted, free of charge, to any person obtaining a
				// copy of this software and associated documentation files (the
				// "Software"), to deal in the Software without restriction, including
				// without limitation the rights to use, copy, modify, merge, publish,
				// distribute, sublicense, and/or sell copies of the Software, and to permit
				// persons to whom the Software is furnished to do so, subject to the
				// following conditions:
				//
				// The above copyright notice and this permission notice shall be included
				// in all copies or substantial portions of the Software.
				//
				// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
				// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
				// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
				// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
				// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
				// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
				// USE OR OTHER DEALINGS IN THE SOFTWARE.

				// a transform stream is a readable/writable stream where you do
				// something with the data.  Sometimes it's called a "filter",
				// but that's not a great name for it, since that implies a thing where
				// some bits pass through, and others are simply ignored.  (That would
				// be a valid example of a transform, of course.)
				//
				// While the output is causally related to the input, it's not a
				// necessarily symmetric or synchronous transformation.  For example,
				// a zlib stream might take multiple plain-text writes(), and then
				// emit a single compressed chunk some time in the future.
				//
				// Here's how this works:
				//
				// The Transform stream has all the aspects of the readable and writable
				// stream classes.  When you write(chunk), that calls _write(chunk,cb)
				// internally, and returns false if there's a lot of pending writes
				// buffered up.  When you call read(), that calls _read(n) until
				// there's enough pending readable data buffered up.
				//
				// In a transform stream, the written data is placed in a buffer.  When
				// _read(n) is called, it transforms the queued up data, calling the
				// buffered _write cb's as it consumes chunks.  If consuming a single
				// written chunk would result in multiple output chunks, then the first
				// outputted bit calls the readcb, and subsequent chunks just go into
				// the read buffer, and will cause it to emit 'readable' if necessary.
				//
				// This way, back-pressure is actually determined by the reading side,
				// since _read has to be called to start processing a new chunk.  However,
				// a pathological inflate type of transform can cause excessive buffering
				// here.  For example, imagine a stream where every byte of input is
				// interpreted as an integer from 0-255, and then results in that many
				// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
				// 1kb of data being output.  In this case, you could write a very small
				// amount of input, and end up with a very large amount of output.  In
				// such a pathological inflating mechanism, there'd be no way to tell
				// the system to stop doing the transform.  A single 4MB write could
				// cause the system to run out of memory.
				//
				// However, even in such a pathological case, only a single written chunk
				// would be consumed, and then the rest would wait (un-transformed) until
				// the results of the previous transformed chunk were consumed.

				'use strict';

				module.exports = Transform;

				var Duplex = require('./_stream_duplex');

				/*<replacement>*/
				var util = require('core-util-is');
				util.inherits = require('inherits');
				/*</replacement>*/

				util.inherits(Transform, Duplex);

				function afterTransform(er, data) {
					var ts = this._transformState;
					ts.transforming = false;

					var cb = ts.writecb;

					if (!cb) {
						return this.emit('error', new Error('write callback called multiple times'));
					}

					ts.writechunk = null;
					ts.writecb = null;

					if (data != null)
						// single equals check for both `null` and `undefined`
						this.push(data);

					cb(er);

					var rs = this._readableState;
					rs.reading = false;
					if (rs.needReadable || rs.length < rs.highWaterMark) {
						this._read(rs.highWaterMark);
					}
				}

				function Transform(options) {
					if (!(this instanceof Transform)) return new Transform(options);

					Duplex.call(this, options);

					this._transformState = {
						afterTransform: afterTransform.bind(this),
						needTransform: false,
						transforming: false,
						writecb: null,
						writechunk: null,
						writeencoding: null
					};

					// start out asking for a readable event once data is transformed.
					this._readableState.needReadable = true;

					// we have implemented the _read method, and done the other things
					// that Readable wants before the first _read call, so unset the
					// sync guard flag.
					this._readableState.sync = false;

					if (options) {
						if (typeof options.transform === 'function') this._transform = options.transform;

						if (typeof options.flush === 'function') this._flush = options.flush;
					}

					// When the writable side finishes, then flush out anything remaining.
					this.on('prefinish', prefinish);
				}

				function prefinish() {
					var _this = this;

					if (typeof this._flush === 'function') {
						this._flush(function (er, data) {
							done(_this, er, data);
						});
					} else {
						done(this, null, null);
					}
				}

				Transform.prototype.push = function (chunk, encoding) {
					this._transformState.needTransform = false;
					return Duplex.prototype.push.call(this, chunk, encoding);
				};

				// This is the part where you do stuff!
				// override this function in implementation classes.
				// 'chunk' is an input chunk.
				//
				// Call `push(newChunk)` to pass along transformed output
				// to the readable side.  You may call 'push' zero or more times.
				//
				// Call `cb(err)` when you are done with this chunk.  If you pass
				// an error, then that'll put the hurt on the whole operation.  If you
				// never call cb(), then you'll never get another chunk.
				Transform.prototype._transform = function (chunk, encoding, cb) {
					throw new Error('_transform() is not implemented');
				};

				Transform.prototype._write = function (chunk, encoding, cb) {
					var ts = this._transformState;
					ts.writecb = cb;
					ts.writechunk = chunk;
					ts.writeencoding = encoding;
					if (!ts.transforming) {
						var rs = this._readableState;
						if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
							this._read(rs.highWaterMark);
					}
				};

				// Doesn't matter what the args are here.
				// _transform does all the work.
				// That we got here means that the readable side wants more data.
				Transform.prototype._read = function (n) {
					var ts = this._transformState;

					if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
						ts.transforming = true;
						this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
					} else {
						// mark that we need a transform, so that any data that comes in
						// will get processed, now that we've asked for it.
						ts.needTransform = true;
					}
				};

				Transform.prototype._destroy = function (err, cb) {
					var _this2 = this;

					Duplex.prototype._destroy.call(this, err, function (err2) {
						cb(err2);
						_this2.emit('close');
					});
				};

				function done(stream, er, data) {
					if (er) return stream.emit('error', er);

					if (data != null)
						// single equals check for both `null` and `undefined`
						stream.push(data);

					// if there's nothing in the write buffer, then that means
					// that nothing more will ever be provided
					if (stream._writableState.length)
						throw new Error('Calling transform done when ws.length != 0');

					if (stream._transformState.transforming)
						throw new Error('Calling transform done when still transforming');

					return stream.push(null);
				}
			},
			{
				'./_stream_duplex': '../node_modules/readable-stream/lib/_stream_duplex.js',
				'core-util-is': '../node_modules/core-util-is/lib/util.js',
				inherits: '../node_modules/inherits/inherits_browser.js'
			}
		],
		'../node_modules/readable-stream/lib/_stream_passthrough.js': [
			function (require, module, exports) {
				// Copyright Joyent, Inc. and other Node contributors.
				//
				// Permission is hereby granted, free of charge, to any person obtaining a
				// copy of this software and associated documentation files (the
				// "Software"), to deal in the Software without restriction, including
				// without limitation the rights to use, copy, modify, merge, publish,
				// distribute, sublicense, and/or sell copies of the Software, and to permit
				// persons to whom the Software is furnished to do so, subject to the
				// following conditions:
				//
				// The above copyright notice and this permission notice shall be included
				// in all copies or substantial portions of the Software.
				//
				// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
				// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
				// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
				// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
				// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
				// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
				// USE OR OTHER DEALINGS IN THE SOFTWARE.

				// a passthrough stream.
				// basically just the most minimal sort of Transform stream.
				// Every written chunk gets output as-is.

				'use strict';

				module.exports = PassThrough;

				var Transform = require('./_stream_transform');

				/*<replacement>*/
				var util = require('core-util-is');
				util.inherits = require('inherits');
				/*</replacement>*/

				util.inherits(PassThrough, Transform);

				function PassThrough(options) {
					if (!(this instanceof PassThrough)) return new PassThrough(options);

					Transform.call(this, options);
				}

				PassThrough.prototype._transform = function (chunk, encoding, cb) {
					cb(null, chunk);
				};
			},
			{
				'./_stream_transform': '../node_modules/readable-stream/lib/_stream_transform.js',
				'core-util-is': '../node_modules/core-util-is/lib/util.js',
				inherits: '../node_modules/inherits/inherits_browser.js'
			}
		],
		'../node_modules/readable-stream/readable-browser.js': [
			function (require, module, exports) {
				exports = module.exports = require('./lib/_stream_readable.js');
				exports.Stream = exports;
				exports.Readable = exports;
				exports.Writable = require('./lib/_stream_writable.js');
				exports.Duplex = require('./lib/_stream_duplex.js');
				exports.Transform = require('./lib/_stream_transform.js');
				exports.PassThrough = require('./lib/_stream_passthrough.js');
			},
			{
				'./lib/_stream_readable.js': '../node_modules/readable-stream/lib/_stream_readable.js',
				'./lib/_stream_writable.js': '../node_modules/readable-stream/lib/_stream_writable.js',
				'./lib/_stream_duplex.js': '../node_modules/readable-stream/lib/_stream_duplex.js',
				'./lib/_stream_transform.js': '../node_modules/readable-stream/lib/_stream_transform.js',
				'./lib/_stream_passthrough.js': '../node_modules/readable-stream/lib/_stream_passthrough.js'
			}
		],
		'../node_modules/stream-http/lib/response.js': [
			function (require, module, exports) {
				var process = require('process');
				var Buffer = require('buffer').Buffer;
				var global = arguments[3];
				var capability = require('./capability');
				var inherits = require('inherits');
				var stream = require('readable-stream');

				var rStates = (exports.readyStates = {
					UNSENT: 0,
					OPENED: 1,
					HEADERS_RECEIVED: 2,
					LOADING: 3,
					DONE: 4
				});

				var IncomingMessage = (exports.IncomingMessage = function (
					xhr,
					response,
					mode,
					fetchTimer
				) {
					var self = this;
					stream.Readable.call(self);

					self._mode = mode;
					self.headers = {};
					self.rawHeaders = [];
					self.trailers = {};
					self.rawTrailers = [];

					// Fake the 'close' event, but only once 'end' fires
					self.on('end', function () {
						// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
						process.nextTick(function () {
							self.emit('close');
						});
					});

					if (mode === 'fetch') {
						self._fetchResponse = response;

						self.url = response.url;
						self.statusCode = response.status;
						self.statusMessage = response.statusText;

						response.headers.forEach(function (header, key) {
							self.headers[key.toLowerCase()] = header;
							self.rawHeaders.push(key, header);
						});

						if (capability.writableStream) {
							var writable = new WritableStream({
								write: function (chunk) {
									return new Promise(function (resolve, reject) {
										if (self._destroyed) {
											reject();
										} else if (self.push(new Buffer(chunk))) {
											resolve();
										} else {
											self._resumeFetch = resolve;
										}
									});
								},
								close: function () {
									global.clearTimeout(fetchTimer);
									if (!self._destroyed) self.push(null);
								},
								abort: function (err) {
									if (!self._destroyed) self.emit('error', err);
								}
							});

							try {
								response.body.pipeTo(writable).catch(function (err) {
									global.clearTimeout(fetchTimer);
									if (!self._destroyed) self.emit('error', err);
								});
								return;
							} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
						}
						// fallback for when writableStream or pipeTo aren't available
						var reader = response.body.getReader();
						function read() {
							reader
								.read()
								.then(function (result) {
									if (self._destroyed) return;
									if (result.done) {
										global.clearTimeout(fetchTimer);
										self.push(null);
										return;
									}
									self.push(new Buffer(result.value));
									read();
								})
								.catch(function (err) {
									global.clearTimeout(fetchTimer);
									if (!self._destroyed) self.emit('error', err);
								});
						}
						read();
					} else {
						self._xhr = xhr;
						self._pos = 0;

						self.url = xhr.responseURL;
						self.statusCode = xhr.status;
						self.statusMessage = xhr.statusText;
						var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
						headers.forEach(function (header) {
							var matches = header.match(/^([^:]+):\s*(.*)/);
							if (matches) {
								var key = matches[1].toLowerCase();
								if (key === 'set-cookie') {
									if (self.headers[key] === undefined) {
										self.headers[key] = [];
									}
									self.headers[key].push(matches[2]);
								} else if (self.headers[key] !== undefined) {
									self.headers[key] += ', ' + matches[2];
								} else {
									self.headers[key] = matches[2];
								}
								self.rawHeaders.push(matches[1], matches[2]);
							}
						});

						self._charset = 'x-user-defined';
						if (!capability.overrideMimeType) {
							var mimeType = self.rawHeaders['mime-type'];
							if (mimeType) {
								var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
								if (charsetMatch) {
									self._charset = charsetMatch[1].toLowerCase();
								}
							}
							if (!self._charset) self._charset = 'utf-8'; // best guess
						}
					}
				});

				inherits(IncomingMessage, stream.Readable);

				IncomingMessage.prototype._read = function () {
					var self = this;

					var resolve = self._resumeFetch;
					if (resolve) {
						self._resumeFetch = null;
						resolve();
					}
				};

				IncomingMessage.prototype._onXHRProgress = function () {
					var self = this;

					var xhr = self._xhr;

					var response = null;
					switch (self._mode) {
						case 'text:vbarray': // For IE9
							if (xhr.readyState !== rStates.DONE) break;
							try {
								// This fails in IE8
								response = new global.VBArray(xhr.responseBody).toArray();
							} catch (e) {}
							if (response !== null) {
								self.push(new Buffer(response));
								break;
							}
						// Falls through in IE8
						case 'text':
							try {
								// This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
								response = xhr.responseText;
							} catch (e) {
								self._mode = 'text:vbarray';
								break;
							}
							if (response.length > self._pos) {
								var newData = response.substr(self._pos);
								if (self._charset === 'x-user-defined') {
									var buffer = new Buffer(newData.length);
									for (var i = 0; i < newData.length; i++) buffer[i] = newData.charCodeAt(i) & 0xff;

									self.push(buffer);
								} else {
									self.push(newData, self._charset);
								}
								self._pos = response.length;
							}
							break;
						case 'arraybuffer':
							if (xhr.readyState !== rStates.DONE || !xhr.response) break;
							response = xhr.response;
							self.push(new Buffer(new Uint8Array(response)));
							break;
						case 'moz-chunked-arraybuffer': // take whole
							response = xhr.response;
							if (xhr.readyState !== rStates.LOADING || !response) break;
							self.push(new Buffer(new Uint8Array(response)));
							break;
						case 'ms-stream':
							response = xhr.response;
							if (xhr.readyState !== rStates.LOADING) break;
							var reader = new global.MSStreamReader();
							reader.onprogress = function () {
								if (reader.result.byteLength > self._pos) {
									self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))));
									self._pos = reader.result.byteLength;
								}
							};
							reader.onload = function () {
								self.push(null);
							};
							// reader.onerror = ??? // TODO: this
							reader.readAsArrayBuffer(response);
							break;
					}

					// The ms-stream case handles end separately in reader.onload()
					if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
						self.push(null);
					}
				};
			},
			{
				'./capability': '../node_modules/stream-http/lib/capability.js',
				inherits: '../node_modules/inherits/inherits_browser.js',
				'readable-stream': '../node_modules/readable-stream/readable-browser.js',
				process: '../node_modules/process/browser.js',
				buffer: '../node_modules/node-libs-browser/node_modules/buffer/index.js'
			}
		],
		'../node_modules/to-arraybuffer/index.js': [
			function (require, module, exports) {
				var Buffer = require('buffer').Buffer;

				module.exports = function (buf) {
					// If the buffer is backed by a Uint8Array, a faster version will work
					if (buf instanceof Uint8Array) {
						// If the buffer isn't a subarray, return the underlying ArrayBuffer
						if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
							return buf.buffer;
						} else if (typeof buf.buffer.slice === 'function') {
							// Otherwise we need to get a proper copy
							return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
						}
					}

					if (Buffer.isBuffer(buf)) {
						// This is the slow version that will work with any Buffer
						// implementation (even in old browsers)
						var arrayCopy = new Uint8Array(buf.length);
						var len = buf.length;
						for (var i = 0; i < len; i++) {
							arrayCopy[i] = buf[i];
						}
						return arrayCopy.buffer;
					} else {
						throw new Error('Argument must be a Buffer');
					}
				};
			},
			{ buffer: '../node_modules/node-libs-browser/node_modules/buffer/index.js' }
		],
		'../node_modules/stream-http/lib/request.js': [
			function (require, module, exports) {
				var Buffer = require('buffer').Buffer;
				var global = arguments[3];
				var process = require('process');
				var capability = require('./capability');
				var inherits = require('inherits');
				var response = require('./response');
				var stream = require('readable-stream');
				var toArrayBuffer = require('to-arraybuffer');

				var IncomingMessage = response.IncomingMessage;
				var rStates = response.readyStates;

				function decideMode(preferBinary, useFetch) {
					if (capability.fetch && useFetch) {
						return 'fetch';
					} else if (capability.mozchunkedarraybuffer) {
						return 'moz-chunked-arraybuffer';
					} else if (capability.msstream) {
						return 'ms-stream';
					} else if (capability.arraybuffer && preferBinary) {
						return 'arraybuffer';
					} else if (capability.vbArray && preferBinary) {
						return 'text:vbarray';
					} else {
						return 'text';
					}
				}

				var ClientRequest = (module.exports = function (opts) {
					var self = this;
					stream.Writable.call(self);

					self._opts = opts;
					self._body = [];
					self._headers = {};
					if (opts.auth)
						self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'));
					Object.keys(opts.headers).forEach(function (name) {
						self.setHeader(name, opts.headers[name]);
					});

					var preferBinary;
					var useFetch = true;
					if (
						opts.mode === 'disable-fetch' ||
						('requestTimeout' in opts && !capability.abortController)
					) {
						// If the use of XHR should be preferred. Not typically needed.
						useFetch = false;
						preferBinary = true;
					} else if (opts.mode === 'prefer-streaming') {
						// If streaming is a high priority but binary compatibility and
						// the accuracy of the 'content-type' header aren't
						preferBinary = false;
					} else if (opts.mode === 'allow-wrong-content-type') {
						// If streaming is more important than preserving the 'content-type' header
						preferBinary = !capability.overrideMimeType;
					} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
						// Use binary if text streaming may corrupt data or the content-type header, or for speed
						preferBinary = true;
					} else {
						throw new Error('Invalid value for opts.mode');
					}
					self._mode = decideMode(preferBinary, useFetch);
					self._fetchTimer = null;

					self.on('finish', function () {
						self._onFinish();
					});
				});

				inherits(ClientRequest, stream.Writable);

				ClientRequest.prototype.setHeader = function (name, value) {
					var self = this;
					var lowerName = name.toLowerCase();
					// This check is not necessary, but it prevents warnings from browsers about setting unsafe
					// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
					// http-browserify did it, so I will too.
					if (unsafeHeaders.indexOf(lowerName) !== -1) return;

					self._headers[lowerName] = {
						name: name,
						value: value
					};
				};

				ClientRequest.prototype.getHeader = function (name) {
					var header = this._headers[name.toLowerCase()];
					if (header) return header.value;
					return null;
				};

				ClientRequest.prototype.removeHeader = function (name) {
					var self = this;
					delete self._headers[name.toLowerCase()];
				};

				ClientRequest.prototype._onFinish = function () {
					var self = this;

					if (self._destroyed) return;
					var opts = self._opts;

					var headersObj = self._headers;
					var body = null;
					if (opts.method !== 'GET' && opts.method !== 'HEAD') {
						if (capability.arraybuffer) {
							body = toArrayBuffer(Buffer.concat(self._body));
						} else if (capability.blobConstructor) {
							body = new global.Blob(
								self._body.map(function (buffer) {
									return toArrayBuffer(buffer);
								}),
								{
									type: (headersObj['content-type'] || {}).value || ''
								}
							);
						} else {
							// get utf8 string
							body = Buffer.concat(self._body).toString();
						}
					}

					// create flattened list of headers
					var headersList = [];
					Object.keys(headersObj).forEach(function (keyName) {
						var name = headersObj[keyName].name;
						var value = headersObj[keyName].value;
						if (Array.isArray(value)) {
							value.forEach(function (v) {
								headersList.push([name, v]);
							});
						} else {
							headersList.push([name, value]);
						}
					});

					if (self._mode === 'fetch') {
						var signal = null;
						var fetchTimer = null;
						if (capability.abortController) {
							var controller = new AbortController();
							signal = controller.signal;
							self._fetchAbortController = controller;

							if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
								self._fetchTimer = global.setTimeout(function () {
									self.emit('requestTimeout');
									if (self._fetchAbortController) self._fetchAbortController.abort();
								}, opts.requestTimeout);
							}
						}

						global
							.fetch(self._opts.url, {
								method: self._opts.method,
								headers: headersList,
								body: body || undefined,
								mode: 'cors',
								credentials: opts.withCredentials ? 'include' : 'same-origin',
								signal: signal
							})
							.then(
								function (response) {
									self._fetchResponse = response;
									self._connect();
								},
								function (reason) {
									global.clearTimeout(self._fetchTimer);
									if (!self._destroyed) self.emit('error', reason);
								}
							);
					} else {
						var xhr = (self._xhr = new global.XMLHttpRequest());
						try {
							xhr.open(self._opts.method, self._opts.url, true);
						} catch (err) {
							process.nextTick(function () {
								self.emit('error', err);
							});
							return;
						}

						// Can't set responseType on really old browsers
						if ('responseType' in xhr) xhr.responseType = self._mode.split(':')[0];

						if ('withCredentials' in xhr) xhr.withCredentials = !!opts.withCredentials;

						if (self._mode === 'text' && 'overrideMimeType' in xhr)
							xhr.overrideMimeType('text/plain; charset=x-user-defined');

						if ('requestTimeout' in opts) {
							xhr.timeout = opts.requestTimeout;
							xhr.ontimeout = function () {
								self.emit('requestTimeout');
							};
						}

						headersList.forEach(function (header) {
							xhr.setRequestHeader(header[0], header[1]);
						});

						self._response = null;
						xhr.onreadystatechange = function () {
							switch (xhr.readyState) {
								case rStates.LOADING:
								case rStates.DONE:
									self._onXHRProgress();
									break;
							}
						};
						// Necessary for streaming in Firefox, since xhr.response is ONLY defined
						// in onprogress, not in onreadystatechange with xhr.readyState = 3
						if (self._mode === 'moz-chunked-arraybuffer') {
							xhr.onprogress = function () {
								self._onXHRProgress();
							};
						}

						xhr.onerror = function () {
							if (self._destroyed) return;
							self.emit('error', new Error('XHR error'));
						};

						try {
							xhr.send(body);
						} catch (err) {
							process.nextTick(function () {
								self.emit('error', err);
							});
							return;
						}
					}
				};

				/**
				 * Checks if xhr.status is readable and non-zero, indicating no error.
				 * Even though the spec says it should be available in readyState 3,
				 * accessing it throws an exception in IE8
				 */
				function statusValid(xhr) {
					try {
						var status = xhr.status;
						return status !== null && status !== 0;
					} catch (e) {
						return false;
					}
				}

				ClientRequest.prototype._onXHRProgress = function () {
					var self = this;

					if (!statusValid(self._xhr) || self._destroyed) return;

					if (!self._response) self._connect();

					self._response._onXHRProgress();
				};

				ClientRequest.prototype._connect = function () {
					var self = this;

					if (self._destroyed) return;

					self._response = new IncomingMessage(
						self._xhr,
						self._fetchResponse,
						self._mode,
						self._fetchTimer
					);
					self._response.on('error', function (err) {
						self.emit('error', err);
					});

					self.emit('response', self._response);
				};

				ClientRequest.prototype._write = function (chunk, encoding, cb) {
					var self = this;

					self._body.push(chunk);
					cb();
				};

				ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
					var self = this;
					self._destroyed = true;
					global.clearTimeout(self._fetchTimer);
					if (self._response) self._response._destroyed = true;
					if (self._xhr) self._xhr.abort();
					else if (self._fetchAbortController) self._fetchAbortController.abort();
				};

				ClientRequest.prototype.end = function (data, encoding, cb) {
					var self = this;
					if (typeof data === 'function') {
						cb = data;
						data = undefined;
					}

					stream.Writable.prototype.end.call(self, data, encoding, cb);
				};

				ClientRequest.prototype.flushHeaders = function () {};
				ClientRequest.prototype.setTimeout = function () {};
				ClientRequest.prototype.setNoDelay = function () {};
				ClientRequest.prototype.setSocketKeepAlive = function () {};

				// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
				var unsafeHeaders = [
					'accept-charset',
					'accept-encoding',
					'access-control-request-headers',
					'access-control-request-method',
					'connection',
					'content-length',
					'cookie',
					'cookie2',
					'date',
					'dnt',
					'expect',
					'host',
					'keep-alive',
					'origin',
					'referer',
					'te',
					'trailer',
					'transfer-encoding',
					'upgrade',
					'via'
				];
			},
			{
				'./capability': '../node_modules/stream-http/lib/capability.js',
				inherits: '../node_modules/inherits/inherits_browser.js',
				'./response': '../node_modules/stream-http/lib/response.js',
				'readable-stream': '../node_modules/readable-stream/readable-browser.js',
				'to-arraybuffer': '../node_modules/to-arraybuffer/index.js',
				buffer: '../node_modules/node-libs-browser/node_modules/buffer/index.js',
				process: '../node_modules/process/browser.js'
			}
		],
		'../node_modules/xtend/immutable.js': [
			function (require, module, exports) {
				module.exports = extend;
				var hasOwnProperty = Object.prototype.hasOwnProperty;

				function extend() {
					var target = {};

					for (var i = 0; i < arguments.length; i++) {
						var source = arguments[i];

						for (var key in source) {
							if (hasOwnProperty.call(source, key)) {
								target[key] = source[key];
							}
						}
					}

					return target;
				}
			},
			{}
		],
		'../node_modules/builtin-status-codes/browser.js': [
			function (require, module, exports) {
				module.exports = {
					100: 'Continue',
					101: 'Switching Protocols',
					102: 'Processing',
					200: 'OK',
					201: 'Created',
					202: 'Accepted',
					203: 'Non-Authoritative Information',
					204: 'No Content',
					205: 'Reset Content',
					206: 'Partial Content',
					207: 'Multi-Status',
					208: 'Already Reported',
					226: 'IM Used',
					300: 'Multiple Choices',
					301: 'Moved Permanently',
					302: 'Found',
					303: 'See Other',
					304: 'Not Modified',
					305: 'Use Proxy',
					307: 'Temporary Redirect',
					308: 'Permanent Redirect',
					400: 'Bad Request',
					401: 'Unauthorized',
					402: 'Payment Required',
					403: 'Forbidden',
					404: 'Not Found',
					405: 'Method Not Allowed',
					406: 'Not Acceptable',
					407: 'Proxy Authentication Required',
					408: 'Request Timeout',
					409: 'Conflict',
					410: 'Gone',
					411: 'Length Required',
					412: 'Precondition Failed',
					413: 'Payload Too Large',
					414: 'URI Too Long',
					415: 'Unsupported Media Type',
					416: 'Range Not Satisfiable',
					417: 'Expectation Failed',
					418: "I'm a teapot",
					421: 'Misdirected Request',
					422: 'Unprocessable Entity',
					423: 'Locked',
					424: 'Failed Dependency',
					425: 'Unordered Collection',
					426: 'Upgrade Required',
					428: 'Precondition Required',
					429: 'Too Many Requests',
					431: 'Request Header Fields Too Large',
					451: 'Unavailable For Legal Reasons',
					500: 'Internal Server Error',
					501: 'Not Implemented',
					502: 'Bad Gateway',
					503: 'Service Unavailable',
					504: 'Gateway Timeout',
					505: 'HTTP Version Not Supported',
					506: 'Variant Also Negotiates',
					507: 'Insufficient Storage',
					508: 'Loop Detected',
					509: 'Bandwidth Limit Exceeded',
					510: 'Not Extended',
					511: 'Network Authentication Required'
				};
			},
			{}
		],
		'../node_modules/node-libs-browser/node_modules/punycode/punycode.js': [
			function (require, module, exports) {
				var global = arguments[3];
				var define;
				/*! https://mths.be/punycode v1.4.1 by @mathias */
				(function (root) {
					/** Detect free variables */
					var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
					var freeModule = typeof module == 'object' && module && !module.nodeType && module;
					var freeGlobal = typeof global == 'object' && global;
					if (
						freeGlobal.global === freeGlobal ||
						freeGlobal.window === freeGlobal ||
						freeGlobal.self === freeGlobal
					) {
						root = freeGlobal;
					}

					/**
					 * The `punycode` object.
					 * @name punycode
					 * @type Object
					 */
					var punycode,
						/** Highest positive signed 32-bit float value */
						maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
						/** Bootstring parameters */
						base = 36,
						tMin = 1,
						tMax = 26,
						skew = 38,
						damp = 700,
						initialBias = 72,
						initialN = 128, // 0x80
						delimiter = '-', // '\x2D'
						/** Regular expressions */
						regexPunycode = /^xn--/,
						regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
						regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
						/** Error messages */
						errors = {
							overflow: 'Overflow: input needs wider integers to process',
							'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
							'invalid-input': 'Invalid input'
						},
						/** Convenience shortcuts */
						baseMinusTMin = base - tMin,
						floor = Math.floor,
						stringFromCharCode = String.fromCharCode,
						/** Temporary variable */
						key;

					/*--------------------------------------------------------------------------*/

					/**
					 * A generic error utility function.
					 * @private
					 * @param {String} type The error type.
					 * @returns {Error} Throws a `RangeError` with the applicable error message.
					 */
					function error(type) {
						throw new RangeError(errors[type]);
					}

					/**
					 * A generic `Array#map` utility function.
					 * @private
					 * @param {Array} array The array to iterate over.
					 * @param {Function} callback The function that gets called for every array
					 * item.
					 * @returns {Array} A new array of values returned by the callback function.
					 */
					function map(array, fn) {
						var length = array.length;
						var result = [];
						while (length--) {
							result[length] = fn(array[length]);
						}
						return result;
					}

					/**
					 * A simple `Array#map`-like wrapper to work with domain name strings or email
					 * addresses.
					 * @private
					 * @param {String} domain The domain name or email address.
					 * @param {Function} callback The function that gets called for every
					 * character.
					 * @returns {Array} A new string of characters returned by the callback
					 * function.
					 */
					function mapDomain(string, fn) {
						var parts = string.split('@');
						var result = '';
						if (parts.length > 1) {
							// In email addresses, only the domain name should be punycoded. Leave
							// the local part (i.e. everything up to `@`) intact.
							result = parts[0] + '@';
							string = parts[1];
						}
						// Avoid `split(regex)` for IE8 compatibility. See #17.
						string = string.replace(regexSeparators, '\x2E');
						var labels = string.split('.');
						var encoded = map(labels, fn).join('.');
						return result + encoded;
					}

					/**
					 * Creates an array containing the numeric code points of each Unicode
					 * character in the string. While JavaScript uses UCS-2 internally,
					 * this function will convert a pair of surrogate halves (each of which
					 * UCS-2 exposes as separate characters) into a single code point,
					 * matching UTF-16.
					 * @see `punycode.ucs2.encode`
					 * @see <https://mathiasbynens.be/notes/javascript-encoding>
					 * @memberOf punycode.ucs2
					 * @name decode
					 * @param {String} string The Unicode input string (UCS-2).
					 * @returns {Array} The new array of code points.
					 */
					function ucs2decode(string) {
						var output = [],
							counter = 0,
							length = string.length,
							value,
							extra;
						while (counter < length) {
							value = string.charCodeAt(counter++);
							if (value >= 0xd800 && value <= 0xdbff && counter < length) {
								// high surrogate, and there is a next character
								extra = string.charCodeAt(counter++);
								if ((extra & 0xfc00) == 0xdc00) {
									// low surrogate
									output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
								} else {
									// unmatched surrogate; only append this code unit, in case the next
									// code unit is the high surrogate of a surrogate pair
									output.push(value);
									counter--;
								}
							} else {
								output.push(value);
							}
						}
						return output;
					}

					/**
					 * Creates a string based on an array of numeric code points.
					 * @see `punycode.ucs2.decode`
					 * @memberOf punycode.ucs2
					 * @name encode
					 * @param {Array} codePoints The array of numeric code points.
					 * @returns {String} The new Unicode string (UCS-2).
					 */
					function ucs2encode(array) {
						return map(array, function (value) {
							var output = '';
							if (value > 0xffff) {
								value -= 0x10000;
								output += stringFromCharCode(((value >>> 10) & 0x3ff) | 0xd800);
								value = 0xdc00 | (value & 0x3ff);
							}
							output += stringFromCharCode(value);
							return output;
						}).join('');
					}

					/**
					 * Converts a basic code point into a digit/integer.
					 * @see `digitToBasic()`
					 * @private
					 * @param {Number} codePoint The basic numeric code point value.
					 * @returns {Number} The numeric value of a basic code point (for use in
					 * representing integers) in the range `0` to `base - 1`, or `base` if
					 * the code point does not represent a value.
					 */
					function basicToDigit(codePoint) {
						if (codePoint - 48 < 10) {
							return codePoint - 22;
						}
						if (codePoint - 65 < 26) {
							return codePoint - 65;
						}
						if (codePoint - 97 < 26) {
							return codePoint - 97;
						}
						return base;
					}

					/**
					 * Converts a digit/integer into a basic code point.
					 * @see `basicToDigit()`
					 * @private
					 * @param {Number} digit The numeric value of a basic code point.
					 * @returns {Number} The basic code point whose value (when used for
					 * representing integers) is `digit`, which needs to be in the range
					 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
					 * used; else, the lowercase form is used. The behavior is undefined
					 * if `flag` is non-zero and `digit` has no uppercase form.
					 */
					function digitToBasic(digit, flag) {
						//  0..25 map to ASCII a..z or A..Z
						// 26..35 map to ASCII 0..9
						return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
					}

					/**
					 * Bias adaptation function as per section 3.4 of RFC 3492.
					 * https://tools.ietf.org/html/rfc3492#section-3.4
					 * @private
					 */
					function adapt(delta, numPoints, firstTime) {
						var k = 0;
						delta = firstTime ? floor(delta / damp) : delta >> 1;
						delta += floor(delta / numPoints);
						for (; /* no initialization */ delta > (baseMinusTMin * tMax) >> 1; k += base) {
							delta = floor(delta / baseMinusTMin);
						}
						return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew));
					}

					/**
					 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
					 * symbols.
					 * @memberOf punycode
					 * @param {String} input The Punycode string of ASCII-only symbols.
					 * @returns {String} The resulting string of Unicode symbols.
					 */
					function decode(input) {
						// Don't use UCS-2
						var output = [],
							inputLength = input.length,
							out,
							i = 0,
							n = initialN,
							bias = initialBias,
							basic,
							j,
							index,
							oldi,
							w,
							k,
							digit,
							t,
							/** Cached calculation results */
							baseMinusT;

						// Handle the basic code points: let `basic` be the number of input code
						// points before the last delimiter, or `0` if there is none, then copy
						// the first basic code points to the output.

						basic = input.lastIndexOf(delimiter);
						if (basic < 0) {
							basic = 0;
						}

						for (j = 0; j < basic; ++j) {
							// if it's not a basic code point
							if (input.charCodeAt(j) >= 0x80) {
								error('not-basic');
							}
							output.push(input.charCodeAt(j));
						}

						// Main decoding loop: start just after the last delimiter if any basic code
						// points were copied; start at the beginning otherwise.

						for (
							index = basic > 0 ? basic + 1 : 0;
							index < inputLength /* no final expression */;

						) {
							// `index` is the index of the next character to be consumed.
							// Decode a generalized variable-length integer into `delta`,
							// which gets added to `i`. The overflow checking is easier
							// if we increase `i` as we go, then subtract off its starting
							// value at the end to obtain `delta`.
							for (oldi = i, w = 1, k = base /* no condition */; ; k += base) {
								if (index >= inputLength) {
									error('invalid-input');
								}

								digit = basicToDigit(input.charCodeAt(index++));

								if (digit >= base || digit > floor((maxInt - i) / w)) {
									error('overflow');
								}

								i += digit * w;
								t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

								if (digit < t) {
									break;
								}

								baseMinusT = base - t;
								if (w > floor(maxInt / baseMinusT)) {
									error('overflow');
								}

								w *= baseMinusT;
							}

							out = output.length + 1;
							bias = adapt(i - oldi, out, oldi == 0);

							// `i` was supposed to wrap around from `out` to `0`,
							// incrementing `n` each time, so we'll fix that now:
							if (floor(i / out) > maxInt - n) {
								error('overflow');
							}

							n += floor(i / out);
							i %= out;

							// Insert `n` at position `i` of the output
							output.splice(i++, 0, n);
						}

						return ucs2encode(output);
					}

					/**
					 * Converts a string of Unicode symbols (e.g. a domain name label) to a
					 * Punycode string of ASCII-only symbols.
					 * @memberOf punycode
					 * @param {String} input The string of Unicode symbols.
					 * @returns {String} The resulting Punycode string of ASCII-only symbols.
					 */
					function encode(input) {
						var n,
							delta,
							handledCPCount,
							basicLength,
							bias,
							j,
							m,
							q,
							k,
							t,
							currentValue,
							output = [],
							/** `inputLength` will hold the number of code points in `input`. */
							inputLength,
							/** Cached calculation results */
							handledCPCountPlusOne,
							baseMinusT,
							qMinusT;

						// Convert the input in UCS-2 to Unicode
						input = ucs2decode(input);

						// Cache the length
						inputLength = input.length;

						// Initialize the state
						n = initialN;
						delta = 0;
						bias = initialBias;

						// Handle the basic code points
						for (j = 0; j < inputLength; ++j) {
							currentValue = input[j];
							if (currentValue < 0x80) {
								output.push(stringFromCharCode(currentValue));
							}
						}

						handledCPCount = basicLength = output.length;

						// `handledCPCount` is the number of code points that have been handled;
						// `basicLength` is the number of basic code points.

						// Finish the basic string - if it is not empty - with a delimiter
						if (basicLength) {
							output.push(delimiter);
						}

						// Main encoding loop:
						while (handledCPCount < inputLength) {
							// All non-basic code points < n have been handled already. Find the next
							// larger one:
							for (m = maxInt, j = 0; j < inputLength; ++j) {
								currentValue = input[j];
								if (currentValue >= n && currentValue < m) {
									m = currentValue;
								}
							}

							// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
							// but guard against overflow
							handledCPCountPlusOne = handledCPCount + 1;
							if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
								error('overflow');
							}

							delta += (m - n) * handledCPCountPlusOne;
							n = m;

							for (j = 0; j < inputLength; ++j) {
								currentValue = input[j];

								if (currentValue < n && ++delta > maxInt) {
									error('overflow');
								}

								if (currentValue == n) {
									// Represent delta as a generalized variable-length integer
									for (q = delta, k = base /* no condition */; ; k += base) {
										t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
										if (q < t) {
											break;
										}
										qMinusT = q - t;
										baseMinusT = base - t;
										output.push(stringFromCharCode(digitToBasic(t + (qMinusT % baseMinusT), 0)));
										q = floor(qMinusT / baseMinusT);
									}

									output.push(stringFromCharCode(digitToBasic(q, 0)));
									bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
									delta = 0;
									++handledCPCount;
								}
							}

							++delta;
							++n;
						}
						return output.join('');
					}

					/**
					 * Converts a Punycode string representing a domain name or an email address
					 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
					 * it doesn't matter if you call it on a string that has already been
					 * converted to Unicode.
					 * @memberOf punycode
					 * @param {String} input The Punycoded domain name or email address to
					 * convert to Unicode.
					 * @returns {String} The Unicode representation of the given Punycode
					 * string.
					 */
					function toUnicode(input) {
						return mapDomain(input, function (string) {
							return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
						});
					}

					/**
					 * Converts a Unicode string representing a domain name or an email address to
					 * Punycode. Only the non-ASCII parts of the domain name will be converted,
					 * i.e. it doesn't matter if you call it with a domain that's already in
					 * ASCII.
					 * @memberOf punycode
					 * @param {String} input The domain name or email address to convert, as a
					 * Unicode string.
					 * @returns {String} The Punycode representation of the given domain name or
					 * email address.
					 */
					function toASCII(input) {
						return mapDomain(input, function (string) {
							return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
						});
					}

					/*--------------------------------------------------------------------------*/

					/** Define the public API */
					punycode = {
						/**
						 * A string representing the current Punycode.js version number.
						 * @memberOf punycode
						 * @type String
						 */
						version: '1.4.1',
						/**
						 * An object of methods to convert from JavaScript's internal character
						 * representation (UCS-2) to Unicode code points, and back.
						 * @see <https://mathiasbynens.be/notes/javascript-encoding>
						 * @memberOf punycode
						 * @type Object
						 */
						ucs2: {
							decode: ucs2decode,
							encode: ucs2encode
						},
						decode: decode,
						encode: encode,
						toASCII: toASCII,
						toUnicode: toUnicode
					};

					/** Expose `punycode` */
					// Some AMD build optimizers, like r.js, check for specific condition patterns
					// like the following:
					if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
						define('punycode', function () {
							return punycode;
						});
					} else if (freeExports && freeModule) {
						if (module.exports == freeExports) {
							// in Node.js, io.js, or RingoJS v0.8.0+
							freeModule.exports = punycode;
						} else {
							// in Narwhal or RingoJS v0.7.0-
							for (key in punycode) {
								punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
							}
						}
					} else {
						// in Rhino or a web browser
						root.punycode = punycode;
					}
				})(this);
			},
			{}
		],
		'../node_modules/url/util.js': [
			function (require, module, exports) {
				'use strict';

				module.exports = {
					isString: function (arg) {
						return typeof arg === 'string';
					},
					isObject: function (arg) {
						return typeof arg === 'object' && arg !== null;
					},
					isNull: function (arg) {
						return arg === null;
					},
					isNullOrUndefined: function (arg) {
						return arg == null;
					}
				};
			},
			{}
		],
		'../node_modules/querystring-es3/decode.js': [
			function (require, module, exports) {
				// Copyright Joyent, Inc. and other Node contributors.
				//
				// Permission is hereby granted, free of charge, to any person obtaining a
				// copy of this software and associated documentation files (the
				// "Software"), to deal in the Software without restriction, including
				// without limitation the rights to use, copy, modify, merge, publish,
				// distribute, sublicense, and/or sell copies of the Software, and to permit
				// persons to whom the Software is furnished to do so, subject to the
				// following conditions:
				//
				// The above copyright notice and this permission notice shall be included
				// in all copies or substantial portions of the Software.
				//
				// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
				// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
				// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
				// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
				// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
				// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
				// USE OR OTHER DEALINGS IN THE SOFTWARE.
				'use strict'; // If obj.hasOwnProperty has been overridden, then calling
				// obj.hasOwnProperty(prop) will break.
				// See: https://github.com/joyent/node/issues/1707

				function hasOwnProperty(obj, prop) {
					return Object.prototype.hasOwnProperty.call(obj, prop);
				}

				module.exports = function (qs, sep, eq, options) {
					sep = sep || '&';
					eq = eq || '=';
					var obj = {};

					if (typeof qs !== 'string' || qs.length === 0) {
						return obj;
					}

					var regexp = /\+/g;
					qs = qs.split(sep);
					var maxKeys = 1000;

					if (options && typeof options.maxKeys === 'number') {
						maxKeys = options.maxKeys;
					}

					var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

					if (maxKeys > 0 && len > maxKeys) {
						len = maxKeys;
					}

					for (var i = 0; i < len; ++i) {
						var x = qs[i].replace(regexp, '%20'),
							idx = x.indexOf(eq),
							kstr,
							vstr,
							k,
							v;

						if (idx >= 0) {
							kstr = x.substr(0, idx);
							vstr = x.substr(idx + 1);
						} else {
							kstr = x;
							vstr = '';
						}

						k = decodeURIComponent(kstr);
						v = decodeURIComponent(vstr);

						if (!hasOwnProperty(obj, k)) {
							obj[k] = v;
						} else if (isArray(obj[k])) {
							obj[k].push(v);
						} else {
							obj[k] = [obj[k], v];
						}
					}

					return obj;
				};

				var isArray =
					Array.isArray ||
					function (xs) {
						return Object.prototype.toString.call(xs) === '[object Array]';
					};
			},
			{}
		],
		'../node_modules/querystring-es3/encode.js': [
			function (require, module, exports) {
				// Copyright Joyent, Inc. and other Node contributors.
				//
				// Permission is hereby granted, free of charge, to any person obtaining a
				// copy of this software and associated documentation files (the
				// "Software"), to deal in the Software without restriction, including
				// without limitation the rights to use, copy, modify, merge, publish,
				// distribute, sublicense, and/or sell copies of the Software, and to permit
				// persons to whom the Software is furnished to do so, subject to the
				// following conditions:
				//
				// The above copyright notice and this permission notice shall be included
				// in all copies or substantial portions of the Software.
				//
				// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
				// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
				// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
				// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
				// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
				// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
				// USE OR OTHER DEALINGS IN THE SOFTWARE.
				'use strict';

				var stringifyPrimitive = function (v) {
					switch (typeof v) {
						case 'string':
							return v;

						case 'boolean':
							return v ? 'true' : 'false';

						case 'number':
							return isFinite(v) ? v : '';

						default:
							return '';
					}
				};

				module.exports = function (obj, sep, eq, name) {
					sep = sep || '&';
					eq = eq || '=';

					if (obj === null) {
						obj = undefined;
					}

					if (typeof obj === 'object') {
						return map(objectKeys(obj), function (k) {
							var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

							if (isArray(obj[k])) {
								return map(obj[k], function (v) {
									return ks + encodeURIComponent(stringifyPrimitive(v));
								}).join(sep);
							} else {
								return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
							}
						}).join(sep);
					}

					if (!name) return '';
					return (
						encodeURIComponent(stringifyPrimitive(name)) +
						eq +
						encodeURIComponent(stringifyPrimitive(obj))
					);
				};

				var isArray =
					Array.isArray ||
					function (xs) {
						return Object.prototype.toString.call(xs) === '[object Array]';
					};

				function map(xs, f) {
					if (xs.map) return xs.map(f);
					var res = [];

					for (var i = 0; i < xs.length; i++) {
						res.push(f(xs[i], i));
					}

					return res;
				}

				var objectKeys =
					Object.keys ||
					function (obj) {
						var res = [];

						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
						}

						return res;
					};
			},
			{}
		],
		'../node_modules/querystring-es3/index.js': [
			function (require, module, exports) {
				'use strict';

				exports.decode = exports.parse = require('./decode');
				exports.encode = exports.stringify = require('./encode');
			},
			{
				'./decode': '../node_modules/querystring-es3/decode.js',
				'./encode': '../node_modules/querystring-es3/encode.js'
			}
		],
		'../node_modules/url/url.js': [
			function (require, module, exports) {
				// Copyright Joyent, Inc. and other Node contributors.
				//
				// Permission is hereby granted, free of charge, to any person obtaining a
				// copy of this software and associated documentation files (the
				// "Software"), to deal in the Software without restriction, including
				// without limitation the rights to use, copy, modify, merge, publish,
				// distribute, sublicense, and/or sell copies of the Software, and to permit
				// persons to whom the Software is furnished to do so, subject to the
				// following conditions:
				//
				// The above copyright notice and this permission notice shall be included
				// in all copies or substantial portions of the Software.
				//
				// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
				// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
				// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
				// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
				// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
				// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
				// USE OR OTHER DEALINGS IN THE SOFTWARE.

				'use strict';

				var punycode = require('punycode');
				var util = require('./util');

				exports.parse = urlParse;
				exports.resolve = urlResolve;
				exports.resolveObject = urlResolveObject;
				exports.format = urlFormat;

				exports.Url = Url;

				function Url() {
					this.protocol = null;
					this.slashes = null;
					this.auth = null;
					this.host = null;
					this.port = null;
					this.hostname = null;
					this.hash = null;
					this.search = null;
					this.query = null;
					this.pathname = null;
					this.path = null;
					this.href = null;
				}

				// Reference: RFC 3986, RFC 1808, RFC 2396

				// define these here so at least they only have to be
				// compiled once on the first module load.
				var protocolPattern = /^([a-z0-9.+-]+:)/i,
					portPattern = /:[0-9]*$/,
					// Special case for a simple path URL
					simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
					// RFC 2396: characters reserved for delimiting URLs.
					// We actually just auto-escape these.
					delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
					// RFC 2396: characters not allowed for various reasons.
					unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
					// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
					autoEscape = ["'"].concat(unwise),
					// Characters that are never ever allowed in a hostname.
					// Note that any invalid chars are also handled, but these
					// are the ones that are *expected* to be seen, so we fast-path
					// them.
					nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
					hostEndingChars = ['/', '?', '#'],
					hostnameMaxLen = 255,
					hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
					hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
					// protocols that can allow "unsafe" and "unwise" chars.
					unsafeProtocol = {
						javascript: true,
						'javascript:': true
					},
					// protocols that never have a hostname.
					hostlessProtocol = {
						javascript: true,
						'javascript:': true
					},
					// protocols that always contain a // bit.
					slashedProtocol = {
						http: true,
						https: true,
						ftp: true,
						gopher: true,
						file: true,
						'http:': true,
						'https:': true,
						'ftp:': true,
						'gopher:': true,
						'file:': true
					},
					querystring = require('querystring');

				function urlParse(url, parseQueryString, slashesDenoteHost) {
					if (url && util.isObject(url) && url instanceof Url) return url;

					var u = new Url();
					u.parse(url, parseQueryString, slashesDenoteHost);
					return u;
				}

				Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
					if (!util.isString(url)) {
						throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
					}

					// Copy chrome, IE, opera backslash-handling behavior.
					// Back slashes before the query string get converted to forward slashes
					// See: https://code.google.com/p/chromium/issues/detail?id=25916
					var queryIndex = url.indexOf('?'),
						splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
						uSplit = url.split(splitter),
						slashRegex = /\\/g;
					uSplit[0] = uSplit[0].replace(slashRegex, '/');
					url = uSplit.join(splitter);

					var rest = url;

					// trim before proceeding.
					// This is to support parse stuff like "  http://foo.com  \n"
					rest = rest.trim();

					if (!slashesDenoteHost && url.split('#').length === 1) {
						// Try fast path regexp
						var simplePath = simplePathPattern.exec(rest);
						if (simplePath) {
							this.path = rest;
							this.href = rest;
							this.pathname = simplePath[1];
							if (simplePath[2]) {
								this.search = simplePath[2];
								if (parseQueryString) {
									this.query = querystring.parse(this.search.substr(1));
								} else {
									this.query = this.search.substr(1);
								}
							} else if (parseQueryString) {
								this.search = '';
								this.query = {};
							}
							return this;
						}
					}

					var proto = protocolPattern.exec(rest);
					if (proto) {
						proto = proto[0];
						var lowerProto = proto.toLowerCase();
						this.protocol = lowerProto;
						rest = rest.substr(proto.length);
					}

					// figure out if it's got a host
					// user@server is *always* interpreted as a hostname, and url
					// resolution will treat //foo/bar as host=foo,path=bar because that's
					// how the browser resolves relative URLs.
					if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
						var slashes = rest.substr(0, 2) === '//';
						if (slashes && !(proto && hostlessProtocol[proto])) {
							rest = rest.substr(2);
							this.slashes = true;
						}
					}

					if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {
						// there's a hostname.
						// the first instance of /, ?, ;, or # ends the host.
						//
						// If there is an @ in the hostname, then non-host chars *are* allowed
						// to the left of the last @ sign, unless some host-ending character
						// comes *before* the @-sign.
						// URLs are obnoxious.
						//
						// ex:
						// http://a@b@c/ => user:a@b host:c
						// http://a@b?@c => user:a host:c path:/?@c

						// v0.12 TODO(isaacs): This is not quite how Chrome does things.
						// Review our test case against browsers more comprehensively.

						// find the first instance of any hostEndingChars
						var hostEnd = -1;
						for (var i = 0; i < hostEndingChars.length; i++) {
							var hec = rest.indexOf(hostEndingChars[i]);
							if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
						}

						// at this point, either we have an explicit point where the
						// auth portion cannot go past, or the last @ char is the decider.
						var auth, atSign;
						if (hostEnd === -1) {
							// atSign can be anywhere.
							atSign = rest.lastIndexOf('@');
						} else {
							// atSign must be in auth portion.
							// http://a@b/c@d => host:b auth:a path:/c@d
							atSign = rest.lastIndexOf('@', hostEnd);
						}

						// Now we have a portion which is definitely the auth.
						// Pull that off.
						if (atSign !== -1) {
							auth = rest.slice(0, atSign);
							rest = rest.slice(atSign + 1);
							this.auth = decodeURIComponent(auth);
						}

						// the host is the remaining to the left of the first non-host char
						hostEnd = -1;
						for (var i = 0; i < nonHostChars.length; i++) {
							var hec = rest.indexOf(nonHostChars[i]);
							if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
						}
						// if we still have not hit it, then the entire thing is a host.
						if (hostEnd === -1) hostEnd = rest.length;

						this.host = rest.slice(0, hostEnd);
						rest = rest.slice(hostEnd);

						// pull out port.
						this.parseHost();

						// we've indicated that there is a hostname,
						// so even if it's empty, it has to be present.
						this.hostname = this.hostname || '';

						// if hostname begins with [ and ends with ]
						// assume that it's an IPv6 address.
						var ipv6Hostname =
							this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

						// validate a little.
						if (!ipv6Hostname) {
							var hostparts = this.hostname.split(/\./);
							for (var i = 0, l = hostparts.length; i < l; i++) {
								var part = hostparts[i];
								if (!part) continue;
								if (!part.match(hostnamePartPattern)) {
									var newpart = '';
									for (var j = 0, k = part.length; j < k; j++) {
										if (part.charCodeAt(j) > 127) {
											// we replace non-ASCII char with a temporary placeholder
											// we need this to make sure size of hostname is not
											// broken by replacing non-ASCII by nothing
											newpart += 'x';
										} else {
											newpart += part[j];
										}
									}
									// we test again with ASCII char only
									if (!newpart.match(hostnamePartPattern)) {
										var validParts = hostparts.slice(0, i);
										var notHost = hostparts.slice(i + 1);
										var bit = part.match(hostnamePartStart);
										if (bit) {
											validParts.push(bit[1]);
											notHost.unshift(bit[2]);
										}
										if (notHost.length) {
											rest = '/' + notHost.join('.') + rest;
										}
										this.hostname = validParts.join('.');
										break;
									}
								}
							}
						}

						if (this.hostname.length > hostnameMaxLen) {
							this.hostname = '';
						} else {
							// hostnames are always lower case.
							this.hostname = this.hostname.toLowerCase();
						}

						if (!ipv6Hostname) {
							// IDNA Support: Returns a punycoded representation of "domain".
							// It only converts parts of the domain name that
							// have non-ASCII characters, i.e. it doesn't matter if
							// you call it with a domain that already is ASCII-only.
							this.hostname = punycode.toASCII(this.hostname);
						}

						var p = this.port ? ':' + this.port : '';
						var h = this.hostname || '';
						this.host = h + p;
						this.href += this.host;

						// strip [ and ] from the hostname
						// the host field still retains them, though
						if (ipv6Hostname) {
							this.hostname = this.hostname.substr(1, this.hostname.length - 2);
							if (rest[0] !== '/') {
								rest = '/' + rest;
							}
						}
					}

					// now rest is set to the post-host stuff.
					// chop off any delim chars.
					if (!unsafeProtocol[lowerProto]) {
						// First, make 100% sure that any "autoEscape" chars get
						// escaped, even if encodeURIComponent doesn't think they
						// need to be.
						for (var i = 0, l = autoEscape.length; i < l; i++) {
							var ae = autoEscape[i];
							if (rest.indexOf(ae) === -1) continue;
							var esc = encodeURIComponent(ae);
							if (esc === ae) {
								esc = escape(ae);
							}
							rest = rest.split(ae).join(esc);
						}
					}

					// chop off from the tail first.
					var hash = rest.indexOf('#');
					if (hash !== -1) {
						// got a fragment string.
						this.hash = rest.substr(hash);
						rest = rest.slice(0, hash);
					}
					var qm = rest.indexOf('?');
					if (qm !== -1) {
						this.search = rest.substr(qm);
						this.query = rest.substr(qm + 1);
						if (parseQueryString) {
							this.query = querystring.parse(this.query);
						}
						rest = rest.slice(0, qm);
					} else if (parseQueryString) {
						// no query string, but parseQueryString still requested
						this.search = '';
						this.query = {};
					}
					if (rest) this.pathname = rest;
					if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
						this.pathname = '/';
					}

					//to support http.request
					if (this.pathname || this.search) {
						var p = this.pathname || '';
						var s = this.search || '';
						this.path = p + s;
					}

					// finally, reconstruct the href based on what has been validated.
					this.href = this.format();
					return this;
				};

				// format a parsed object into a url string
				function urlFormat(obj) {
					// ensure it's an object, and not a string url.
					// If it's an obj, this is a no-op.
					// this way, you can call url_format() on strings
					// to clean up potentially wonky urls.
					if (util.isString(obj)) obj = urlParse(obj);
					if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
					return obj.format();
				}

				Url.prototype.format = function () {
					var auth = this.auth || '';
					if (auth) {
						auth = encodeURIComponent(auth);
						auth = auth.replace(/%3A/i, ':');
						auth += '@';
					}

					var protocol = this.protocol || '',
						pathname = this.pathname || '',
						hash = this.hash || '',
						host = false,
						query = '';

					if (this.host) {
						host = auth + this.host;
					} else if (this.hostname) {
						host =
							auth +
							(this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
						if (this.port) {
							host += ':' + this.port;
						}
					}

					if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
						query = querystring.stringify(this.query);
					}

					var search = this.search || (query && '?' + query) || '';

					if (protocol && protocol.substr(-1) !== ':') protocol += ':';

					// only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
					// unless they had them to begin with.
					if (this.slashes || ((!protocol || slashedProtocol[protocol]) && host !== false)) {
						host = '//' + (host || '');
						if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
					} else if (!host) {
						host = '';
					}

					if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
					if (search && search.charAt(0) !== '?') search = '?' + search;

					pathname = pathname.replace(/[?#]/g, function (match) {
						return encodeURIComponent(match);
					});
					search = search.replace('#', '%23');

					return protocol + host + pathname + search + hash;
				};

				function urlResolve(source, relative) {
					return urlParse(source, false, true).resolve(relative);
				}

				Url.prototype.resolve = function (relative) {
					return this.resolveObject(urlParse(relative, false, true)).format();
				};

				function urlResolveObject(source, relative) {
					if (!source) return relative;
					return urlParse(source, false, true).resolveObject(relative);
				}

				Url.prototype.resolveObject = function (relative) {
					if (util.isString(relative)) {
						var rel = new Url();
						rel.parse(relative, false, true);
						relative = rel;
					}

					var result = new Url();
					var tkeys = Object.keys(this);
					for (var tk = 0; tk < tkeys.length; tk++) {
						var tkey = tkeys[tk];
						result[tkey] = this[tkey];
					}

					// hash is always overridden, no matter what.
					// even href="" will remove it.
					result.hash = relative.hash;

					// if the relative url is empty, then there's nothing left to do here.
					if (relative.href === '') {
						result.href = result.format();
						return result;
					}

					// hrefs like //foo/bar always cut to the protocol.
					if (relative.slashes && !relative.protocol) {
						// take everything except the protocol from relative
						var rkeys = Object.keys(relative);
						for (var rk = 0; rk < rkeys.length; rk++) {
							var rkey = rkeys[rk];
							if (rkey !== 'protocol') result[rkey] = relative[rkey];
						}

						//urlParse appends trailing / to urls like http://www.example.com
						if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
							result.path = result.pathname = '/';
						}

						result.href = result.format();
						return result;
					}

					if (relative.protocol && relative.protocol !== result.protocol) {
						// if it's a known url protocol, then changing
						// the protocol does weird things
						// first, if it's not file:, then we MUST have a host,
						// and if there was a path
						// to begin with, then we MUST have a path.
						// if it is file:, then the host is dropped,
						// because that's known to be hostless.
						// anything else is assumed to be absolute.
						if (!slashedProtocol[relative.protocol]) {
							var keys = Object.keys(relative);
							for (var v = 0; v < keys.length; v++) {
								var k = keys[v];
								result[k] = relative[k];
							}
							result.href = result.format();
							return result;
						}

						result.protocol = relative.protocol;
						if (!relative.host && !hostlessProtocol[relative.protocol]) {
							var relPath = (relative.pathname || '').split('/');
							while (relPath.length && !(relative.host = relPath.shift()));
							if (!relative.host) relative.host = '';
							if (!relative.hostname) relative.hostname = '';
							if (relPath[0] !== '') relPath.unshift('');
							if (relPath.length < 2) relPath.unshift('');
							result.pathname = relPath.join('/');
						} else {
							result.pathname = relative.pathname;
						}
						result.search = relative.search;
						result.query = relative.query;
						result.host = relative.host || '';
						result.auth = relative.auth;
						result.hostname = relative.hostname || relative.host;
						result.port = relative.port;
						// to support http.request
						if (result.pathname || result.search) {
							var p = result.pathname || '';
							var s = result.search || '';
							result.path = p + s;
						}
						result.slashes = result.slashes || relative.slashes;
						result.href = result.format();
						return result;
					}

					var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
						isRelAbs = relative.host || (relative.pathname && relative.pathname.charAt(0) === '/'),
						mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname),
						removeAllDots = mustEndAbs,
						srcPath = (result.pathname && result.pathname.split('/')) || [],
						relPath = (relative.pathname && relative.pathname.split('/')) || [],
						psychotic = result.protocol && !slashedProtocol[result.protocol];

					// if the url is a non-slashed url, then relative
					// links like ../.. should be able
					// to crawl up to the hostname, as well.  This is strange.
					// result.protocol has already been set by now.
					// Later on, put the first path part into the host field.
					if (psychotic) {
						result.hostname = '';
						result.port = null;
						if (result.host) {
							if (srcPath[0] === '') srcPath[0] = result.host;
							else srcPath.unshift(result.host);
						}
						result.host = '';
						if (relative.protocol) {
							relative.hostname = null;
							relative.port = null;
							if (relative.host) {
								if (relPath[0] === '') relPath[0] = relative.host;
								else relPath.unshift(relative.host);
							}
							relative.host = null;
						}
						mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
					}

					if (isRelAbs) {
						// it's absolute.
						result.host = relative.host || relative.host === '' ? relative.host : result.host;
						result.hostname =
							relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
						result.search = relative.search;
						result.query = relative.query;
						srcPath = relPath;
						// fall through to the dot-handling below.
					} else if (relPath.length) {
						// it's relative
						// throw away the existing file, and take the new path instead.
						if (!srcPath) srcPath = [];
						srcPath.pop();
						srcPath = srcPath.concat(relPath);
						result.search = relative.search;
						result.query = relative.query;
					} else if (!util.isNullOrUndefined(relative.search)) {
						// just pull out the search.
						// like href='?foo'.
						// Put this after the other two cases because it simplifies the booleans
						if (psychotic) {
							result.hostname = result.host = srcPath.shift();
							//occationaly the auth can get stuck only in host
							//this especially happens in cases like
							//url.resolveObject('mailto:local1@domain1', 'local2@domain2')
							var authInHost =
								result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
							if (authInHost) {
								result.auth = authInHost.shift();
								result.host = result.hostname = authInHost.shift();
							}
						}
						result.search = relative.search;
						result.query = relative.query;
						//to support http.request
						if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
							result.path =
								(result.pathname ? result.pathname : '') + (result.search ? result.search : '');
						}
						result.href = result.format();
						return result;
					}

					if (!srcPath.length) {
						// no path at all.  easy.
						// we've already handled the other stuff above.
						result.pathname = null;
						//to support http.request
						if (result.search) {
							result.path = '/' + result.search;
						} else {
							result.path = null;
						}
						result.href = result.format();
						return result;
					}

					// if a url ENDs in . or .., then it must get a trailing slash.
					// however, if it ends in anything else non-slashy,
					// then it must NOT get a trailing slash.
					var last = srcPath.slice(-1)[0];
					var hasTrailingSlash =
						((result.host || relative.host || srcPath.length > 1) &&
							(last === '.' || last === '..')) ||
						last === '';

					// strip single dots, resolve double dots to parent dir
					// if the path tries to go above the root, `up` ends up > 0
					var up = 0;
					for (var i = srcPath.length; i >= 0; i--) {
						last = srcPath[i];
						if (last === '.') {
							srcPath.splice(i, 1);
						} else if (last === '..') {
							srcPath.splice(i, 1);
							up++;
						} else if (up) {
							srcPath.splice(i, 1);
							up--;
						}
					}

					// if the path is allowed to go above the root, restore leading ..s
					if (!mustEndAbs && !removeAllDots) {
						for (; up--; up) {
							srcPath.unshift('..');
						}
					}

					if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
						srcPath.unshift('');
					}

					if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
						srcPath.push('');
					}

					var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');

					// put the host back
					if (psychotic) {
						result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
						//occationaly the auth can get stuck only in host
						//this especially happens in cases like
						//url.resolveObject('mailto:local1@domain1', 'local2@domain2')
						var authInHost =
							result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
						if (authInHost) {
							result.auth = authInHost.shift();
							result.host = result.hostname = authInHost.shift();
						}
					}

					mustEndAbs = mustEndAbs || (result.host && srcPath.length);

					if (mustEndAbs && !isAbsolute) {
						srcPath.unshift('');
					}

					if (!srcPath.length) {
						result.pathname = null;
						result.path = null;
					} else {
						result.pathname = srcPath.join('/');
					}

					//to support request.http
					if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
						result.path =
							(result.pathname ? result.pathname : '') + (result.search ? result.search : '');
					}
					result.auth = relative.auth || result.auth;
					result.slashes = result.slashes || relative.slashes;
					result.href = result.format();
					return result;
				};

				Url.prototype.parseHost = function () {
					var host = this.host;
					var port = portPattern.exec(host);
					if (port) {
						port = port[0];
						if (port !== ':') {
							this.port = port.substr(1);
						}
						host = host.substr(0, host.length - port.length);
					}
					if (host) this.hostname = host;
				};
			},
			{
				punycode: '../node_modules/node-libs-browser/node_modules/punycode/punycode.js',
				'./util': '../node_modules/url/util.js',
				querystring: '../node_modules/querystring-es3/index.js'
			}
		],
		'../node_modules/stream-http/index.js': [
			function (require, module, exports) {
				var global = arguments[3];
				var ClientRequest = require('./lib/request');
				var response = require('./lib/response');
				var extend = require('xtend');
				var statusCodes = require('builtin-status-codes');
				var url = require('url');

				var http = exports;

				http.request = function (opts, cb) {
					if (typeof opts === 'string') opts = url.parse(opts);
					else opts = extend(opts);

					// Normally, the page is loaded from http or https, so not specifying a protocol
					// will result in a (valid) protocol-relative url. However, this won't work if
					// the protocol is something else, like 'file:'
					var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : '';

					var protocol = opts.protocol || defaultProtocol;
					var host = opts.hostname || opts.host;
					var port = opts.port;
					var path = opts.path || '/';

					// Necessary for IPv6 addresses
					if (host && host.indexOf(':') !== -1) host = '[' + host + ']';

					// This may be a relative url. The browser should always be able to interpret it correctly.
					opts.url = (host ? protocol + '//' + host : '') + (port ? ':' + port : '') + path;
					opts.method = (opts.method || 'GET').toUpperCase();
					opts.headers = opts.headers || {};

					// Also valid opts.auth, opts.mode

					var req = new ClientRequest(opts);
					if (cb) req.on('response', cb);
					return req;
				};

				http.get = function get(opts, cb) {
					var req = http.request(opts, cb);
					req.end();
					return req;
				};

				http.ClientRequest = ClientRequest;
				http.IncomingMessage = response.IncomingMessage;

				http.Agent = function () {};
				http.Agent.defaultMaxSockets = 4;

				http.globalAgent = new http.Agent();

				http.STATUS_CODES = statusCodes;

				http.METHODS = [
					'CHECKOUT',
					'CONNECT',
					'COPY',
					'DELETE',
					'GET',
					'HEAD',
					'LOCK',
					'M-SEARCH',
					'MERGE',
					'MKACTIVITY',
					'MKCOL',
					'MOVE',
					'NOTIFY',
					'OPTIONS',
					'PATCH',
					'POST',
					'PROPFIND',
					'PROPPATCH',
					'PURGE',
					'PUT',
					'REPORT',
					'SEARCH',
					'SUBSCRIBE',
					'TRACE',
					'UNLOCK',
					'UNSUBSCRIBE'
				];
			},
			{
				'./lib/request': '../node_modules/stream-http/lib/request.js',
				'./lib/response': '../node_modules/stream-http/lib/response.js',
				xtend: '../node_modules/xtend/immutable.js',
				'builtin-status-codes': '../node_modules/builtin-status-codes/browser.js',
				url: '../node_modules/url/url.js'
			}
		],
		'../node_modules/https-browserify/index.js': [
			function (require, module, exports) {
				var http = require('http');
				var url = require('url');

				var https = module.exports;

				for (var key in http) {
					if (http.hasOwnProperty(key)) https[key] = http[key];
				}

				https.request = function (params, cb) {
					params = validateParams(params);
					return http.request.call(this, params, cb);
				};

				https.get = function (params, cb) {
					params = validateParams(params);
					return http.get.call(this, params, cb);
				};

				function validateParams(params) {
					if (typeof params === 'string') {
						params = url.parse(params);
					}
					if (!params.protocol) {
						params.protocol = 'https:';
					}
					if (params.protocol !== 'https:') {
						throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
					}
					return params;
				}
			},
			{ http: '../node_modules/stream-http/index.js', url: '../node_modules/url/url.js' }
		],
		'../node_modules/os-browserify/browser.js': [
			function (require, module, exports) {
				exports.endianness = function () {
					return 'LE';
				};

				exports.hostname = function () {
					if (typeof location !== 'undefined') {
						return location.hostname;
					} else return '';
				};

				exports.loadavg = function () {
					return [];
				};

				exports.uptime = function () {
					return 0;
				};

				exports.freemem = function () {
					return Number.MAX_VALUE;
				};

				exports.totalmem = function () {
					return Number.MAX_VALUE;
				};

				exports.cpus = function () {
					return [];
				};

				exports.type = function () {
					return 'Browser';
				};

				exports.release = function () {
					if (typeof navigator !== 'undefined') {
						return navigator.appVersion;
					}
					return '';
				};

				exports.networkInterfaces = exports.getNetworkInterfaces = function () {
					return {};
				};

				exports.arch = function () {
					return 'javascript';
				};

				exports.platform = function () {
					return 'browser';
				};

				exports.tmpdir = exports.tmpDir = function () {
					return '/tmp';
				};

				exports.EOL = '\n';

				exports.homedir = function () {
					return '/';
				};
			},
			{}
		],
		'../node_modules/xhr2-cookies/dist/progress-event.js': [
			function (require, module, exports) {
				'use strict';
				Object.defineProperty(exports, '__esModule', { value: true });
				var ProgressEvent = /** @class */ (function () {
					function ProgressEvent(type) {
						this.type = type;
						this.bubbles = false;
						this.cancelable = false;
						this.loaded = 0;
						this.lengthComputable = false;
						this.total = 0;
					}
					return ProgressEvent;
				})();
				exports.ProgressEvent = ProgressEvent;
			},
			{}
		],
		'../node_modules/xhr2-cookies/dist/errors.js': [
			function (require, module, exports) {
				'use strict';
				var __extends =
					(this && this.__extends) ||
					(function () {
						var extendStatics =
							Object.setPrototypeOf ||
							({ __proto__: [] } instanceof Array &&
								function (d, b) {
									d.__proto__ = b;
								}) ||
							function (d, b) {
								for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
							};
						return function (d, b) {
							extendStatics(d, b);
							function __() {
								this.constructor = d;
							}
							d.prototype =
								b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
						};
					})();
				Object.defineProperty(exports, '__esModule', { value: true });
				var SecurityError = /** @class */ (function (_super) {
					__extends(SecurityError, _super);
					function SecurityError() {
						return (_super !== null && _super.apply(this, arguments)) || this;
					}
					return SecurityError;
				})(Error);
				exports.SecurityError = SecurityError;
				var InvalidStateError = /** @class */ (function (_super) {
					__extends(InvalidStateError, _super);
					function InvalidStateError() {
						return (_super !== null && _super.apply(this, arguments)) || this;
					}
					return InvalidStateError;
				})(Error);
				exports.InvalidStateError = InvalidStateError;
				var NetworkError = /** @class */ (function (_super) {
					__extends(NetworkError, _super);
					function NetworkError() {
						return (_super !== null && _super.apply(this, arguments)) || this;
					}
					return NetworkError;
				})(Error);
				exports.NetworkError = NetworkError;
				var SyntaxError = /** @class */ (function (_super) {
					__extends(SyntaxError, _super);
					function SyntaxError() {
						return (_super !== null && _super.apply(this, arguments)) || this;
					}
					return SyntaxError;
				})(Error);
				exports.SyntaxError = SyntaxError;
			},
			{}
		],
		'../node_modules/xhr2-cookies/dist/xml-http-request-event-target.js': [
			function (require, module, exports) {
				'use strict';
				Object.defineProperty(exports, '__esModule', { value: true });
				var XMLHttpRequestEventTarget = /** @class */ (function () {
					function XMLHttpRequestEventTarget() {
						this.listeners = {};
					}
					XMLHttpRequestEventTarget.prototype.addEventListener = function (eventType, listener) {
						eventType = eventType.toLowerCase();
						this.listeners[eventType] = this.listeners[eventType] || [];
						this.listeners[eventType].push(listener.handleEvent || listener);
					};
					XMLHttpRequestEventTarget.prototype.removeEventListener = function (eventType, listener) {
						eventType = eventType.toLowerCase();
						if (!this.listeners[eventType]) {
							return;
						}
						var index = this.listeners[eventType].indexOf(listener.handleEvent || listener);
						if (index < 0) {
							return;
						}
						this.listeners[eventType].splice(index, 1);
					};
					XMLHttpRequestEventTarget.prototype.dispatchEvent = function (event) {
						var eventType = event.type.toLowerCase();
						event.target = this; // TODO: set event.currentTarget?
						if (this.listeners[eventType]) {
							for (var _i = 0, _a = this.listeners[eventType]; _i < _a.length; _i++) {
								var listener_1 = _a[_i];
								listener_1.call(this, event);
							}
						}
						var listener = this['on' + eventType];
						if (listener) {
							listener.call(this, event);
						}
						return true;
					};
					return XMLHttpRequestEventTarget;
				})();
				exports.XMLHttpRequestEventTarget = XMLHttpRequestEventTarget;
			},
			{}
		],
		'../node_modules/xhr2-cookies/dist/xml-http-request-upload.js': [
			function (require, module, exports) {
				var Buffer = require('buffer').Buffer;
				('use strict');
				var __extends =
					(this && this.__extends) ||
					(function () {
						var extendStatics =
							Object.setPrototypeOf ||
							({ __proto__: [] } instanceof Array &&
								function (d, b) {
									d.__proto__ = b;
								}) ||
							function (d, b) {
								for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
							};
						return function (d, b) {
							extendStatics(d, b);
							function __() {
								this.constructor = d;
							}
							d.prototype =
								b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
						};
					})();
				Object.defineProperty(exports, '__esModule', { value: true });
				var xml_http_request_event_target_1 = require('./xml-http-request-event-target');
				var XMLHttpRequestUpload = /** @class */ (function (_super) {
					__extends(XMLHttpRequestUpload, _super);
					function XMLHttpRequestUpload() {
						var _this = _super.call(this) || this;
						_this._contentType = null;
						_this._body = null;
						_this._reset();
						return _this;
					}
					XMLHttpRequestUpload.prototype._reset = function () {
						this._contentType = null;
						this._body = null;
					};
					XMLHttpRequestUpload.prototype._setData = function (data) {
						if (data == null) {
							return;
						}
						if (typeof data === 'string') {
							if (data.length !== 0) {
								this._contentType = 'text/plain;charset=UTF-8';
							}
							this._body = new Buffer(data, 'utf-8');
						} else if (Buffer.isBuffer(data)) {
							this._body = data;
						} else if (data instanceof ArrayBuffer) {
							var body = new Buffer(data.byteLength);
							var view = new Uint8Array(data);
							for (var i = 0; i < data.byteLength; i++) {
								body[i] = view[i];
							}
							this._body = body;
						} else if (data.buffer && data.buffer instanceof ArrayBuffer) {
							var body = new Buffer(data.byteLength);
							var offset = data.byteOffset;
							var view = new Uint8Array(data.buffer);
							for (var i = 0; i < data.byteLength; i++) {
								body[i] = view[i + offset];
							}
							this._body = body;
						} else {
							throw new Error('Unsupported send() data ' + data);
						}
					};
					XMLHttpRequestUpload.prototype._finalizeHeaders = function (headers, loweredHeaders) {
						if (this._contentType && !loweredHeaders['content-type']) {
							headers['Content-Type'] = this._contentType;
						}
						if (this._body) {
							headers['Content-Length'] = this._body.length.toString();
						}
					};
					XMLHttpRequestUpload.prototype._startUpload = function (request) {
						if (this._body) {
							request.write(this._body);
						}
						request.end();
					};
					return XMLHttpRequestUpload;
				})(xml_http_request_event_target_1.XMLHttpRequestEventTarget);
				exports.XMLHttpRequestUpload = XMLHttpRequestUpload;
			},
			{
				'./xml-http-request-event-target':
					'../node_modules/xhr2-cookies/dist/xml-http-request-event-target.js',
				buffer: '../node_modules/node-libs-browser/node_modules/buffer/index.js'
			}
		],
		'../node_modules/cookiejar/cookiejar.js': [
			function (require, module, exports) {
				/* jshint node: true */
				(function () {
					'use strict';

					function CookieAccessInfo(domain, path, secure, script) {
						if (this instanceof CookieAccessInfo) {
							this.domain = domain || undefined;
							this.path = path || '/';
							this.secure = !!secure;
							this.script = !!script;
							return this;
						}
						return new CookieAccessInfo(domain, path, secure, script);
					}
					CookieAccessInfo.All = Object.freeze(Object.create(null));
					exports.CookieAccessInfo = CookieAccessInfo;

					function Cookie(cookiestr, request_domain, request_path) {
						if (cookiestr instanceof Cookie) {
							return cookiestr;
						}
						if (this instanceof Cookie) {
							this.name = null;
							this.value = null;
							this.expiration_date = Infinity;
							this.path = String(request_path || '/');
							this.explicit_path = false;
							this.domain = request_domain || null;
							this.explicit_domain = false;
							this.secure = false; //how to define default?
							this.noscript = false; //httponly
							if (cookiestr) {
								this.parse(cookiestr, request_domain, request_path);
							}
							return this;
						}
						return new Cookie(cookiestr, request_domain, request_path);
					}
					exports.Cookie = Cookie;

					Cookie.prototype.toString = function toString() {
						var str = [this.name + '=' + this.value];
						if (this.expiration_date !== Infinity) {
							str.push('expires=' + new Date(this.expiration_date).toGMTString());
						}
						if (this.domain) {
							str.push('domain=' + this.domain);
						}
						if (this.path) {
							str.push('path=' + this.path);
						}
						if (this.secure) {
							str.push('secure');
						}
						if (this.noscript) {
							str.push('httponly');
						}
						return str.join('; ');
					};

					Cookie.prototype.toValueString = function toValueString() {
						return this.name + '=' + this.value;
					};

					var cookie_str_splitter = /[:](?=\s*[a-zA-Z0-9_\-]+\s*[=])/g;
					Cookie.prototype.parse = function parse(str, request_domain, request_path) {
						if (this instanceof Cookie) {
							var parts = str.split(';').filter(function (value) {
								return !!value;
							});
							var i;

							var pair = parts[0].match(/([^=]+)=([\s\S]*)/);
							if (!pair) {
								console.warn("Invalid cookie header encountered. Header: '" + str + "'");
								return;
							}

							var key = pair[1];
							var value = pair[2];
							if (typeof key !== 'string' || key.length === 0 || typeof value !== 'string') {
								console.warn("Unable to extract values from cookie header. Cookie: '" + str + "'");
								return;
							}

							this.name = key;
							this.value = value;

							for (i = 1; i < parts.length; i += 1) {
								pair = parts[i].match(/([^=]+)(?:=([\s\S]*))?/);
								key = pair[1].trim().toLowerCase();
								value = pair[2];
								switch (key) {
									case 'httponly':
										this.noscript = true;
										break;
									case 'expires':
										this.expiration_date = value ? Number(Date.parse(value)) : Infinity;
										break;
									case 'path':
										this.path = value ? value.trim() : '';
										this.explicit_path = true;
										break;
									case 'domain':
										this.domain = value ? value.trim() : '';
										this.explicit_domain = !!this.domain;
										break;
									case 'secure':
										this.secure = true;
										break;
								}
							}

							if (!this.explicit_path) {
								this.path = request_path || '/';
							}
							if (!this.explicit_domain) {
								this.domain = request_domain;
							}

							return this;
						}
						return new Cookie().parse(str, request_domain, request_path);
					};

					Cookie.prototype.matches = function matches(access_info) {
						if (access_info === CookieAccessInfo.All) {
							return true;
						}
						if (
							(this.noscript && access_info.script) ||
							(this.secure && !access_info.secure) ||
							!this.collidesWith(access_info)
						) {
							return false;
						}
						return true;
					};

					Cookie.prototype.collidesWith = function collidesWith(access_info) {
						if ((this.path && !access_info.path) || (this.domain && !access_info.domain)) {
							return false;
						}
						if (this.path && access_info.path.indexOf(this.path) !== 0) {
							return false;
						}
						if (this.explicit_path && access_info.path.indexOf(this.path) !== 0) {
							return false;
						}
						var access_domain = access_info.domain && access_info.domain.replace(/^[\.]/, '');
						var cookie_domain = this.domain && this.domain.replace(/^[\.]/, '');
						if (cookie_domain === access_domain) {
							return true;
						}
						if (cookie_domain) {
							if (!this.explicit_domain) {
								return false; // we already checked if the domains were exactly the same
							}
							var wildcard = access_domain.indexOf(cookie_domain);
							if (wildcard === -1 || wildcard !== access_domain.length - cookie_domain.length) {
								return false;
							}
							return true;
						}
						return true;
					};

					function CookieJar() {
						var cookies, cookies_list, collidable_cookie;
						if (this instanceof CookieJar) {
							cookies = Object.create(null); //name: [Cookie]

							this.setCookie = function setCookie(cookie, request_domain, request_path) {
								var remove, i;
								cookie = new Cookie(cookie, request_domain, request_path);
								//Delete the cookie if the set is past the current time
								remove = cookie.expiration_date <= Date.now();
								if (cookies[cookie.name] !== undefined) {
									cookies_list = cookies[cookie.name];
									for (i = 0; i < cookies_list.length; i += 1) {
										collidable_cookie = cookies_list[i];
										if (collidable_cookie.collidesWith(cookie)) {
											if (remove) {
												cookies_list.splice(i, 1);
												if (cookies_list.length === 0) {
													delete cookies[cookie.name];
												}
												return false;
											}
											cookies_list[i] = cookie;
											return cookie;
										}
									}
									if (remove) {
										return false;
									}
									cookies_list.push(cookie);
									return cookie;
								}
								if (remove) {
									return false;
								}
								cookies[cookie.name] = [cookie];
								return cookies[cookie.name];
							};
							//returns a cookie
							this.getCookie = function getCookie(cookie_name, access_info) {
								var cookie, i;
								cookies_list = cookies[cookie_name];
								if (!cookies_list) {
									return;
								}
								for (i = 0; i < cookies_list.length; i += 1) {
									cookie = cookies_list[i];
									if (cookie.expiration_date <= Date.now()) {
										if (cookies_list.length === 0) {
											delete cookies[cookie.name];
										}
										continue;
									}

									if (cookie.matches(access_info)) {
										return cookie;
									}
								}
							};
							//returns a list of cookies
							this.getCookies = function getCookies(access_info) {
								var matches = [],
									cookie_name,
									cookie;
								for (cookie_name in cookies) {
									cookie = this.getCookie(cookie_name, access_info);
									if (cookie) {
										matches.push(cookie);
									}
								}
								matches.toString = function toString() {
									return matches.join(':');
								};
								matches.toValueString = function toValueString() {
									return matches
										.map(function (c) {
											return c.toValueString();
										})
										.join('; ');
								};
								return matches;
							};

							return this;
						}
						return new CookieJar();
					}
					exports.CookieJar = CookieJar;

					//returns list of cookies that were set correctly. Cookies that are expired and removed are not returned.
					CookieJar.prototype.setCookies = function setCookies(
						cookies,
						request_domain,
						request_path
					) {
						cookies = Array.isArray(cookies) ? cookies : cookies.split(cookie_str_splitter);
						var successful = [],
							i,
							cookie;
						cookies = cookies.map(function (item) {
							return new Cookie(item, request_domain, request_path);
						});
						for (i = 0; i < cookies.length; i += 1) {
							cookie = cookies[i];
							if (this.setCookie(cookie, request_domain, request_path)) {
								successful.push(cookie);
							}
						}
						return successful;
					};
				})();
			},
			{}
		],
		'../node_modules/xhr2-cookies/dist/xml-http-request.js': [
			function (require, module, exports) {
				var process = require('process');
				var Buffer = require('buffer').Buffer;
				('use strict');
				var __extends =
					(this && this.__extends) ||
					(function () {
						var extendStatics =
							Object.setPrototypeOf ||
							({ __proto__: [] } instanceof Array &&
								function (d, b) {
									d.__proto__ = b;
								}) ||
							function (d, b) {
								for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
							};
						return function (d, b) {
							extendStatics(d, b);
							function __() {
								this.constructor = d;
							}
							d.prototype =
								b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
						};
					})();
				var __assign =
					(this && this.__assign) ||
					Object.assign ||
					function (t) {
						for (var s, i = 1, n = arguments.length; i < n; i++) {
							s = arguments[i];
							for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
						}
						return t;
					};
				Object.defineProperty(exports, '__esModule', { value: true });
				var http = require('http');
				var https = require('https');
				var os = require('os');
				var url = require('url');
				var progress_event_1 = require('./progress-event');
				var errors_1 = require('./errors');
				var xml_http_request_event_target_1 = require('./xml-http-request-event-target');
				var xml_http_request_upload_1 = require('./xml-http-request-upload');
				var Cookie = require('cookiejar');
				var XMLHttpRequest = /** @class */ (function (_super) {
					__extends(XMLHttpRequest, _super);
					function XMLHttpRequest(options) {
						if (options === void 0) {
							options = {};
						}
						var _this = _super.call(this) || this;
						_this.UNSENT = XMLHttpRequest.UNSENT;
						_this.OPENED = XMLHttpRequest.OPENED;
						_this.HEADERS_RECEIVED = XMLHttpRequest.HEADERS_RECEIVED;
						_this.LOADING = XMLHttpRequest.LOADING;
						_this.DONE = XMLHttpRequest.DONE;
						_this.onreadystatechange = null;
						_this.readyState = XMLHttpRequest.UNSENT;
						_this.response = null;
						_this.responseText = '';
						_this.responseType = '';
						_this.status = 0; // TODO: UNSENT?
						_this.statusText = '';
						_this.timeout = 0;
						_this.upload = new xml_http_request_upload_1.XMLHttpRequestUpload();
						_this.responseUrl = '';
						_this.withCredentials = false;
						_this._method = null;
						_this._url = null;
						_this._sync = false;
						_this._headers = {};
						_this._loweredHeaders = {};
						_this._mimeOverride = null; // TODO: is type right?
						_this._request = null;
						_this._response = null;
						_this._responseParts = null;
						_this._responseHeaders = null;
						_this._aborting = null; // TODO: type?
						_this._error = null; // TODO: type?
						_this._loadedBytes = 0;
						_this._totalBytes = 0;
						_this._lengthComputable = false;
						_this._restrictedMethods = { CONNECT: true, TRACE: true, TRACK: true };
						_this._restrictedHeaders = {
							'accept-charset': true,
							'accept-encoding': true,
							'access-control-request-headers': true,
							'access-control-request-method': true,
							connection: true,
							'content-length': true,
							cookie: true,
							cookie2: true,
							date: true,
							dnt: true,
							expect: true,
							host: true,
							'keep-alive': true,
							origin: true,
							referer: true,
							te: true,
							trailer: true,
							'transfer-encoding': true,
							upgrade: true,
							'user-agent': true,
							via: true
						};
						_this._privateHeaders = { 'set-cookie': true, 'set-cookie2': true };
						_this._userAgent =
							'Mozilla/5.0 (' +
							os.type() +
							' ' +
							os.arch() +
							') node.js/' +
							process.versions.node +
							' v8/' +
							process.versions.v8;
						_this._anonymous = options.anon || false;
						return _this;
					}
					XMLHttpRequest.prototype.open = function (method, url, async, user, password) {
						if (async === void 0) {
							async = true;
						}
						method = method.toUpperCase();
						if (this._restrictedMethods[method]) {
							throw new XMLHttpRequest.SecurityError(
								'HTTP method ' + method + ' is not allowed in XHR'
							);
						}
						var xhrUrl = this._parseUrl(url, user, password);
						if (
							this.readyState === XMLHttpRequest.HEADERS_RECEIVED ||
							this.readyState === XMLHttpRequest.LOADING
						) {
							// TODO(pwnall): terminate abort(), terminate send()
						}
						this._method = method;
						this._url = xhrUrl;
						this._sync = !async;
						this._headers = {};
						this._loweredHeaders = {};
						this._mimeOverride = null;
						this._setReadyState(XMLHttpRequest.OPENED);
						this._request = null;
						this._response = null;
						this.status = 0;
						this.statusText = '';
						this._responseParts = [];
						this._responseHeaders = null;
						this._loadedBytes = 0;
						this._totalBytes = 0;
						this._lengthComputable = false;
					};
					XMLHttpRequest.prototype.setRequestHeader = function (name, value) {
						if (this.readyState !== XMLHttpRequest.OPENED) {
							throw new XMLHttpRequest.InvalidStateError('XHR readyState must be OPENED');
						}
						var loweredName = name.toLowerCase();
						if (
							this._restrictedHeaders[loweredName] ||
							/^sec-/.test(loweredName) ||
							/^proxy-/.test(loweredName)
						) {
							console.warn('Refused to set unsafe header "' + name + '"');
							return;
						}
						value = value.toString();
						if (this._loweredHeaders[loweredName] != null) {
							name = this._loweredHeaders[loweredName];
							this._headers[name] = this._headers[name] + ', ' + value;
						} else {
							this._loweredHeaders[loweredName] = name;
							this._headers[name] = value;
						}
					};
					XMLHttpRequest.prototype.send = function (data) {
						if (this.readyState !== XMLHttpRequest.OPENED) {
							throw new XMLHttpRequest.InvalidStateError('XHR readyState must be OPENED');
						}
						if (this._request) {
							throw new XMLHttpRequest.InvalidStateError('send() already called');
						}
						switch (this._url.protocol) {
							case 'file:':
								return this._sendFile(data);
							case 'http:':
							case 'https:':
								return this._sendHttp(data);
							default:
								throw new XMLHttpRequest.NetworkError('Unsupported protocol ' + this._url.protocol);
						}
					};
					XMLHttpRequest.prototype.abort = function () {
						if (this._request == null) {
							return;
						}
						this._request.abort();
						this._setError();
						this._dispatchProgress('abort');
						this._dispatchProgress('loadend');
					};
					XMLHttpRequest.prototype.getResponseHeader = function (name) {
						if (this._responseHeaders == null || name == null) {
							return null;
						}
						var loweredName = name.toLowerCase();
						return this._responseHeaders.hasOwnProperty(loweredName)
							? this._responseHeaders[name.toLowerCase()]
							: null;
					};
					XMLHttpRequest.prototype.getAllResponseHeaders = function () {
						var _this = this;
						if (this._responseHeaders == null) {
							return '';
						}
						return Object.keys(this._responseHeaders)
							.map(function (key) {
								return key + ': ' + _this._responseHeaders[key];
							})
							.join('\r\n');
					};
					XMLHttpRequest.prototype.overrideMimeType = function (mimeType) {
						if (
							this.readyState === XMLHttpRequest.LOADING ||
							this.readyState === XMLHttpRequest.DONE
						) {
							throw new XMLHttpRequest.InvalidStateError(
								'overrideMimeType() not allowed in LOADING or DONE'
							);
						}
						this._mimeOverride = mimeType.toLowerCase();
					};
					XMLHttpRequest.prototype.nodejsSet = function (options) {
						this.nodejsHttpAgent = options.httpAgent || this.nodejsHttpAgent;
						this.nodejsHttpsAgent = options.httpsAgent || this.nodejsHttpsAgent;
						if (options.hasOwnProperty('baseUrl')) {
							if (options.baseUrl != null) {
								var parsedUrl = url.parse(options.baseUrl, false, true);
								if (!parsedUrl.protocol) {
									throw new XMLHttpRequest.SyntaxError('baseUrl must be an absolute URL');
								}
							}
							this.nodejsBaseUrl = options.baseUrl;
						}
					};
					XMLHttpRequest.nodejsSet = function (options) {
						XMLHttpRequest.prototype.nodejsSet(options);
					};
					XMLHttpRequest.prototype._setReadyState = function (readyState) {
						this.readyState = readyState;
						this.dispatchEvent(new progress_event_1.ProgressEvent('readystatechange'));
					};
					XMLHttpRequest.prototype._sendFile = function (data) {
						// TODO
						throw new Error('Protocol file: not implemented');
					};
					XMLHttpRequest.prototype._sendHttp = function (data) {
						if (this._sync) {
							throw new Error('Synchronous XHR processing not implemented');
						}
						if (data && (this._method === 'GET' || this._method === 'HEAD')) {
							console.warn('Discarding entity body for ' + this._method + ' requests');
							data = null;
						} else {
							data = data || '';
						}
						this.upload._setData(data);
						this._finalizeHeaders();
						this._sendHxxpRequest();
					};
					XMLHttpRequest.prototype._sendHxxpRequest = function () {
						var _this = this;
						if (this.withCredentials) {
							var cookie = XMLHttpRequest.cookieJar
								.getCookies(
									Cookie.CookieAccessInfo(
										this._url.hostname,
										this._url.pathname,
										this._url.protocol === 'https:'
									)
								)
								.toValueString();
							this._headers.cookie = this._headers.cookie2 = cookie;
						}
						var _a =
								this._url.protocol === 'http:'
									? [http, this.nodejsHttpAgent]
									: [https, this.nodejsHttpsAgent],
							hxxp = _a[0],
							agent = _a[1];
						var requestMethod = hxxp.request.bind(hxxp);
						var request = requestMethod({
							hostname: this._url.hostname,
							port: +this._url.port,
							path: this._url.path,
							auth: this._url.auth,
							method: this._method,
							headers: this._headers,
							agent: agent
						});
						this._request = request;
						if (this.timeout) {
							request.setTimeout(this.timeout, function () {
								return _this._onHttpTimeout(request);
							});
						}
						request.on('response', function (response) {
							return _this._onHttpResponse(request, response);
						});
						request.on('error', function (error) {
							return _this._onHttpRequestError(request, error);
						});
						this.upload._startUpload(request);
						if (this._request === request) {
							this._dispatchProgress('loadstart');
						}
					};
					XMLHttpRequest.prototype._finalizeHeaders = function () {
						this._headers = __assign(
							{},
							this._headers,
							{ Connection: 'keep-alive', Host: this._url.host, 'User-Agent': this._userAgent },
							this._anonymous ? { Referer: 'about:blank' } : {}
						);
						this.upload._finalizeHeaders(this._headers, this._loweredHeaders);
					};
					XMLHttpRequest.prototype._onHttpResponse = function (request, response) {
						var _this = this;
						if (this._request !== request) {
							return;
						}
						if (
							this.withCredentials &&
							(response.headers['set-cookie'] || response.headers['set-cookie2'])
						) {
							XMLHttpRequest.cookieJar.setCookies(
								response.headers['set-cookie'] || response.headers['set-cookie2']
							);
						}
						if ([301, 302, 303, 307, 308].indexOf(response.statusCode) >= 0) {
							this._url = this._parseUrl(response.headers.location);
							this._method = 'GET';
							if (this._loweredHeaders['content-type']) {
								delete this._headers[this._loweredHeaders['content-type']];
								delete this._loweredHeaders['content-type'];
							}
							if (this._headers['Content-Type'] != null) {
								delete this._headers['Content-Type'];
							}
							delete this._headers['Content-Length'];
							this.upload._reset();
							this._finalizeHeaders();
							this._sendHxxpRequest();
							return;
						}
						this._response = response;
						this._response.on('data', function (data) {
							return _this._onHttpResponseData(response, data);
						});
						this._response.on('end', function () {
							return _this._onHttpResponseEnd(response);
						});
						this._response.on('close', function () {
							return _this._onHttpResponseClose(response);
						});
						this.responseUrl = this._url.href.split('#')[0];
						this.status = response.statusCode;
						this.statusText = http.STATUS_CODES[this.status];
						this._parseResponseHeaders(response);
						var lengthString = this._responseHeaders['content-length'] || '';
						this._totalBytes = +lengthString;
						this._lengthComputable = !!lengthString;
						this._setReadyState(XMLHttpRequest.HEADERS_RECEIVED);
					};
					XMLHttpRequest.prototype._onHttpResponseData = function (response, data) {
						if (this._response !== response) {
							return;
						}
						this._responseParts.push(new Buffer(data));
						this._loadedBytes += data.length;
						if (this.readyState !== XMLHttpRequest.LOADING) {
							this._setReadyState(XMLHttpRequest.LOADING);
						}
						this._dispatchProgress('progress');
					};
					XMLHttpRequest.prototype._onHttpResponseEnd = function (response) {
						if (this._response !== response) {
							return;
						}
						this._parseResponse();
						this._request = null;
						this._response = null;
						this._setReadyState(XMLHttpRequest.DONE);
						this._dispatchProgress('load');
						this._dispatchProgress('loadend');
					};
					XMLHttpRequest.prototype._onHttpResponseClose = function (response) {
						if (this._response !== response) {
							return;
						}
						var request = this._request;
						this._setError();
						request.abort();
						this._setReadyState(XMLHttpRequest.DONE);
						this._dispatchProgress('error');
						this._dispatchProgress('loadend');
					};
					XMLHttpRequest.prototype._onHttpTimeout = function (request) {
						if (this._request !== request) {
							return;
						}
						this._setError();
						request.abort();
						this._setReadyState(XMLHttpRequest.DONE);
						this._dispatchProgress('timeout');
						this._dispatchProgress('loadend');
					};
					XMLHttpRequest.prototype._onHttpRequestError = function (request, error) {
						if (this._request !== request) {
							return;
						}
						this._setError();
						request.abort();
						this._setReadyState(XMLHttpRequest.DONE);
						this._dispatchProgress('error');
						this._dispatchProgress('loadend');
					};
					XMLHttpRequest.prototype._dispatchProgress = function (eventType) {
						var event = new XMLHttpRequest.ProgressEvent(eventType);
						event.lengthComputable = this._lengthComputable;
						event.loaded = this._loadedBytes;
						event.total = this._totalBytes;
						this.dispatchEvent(event);
					};
					XMLHttpRequest.prototype._setError = function () {
						this._request = null;
						this._response = null;
						this._responseHeaders = null;
						this._responseParts = null;
					};
					XMLHttpRequest.prototype._parseUrl = function (urlString, user, password) {
						var absoluteUrl =
							this.nodejsBaseUrl == null ? urlString : url.resolve(this.nodejsBaseUrl, urlString);
						var xhrUrl = url.parse(absoluteUrl, false, true);
						xhrUrl.hash = null;
						var _a = (xhrUrl.auth || '').split(':'),
							xhrUser = _a[0],
							xhrPassword = _a[1];
						if (xhrUser || xhrPassword || user || password) {
							xhrUrl.auth = (user || xhrUser || '') + ':' + (password || xhrPassword || '');
						}
						return xhrUrl;
					};
					XMLHttpRequest.prototype._parseResponseHeaders = function (response) {
						this._responseHeaders = {};
						for (var name_1 in response.headers) {
							var loweredName = name_1.toLowerCase();
							if (this._privateHeaders[loweredName]) {
								continue;
							}
							this._responseHeaders[loweredName] = response.headers[name_1];
						}
						if (this._mimeOverride != null) {
							this._responseHeaders['content-type'] = this._mimeOverride;
						}
					};
					XMLHttpRequest.prototype._parseResponse = function () {
						var buffer = Buffer.concat(this._responseParts);
						this._responseParts = null;
						switch (this.responseType) {
							case 'json':
								this.responseText = null;
								try {
									this.response = JSON.parse(buffer.toString('utf-8'));
								} catch (_a) {
									this.response = null;
								}
								return;
							case 'buffer':
								this.responseText = null;
								this.response = buffer;
								return;
							case 'arraybuffer':
								this.responseText = null;
								var arrayBuffer = new ArrayBuffer(buffer.length);
								var view = new Uint8Array(arrayBuffer);
								for (var i = 0; i < buffer.length; i++) {
									view[i] = buffer[i];
								}
								this.response = arrayBuffer;
								return;
							case 'text':
							default:
								try {
									this.responseText = buffer.toString(this._parseResponseEncoding());
								} catch (_b) {
									this.responseText = buffer.toString('binary');
								}
								this.response = this.responseText;
						}
					};
					XMLHttpRequest.prototype._parseResponseEncoding = function () {
						return (
							/;\s*charset=(.*)$/.exec(this._responseHeaders['content-type'] || '')[1] || 'utf-8'
						);
					};
					XMLHttpRequest.ProgressEvent = progress_event_1.ProgressEvent;
					XMLHttpRequest.InvalidStateError = errors_1.InvalidStateError;
					XMLHttpRequest.NetworkError = errors_1.NetworkError;
					XMLHttpRequest.SecurityError = errors_1.SecurityError;
					XMLHttpRequest.SyntaxError = errors_1.SyntaxError;
					XMLHttpRequest.XMLHttpRequestUpload = xml_http_request_upload_1.XMLHttpRequestUpload;
					XMLHttpRequest.UNSENT = 0;
					XMLHttpRequest.OPENED = 1;
					XMLHttpRequest.HEADERS_RECEIVED = 2;
					XMLHttpRequest.LOADING = 3;
					XMLHttpRequest.DONE = 4;
					XMLHttpRequest.cookieJar = Cookie.CookieJar();
					return XMLHttpRequest;
				})(xml_http_request_event_target_1.XMLHttpRequestEventTarget);
				exports.XMLHttpRequest = XMLHttpRequest;
				XMLHttpRequest.prototype.nodejsHttpAgent = http.globalAgent;
				XMLHttpRequest.prototype.nodejsHttpsAgent = https.globalAgent;
				XMLHttpRequest.prototype.nodejsBaseUrl = null;
			},
			{
				http: '../node_modules/stream-http/index.js',
				https: '../node_modules/https-browserify/index.js',
				os: '../node_modules/os-browserify/browser.js',
				url: '../node_modules/url/url.js',
				'./progress-event': '../node_modules/xhr2-cookies/dist/progress-event.js',
				'./errors': '../node_modules/xhr2-cookies/dist/errors.js',
				'./xml-http-request-event-target':
					'../node_modules/xhr2-cookies/dist/xml-http-request-event-target.js',
				'./xml-http-request-upload': '../node_modules/xhr2-cookies/dist/xml-http-request-upload.js',
				cookiejar: '../node_modules/cookiejar/cookiejar.js',
				process: '../node_modules/process/browser.js',
				buffer: '../node_modules/node-libs-browser/node_modules/buffer/index.js'
			}
		],
		'../node_modules/xhr2-cookies/dist/index.js': [
			function (require, module, exports) {
				'use strict';
				function __export(m) {
					for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
				}
				Object.defineProperty(exports, '__esModule', { value: true });
				__export(require('./xml-http-request'));
				var xml_http_request_event_target_1 = require('./xml-http-request-event-target');
				exports.XMLHttpRequestEventTarget =
					xml_http_request_event_target_1.XMLHttpRequestEventTarget;
			},
			{
				'./xml-http-request': '../node_modules/xhr2-cookies/dist/xml-http-request.js',
				'./xml-http-request-event-target':
					'../node_modules/xhr2-cookies/dist/xml-http-request-event-target.js'
			}
		],
		'../node_modules/@taquito/http-utils/dist/taquito-http-utils.es5.js': [
			function (require, module, exports) {
				var process = require('process');
				('use strict');

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.VERSION =
					exports.STATUS_CODE =
					exports.HttpResponseError =
					exports.HttpRequestFailed =
					exports.HttpBackend =
						void 0;

				/**
				 * Hypertext Transfer Protocol (HTTP) response status codes.
				 * @see {@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes}
				 */
				var STATUS_CODE;
				exports.STATUS_CODE = STATUS_CODE;

				(function (STATUS_CODE) {
					/**
					 * The server has received the request headers and the client should proceed to send the request body
					 * (in the case of a request for which a body needs to be sent; for example, a POST request).
					 * Sending a large request body to a server after a request has been rejected for inappropriate headers would be inefficient.
					 * To have a server check the request's headers, a client must send Expect: 100-continue as a header in its initial request
					 * and receive a 100 Continue status code in response before sending the body. The response 417 Expectation Failed indicates the request should not be continued.
					 */
					STATUS_CODE[(STATUS_CODE['CONTINUE'] = 100)] = 'CONTINUE';
					/**
					 * The requester has asked the server to switch protocols and the server has agreed to do so.
					 */

					STATUS_CODE[(STATUS_CODE['SWITCHING_PROTOCOLS'] = 101)] = 'SWITCHING_PROTOCOLS';
					/**
					 * A WebDAV request may contain many sub-requests involving file operations, requiring a long time to complete the request.
					 * This code indicates that the server has received and is processing the request, but no response is available yet.
					 * This prevents the client from timing out and assuming the request was lost.
					 */

					STATUS_CODE[(STATUS_CODE['PROCESSING'] = 102)] = 'PROCESSING';
					/**
					 * Standard response for successful HTTP requests.
					 * The actual response will depend on the request method used.
					 * In a GET request, the response will contain an entity corresponding to the requested resource.
					 * In a POST request, the response will contain an entity describing or containing the result of the action.
					 */

					STATUS_CODE[(STATUS_CODE['OK'] = 200)] = 'OK';
					/**
					 * The request has been fulfilled, resulting in the creation of a new resource.
					 */

					STATUS_CODE[(STATUS_CODE['CREATED'] = 201)] = 'CREATED';
					/**
					 * The request has been accepted for processing, but the processing has not been completed.
					 * The request might or might not be eventually acted upon, and may be disallowed when processing occurs.
					 */

					STATUS_CODE[(STATUS_CODE['ACCEPTED'] = 202)] = 'ACCEPTED';
					/**
					 * SINCE HTTP/1.1
					 * The server is a transforming proxy that received a 200 OK from its origin,
					 * but is returning a modified version of the origin's response.
					 */

					STATUS_CODE[(STATUS_CODE['NON_AUTHORITATIVE_INFORMATION'] = 203)] =
						'NON_AUTHORITATIVE_INFORMATION';
					/**
					 * The server successfully processed the request and is not returning any content.
					 */

					STATUS_CODE[(STATUS_CODE['NO_CONTENT'] = 204)] = 'NO_CONTENT';
					/**
					 * The server successfully processed the request, but is not returning any content.
					 * Unlike a 204 response, this response requires that the requester reset the document view.
					 */

					STATUS_CODE[(STATUS_CODE['RESET_CONTENT'] = 205)] = 'RESET_CONTENT';
					/**
					 * The server is delivering only part of the resource (byte serving) due to a range header sent by the client.
					 * The range header is used by HTTP clients to enable resuming of interrupted downloads,
					 * or split a download into multiple simultaneous streams.
					 */

					STATUS_CODE[(STATUS_CODE['PARTIAL_CONTENT'] = 206)] = 'PARTIAL_CONTENT';
					/**
					 * The message body that follows is an XML message and can contain a number of separate response codes,
					 * depending on how many sub-requests were made.
					 */

					STATUS_CODE[(STATUS_CODE['MULTI_STATUS'] = 207)] = 'MULTI_STATUS';
					/**
					 * The members of a DAV binding have already been enumerated in a preceding part of the (multistatus) response,
					 * and are not being included again.
					 */

					STATUS_CODE[(STATUS_CODE['ALREADY_REPORTED'] = 208)] = 'ALREADY_REPORTED';
					/**
					 * The server has fulfilled a request for the resource,
					 * and the response is a representation of the result of one or more instance-manipulations applied to the current instance.
					 */

					STATUS_CODE[(STATUS_CODE['IM_USED'] = 226)] = 'IM_USED';
					/**
					 * Indicates multiple options for the resource from which the client may choose (via agent-driven content negotiation).
					 * For example, this code could be used to present multiple video format options,
					 * to list files with different filename extensions, or to suggest word-sense disambiguation.
					 */

					STATUS_CODE[(STATUS_CODE['MULTIPLE_CHOICES'] = 300)] = 'MULTIPLE_CHOICES';
					/**
					 * This and all future requests should be directed to the given URI.
					 */

					STATUS_CODE[(STATUS_CODE['MOVED_PERMANENTLY'] = 301)] = 'MOVED_PERMANENTLY';
					/**
					 * This is an example of industry practice contradicting the standard.
					 * The HTTP/1.0 specification (RFC 1945) required the client to perform a temporary redirect
					 * (the original describing phrase was "Moved Temporarily"), but popular browsers implemented 302
					 * with the functionality of a 303 See Other. Therefore, HTTP/1.1 added status codes 303 and 307
					 * to distinguish between the two behaviours. However, some Web applications and frameworks
					 * use the 302 status code as if it were the 303.
					 */

					STATUS_CODE[(STATUS_CODE['FOUND'] = 302)] = 'FOUND';
					/**
					 * SINCE HTTP/1.1
					 * The response to the request can be found under another URI using a GET method.
					 * When received in response to a POST (or PUT/DELETE), the client should presume that
					 * the server has received the data and should issue a redirect with a separate GET message.
					 */

					STATUS_CODE[(STATUS_CODE['SEE_OTHER'] = 303)] = 'SEE_OTHER';
					/**
					 * Indicates that the resource has not been modified since the version specified by the request headers If-Modified-Since or If-None-Match.
					 * In such case, there is no need to retransmit the resource since the client still has a previously-downloaded copy.
					 */

					STATUS_CODE[(STATUS_CODE['NOT_MODIFIED'] = 304)] = 'NOT_MODIFIED';
					/**
					 * SINCE HTTP/1.1
					 * The requested resource is available only through a proxy, the address for which is provided in the response.
					 * Many HTTP clients (such as Mozilla and Internet Explorer) do not correctly handle responses with this status code, primarily for security reasons.
					 */

					STATUS_CODE[(STATUS_CODE['USE_PROXY'] = 305)] = 'USE_PROXY';
					/**
					 * No longer used. Originally meant "Subsequent requests should use the specified proxy."
					 */

					STATUS_CODE[(STATUS_CODE['SWITCH_PROXY'] = 306)] = 'SWITCH_PROXY';
					/**
					 * SINCE HTTP/1.1
					 * In this case, the request should be repeated with another URI; however, future requests should still use the original URI.
					 * In contrast to how 302 was historically implemented, the request method is not allowed to be changed when reissuing the original request.
					 * For example, a POST request should be repeated using another POST request.
					 */

					STATUS_CODE[(STATUS_CODE['TEMPORARY_REDIRECT'] = 307)] = 'TEMPORARY_REDIRECT';
					/**
					 * The request and all future requests should be repeated using another URI.
					 * 307 and 308 parallel the behaviors of 302 and 301, but do not allow the HTTP method to change.
					 * So, for example, submitting a form to a permanently redirected resource may continue smoothly.
					 */

					STATUS_CODE[(STATUS_CODE['PERMANENT_REDIRECT'] = 308)] = 'PERMANENT_REDIRECT';
					/**
					 * The server cannot or will not process the request due to an apparent client error
					 * (e.g., malformed request syntax, too large size, invalid request message framing, or deceptive request routing).
					 */

					STATUS_CODE[(STATUS_CODE['BAD_REQUEST'] = 400)] = 'BAD_REQUEST';
					/**
					 * Similar to 403 Forbidden, but specifically for use when authentication is required and has failed or has not yet
					 * been provided. The response must include a WWW-Authenticate header field containing a challenge applicable to the
					 * requested resource. See Basic access authentication and Digest access authentication. 401 semantically means
					 * "unauthenticated",i.e. the user does not have the necessary credentials.
					 */

					STATUS_CODE[(STATUS_CODE['UNAUTHORIZED'] = 401)] = 'UNAUTHORIZED';
					/**
					 * Reserved for future use. The original intention was that this code might be used as part of some form of digital
					 * cash or micro payment scheme, but that has not happened, and this code is not usually used.
					 * Google Developers API uses this status if a particular developer has exceeded the daily limit on requests.
					 */

					STATUS_CODE[(STATUS_CODE['PAYMENT_REQUIRED'] = 402)] = 'PAYMENT_REQUIRED';
					/**
					 * The request was valid, but the server is refusing action.
					 * The user might not have the necessary permissions for a resource.
					 */

					STATUS_CODE[(STATUS_CODE['FORBIDDEN'] = 403)] = 'FORBIDDEN';
					/**
					 * The requested resource could not be found but may be available in the future.
					 * Subsequent requests by the client are permissible.
					 */

					STATUS_CODE[(STATUS_CODE['NOT_FOUND'] = 404)] = 'NOT_FOUND';
					/**
					 * A request method is not supported for the requested resource;
					 * for example, a GET request on a form that requires data to be presented via POST, or a PUT request on a read-only resource.
					 */

					STATUS_CODE[(STATUS_CODE['METHOD_NOT_ALLOWED'] = 405)] = 'METHOD_NOT_ALLOWED';
					/**
					 * The requested resource is capable of generating only content not acceptable according to the Accept headers sent in the request.
					 */

					STATUS_CODE[(STATUS_CODE['NOT_ACCEPTABLE'] = 406)] = 'NOT_ACCEPTABLE';
					/**
					 * The client must first authenticate itself with the proxy.
					 */

					STATUS_CODE[(STATUS_CODE['PROXY_AUTHENTICATION_REQUIRED'] = 407)] =
						'PROXY_AUTHENTICATION_REQUIRED';
					/**
					 * The server timed out waiting for the request.
					 * According to HTTP specifications:
					 * "The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time."
					 */

					STATUS_CODE[(STATUS_CODE['REQUEST_TIMEOUT'] = 408)] = 'REQUEST_TIMEOUT';
					/**
					 * Indicates that the request could not be processed because of conflict in the request,
					 * such as an edit conflict between multiple simultaneous updates.
					 */

					STATUS_CODE[(STATUS_CODE['CONFLICT'] = 409)] = 'CONFLICT';
					/**
					 * Indicates that the resource requested is no longer available and will not be available again.
					 * This should be used when a resource has been intentionally removed and the resource should be purged.
					 * Upon receiving a 410 status code, the client should not request the resource in the future.
					 * Clients such as search engines should remove the resource from their indices.
					 * Most use cases do not require clients and search engines to purge the resource, and a "404 Not Found" may be used instead.
					 */

					STATUS_CODE[(STATUS_CODE['GONE'] = 410)] = 'GONE';
					/**
					 * The request did not specify the length of its content, which is required by the requested resource.
					 */

					STATUS_CODE[(STATUS_CODE['LENGTH_REQUIRED'] = 411)] = 'LENGTH_REQUIRED';
					/**
					 * The server does not meet one of the preconditions that the requester put on the request.
					 */

					STATUS_CODE[(STATUS_CODE['PRECONDITION_FAILED'] = 412)] = 'PRECONDITION_FAILED';
					/**
					 * The request is larger than the server is willing or able to process. Previously called "Request Entity Too Large".
					 */

					STATUS_CODE[(STATUS_CODE['PAYLOAD_TOO_LARGE'] = 413)] = 'PAYLOAD_TOO_LARGE';
					/**
					 * The URI provided was too long for the server to process. Often the result of too much data being encoded as a query-string of a GET request,
					 * in which case it should be converted to a POST request.
					 * Called "Request-URI Too Long" previously.
					 */

					STATUS_CODE[(STATUS_CODE['URI_TOO_LONG'] = 414)] = 'URI_TOO_LONG';
					/**
					 * The request entity has a media type which the server or resource does not support.
					 * For example, the client uploads an image as image/svg+xml, but the server requires that images use a different format.
					 */

					STATUS_CODE[(STATUS_CODE['UNSUPPORTED_MEDIA_TYPE'] = 415)] = 'UNSUPPORTED_MEDIA_TYPE';
					/**
					 * The client has asked for a portion of the file (byte serving), but the server cannot supply that portion.
					 * For example, if the client asked for a part of the file that lies beyond the end of the file.
					 * Called "Requested Range Not Satisfiable" previously.
					 */

					STATUS_CODE[(STATUS_CODE['RANGE_NOT_SATISFIABLE'] = 416)] = 'RANGE_NOT_SATISFIABLE';
					/**
					 * The server cannot meet the requirements of the Expect request-header field.
					 */

					STATUS_CODE[(STATUS_CODE['EXPECTATION_FAILED'] = 417)] = 'EXPECTATION_FAILED';
					/**
					 * This code was defined in 1998 as one of the traditional IETF April Fools' jokes, in RFC 2324, Hyper Text Coffee Pot Control Protocol,
					 * and is not expected to be implemented by actual HTTP servers. The RFC specifies this code should be returned by
					 * teapots requested to brew coffee. This HTTP status is used as an Easter egg in some websites, including Google.com.
					 */

					STATUS_CODE[(STATUS_CODE['I_AM_A_TEAPOT'] = 418)] = 'I_AM_A_TEAPOT';
					/**
					 * The request was directed at a server that is not able to produce a response (for example because a connection reuse).
					 */

					STATUS_CODE[(STATUS_CODE['MISDIRECTED_REQUEST'] = 421)] = 'MISDIRECTED_REQUEST';
					/**
					 * The request was well-formed but was unable to be followed due to semantic errors.
					 */

					STATUS_CODE[(STATUS_CODE['UNPROCESSABLE_ENTITY'] = 422)] = 'UNPROCESSABLE_ENTITY';
					/**
					 * The resource that is being accessed is locked.
					 */

					STATUS_CODE[(STATUS_CODE['LOCKED'] = 423)] = 'LOCKED';
					/**
					 * The request failed due to failure of a previous request (e.g., a PROPPATCH).
					 */

					STATUS_CODE[(STATUS_CODE['FAILED_DEPENDENCY'] = 424)] = 'FAILED_DEPENDENCY';
					/**
					 * The client should switch to a different protocol such as TLS/1.0, given in the Upgrade header field.
					 */

					STATUS_CODE[(STATUS_CODE['UPGRADE_REQUIRED'] = 426)] = 'UPGRADE_REQUIRED';
					/**
					 * The origin server requires the request to be conditional.
					 * Intended to prevent "the 'lost update' problem, where a client
					 * GETs a resource's state, modifies it, and PUTs it back to the server,
					 * when meanwhile a third party has modified the state on the server, leading to a conflict."
					 */

					STATUS_CODE[(STATUS_CODE['PRECONDITION_REQUIRED'] = 428)] = 'PRECONDITION_REQUIRED';
					/**
					 * The user has sent too many requests in a given amount of time. Intended for use with rate-limiting schemes.
					 */

					STATUS_CODE[(STATUS_CODE['TOO_MANY_REQUESTS'] = 429)] = 'TOO_MANY_REQUESTS';
					/**
					 * The server is unwilling to process the request because either an individual header field,
					 * or all the header fields collectively, are too large.
					 */

					STATUS_CODE[(STATUS_CODE['REQUEST_HEADER_FIELDS_TOO_LARGE'] = 431)] =
						'REQUEST_HEADER_FIELDS_TOO_LARGE';
					/**
					 * A server operator has received a legal demand to deny access to a resource or to a set of resources
					 * that includes the requested resource. The code 451 was chosen as a reference to the novel Fahrenheit 451.
					 */

					STATUS_CODE[(STATUS_CODE['UNAVAILABLE_FOR_LEGAL_REASONS'] = 451)] =
						'UNAVAILABLE_FOR_LEGAL_REASONS';
					/**
					 * A generic error message, given when an unexpected condition was encountered and no more specific message is suitable.
					 */

					STATUS_CODE[(STATUS_CODE['INTERNAL_SERVER_ERROR'] = 500)] = 'INTERNAL_SERVER_ERROR';
					/**
					 * The server either does not recognize the request method, or it lacks the ability to fulfill the request.
					 * Usually this implies future availability (e.g., a new feature of a web-service API).
					 */

					STATUS_CODE[(STATUS_CODE['NOT_IMPLEMENTED'] = 501)] = 'NOT_IMPLEMENTED';
					/**
					 * The server was acting as a gateway or proxy and received an invalid response from the upstream server.
					 */

					STATUS_CODE[(STATUS_CODE['BAD_GATEWAY'] = 502)] = 'BAD_GATEWAY';
					/**
					 * The server is currently unavailable (because it is overloaded or down for maintenance).
					 * Generally, this is a temporary state.
					 */

					STATUS_CODE[(STATUS_CODE['SERVICE_UNAVAILABLE'] = 503)] = 'SERVICE_UNAVAILABLE';
					/**
					 * The server was acting as a gateway or proxy and did not receive a timely response from the upstream server.
					 */

					STATUS_CODE[(STATUS_CODE['GATEWAY_TIMEOUT'] = 504)] = 'GATEWAY_TIMEOUT';
					/**
					 * The server does not support the HTTP protocol version used in the request
					 */

					STATUS_CODE[(STATUS_CODE['HTTP_VERSION_NOT_SUPPORTED'] = 505)] =
						'HTTP_VERSION_NOT_SUPPORTED';
					/**
					 * Transparent content negotiation for the request results in a circular reference.
					 */

					STATUS_CODE[(STATUS_CODE['VARIANT_ALSO_NEGOTIATES'] = 506)] = 'VARIANT_ALSO_NEGOTIATES';
					/**
					 * The server is unable to store the representation needed to complete the request.
					 */

					STATUS_CODE[(STATUS_CODE['INSUFFICIENT_STORAGE'] = 507)] = 'INSUFFICIENT_STORAGE';
					/**
					 * The server detected an infinite loop while processing the request.
					 */

					STATUS_CODE[(STATUS_CODE['LOOP_DETECTED'] = 508)] = 'LOOP_DETECTED';
					/**
					 * Further extensions to the request are required for the server to fulfill it.
					 */

					STATUS_CODE[(STATUS_CODE['NOT_EXTENDED'] = 510)] = 'NOT_EXTENDED';
					/**
					 * The client needs to authenticate to gain network access.
					 * Intended for use by intercepting proxies used to control access to the network (e.g., "captive portals" used
					 * to require agreement to Terms of Service before granting full Internet access via a Wi-Fi hotspot).
					 */

					STATUS_CODE[(STATUS_CODE['NETWORK_AUTHENTICATION_REQUIRED'] = 511)] =
						'NETWORK_AUTHENTICATION_REQUIRED';
				})(STATUS_CODE || (exports.STATUS_CODE = STATUS_CODE = {})); // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!

				/* tslint:disable */

				var VERSION = {
					commitHash: '68be71fd14ffd87bd0a0f91dab60d69c8665e88c',
					version: '10.2.0'
				};
				/* tslint:enable */

				/**
				 * @packageDocumentation
				 * @module @taquito/http-utils
				 */
				// tslint:disable: strict-type-predicates

				exports.VERSION = VERSION;
				var isNode =
					typeof process !== 'undefined' &&
					process.versions != null &&
					process.versions.node != null; // tslint:enable: strict-type-predicates

				var XMLHttpRequestCTOR = isNode ? require('xhr2-cookies').XMLHttpRequest : XMLHttpRequest;
				var defaultTimeout = 30000;

				var HttpResponseError =
					/** @class */
					(function () {
						function HttpResponseError(message, status, statusText, body, url) {
							this.message = message;
							this.status = status;
							this.statusText = statusText;
							this.body = body;
							this.url = url;
							this.name = 'HttpResponse';
						}

						return HttpResponseError;
					})();

				exports.HttpResponseError = HttpResponseError;

				var HttpRequestFailed =
					/** @class */
					(function () {
						function HttpRequestFailed(url, innerEvent) {
							this.url = url;
							this.innerEvent = innerEvent;
							this.name = 'HttpRequestFailed';
							this.message = 'Request to ' + url + ' failed';
						}

						return HttpRequestFailed;
					})();

				exports.HttpRequestFailed = HttpRequestFailed;

				var HttpBackend =
					/** @class */
					(function () {
						function HttpBackend() {}

						HttpBackend.prototype.serialize = function (obj) {
							if (!obj) {
								return '';
							}

							var str = [];

							var _loop_1 = function (p) {
								if (obj.hasOwnProperty(p) && typeof obj[p] !== 'undefined') {
									var prop = typeof obj[p].toJSON === 'function' ? obj[p].toJSON() : obj[p]; // query arguments can have no value so we need some way of handling that
									// example https://domain.com/query?all

									if (prop === null) {
										str.push(encodeURIComponent(p));
										return 'continue';
									} // another use case is multiple arguments with the same name
									// they are passed as array

									if (Array.isArray(prop)) {
										prop.forEach(function (item) {
											str.push(encodeURIComponent(p) + '=' + encodeURIComponent(item));
										});
										return 'continue';
									}

									str.push(encodeURIComponent(p) + '=' + encodeURIComponent(prop));
								}
							};

							for (var p in obj) {
								_loop_1(p);
							}

							var serialized = str.join('&');

							if (serialized) {
								return '?' + serialized;
							} else {
								return '';
							}
						};

						HttpBackend.prototype.createXHR = function () {
							return new XMLHttpRequestCTOR();
						};
						/**
						 *
						 * @param options contains options to be passed for the HTTP request (url, method and timeout)
						 */

						HttpBackend.prototype.createRequest = function (_a, data) {
							var _this = this;

							var url = _a.url,
								method = _a.method,
								timeout = _a.timeout,
								query = _a.query,
								_b = _a.headers,
								headers = _b === void 0 ? {} : _b,
								_c = _a.json,
								json = _c === void 0 ? true : _c,
								_d = _a.mimeType,
								mimeType = _d === void 0 ? undefined : _d;
							return new Promise(function (resolve, reject) {
								var request = _this.createXHR();

								request.open(method || 'GET', '' + url + _this.serialize(query));

								if (!headers['Content-Type']) {
									request.setRequestHeader('Content-Type', 'application/json');
								}

								if (mimeType) {
									request.overrideMimeType('' + mimeType);
								}

								for (var k in headers) {
									request.setRequestHeader(k, headers[k]);
								}

								request.timeout = timeout || defaultTimeout;

								request.onload = function () {
									if (this.status >= 200 && this.status < 300) {
										if (json) {
											try {
												resolve(JSON.parse(request.response));
											} catch (ex) {
												reject(new Error('Unable to parse response: ' + request.response));
											}
										} else {
											resolve(request.response);
										}
									} else {
										reject(
											new HttpResponseError(
												'Http error response: (' + this.status + ') ' + request.response,
												this.status,
												request.statusText,
												request.response,
												url
											)
										);
									}
								};

								request.ontimeout = function () {
									reject(new Error('Request timed out after: ' + request.timeout + 'ms'));
								};

								request.onerror = function (err) {
									reject(new HttpRequestFailed(url, err));
								};

								if (data) {
									var dataStr = JSON.stringify(data);
									request.send(dataStr);
								} else {
									request.send();
								}
							});
						};

						return HttpBackend;
					})();

				exports.HttpBackend = HttpBackend;
			},
			{
				'xhr2-cookies': '../node_modules/xhr2-cookies/dist/index.js',
				process: '../node_modules/process/browser.js'
			}
		],
		'../node_modules/bignumber.js/bignumber.js': [
			function (require, module, exports) {
				var define;
				(function (globalObject) {
					'use strict';

					/*
					 *      bignumber.js v9.0.1
					 *      A JavaScript library for arbitrary-precision arithmetic.
					 *      https://github.com/MikeMcl/bignumber.js
					 *      Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>
					 *      MIT Licensed.
					 *
					 *      BigNumber.prototype methods     |  BigNumber methods
					 *                                      |
					 *      absoluteValue            abs    |  clone
					 *      comparedTo                      |  config               set
					 *      decimalPlaces            dp     |      DECIMAL_PLACES
					 *      dividedBy                div    |      ROUNDING_MODE
					 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
					 *      exponentiatedBy          pow    |      RANGE
					 *      integerValue                    |      CRYPTO
					 *      isEqualTo                eq     |      MODULO_MODE
					 *      isFinite                        |      POW_PRECISION
					 *      isGreaterThan            gt     |      FORMAT
					 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
					 *      isInteger                       |  isBigNumber
					 *      isLessThan               lt     |  maximum              max
					 *      isLessThanOrEqualTo      lte    |  minimum              min
					 *      isNaN                           |  random
					 *      isNegative                      |  sum
					 *      isPositive                      |
					 *      isZero                          |
					 *      minus                           |
					 *      modulo                   mod    |
					 *      multipliedBy             times  |
					 *      negated                         |
					 *      plus                            |
					 *      precision                sd     |
					 *      shiftedBy                       |
					 *      squareRoot               sqrt   |
					 *      toExponential                   |
					 *      toFixed                         |
					 *      toFormat                        |
					 *      toFraction                      |
					 *      toJSON                          |
					 *      toNumber                        |
					 *      toPrecision                     |
					 *      toString                        |
					 *      valueOf                         |
					 *
					 */

					var BigNumber,
						isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
						mathceil = Math.ceil,
						mathfloor = Math.floor,
						bignumberError = '[BigNumber Error] ',
						tooManyDigits =
							bignumberError + 'Number primitive has more than 15 significant digits: ',
						BASE = 1e14,
						LOG_BASE = 14,
						MAX_SAFE_INTEGER = 0x1fffffffffffff, // 2^53 - 1
						// MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
						POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
						SQRT_BASE = 1e7,
						// EDITABLE
						// The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
						// the arguments to toExponential, toFixed, toFormat, and toPrecision.
						MAX = 1e9; // 0 to MAX_INT32

					/*
					 * Create and return a BigNumber constructor.
					 */
					function clone(configObject) {
						var div,
							convertBase,
							parseNumeric,
							P = (BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null }),
							ONE = new BigNumber(1),
							//----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------

							// The default values below must be integers within the inclusive ranges stated.
							// The values can also be changed at run-time using BigNumber.set.

							// The maximum number of decimal places for operations involving division.
							DECIMAL_PLACES = 20, // 0 to MAX
							// The rounding mode used when rounding to the above decimal places, and when using
							// toExponential, toFixed, toFormat and toPrecision, and round (default value).
							// UP         0 Away from zero.
							// DOWN       1 Towards zero.
							// CEIL       2 Towards +Infinity.
							// FLOOR      3 Towards -Infinity.
							// HALF_UP    4 Towards nearest neighbour. If equidistant, up.
							// HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
							// HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
							// HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
							// HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
							ROUNDING_MODE = 4, // 0 to 8
							// EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

							// The exponent value at and beneath which toString returns exponential notation.
							// Number type: -7
							TO_EXP_NEG = -7, // 0 to -MAX
							// The exponent value at and above which toString returns exponential notation.
							// Number type: 21
							TO_EXP_POS = 21, // 0 to MAX
							// RANGE : [MIN_EXP, MAX_EXP]

							// The minimum exponent value, beneath which underflow to zero occurs.
							// Number type: -324  (5e-324)
							MIN_EXP = -1e7, // -1 to -MAX
							// The maximum exponent value, above which overflow to Infinity occurs.
							// Number type:  308  (1.7976931348623157e+308)
							// For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
							MAX_EXP = 1e7, // 1 to MAX
							// Whether to use cryptographically-secure random number generation, if available.
							CRYPTO = false, // true or false
							// The modulo mode used when calculating the modulus: a mod n.
							// The quotient (q = a / n) is calculated according to the corresponding rounding mode.
							// The remainder (r) is calculated as: r = a - n * q.
							//
							// UP        0 The remainder is positive if the dividend is negative, else is negative.
							// DOWN      1 The remainder has the same sign as the dividend.
							//             This modulo mode is commonly known as 'truncated division' and is
							//             equivalent to (a % n) in JavaScript.
							// FLOOR     3 The remainder has the same sign as the divisor (Python %).
							// HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
							// EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
							//             The remainder is always positive.
							//
							// The truncated division, floored division, Euclidian division and IEEE 754 remainder
							// modes are commonly used for the modulus operation.
							// Although the other rounding modes can also be used, they may not give useful results.
							MODULO_MODE = 1, // 0 to 9
							// The maximum number of significant digits of the result of the exponentiatedBy operation.
							// If POW_PRECISION is 0, there will be unlimited significant digits.
							POW_PRECISION = 0, // 0 to MAX
							// The format specification used by the BigNumber.prototype.toFormat method.
							FORMAT = {
								prefix: '',
								groupSize: 3,
								secondaryGroupSize: 0,
								groupSeparator: ',',
								decimalSeparator: '.',
								fractionGroupSize: 0,
								fractionGroupSeparator: '\xA0', // non-breaking space
								suffix: ''
							},
							// The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
							// '-', '.', whitespace, or repeated character.
							// '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
							ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';

						//------------------------------------------------------------------------------------------

						// CONSTRUCTOR

						/*
						 * The BigNumber constructor and exported function.
						 * Create and return a new instance of a BigNumber object.
						 *
						 * v {number|string|BigNumber} A numeric value.
						 * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
						 */
						function BigNumber(v, b) {
							var alphabet,
								c,
								caseChanged,
								e,
								i,
								isNum,
								len,
								str,
								x = this;

							// Enable constructor call without `new`.
							if (!(x instanceof BigNumber)) return new BigNumber(v, b);

							if (b == null) {
								if (v && v._isBigNumber === true) {
									x.s = v.s;

									if (!v.c || v.e > MAX_EXP) {
										x.c = x.e = null;
									} else if (v.e < MIN_EXP) {
										x.c = [(x.e = 0)];
									} else {
										x.e = v.e;
										x.c = v.c.slice();
									}

									return;
								}

								if ((isNum = typeof v == 'number') && v * 0 == 0) {
									// Use `1 / n` to handle minus zero also.
									x.s = 1 / v < 0 ? ((v = -v), -1) : 1;

									// Fast path for integers, where n < 2147483648 (2**31).
									if (v === ~~v) {
										for (e = 0, i = v; i >= 10; i /= 10, e++);

										if (e > MAX_EXP) {
											x.c = x.e = null;
										} else {
											x.e = e;
											x.c = [v];
										}

										return;
									}

									str = String(v);
								} else {
									if (!isNumeric.test((str = String(v)))) return parseNumeric(x, str, isNum);

									x.s = str.charCodeAt(0) == 45 ? ((str = str.slice(1)), -1) : 1;
								}

								// Decimal point?
								if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

								// Exponential form?
								if ((i = str.search(/e/i)) > 0) {
									// Determine exponent.
									if (e < 0) e = i;
									e += +str.slice(i + 1);
									str = str.substring(0, i);
								} else if (e < 0) {
									// Integer.
									e = str.length;
								}
							} else {
								// '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
								intCheck(b, 2, ALPHABET.length, 'Base');

								// Allow exponential notation to be used with base 10 argument, while
								// also rounding to DECIMAL_PLACES as with other bases.
								if (b == 10) {
									x = new BigNumber(v);
									return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
								}

								str = String(v);

								if ((isNum = typeof v == 'number')) {
									// Avoid potential interpretation of Infinity and NaN as base 44+ values.
									if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

									x.s = 1 / v < 0 ? ((str = str.slice(1)), -1) : 1;

									// '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
									if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
										throw Error(tooManyDigits + v);
									}
								} else {
									x.s = str.charCodeAt(0) === 45 ? ((str = str.slice(1)), -1) : 1;
								}

								alphabet = ALPHABET.slice(0, b);
								e = i = 0;

								// Check that str is a valid base b number.
								// Don't use RegExp, so alphabet can contain special characters.
								for (len = str.length; i < len; i++) {
									if (alphabet.indexOf((c = str.charAt(i))) < 0) {
										if (c == '.') {
											// If '.' is not the first character and it has not be found before.
											if (i > e) {
												e = len;
												continue;
											}
										} else if (!caseChanged) {
											// Allow e.g. hexadecimal 'FF' as well as 'ff'.
											if (
												(str == str.toUpperCase() && (str = str.toLowerCase())) ||
												(str == str.toLowerCase() && (str = str.toUpperCase()))
											) {
												caseChanged = true;
												i = -1;
												e = 0;
												continue;
											}
										}

										return parseNumeric(x, String(v), isNum, b);
									}
								}

								// Prevent later check for length on converted number.
								isNum = false;
								str = convertBase(str, b, 10, x.s);

								// Decimal point?
								if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
								else e = str.length;
							}

							// Determine leading zeros.
							for (i = 0; str.charCodeAt(i) === 48; i++);

							// Determine trailing zeros.
							for (len = str.length; str.charCodeAt(--len) === 48; );

							if ((str = str.slice(i, ++len))) {
								len -= i;

								// '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
								if (
									isNum &&
									BigNumber.DEBUG &&
									len > 15 &&
									(v > MAX_SAFE_INTEGER || v !== mathfloor(v))
								) {
									throw Error(tooManyDigits + x.s * v);
								}

								// Overflow?
								if ((e = e - i - 1) > MAX_EXP) {
									// Infinity.
									x.c = x.e = null;

									// Underflow?
								} else if (e < MIN_EXP) {
									// Zero.
									x.c = [(x.e = 0)];
								} else {
									x.e = e;
									x.c = [];

									// Transform base

									// e is the base 10 exponent.
									// i is where to slice str to get the first element of the coefficient array.
									i = (e + 1) % LOG_BASE;
									if (e < 0) i += LOG_BASE; // i < 1

									if (i < len) {
										if (i) x.c.push(+str.slice(0, i));

										for (len -= LOG_BASE; i < len; ) {
											x.c.push(+str.slice(i, (i += LOG_BASE)));
										}

										i = LOG_BASE - (str = str.slice(i)).length;
									} else {
										i -= len;
									}

									for (; i--; str += '0');
									x.c.push(+str);
								}
							} else {
								// Zero.
								x.c = [(x.e = 0)];
							}
						}

						// CONSTRUCTOR PROPERTIES

						BigNumber.clone = clone;

						BigNumber.ROUND_UP = 0;
						BigNumber.ROUND_DOWN = 1;
						BigNumber.ROUND_CEIL = 2;
						BigNumber.ROUND_FLOOR = 3;
						BigNumber.ROUND_HALF_UP = 4;
						BigNumber.ROUND_HALF_DOWN = 5;
						BigNumber.ROUND_HALF_EVEN = 6;
						BigNumber.ROUND_HALF_CEIL = 7;
						BigNumber.ROUND_HALF_FLOOR = 8;
						BigNumber.EUCLID = 9;

						/*
						 * Configure infrequently-changing library-wide settings.
						 *
						 * Accept an object with the following optional properties (if the value of a property is
						 * a number, it must be an integer within the inclusive range stated):
						 *
						 *   DECIMAL_PLACES   {number}           0 to MAX
						 *   ROUNDING_MODE    {number}           0 to 8
						 *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
						 *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
						 *   CRYPTO           {boolean}          true or false
						 *   MODULO_MODE      {number}           0 to 9
						 *   POW_PRECISION       {number}           0 to MAX
						 *   ALPHABET         {string}           A string of two or more unique characters which does
						 *                                       not contain '.'.
						 *   FORMAT           {object}           An object with some of the following properties:
						 *     prefix                 {string}
						 *     groupSize              {number}
						 *     secondaryGroupSize     {number}
						 *     groupSeparator         {string}
						 *     decimalSeparator       {string}
						 *     fractionGroupSize      {number}
						 *     fractionGroupSeparator {string}
						 *     suffix                 {string}
						 *
						 * (The values assigned to the above FORMAT object properties are not checked for validity.)
						 *
						 * E.g.
						 * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
						 *
						 * Ignore properties/parameters set to null or undefined, except for ALPHABET.
						 *
						 * Return an object with the properties current values.
						 */
						BigNumber.config = BigNumber.set = function (obj) {
							var p, v;

							if (obj != null) {
								if (typeof obj == 'object') {
									// DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
									// '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
									if (obj.hasOwnProperty((p = 'DECIMAL_PLACES'))) {
										v = obj[p];
										intCheck(v, 0, MAX, p);
										DECIMAL_PLACES = v;
									}

									// ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
									// '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
									if (obj.hasOwnProperty((p = 'ROUNDING_MODE'))) {
										v = obj[p];
										intCheck(v, 0, 8, p);
										ROUNDING_MODE = v;
									}

									// EXPONENTIAL_AT {number|number[]}
									// Integer, -MAX to MAX inclusive or
									// [integer -MAX to 0 inclusive, 0 to MAX inclusive].
									// '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
									if (obj.hasOwnProperty((p = 'EXPONENTIAL_AT'))) {
										v = obj[p];
										if (v && v.pop) {
											intCheck(v[0], -MAX, 0, p);
											intCheck(v[1], 0, MAX, p);
											TO_EXP_NEG = v[0];
											TO_EXP_POS = v[1];
										} else {
											intCheck(v, -MAX, MAX, p);
											TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
										}
									}

									// RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
									// [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
									// '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
									if (obj.hasOwnProperty((p = 'RANGE'))) {
										v = obj[p];
										if (v && v.pop) {
											intCheck(v[0], -MAX, -1, p);
											intCheck(v[1], 1, MAX, p);
											MIN_EXP = v[0];
											MAX_EXP = v[1];
										} else {
											intCheck(v, -MAX, MAX, p);
											if (v) {
												MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
											} else {
												throw Error(bignumberError + p + ' cannot be zero: ' + v);
											}
										}
									}

									// CRYPTO {boolean} true or false.
									// '[BigNumber Error] CRYPTO not true or false: {v}'
									// '[BigNumber Error] crypto unavailable'
									if (obj.hasOwnProperty((p = 'CRYPTO'))) {
										v = obj[p];
										if (v === !!v) {
											if (v) {
												if (
													typeof crypto != 'undefined' &&
													crypto &&
													(crypto.getRandomValues || crypto.randomBytes)
												) {
													CRYPTO = v;
												} else {
													CRYPTO = !v;
													throw Error(bignumberError + 'crypto unavailable');
												}
											} else {
												CRYPTO = v;
											}
										} else {
											throw Error(bignumberError + p + ' not true or false: ' + v);
										}
									}

									// MODULO_MODE {number} Integer, 0 to 9 inclusive.
									// '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
									if (obj.hasOwnProperty((p = 'MODULO_MODE'))) {
										v = obj[p];
										intCheck(v, 0, 9, p);
										MODULO_MODE = v;
									}

									// POW_PRECISION {number} Integer, 0 to MAX inclusive.
									// '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
									if (obj.hasOwnProperty((p = 'POW_PRECISION'))) {
										v = obj[p];
										intCheck(v, 0, MAX, p);
										POW_PRECISION = v;
									}

									// FORMAT {object}
									// '[BigNumber Error] FORMAT not an object: {v}'
									if (obj.hasOwnProperty((p = 'FORMAT'))) {
										v = obj[p];
										if (typeof v == 'object') FORMAT = v;
										else throw Error(bignumberError + p + ' not an object: ' + v);
									}

									// ALPHABET {string}
									// '[BigNumber Error] ALPHABET invalid: {v}'
									if (obj.hasOwnProperty((p = 'ALPHABET'))) {
										v = obj[p];

										// Disallow if less than two characters,
										// or if it contains '+', '-', '.', whitespace, or a repeated character.
										if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
											ALPHABET = v;
										} else {
											throw Error(bignumberError + p + ' invalid: ' + v);
										}
									}
								} else {
									// '[BigNumber Error] Object expected: {v}'
									throw Error(bignumberError + 'Object expected: ' + obj);
								}
							}

							return {
								DECIMAL_PLACES: DECIMAL_PLACES,
								ROUNDING_MODE: ROUNDING_MODE,
								EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
								RANGE: [MIN_EXP, MAX_EXP],
								CRYPTO: CRYPTO,
								MODULO_MODE: MODULO_MODE,
								POW_PRECISION: POW_PRECISION,
								FORMAT: FORMAT,
								ALPHABET: ALPHABET
							};
						};

						/*
						 * Return true if v is a BigNumber instance, otherwise return false.
						 *
						 * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
						 *
						 * v {any}
						 *
						 * '[BigNumber Error] Invalid BigNumber: {v}'
						 */
						BigNumber.isBigNumber = function (v) {
							if (!v || v._isBigNumber !== true) return false;
							if (!BigNumber.DEBUG) return true;

							var i,
								n,
								c = v.c,
								e = v.e,
								s = v.s;

							out: if ({}.toString.call(c) == '[object Array]') {
								if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
									// If the first element is zero, the BigNumber value must be zero.
									if (c[0] === 0) {
										if (e === 0 && c.length === 1) return true;
										break out;
									}

									// Calculate number of digits that c[0] should have, based on the exponent.
									i = (e + 1) % LOG_BASE;
									if (i < 1) i += LOG_BASE;

									// Calculate number of digits of c[0].
									//if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
									if (String(c[0]).length == i) {
										for (i = 0; i < c.length; i++) {
											n = c[i];
											if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
										}

										// Last element cannot be zero, unless it is the only element.
										if (n !== 0) return true;
									}
								}

								// Infinity/NaN
							} else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
								return true;
							}

							throw Error(bignumberError + 'Invalid BigNumber: ' + v);
						};

						/*
						 * Return a new BigNumber whose value is the maximum of the arguments.
						 *
						 * arguments {number|string|BigNumber}
						 */
						BigNumber.maximum = BigNumber.max = function () {
							return maxOrMin(arguments, P.lt);
						};

						/*
						 * Return a new BigNumber whose value is the minimum of the arguments.
						 *
						 * arguments {number|string|BigNumber}
						 */
						BigNumber.minimum = BigNumber.min = function () {
							return maxOrMin(arguments, P.gt);
						};

						/*
						 * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
						 * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
						 * zeros are produced).
						 *
						 * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
						 *
						 * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
						 * '[BigNumber Error] crypto unavailable'
						 */
						BigNumber.random = (function () {
							var pow2_53 = 0x20000000000000;

							// Return a 53 bit integer n, where 0 <= n < 9007199254740992.
							// Check if Math.random() produces more than 32 bits of randomness.
							// If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
							// 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
							var random53bitInt =
								(Math.random() * pow2_53) & 0x1fffff
									? function () {
											return mathfloor(Math.random() * pow2_53);
									  }
									: function () {
											return (
												((Math.random() * 0x40000000) | 0) * 0x800000 +
												((Math.random() * 0x800000) | 0)
											);
									  };

							return function (dp) {
								var a,
									b,
									e,
									k,
									v,
									i = 0,
									c = [],
									rand = new BigNumber(ONE);

								if (dp == null) dp = DECIMAL_PLACES;
								else intCheck(dp, 0, MAX);

								k = mathceil(dp / LOG_BASE);

								if (CRYPTO) {
									// Browsers supporting crypto.getRandomValues.
									if (crypto.getRandomValues) {
										a = crypto.getRandomValues(new Uint32Array((k *= 2)));

										for (; i < k; ) {
											// 53 bits:
											// ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
											// 11111 11111111 11111111 11111111 11100000 00000000 00000000
											// ((Math.pow(2, 32) - 1) >>> 11).toString(2)
											//                                     11111 11111111 11111111
											// 0x20000 is 2^21.
											v = a[i] * 0x20000 + (a[i + 1] >>> 11);

											// Rejection sampling:
											// 0 <= v < 9007199254740992
											// Probability that v >= 9e15, is
											// 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
											if (v >= 9e15) {
												b = crypto.getRandomValues(new Uint32Array(2));
												a[i] = b[0];
												a[i + 1] = b[1];
											} else {
												// 0 <= v <= 8999999999999999
												// 0 <= (v % 1e14) <= 99999999999999
												c.push(v % 1e14);
												i += 2;
											}
										}
										i = k / 2;

										// Node.js supporting crypto.randomBytes.
									} else if (crypto.randomBytes) {
										// buffer
										a = crypto.randomBytes((k *= 7));

										for (; i < k; ) {
											// 0x1000000000000 is 2^48, 0x10000000000 is 2^40
											// 0x100000000 is 2^32, 0x1000000 is 2^24
											// 11111 11111111 11111111 11111111 11111111 11111111 11111111
											// 0 <= v < 9007199254740992
											v =
												(a[i] & 31) * 0x1000000000000 +
												a[i + 1] * 0x10000000000 +
												a[i + 2] * 0x100000000 +
												a[i + 3] * 0x1000000 +
												(a[i + 4] << 16) +
												(a[i + 5] << 8) +
												a[i + 6];

											if (v >= 9e15) {
												crypto.randomBytes(7).copy(a, i);
											} else {
												// 0 <= (v % 1e14) <= 99999999999999
												c.push(v % 1e14);
												i += 7;
											}
										}
										i = k / 7;
									} else {
										CRYPTO = false;
										throw Error(bignumberError + 'crypto unavailable');
									}
								}

								// Use Math.random.
								if (!CRYPTO) {
									for (; i < k; ) {
										v = random53bitInt();
										if (v < 9e15) c[i++] = v % 1e14;
									}
								}

								k = c[--i];
								dp %= LOG_BASE;

								// Convert trailing digits to zeros according to dp.
								if (k && dp) {
									v = POWS_TEN[LOG_BASE - dp];
									c[i] = mathfloor(k / v) * v;
								}

								// Remove trailing elements which are zero.
								for (; c[i] === 0; c.pop(), i--);

								// Zero?
								if (i < 0) {
									c = [(e = 0)];
								} else {
									// Remove leading elements which are zero and adjust exponent accordingly.
									for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

									// Count the digits of the first element of c to determine leading zeros, and...
									for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

									// adjust the exponent accordingly.
									if (i < LOG_BASE) e -= LOG_BASE - i;
								}

								rand.e = e;
								rand.c = c;
								return rand;
							};
						})();

						/*
						 * Return a BigNumber whose value is the sum of the arguments.
						 *
						 * arguments {number|string|BigNumber}
						 */
						BigNumber.sum = function () {
							var i = 1,
								args = arguments,
								sum = new BigNumber(args[0]);
							for (; i < args.length; ) sum = sum.plus(args[i++]);
							return sum;
						};

						// PRIVATE FUNCTIONS

						// Called by BigNumber and BigNumber.prototype.toString.
						convertBase = (function () {
							var decimal = '0123456789';

							/*
							 * Convert string of baseIn to an array of numbers of baseOut.
							 * Eg. toBaseOut('255', 10, 16) returns [15, 15].
							 * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
							 */
							function toBaseOut(str, baseIn, baseOut, alphabet) {
								var j,
									arr = [0],
									arrL,
									i = 0,
									len = str.length;

								for (; i < len; ) {
									for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

									arr[0] += alphabet.indexOf(str.charAt(i++));

									for (j = 0; j < arr.length; j++) {
										if (arr[j] > baseOut - 1) {
											if (arr[j + 1] == null) arr[j + 1] = 0;
											arr[j + 1] += (arr[j] / baseOut) | 0;
											arr[j] %= baseOut;
										}
									}
								}

								return arr.reverse();
							}

							// Convert a numeric string of baseIn to a numeric string of baseOut.
							// If the caller is toString, we are converting from base 10 to baseOut.
							// If the caller is BigNumber, we are converting from baseIn to base 10.
							return function (str, baseIn, baseOut, sign, callerIsToString) {
								var alphabet,
									d,
									e,
									k,
									r,
									x,
									xc,
									y,
									i = str.indexOf('.'),
									dp = DECIMAL_PLACES,
									rm = ROUNDING_MODE;

								// Non-integer.
								if (i >= 0) {
									k = POW_PRECISION;

									// Unlimited precision.
									POW_PRECISION = 0;
									str = str.replace('.', '');
									y = new BigNumber(baseIn);
									x = y.pow(str.length - i);
									POW_PRECISION = k;

									// Convert str as if an integer, then restore the fraction part by dividing the
									// result by its base raised to a power.

									y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'), 10, baseOut, decimal);
									y.e = y.c.length;
								}

								// Convert the number as integer.

								xc = toBaseOut(
									str,
									baseIn,
									baseOut,
									callerIsToString
										? ((alphabet = ALPHABET), decimal)
										: ((alphabet = decimal), ALPHABET)
								);

								// xc now represents str as an integer and converted to baseOut. e is the exponent.
								e = k = xc.length;

								// Remove trailing zeros.
								for (; xc[--k] == 0; xc.pop());

								// Zero?
								if (!xc[0]) return alphabet.charAt(0);

								// Does str represent an integer? If so, no need for the division.
								if (i < 0) {
									--e;
								} else {
									x.c = xc;
									x.e = e;

									// The sign is needed for correct rounding.
									x.s = sign;
									x = div(x, y, dp, rm, baseOut);
									xc = x.c;
									r = x.r;
									e = x.e;
								}

								// xc now represents str converted to baseOut.

								// THe index of the rounding digit.
								d = e + dp + 1;

								// The rounding digit: the digit to the right of the digit that may be rounded up.
								i = xc[d];

								// Look at the rounding digits and mode to determine whether to round up.

								k = baseOut / 2;
								r = r || d < 0 || xc[d + 1] != null;

								r =
									rm < 4
										? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
										: i > k ||
										  (i == k &&
												(rm == 4 || r || (rm == 6 && xc[d - 1] & 1) || rm == (x.s < 0 ? 8 : 7)));

								// If the index of the rounding digit is not greater than zero, or xc represents
								// zero, then the result of the base conversion is zero or, if rounding up, a value
								// such as 0.00001.
								if (d < 1 || !xc[0]) {
									// 1^-dp or 0
									str = r
										? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0))
										: alphabet.charAt(0);
								} else {
									// Truncate xc to the required number of decimal places.
									xc.length = d;

									// Round up?
									if (r) {
										// Rounding up may mean the previous digit has to be rounded up and so on.
										for (--baseOut; ++xc[--d] > baseOut; ) {
											xc[d] = 0;

											if (!d) {
												++e;
												xc = [1].concat(xc);
											}
										}
									}

									// Determine trailing zeros.
									for (k = xc.length; !xc[--k]; );

									// E.g. [4, 11, 15] becomes 4bf.
									for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

									// Add leading zeros, decimal point and trailing zeros as required.
									str = toFixedPoint(str, e, alphabet.charAt(0));
								}

								// The caller will add the sign.
								return str;
							};
						})();

						// Perform division in the specified base. Called by div and convertBase.
						div = (function () {
							// Assume non-zero x and k.
							function multiply(x, k, base) {
								var m,
									temp,
									xlo,
									xhi,
									carry = 0,
									i = x.length,
									klo = k % SQRT_BASE,
									khi = (k / SQRT_BASE) | 0;

								for (x = x.slice(); i--; ) {
									xlo = x[i] % SQRT_BASE;
									xhi = (x[i] / SQRT_BASE) | 0;
									m = khi * xlo + xhi * klo;
									temp = klo * xlo + (m % SQRT_BASE) * SQRT_BASE + carry;
									carry = ((temp / base) | 0) + ((m / SQRT_BASE) | 0) + khi * xhi;
									x[i] = temp % base;
								}

								if (carry) x = [carry].concat(x);

								return x;
							}

							function compare(a, b, aL, bL) {
								var i, cmp;

								if (aL != bL) {
									cmp = aL > bL ? 1 : -1;
								} else {
									for (i = cmp = 0; i < aL; i++) {
										if (a[i] != b[i]) {
											cmp = a[i] > b[i] ? 1 : -1;
											break;
										}
									}
								}

								return cmp;
							}

							function subtract(a, b, aL, base) {
								var i = 0;

								// Subtract b from a.
								for (; aL--; ) {
									a[aL] -= i;
									i = a[aL] < b[aL] ? 1 : 0;
									a[aL] = i * base + a[aL] - b[aL];
								}

								// Remove leading zeros.
								for (; !a[0] && a.length > 1; a.splice(0, 1));
							}

							// x: dividend, y: divisor.
							return function (x, y, dp, rm, base) {
								var cmp,
									e,
									i,
									more,
									n,
									prod,
									prodL,
									q,
									qc,
									rem,
									remL,
									rem0,
									xi,
									xL,
									yc0,
									yL,
									yz,
									s = x.s == y.s ? 1 : -1,
									xc = x.c,
									yc = y.c;

								// Either NaN, Infinity or 0?
								if (!xc || !xc[0] || !yc || !yc[0]) {
									return new BigNumber(
										// Return NaN if either NaN, or both Infinity or 0.
										!x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc)
											? NaN
											: // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
											(xc && xc[0] == 0) || !yc
											? s * 0
											: s / 0
									);
								}

								q = new BigNumber(s);
								qc = q.c = [];
								e = x.e - y.e;
								s = dp + e + 1;

								if (!base) {
									base = BASE;
									e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
									s = (s / LOG_BASE) | 0;
								}

								// Result exponent may be one less then the current value of e.
								// The coefficients of the BigNumbers from convertBase may have trailing zeros.
								for (i = 0; yc[i] == (xc[i] || 0); i++);

								if (yc[i] > (xc[i] || 0)) e--;

								if (s < 0) {
									qc.push(1);
									more = true;
								} else {
									xL = xc.length;
									yL = yc.length;
									i = 0;
									s += 2;

									// Normalise xc and yc so highest order digit of yc is >= base / 2.

									n = mathfloor(base / (yc[0] + 1));

									// Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
									// if (n > 1 || n++ == 1 && yc[0] < base / 2) {
									if (n > 1) {
										yc = multiply(yc, n, base);
										xc = multiply(xc, n, base);
										yL = yc.length;
										xL = xc.length;
									}

									xi = yL;
									rem = xc.slice(0, yL);
									remL = rem.length;

									// Add zeros to make remainder as long as divisor.
									for (; remL < yL; rem[remL++] = 0);
									yz = yc.slice();
									yz = [0].concat(yz);
									yc0 = yc[0];
									if (yc[1] >= base / 2) yc0++;
									// Not necessary, but to prevent trial digit n > base, when using base 3.
									// else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

									do {
										n = 0;

										// Compare divisor and remainder.
										cmp = compare(yc, rem, yL, remL);

										// If divisor < remainder.
										if (cmp < 0) {
											// Calculate trial digit, n.

											rem0 = rem[0];
											if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

											// n is how many times the divisor goes into the current remainder.
											n = mathfloor(rem0 / yc0);

											//  Algorithm:
											//  product = divisor multiplied by trial digit (n).
											//  Compare product and remainder.
											//  If product is greater than remainder:
											//    Subtract divisor from product, decrement trial digit.
											//  Subtract product from remainder.
											//  If product was less than remainder at the last compare:
											//    Compare new remainder and divisor.
											//    If remainder is greater than divisor:
											//      Subtract divisor from remainder, increment trial digit.

											if (n > 1) {
												// n may be > base only when base is 3.
												if (n >= base) n = base - 1;

												// product = divisor * trial digit.
												prod = multiply(yc, n, base);
												prodL = prod.length;
												remL = rem.length;

												// Compare product and remainder.
												// If product > remainder then trial digit n too high.
												// n is 1 too high about 5% of the time, and is not known to have
												// ever been more than 1 too high.
												while (compare(prod, rem, prodL, remL) == 1) {
													n--;

													// Subtract divisor from product.
													subtract(prod, yL < prodL ? yz : yc, prodL, base);
													prodL = prod.length;
													cmp = 1;
												}
											} else {
												// n is 0 or 1, cmp is -1.
												// If n is 0, there is no need to compare yc and rem again below,
												// so change cmp to 1 to avoid it.
												// If n is 1, leave cmp as -1, so yc and rem are compared again.
												if (n == 0) {
													// divisor < remainder, so n must be at least 1.
													cmp = n = 1;
												}

												// product = divisor
												prod = yc.slice();
												prodL = prod.length;
											}

											if (prodL < remL) prod = [0].concat(prod);

											// Subtract product from remainder.
											subtract(rem, prod, remL, base);
											remL = rem.length;

											// If product was < remainder.
											if (cmp == -1) {
												// Compare divisor and new remainder.
												// If divisor < new remainder, subtract divisor from remainder.
												// Trial digit n too low.
												// n is 1 too low about 5% of the time, and very rarely 2 too low.
												while (compare(yc, rem, yL, remL) < 1) {
													n++;

													// Subtract divisor from remainder.
													subtract(rem, yL < remL ? yz : yc, remL, base);
													remL = rem.length;
												}
											}
										} else if (cmp === 0) {
											n++;
											rem = [0];
										} // else cmp === 1 and n will be 0

										// Add the next digit, n, to the result array.
										qc[i++] = n;

										// Update the remainder.
										if (rem[0]) {
											rem[remL++] = xc[xi] || 0;
										} else {
											rem = [xc[xi]];
											remL = 1;
										}
									} while ((xi++ < xL || rem[0] != null) && s--);

									more = rem[0] != null;

									// Leading zero?
									if (!qc[0]) qc.splice(0, 1);
								}

								if (base == BASE) {
									// To calculate q.e, first get the number of digits of qc[0].
									for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

									round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

									// Caller is convertBase.
								} else {
									q.e = e;
									q.r = +more;
								}

								return q;
							};
						})();

						/*
						 * Return a string representing the value of BigNumber n in fixed-point or exponential
						 * notation rounded to the specified decimal places or significant digits.
						 *
						 * n: a BigNumber.
						 * i: the index of the last digit required (i.e. the digit that may be rounded up).
						 * rm: the rounding mode.
						 * id: 1 (toExponential) or 2 (toPrecision).
						 */
						function format(n, i, rm, id) {
							var c0, e, ne, len, str;

							if (rm == null) rm = ROUNDING_MODE;
							else intCheck(rm, 0, 8);

							if (!n.c) return n.toString();

							c0 = n.c[0];
							ne = n.e;

							if (i == null) {
								str = coeffToString(n.c);
								str =
									id == 1 || (id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS))
										? toExponential(str, ne)
										: toFixedPoint(str, ne, '0');
							} else {
								n = round(new BigNumber(n), i, rm);

								// n.e may have changed if the value was rounded up.
								e = n.e;

								str = coeffToString(n.c);
								len = str.length;

								// toPrecision returns exponential notation if the number of significant digits
								// specified is less than the number of digits necessary to represent the integer
								// part of the value in fixed-point notation.

								// Exponential notation.
								if (id == 1 || (id == 2 && (i <= e || e <= TO_EXP_NEG))) {
									// Append zeros?
									for (; len < i; str += '0', len++);
									str = toExponential(str, e);

									// Fixed-point notation.
								} else {
									i -= ne;
									str = toFixedPoint(str, e, '0');

									// Append zeros?
									if (e + 1 > len) {
										if (--i > 0) for (str += '.'; i--; str += '0');
									} else {
										i += e - len;
										if (i > 0) {
											if (e + 1 == len) str += '.';
											for (; i--; str += '0');
										}
									}
								}
							}

							return n.s < 0 && c0 ? '-' + str : str;
						}

						// Handle BigNumber.max and BigNumber.min.
						function maxOrMin(args, method) {
							var n,
								i = 1,
								m = new BigNumber(args[0]);

							for (; i < args.length; i++) {
								n = new BigNumber(args[i]);

								// If any number is NaN, return NaN.
								if (!n.s) {
									m = n;
									break;
								} else if (method.call(m, n)) {
									m = n;
								}
							}

							return m;
						}

						/*
						 * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
						 * Called by minus, plus and times.
						 */
						function normalise(n, c, e) {
							var i = 1,
								j = c.length;

							// Remove trailing zeros.
							for (; !c[--j]; c.pop());

							// Calculate the base 10 exponent. First get the number of digits of c[0].
							for (j = c[0]; j >= 10; j /= 10, i++);

							// Overflow?
							if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
								// Infinity.
								n.c = n.e = null;

								// Underflow?
							} else if (e < MIN_EXP) {
								// Zero.
								n.c = [(n.e = 0)];
							} else {
								n.e = e;
								n.c = c;
							}

							return n;
						}

						// Handle values that fail the validity test in BigNumber.
						parseNumeric = (function () {
							var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
								dotAfter = /^([^.]+)\.$/,
								dotBefore = /^\.([^.]+)$/,
								isInfinityOrNaN = /^-?(Infinity|NaN)$/,
								whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

							return function (x, str, isNum, b) {
								var base,
									s = isNum ? str : str.replace(whitespaceOrPlus, '');

								// No exception on ±Infinity or NaN.
								if (isInfinityOrNaN.test(s)) {
									x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
								} else {
									if (!isNum) {
										// basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
										s = s.replace(basePrefix, function (m, p1, p2) {
											base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
											return !b || b == base ? p1 : m;
										});

										if (b) {
											base = b;

											// E.g. '1.' to '1', '.1' to '0.1'
											s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
										}

										if (str != s) return new BigNumber(s, base);
									}

									// '[BigNumber Error] Not a number: {n}'
									// '[BigNumber Error] Not a base {b} number: {n}'
									if (BigNumber.DEBUG) {
										throw Error(
											bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str
										);
									}

									// NaN
									x.s = null;
								}

								x.c = x.e = null;
							};
						})();

						/*
						 * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
						 * If r is truthy, it is known that there are more digits after the rounding digit.
						 */
						function round(x, sd, rm, r) {
							var d,
								i,
								j,
								k,
								n,
								ni,
								rd,
								xc = x.c,
								pows10 = POWS_TEN;

							// if x is not Infinity or NaN...
							if (xc) {
								// rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
								// n is a base 1e14 number, the value of the element of array x.c containing rd.
								// ni is the index of n within x.c.
								// d is the number of digits of n.
								// i is the index of rd within n including leading zeros.
								// j is the actual index of rd within n (if < 0, rd is a leading zero).
								out: {
									// Get the number of digits of the first element of xc.
									for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
									i = sd - d;

									// If the rounding digit is in the first element of xc...
									if (i < 0) {
										i += LOG_BASE;
										j = sd;
										n = xc[(ni = 0)];

										// Get the rounding digit at index j of n.
										rd = (n / pows10[d - j - 1]) % 10 | 0;
									} else {
										ni = mathceil((i + 1) / LOG_BASE);

										if (ni >= xc.length) {
											if (r) {
												// Needed by sqrt.
												for (; xc.length <= ni; xc.push(0));
												n = rd = 0;
												d = 1;
												i %= LOG_BASE;
												j = i - LOG_BASE + 1;
											} else {
												break out;
											}
										} else {
											n = k = xc[ni];

											// Get the number of digits of n.
											for (d = 1; k >= 10; k /= 10, d++);

											// Get the index of rd within n.
											i %= LOG_BASE;

											// Get the index of rd within n, adjusted for leading zeros.
											// The number of leading zeros of n is given by LOG_BASE - d.
											j = i - LOG_BASE + d;

											// Get the rounding digit at index j of n.
											rd = j < 0 ? 0 : (n / pows10[d - j - 1]) % 10 | 0;
										}
									}

									r =
										r ||
										sd < 0 ||
										// Are there any non-zero digits after the rounding digit?
										// The expression  n % pows10[d - j - 1]  returns all digits of n to the right
										// of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
										xc[ni + 1] != null ||
										(j < 0 ? n : n % pows10[d - j - 1]);

									r =
										rm < 4
											? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
											: rd > 5 ||
											  (rd == 5 &&
													(rm == 4 ||
														r ||
														(rm == 6 &&
															// Check whether the digit to the left of the rounding digit is odd.
															(i > 0 ? (j > 0 ? n / pows10[d - j] : 0) : xc[ni - 1]) % 10 & 1) ||
														rm == (x.s < 0 ? 8 : 7)));

									if (sd < 1 || !xc[0]) {
										xc.length = 0;

										if (r) {
											// Convert sd to decimal places.
											sd -= x.e + 1;

											// 1, 0.1, 0.01, 0.001, 0.0001 etc.
											xc[0] = pows10[(LOG_BASE - (sd % LOG_BASE)) % LOG_BASE];
											x.e = -sd || 0;
										} else {
											// Zero.
											xc[0] = x.e = 0;
										}

										return x;
									}

									// Remove excess digits.
									if (i == 0) {
										xc.length = ni;
										k = 1;
										ni--;
									} else {
										xc.length = ni + 1;
										k = pows10[LOG_BASE - i];

										// E.g. 56700 becomes 56000 if 7 is the rounding digit.
										// j > 0 means i > number of leading zeros of n.
										xc[ni] = j > 0 ? mathfloor((n / pows10[d - j]) % pows10[j]) * k : 0;
									}

									// Round up?
									if (r) {
										for (;;) {
											// If the digit to be rounded up is in the first element of xc...
											if (ni == 0) {
												// i will be the length of xc[0] before k is added.
												for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
												j = xc[0] += k;
												for (k = 1; j >= 10; j /= 10, k++);

												// if i != k the length has increased.
												if (i != k) {
													x.e++;
													if (xc[0] == BASE) xc[0] = 1;
												}

												break;
											} else {
												xc[ni] += k;
												if (xc[ni] != BASE) break;
												xc[ni--] = 0;
												k = 1;
											}
										}
									}

									// Remove trailing zeros.
									for (i = xc.length; xc[--i] === 0; xc.pop());
								}

								// Overflow? Infinity.
								if (x.e > MAX_EXP) {
									x.c = x.e = null;

									// Underflow? Zero.
								} else if (x.e < MIN_EXP) {
									x.c = [(x.e = 0)];
								}
							}

							return x;
						}

						function valueOf(n) {
							var str,
								e = n.e;

							if (e === null) return n.toString();

							str = coeffToString(n.c);

							str =
								e <= TO_EXP_NEG || e >= TO_EXP_POS
									? toExponential(str, e)
									: toFixedPoint(str, e, '0');

							return n.s < 0 ? '-' + str : str;
						}

						// PROTOTYPE/INSTANCE METHODS

						/*
						 * Return a new BigNumber whose value is the absolute value of this BigNumber.
						 */
						P.absoluteValue = P.abs = function () {
							var x = new BigNumber(this);
							if (x.s < 0) x.s = 1;
							return x;
						};

						/*
						 * Return
						 *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
						 *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
						 *   0 if they have the same value,
						 *   or null if the value of either is NaN.
						 */
						P.comparedTo = function (y, b) {
							return compare(this, new BigNumber(y, b));
						};

						/*
						 * If dp is undefined or null or true or false, return the number of decimal places of the
						 * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
						 *
						 * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
						 * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
						 * ROUNDING_MODE if rm is omitted.
						 *
						 * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
						 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
						 *
						 * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
						 */
						P.decimalPlaces = P.dp = function (dp, rm) {
							var c,
								n,
								v,
								x = this;

							if (dp != null) {
								intCheck(dp, 0, MAX);
								if (rm == null) rm = ROUNDING_MODE;
								else intCheck(rm, 0, 8);

								return round(new BigNumber(x), dp + x.e + 1, rm);
							}

							if (!(c = x.c)) return null;
							n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

							// Subtract the number of trailing zeros of the last number.
							if ((v = c[v])) for (; v % 10 == 0; v /= 10, n--);
							if (n < 0) n = 0;

							return n;
						};

						/*
						 *  n / 0 = I
						 *  n / N = N
						 *  n / I = 0
						 *  0 / n = 0
						 *  0 / 0 = N
						 *  0 / N = N
						 *  0 / I = 0
						 *  N / n = N
						 *  N / 0 = N
						 *  N / N = N
						 *  N / I = N
						 *  I / n = I
						 *  I / 0 = I
						 *  I / N = N
						 *  I / I = N
						 *
						 * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
						 * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
						 */
						P.dividedBy = P.div = function (y, b) {
							return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
						};

						/*
						 * Return a new BigNumber whose value is the integer part of dividing the value of this
						 * BigNumber by the value of BigNumber(y, b).
						 */
						P.dividedToIntegerBy = P.idiv = function (y, b) {
							return div(this, new BigNumber(y, b), 0, 1);
						};

						/*
						 * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
						 *
						 * If m is present, return the result modulo m.
						 * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
						 * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
						 *
						 * The modular power operation works efficiently when x, n, and m are integers, otherwise it
						 * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
						 *
						 * n {number|string|BigNumber} The exponent. An integer.
						 * [m] {number|string|BigNumber} The modulus.
						 *
						 * '[BigNumber Error] Exponent not an integer: {n}'
						 */
						P.exponentiatedBy = P.pow = function (n, m) {
							var half,
								isModExp,
								i,
								k,
								more,
								nIsBig,
								nIsNeg,
								nIsOdd,
								y,
								x = this;

							n = new BigNumber(n);

							// Allow NaN and ±Infinity, but not other non-integers.
							if (n.c && !n.isInteger()) {
								throw Error(bignumberError + 'Exponent not an integer: ' + valueOf(n));
							}

							if (m != null) m = new BigNumber(m);

							// Exponent of MAX_SAFE_INTEGER is 15.
							nIsBig = n.e > 14;

							// If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
							if (!x.c || !x.c[0] || (x.c[0] == 1 && !x.e && x.c.length == 1) || !n.c || !n.c[0]) {
								// The sign of the result of pow when x is negative depends on the evenness of n.
								// If +n overflows to ±Infinity, the evenness of n would be not be known.
								y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
								return m ? y.mod(m) : y;
							}

							nIsNeg = n.s < 0;

							if (m) {
								// x % m returns NaN if abs(m) is zero, or m is NaN.
								if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

								isModExp = !nIsNeg && x.isInteger() && m.isInteger();

								if (isModExp) x = x.mod(m);

								// Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
								// Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
							} else if (
								n.e > 9 &&
								(x.e > 0 ||
									x.e < -1 ||
									(x.e == 0
										? // [1, 240000000]
										  x.c[0] > 1 || (nIsBig && x.c[1] >= 24e7)
										: // [80000000000000]  [99999750000000]
										  x.c[0] < 8e13 || (nIsBig && x.c[0] <= 9999975e7)))
							) {
								// If x is negative and n is odd, k = -0, else k = 0.
								k = x.s < 0 && isOdd(n) ? -0 : 0;

								// If x >= 1, k = ±Infinity.
								if (x.e > -1) k = 1 / k;

								// If n is negative return ±0, else return ±Infinity.
								return new BigNumber(nIsNeg ? 1 / k : k);
							} else if (POW_PRECISION) {
								// Truncating each coefficient array to a length of k after each multiplication
								// equates to truncating significant digits to POW_PRECISION + [28, 41],
								// i.e. there will be a minimum of 28 guard digits retained.
								k = mathceil(POW_PRECISION / LOG_BASE + 2);
							}

							if (nIsBig) {
								half = new BigNumber(0.5);
								if (nIsNeg) n.s = 1;
								nIsOdd = isOdd(n);
							} else {
								i = Math.abs(+valueOf(n));
								nIsOdd = i % 2;
							}

							y = new BigNumber(ONE);

							// Performs 54 loop iterations for n of 9007199254740991.
							for (;;) {
								if (nIsOdd) {
									y = y.times(x);
									if (!y.c) break;

									if (k) {
										if (y.c.length > k) y.c.length = k;
									} else if (isModExp) {
										y = y.mod(m); //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
									}
								}

								if (i) {
									i = mathfloor(i / 2);
									if (i === 0) break;
									nIsOdd = i % 2;
								} else {
									n = n.times(half);
									round(n, n.e + 1, 1);

									if (n.e > 14) {
										nIsOdd = isOdd(n);
									} else {
										i = +valueOf(n);
										if (i === 0) break;
										nIsOdd = i % 2;
									}
								}

								x = x.times(x);

								if (k) {
									if (x.c && x.c.length > k) x.c.length = k;
								} else if (isModExp) {
									x = x.mod(m); //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
								}
							}

							if (isModExp) return y;
							if (nIsNeg) y = ONE.div(y);

							return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
						};

						/*
						 * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
						 * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
						 *
						 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
						 *
						 * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
						 */
						P.integerValue = function (rm) {
							var n = new BigNumber(this);
							if (rm == null) rm = ROUNDING_MODE;
							else intCheck(rm, 0, 8);
							return round(n, n.e + 1, rm);
						};

						/*
						 * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
						 * otherwise return false.
						 */
						P.isEqualTo = P.eq = function (y, b) {
							return compare(this, new BigNumber(y, b)) === 0;
						};

						/*
						 * Return true if the value of this BigNumber is a finite number, otherwise return false.
						 */
						P.isFinite = function () {
							return !!this.c;
						};

						/*
						 * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
						 * otherwise return false.
						 */
						P.isGreaterThan = P.gt = function (y, b) {
							return compare(this, new BigNumber(y, b)) > 0;
						};

						/*
						 * Return true if the value of this BigNumber is greater than or equal to the value of
						 * BigNumber(y, b), otherwise return false.
						 */
						P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
							return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;
						};

						/*
						 * Return true if the value of this BigNumber is an integer, otherwise return false.
						 */
						P.isInteger = function () {
							return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
						};

						/*
						 * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
						 * otherwise return false.
						 */
						P.isLessThan = P.lt = function (y, b) {
							return compare(this, new BigNumber(y, b)) < 0;
						};

						/*
						 * Return true if the value of this BigNumber is less than or equal to the value of
						 * BigNumber(y, b), otherwise return false.
						 */
						P.isLessThanOrEqualTo = P.lte = function (y, b) {
							return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
						};

						/*
						 * Return true if the value of this BigNumber is NaN, otherwise return false.
						 */
						P.isNaN = function () {
							return !this.s;
						};

						/*
						 * Return true if the value of this BigNumber is negative, otherwise return false.
						 */
						P.isNegative = function () {
							return this.s < 0;
						};

						/*
						 * Return true if the value of this BigNumber is positive, otherwise return false.
						 */
						P.isPositive = function () {
							return this.s > 0;
						};

						/*
						 * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
						 */
						P.isZero = function () {
							return !!this.c && this.c[0] == 0;
						};

						/*
						 *  n - 0 = n
						 *  n - N = N
						 *  n - I = -I
						 *  0 - n = -n
						 *  0 - 0 = 0
						 *  0 - N = N
						 *  0 - I = -I
						 *  N - n = N
						 *  N - 0 = N
						 *  N - N = N
						 *  N - I = N
						 *  I - n = I
						 *  I - 0 = I
						 *  I - N = N
						 *  I - I = N
						 *
						 * Return a new BigNumber whose value is the value of this BigNumber minus the value of
						 * BigNumber(y, b).
						 */
						P.minus = function (y, b) {
							var i,
								j,
								t,
								xLTy,
								x = this,
								a = x.s;

							y = new BigNumber(y, b);
							b = y.s;

							// Either NaN?
							if (!a || !b) return new BigNumber(NaN);

							// Signs differ?
							if (a != b) {
								y.s = -b;
								return x.plus(y);
							}

							var xe = x.e / LOG_BASE,
								ye = y.e / LOG_BASE,
								xc = x.c,
								yc = y.c;

							if (!xe || !ye) {
								// Either Infinity?
								if (!xc || !yc) return xc ? ((y.s = -b), y) : new BigNumber(yc ? x : NaN);

								// Either zero?
								if (!xc[0] || !yc[0]) {
									// Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
									return yc[0]
										? ((y.s = -b), y)
										: new BigNumber(
												xc[0]
													? x
													: // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
													ROUNDING_MODE == 3
													? -0
													: 0
										  );
								}
							}

							xe = bitFloor(xe);
							ye = bitFloor(ye);
							xc = xc.slice();

							// Determine which is the bigger number.
							if ((a = xe - ye)) {
								if ((xLTy = a < 0)) {
									a = -a;
									t = xc;
								} else {
									ye = xe;
									t = yc;
								}

								t.reverse();

								// Prepend zeros to equalise exponents.
								for (b = a; b--; t.push(0));
								t.reverse();
							} else {
								// Exponents equal. Check digit by digit.
								j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

								for (a = b = 0; b < j; b++) {
									if (xc[b] != yc[b]) {
										xLTy = xc[b] < yc[b];
										break;
									}
								}
							}

							// x < y? Point xc to the array of the bigger number.
							if (xLTy) (t = xc), (xc = yc), (yc = t), (y.s = -y.s);

							b = (j = yc.length) - (i = xc.length);

							// Append zeros to xc if shorter.
							// No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
							if (b > 0) for (; b--; xc[i++] = 0);
							b = BASE - 1;

							// Subtract yc from xc.
							for (; j > a; ) {
								if (xc[--j] < yc[j]) {
									for (i = j; i && !xc[--i]; xc[i] = b);
									--xc[i];
									xc[j] += BASE;
								}

								xc[j] -= yc[j];
							}

							// Remove leading zeros and adjust exponent accordingly.
							for (; xc[0] == 0; xc.splice(0, 1), --ye);

							// Zero?
							if (!xc[0]) {
								// Following IEEE 754 (2008) 6.3,
								// n - n = +0  but  n - n = -0  when rounding towards -Infinity.
								y.s = ROUNDING_MODE == 3 ? -1 : 1;
								y.c = [(y.e = 0)];
								return y;
							}

							// No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
							// for finite x and y.
							return normalise(y, xc, ye);
						};

						/*
						 *   n % 0 =  N
						 *   n % N =  N
						 *   n % I =  n
						 *   0 % n =  0
						 *  -0 % n = -0
						 *   0 % 0 =  N
						 *   0 % N =  N
						 *   0 % I =  0
						 *   N % n =  N
						 *   N % 0 =  N
						 *   N % N =  N
						 *   N % I =  N
						 *   I % n =  N
						 *   I % 0 =  N
						 *   I % N =  N
						 *   I % I =  N
						 *
						 * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
						 * BigNumber(y, b). The result depends on the value of MODULO_MODE.
						 */
						P.modulo = P.mod = function (y, b) {
							var q,
								s,
								x = this;

							y = new BigNumber(y, b);

							// Return NaN if x is Infinity or NaN, or y is NaN or zero.
							if (!x.c || !y.s || (y.c && !y.c[0])) {
								return new BigNumber(NaN);

								// Return x if y is Infinity or x is zero.
							} else if (!y.c || (x.c && !x.c[0])) {
								return new BigNumber(x);
							}

							if (MODULO_MODE == 9) {
								// Euclidian division: q = sign(y) * floor(x / abs(y))
								// r = x - qy    where  0 <= r < abs(y)
								s = y.s;
								y.s = 1;
								q = div(x, y, 0, 3);
								y.s = s;
								q.s *= s;
							} else {
								q = div(x, y, 0, MODULO_MODE);
							}

							y = x.minus(q.times(y));

							// To match JavaScript %, ensure sign of zero is sign of dividend.
							if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

							return y;
						};

						/*
						 *  n * 0 = 0
						 *  n * N = N
						 *  n * I = I
						 *  0 * n = 0
						 *  0 * 0 = 0
						 *  0 * N = N
						 *  0 * I = N
						 *  N * n = N
						 *  N * 0 = N
						 *  N * N = N
						 *  N * I = N
						 *  I * n = I
						 *  I * 0 = N
						 *  I * N = N
						 *  I * I = I
						 *
						 * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
						 * of BigNumber(y, b).
						 */
						P.multipliedBy = P.times = function (y, b) {
							var c,
								e,
								i,
								j,
								k,
								m,
								xcL,
								xlo,
								xhi,
								ycL,
								ylo,
								yhi,
								zc,
								base,
								sqrtBase,
								x = this,
								xc = x.c,
								yc = (y = new BigNumber(y, b)).c;

							// Either NaN, ±Infinity or ±0?
							if (!xc || !yc || !xc[0] || !yc[0]) {
								// Return NaN if either is NaN, or one is 0 and the other is Infinity.
								if (!x.s || !y.s || (xc && !xc[0] && !yc) || (yc && !yc[0] && !xc)) {
									y.c = y.e = y.s = null;
								} else {
									y.s *= x.s;

									// Return ±Infinity if either is ±Infinity.
									if (!xc || !yc) {
										y.c = y.e = null;

										// Return ±0 if either is ±0.
									} else {
										y.c = [0];
										y.e = 0;
									}
								}

								return y;
							}

							e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
							y.s *= x.s;
							xcL = xc.length;
							ycL = yc.length;

							// Ensure xc points to longer array and xcL to its length.
							if (xcL < ycL) (zc = xc), (xc = yc), (yc = zc), (i = xcL), (xcL = ycL), (ycL = i);

							// Initialise the result array with zeros.
							for (i = xcL + ycL, zc = []; i--; zc.push(0));

							base = BASE;
							sqrtBase = SQRT_BASE;

							for (i = ycL; --i >= 0; ) {
								c = 0;
								ylo = yc[i] % sqrtBase;
								yhi = (yc[i] / sqrtBase) | 0;

								for (k = xcL, j = i + k; j > i; ) {
									xlo = xc[--k] % sqrtBase;
									xhi = (xc[k] / sqrtBase) | 0;
									m = yhi * xlo + xhi * ylo;
									xlo = ylo * xlo + (m % sqrtBase) * sqrtBase + zc[j] + c;
									c = ((xlo / base) | 0) + ((m / sqrtBase) | 0) + yhi * xhi;
									zc[j--] = xlo % base;
								}

								zc[j] = c;
							}

							if (c) {
								++e;
							} else {
								zc.splice(0, 1);
							}

							return normalise(y, zc, e);
						};

						/*
						 * Return a new BigNumber whose value is the value of this BigNumber negated,
						 * i.e. multiplied by -1.
						 */
						P.negated = function () {
							var x = new BigNumber(this);
							x.s = -x.s || null;
							return x;
						};

						/*
						 *  n + 0 = n
						 *  n + N = N
						 *  n + I = I
						 *  0 + n = n
						 *  0 + 0 = 0
						 *  0 + N = N
						 *  0 + I = I
						 *  N + n = N
						 *  N + 0 = N
						 *  N + N = N
						 *  N + I = N
						 *  I + n = I
						 *  I + 0 = I
						 *  I + N = N
						 *  I + I = I
						 *
						 * Return a new BigNumber whose value is the value of this BigNumber plus the value of
						 * BigNumber(y, b).
						 */
						P.plus = function (y, b) {
							var t,
								x = this,
								a = x.s;

							y = new BigNumber(y, b);
							b = y.s;

							// Either NaN?
							if (!a || !b) return new BigNumber(NaN);

							// Signs differ?
							if (a != b) {
								y.s = -b;
								return x.minus(y);
							}

							var xe = x.e / LOG_BASE,
								ye = y.e / LOG_BASE,
								xc = x.c,
								yc = y.c;

							if (!xe || !ye) {
								// Return ±Infinity if either ±Infinity.
								if (!xc || !yc) return new BigNumber(a / 0);

								// Either zero?
								// Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
								if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
							}

							xe = bitFloor(xe);
							ye = bitFloor(ye);
							xc = xc.slice();

							// Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
							if ((a = xe - ye)) {
								if (a > 0) {
									ye = xe;
									t = yc;
								} else {
									a = -a;
									t = xc;
								}

								t.reverse();
								for (; a--; t.push(0));
								t.reverse();
							}

							a = xc.length;
							b = yc.length;

							// Point xc to the longer array, and b to the shorter length.
							if (a - b < 0) (t = yc), (yc = xc), (xc = t), (b = a);

							// Only start adding at yc.length - 1 as the further digits of xc can be ignored.
							for (a = 0; b; ) {
								a = ((xc[--b] = xc[b] + yc[b] + a) / BASE) | 0;
								xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
							}

							if (a) {
								xc = [a].concat(xc);
								++ye;
							}

							// No need to check for zero, as +x + +y != 0 && -x + -y != 0
							// ye = MAX_EXP + 1 possible
							return normalise(y, xc, ye);
						};

						/*
						 * If sd is undefined or null or true or false, return the number of significant digits of
						 * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
						 * If sd is true include integer-part trailing zeros in the count.
						 *
						 * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
						 * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
						 * ROUNDING_MODE if rm is omitted.
						 *
						 * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
						 *                     boolean: whether to count integer-part trailing zeros: true or false.
						 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
						 *
						 * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
						 */
						P.precision = P.sd = function (sd, rm) {
							var c,
								n,
								v,
								x = this;

							if (sd != null && sd !== !!sd) {
								intCheck(sd, 1, MAX);
								if (rm == null) rm = ROUNDING_MODE;
								else intCheck(rm, 0, 8);

								return round(new BigNumber(x), sd, rm);
							}

							if (!(c = x.c)) return null;
							v = c.length - 1;
							n = v * LOG_BASE + 1;

							if ((v = c[v])) {
								// Subtract the number of trailing zeros of the last element.
								for (; v % 10 == 0; v /= 10, n--);

								// Add the number of digits of the first element.
								for (v = c[0]; v >= 10; v /= 10, n++);
							}

							if (sd && x.e + 1 > n) n = x.e + 1;

							return n;
						};

						/*
						 * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
						 * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
						 *
						 * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
						 *
						 * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
						 */
						P.shiftedBy = function (k) {
							intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
							return this.times('1e' + k);
						};

						/*
						 *  sqrt(-n) =  N
						 *  sqrt(N) =  N
						 *  sqrt(-I) =  N
						 *  sqrt(I) =  I
						 *  sqrt(0) =  0
						 *  sqrt(-0) = -0
						 *
						 * Return a new BigNumber whose value is the square root of the value of this BigNumber,
						 * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
						 */
						P.squareRoot = P.sqrt = function () {
							var m,
								n,
								r,
								rep,
								t,
								x = this,
								c = x.c,
								s = x.s,
								e = x.e,
								dp = DECIMAL_PLACES + 4,
								half = new BigNumber('0.5');

							// Negative/NaN/Infinity/zero?
							if (s !== 1 || !c || !c[0]) {
								return new BigNumber(!s || (s < 0 && (!c || c[0])) ? NaN : c ? x : 1 / 0);
							}

							// Initial estimate.
							s = Math.sqrt(+valueOf(x));

							// Math.sqrt underflow/overflow?
							// Pass x to Math.sqrt as integer, then adjust the exponent of the result.
							if (s == 0 || s == 1 / 0) {
								n = coeffToString(c);
								if ((n.length + e) % 2 == 0) n += '0';
								s = Math.sqrt(+n);
								e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

								if (s == 1 / 0) {
									n = '5e' + e;
								} else {
									n = s.toExponential();
									n = n.slice(0, n.indexOf('e') + 1) + e;
								}

								r = new BigNumber(n);
							} else {
								r = new BigNumber(s + '');
							}

							// Check for zero.
							// r could be zero if MIN_EXP is changed after the this value was created.
							// This would cause a division by zero (x/t) and hence Infinity below, which would cause
							// coeffToString to throw.
							if (r.c[0]) {
								e = r.e;
								s = e + dp;
								if (s < 3) s = 0;

								// Newton-Raphson iteration.
								for (;;) {
									t = r;
									r = half.times(t.plus(div(x, t, dp, 1)));

									if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
										// The exponent of r may here be one less than the final result exponent,
										// e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
										// are indexed correctly.
										if (r.e < e) --s;
										n = n.slice(s - 3, s + 1);

										// The 4th rounding digit may be in error by -1 so if the 4 rounding digits
										// are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
										// iteration.
										if (n == '9999' || (!rep && n == '4999')) {
											// On the first iteration only, check to see if rounding up gives the
											// exact result as the nines may infinitely repeat.
											if (!rep) {
												round(t, t.e + DECIMAL_PLACES + 2, 0);

												if (t.times(t).eq(x)) {
													r = t;
													break;
												}
											}

											dp += 4;
											s += 4;
											rep = 1;
										} else {
											// If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
											// result. If not, then there are further digits and m will be truthy.
											if (!+n || (!+n.slice(1) && n.charAt(0) == '5')) {
												// Truncate to the first rounding digit.
												round(r, r.e + DECIMAL_PLACES + 2, 1);
												m = !r.times(r).eq(x);
											}

											break;
										}
									}
								}
							}

							return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
						};

						/*
						 * Return a string representing the value of this BigNumber in exponential notation and
						 * rounded using ROUNDING_MODE to dp fixed decimal places.
						 *
						 * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
						 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
						 *
						 * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
						 */
						P.toExponential = function (dp, rm) {
							if (dp != null) {
								intCheck(dp, 0, MAX);
								dp++;
							}
							return format(this, dp, rm, 1);
						};

						/*
						 * Return a string representing the value of this BigNumber in fixed-point notation rounding
						 * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
						 *
						 * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
						 * but e.g. (-0.00001).toFixed(0) is '-0'.
						 *
						 * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
						 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
						 *
						 * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
						 */
						P.toFixed = function (dp, rm) {
							if (dp != null) {
								intCheck(dp, 0, MAX);
								dp = dp + this.e + 1;
							}
							return format(this, dp, rm);
						};

						/*
						 * Return a string representing the value of this BigNumber in fixed-point notation rounded
						 * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
						 * of the format or FORMAT object (see BigNumber.set).
						 *
						 * The formatting object may contain some or all of the properties shown below.
						 *
						 * FORMAT = {
						 *   prefix: '',
						 *   groupSize: 3,
						 *   secondaryGroupSize: 0,
						 *   groupSeparator: ',',
						 *   decimalSeparator: '.',
						 *   fractionGroupSize: 0,
						 *   fractionGroupSeparator: '\xA0',      // non-breaking space
						 *   suffix: ''
						 * };
						 *
						 * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
						 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
						 * [format] {object} Formatting options. See FORMAT pbject above.
						 *
						 * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
						 * '[BigNumber Error] Argument not an object: {format}'
						 */
						P.toFormat = function (dp, rm, format) {
							var str,
								x = this;

							if (format == null) {
								if (dp != null && rm && typeof rm == 'object') {
									format = rm;
									rm = null;
								} else if (dp && typeof dp == 'object') {
									format = dp;
									dp = rm = null;
								} else {
									format = FORMAT;
								}
							} else if (typeof format != 'object') {
								throw Error(bignumberError + 'Argument not an object: ' + format);
							}

							str = x.toFixed(dp, rm);

							if (x.c) {
								var i,
									arr = str.split('.'),
									g1 = +format.groupSize,
									g2 = +format.secondaryGroupSize,
									groupSeparator = format.groupSeparator || '',
									intPart = arr[0],
									fractionPart = arr[1],
									isNeg = x.s < 0,
									intDigits = isNeg ? intPart.slice(1) : intPart,
									len = intDigits.length;

								if (g2) (i = g1), (g1 = g2), (g2 = i), (len -= i);

								if (g1 > 0 && len > 0) {
									i = len % g1 || g1;
									intPart = intDigits.substr(0, i);
									for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
									if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
									if (isNeg) intPart = '-' + intPart;
								}

								str = fractionPart
									? intPart +
									  (format.decimalSeparator || '') +
									  ((g2 = +format.fractionGroupSize)
											? fractionPart.replace(
													new RegExp('\\d{' + g2 + '}\\B', 'g'),
													'$&' + (format.fractionGroupSeparator || '')
											  )
											: fractionPart)
									: intPart;
							}

							return (format.prefix || '') + str + (format.suffix || '');
						};

						/*
						 * Return an array of two BigNumbers representing the value of this BigNumber as a simple
						 * fraction with an integer numerator and an integer denominator.
						 * The denominator will be a positive non-zero value less than or equal to the specified
						 * maximum denominator. If a maximum denominator is not specified, the denominator will be
						 * the lowest value necessary to represent the number exactly.
						 *
						 * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
						 *
						 * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
						 */
						P.toFraction = function (md) {
							var d,
								d0,
								d1,
								d2,
								e,
								exp,
								n,
								n0,
								n1,
								q,
								r,
								s,
								x = this,
								xc = x.c;

							if (md != null) {
								n = new BigNumber(md);

								// Throw if md is less than one or is not an integer, unless it is Infinity.
								if ((!n.isInteger() && (n.c || n.s !== 1)) || n.lt(ONE)) {
									throw Error(
										bignumberError +
											'Argument ' +
											(n.isInteger() ? 'out of range: ' : 'not an integer: ') +
											valueOf(n)
									);
								}
							}

							if (!xc) return new BigNumber(x);

							d = new BigNumber(ONE);
							n1 = d0 = new BigNumber(ONE);
							d1 = n0 = new BigNumber(ONE);
							s = coeffToString(xc);

							// Determine initial denominator.
							// d is a power of 10 and the minimum max denominator that specifies the value exactly.
							e = d.e = s.length - x.e - 1;
							d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
							md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

							exp = MAX_EXP;
							MAX_EXP = 1 / 0;
							n = new BigNumber(s);

							// n0 = d1 = 0
							n0.c[0] = 0;

							for (;;) {
								q = div(n, d, 0, 1);
								d2 = d0.plus(q.times(d1));
								if (d2.comparedTo(md) == 1) break;
								d0 = d1;
								d1 = d2;
								n1 = n0.plus(q.times((d2 = n1)));
								n0 = d2;
								d = n.minus(q.times((d2 = d)));
								n = d2;
							}

							d2 = div(md.minus(d0), d1, 0, 1);
							n0 = n0.plus(d2.times(n1));
							d0 = d0.plus(d2.times(d1));
							n0.s = n1.s = x.s;
							e = e * 2;

							// Determine which fraction is closer to x, n0/d0 or n1/d1
							r =
								div(n1, d1, e, ROUNDING_MODE)
									.minus(x)
									.abs()
									.comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1
									? [n1, d1]
									: [n0, d0];

							MAX_EXP = exp;

							return r;
						};

						/*
						 * Return the value of this BigNumber converted to a number primitive.
						 */
						P.toNumber = function () {
							return +valueOf(this);
						};

						/*
						 * Return a string representing the value of this BigNumber rounded to sd significant digits
						 * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
						 * necessary to represent the integer part of the value in fixed-point notation, then use
						 * exponential notation.
						 *
						 * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
						 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
						 *
						 * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
						 */
						P.toPrecision = function (sd, rm) {
							if (sd != null) intCheck(sd, 1, MAX);
							return format(this, sd, rm, 2);
						};

						/*
						 * Return a string representing the value of this BigNumber in base b, or base 10 if b is
						 * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
						 * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
						 * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
						 * TO_EXP_NEG, return exponential notation.
						 *
						 * [b] {number} Integer, 2 to ALPHABET.length inclusive.
						 *
						 * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
						 */
						P.toString = function (b) {
							var str,
								n = this,
								s = n.s,
								e = n.e;

							// Infinity or NaN?
							if (e === null) {
								if (s) {
									str = 'Infinity';
									if (s < 0) str = '-' + str;
								} else {
									str = 'NaN';
								}
							} else {
								if (b == null) {
									str =
										e <= TO_EXP_NEG || e >= TO_EXP_POS
											? toExponential(coeffToString(n.c), e)
											: toFixedPoint(coeffToString(n.c), e, '0');
								} else if (b === 10) {
									n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
									str = toFixedPoint(coeffToString(n.c), n.e, '0');
								} else {
									intCheck(b, 2, ALPHABET.length, 'Base');
									str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
								}

								if (s < 0 && n.c[0]) str = '-' + str;
							}

							return str;
						};

						/*
						 * Return as toString, but do not accept a base argument, and include the minus sign for
						 * negative zero.
						 */
						P.valueOf = P.toJSON = function () {
							return valueOf(this);
						};

						P._isBigNumber = true;

						if (configObject != null) BigNumber.set(configObject);

						return BigNumber;
					}

					// PRIVATE HELPER FUNCTIONS

					// These functions don't need access to variables,
					// e.g. DECIMAL_PLACES, in the scope of the `clone` function above.

					function bitFloor(n) {
						var i = n | 0;
						return n > 0 || n === i ? i : i - 1;
					}

					// Return a coefficient array as a string of base 10 digits.
					function coeffToString(a) {
						var s,
							z,
							i = 1,
							j = a.length,
							r = a[0] + '';

						for (; i < j; ) {
							s = a[i++] + '';
							z = LOG_BASE - s.length;
							for (; z--; s = '0' + s);
							r += s;
						}

						// Determine trailing zeros.
						for (j = r.length; r.charCodeAt(--j) === 48; );

						return r.slice(0, j + 1 || 1);
					}

					// Compare the value of BigNumbers x and y.
					function compare(x, y) {
						var a,
							b,
							xc = x.c,
							yc = y.c,
							i = x.s,
							j = y.s,
							k = x.e,
							l = y.e;

						// Either NaN?
						if (!i || !j) return null;

						a = xc && !xc[0];
						b = yc && !yc[0];

						// Either zero?
						if (a || b) return a ? (b ? 0 : -j) : i;

						// Signs differ?
						if (i != j) return i;

						a = i < 0;
						b = k == l;

						// Either Infinity?
						if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

						// Compare exponents.
						if (!b) return (k > l) ^ a ? 1 : -1;

						j = (k = xc.length) < (l = yc.length) ? k : l;

						// Compare digit by digit.
						for (i = 0; i < j; i++) if (xc[i] != yc[i]) return (xc[i] > yc[i]) ^ a ? 1 : -1;

						// Compare lengths.
						return k == l ? 0 : (k > l) ^ a ? 1 : -1;
					}

					/*
					 * Check that n is a primitive number, an integer, and in range, otherwise throw.
					 */
					function intCheck(n, min, max, name) {
						if (n < min || n > max || n !== mathfloor(n)) {
							throw Error(
								bignumberError +
									(name || 'Argument') +
									(typeof n == 'number'
										? n < min || n > max
											? ' out of range: '
											: ' not an integer: '
										: ' not a primitive number: ') +
									String(n)
							);
						}
					}

					// Assumes finite n.
					function isOdd(n) {
						var k = n.c.length - 1;
						return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
					}

					function toExponential(str, e) {
						return (
							(str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) + (e < 0 ? 'e' : 'e+') + e
						);
					}

					function toFixedPoint(str, e, z) {
						var len, zs;

						// Negative exponent?
						if (e < 0) {
							// Prepend zeros.
							for (zs = z + '.'; ++e; zs += z);
							str = zs + str;

							// Positive exponent
						} else {
							len = str.length;

							// Append zeros.
							if (++e > len) {
								for (zs = z, e -= len; --e; zs += z);
								str += zs;
							} else if (e < len) {
								str = str.slice(0, e) + '.' + str.slice(e);
							}
						}

						return str;
					}

					// EXPORT

					BigNumber = clone();
					BigNumber['default'] = BigNumber.BigNumber = BigNumber;

					// AMD.
					if (typeof define == 'function' && define.amd) {
						define(function () {
							return BigNumber;
						});

						// Node.js and other environments that support module.exports.
					} else if (typeof module != 'undefined' && module.exports) {
						module.exports = BigNumber;

						// Browser.
					} else {
						if (!globalObject) {
							globalObject = typeof self != 'undefined' && self ? self : window;
						}

						globalObject.BigNumber = BigNumber;
					}
				})(this);
			},
			{}
		],
		'../node_modules/lodash/isArray.js': [
			function (require, module, exports) {
				/**
				 * Checks if `value` is classified as an `Array` object.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
				 * @example
				 *
				 * _.isArray([1, 2, 3]);
				 * // => true
				 *
				 * _.isArray(document.body.children);
				 * // => false
				 *
				 * _.isArray('abc');
				 * // => false
				 *
				 * _.isArray(_.noop);
				 * // => false
				 */
				var isArray = Array.isArray;

				module.exports = isArray;
			},
			{}
		],
		'../node_modules/lodash/_freeGlobal.js': [
			function (require, module, exports) {
				var global = arguments[3];
				/** Detect free variable `global` from Node.js. */
				var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

				module.exports = freeGlobal;
			},
			{}
		],
		'../node_modules/lodash/_root.js': [
			function (require, module, exports) {
				var freeGlobal = require('./_freeGlobal');

				/** Detect free variable `self`. */
				var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

				/** Used as a reference to the global object. */
				var root = freeGlobal || freeSelf || Function('return this')();

				module.exports = root;
			},
			{ './_freeGlobal': '../node_modules/lodash/_freeGlobal.js' }
		],
		'../node_modules/lodash/_Symbol.js': [
			function (require, module, exports) {
				var root = require('./_root');

				/** Built-in value references. */
				var Symbol = root.Symbol;

				module.exports = Symbol;
			},
			{ './_root': '../node_modules/lodash/_root.js' }
		],
		'../node_modules/lodash/_getRawTag.js': [
			function (require, module, exports) {
				var Symbol = require('./_Symbol');

				/** Used for built-in method references. */
				var objectProto = Object.prototype;

				/** Used to check objects for own properties. */
				var hasOwnProperty = objectProto.hasOwnProperty;

				/**
				 * Used to resolve the
				 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
				 * of values.
				 */
				var nativeObjectToString = objectProto.toString;

				/** Built-in value references. */
				var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

				/**
				 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
				 *
				 * @private
				 * @param {*} value The value to query.
				 * @returns {string} Returns the raw `toStringTag`.
				 */
				function getRawTag(value) {
					var isOwn = hasOwnProperty.call(value, symToStringTag),
						tag = value[symToStringTag];

					try {
						value[symToStringTag] = undefined;
						var unmasked = true;
					} catch (e) {}

					var result = nativeObjectToString.call(value);
					if (unmasked) {
						if (isOwn) {
							value[symToStringTag] = tag;
						} else {
							delete value[symToStringTag];
						}
					}
					return result;
				}

				module.exports = getRawTag;
			},
			{ './_Symbol': '../node_modules/lodash/_Symbol.js' }
		],
		'../node_modules/lodash/_objectToString.js': [
			function (require, module, exports) {
				/** Used for built-in method references. */
				var objectProto = Object.prototype;

				/**
				 * Used to resolve the
				 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
				 * of values.
				 */
				var nativeObjectToString = objectProto.toString;

				/**
				 * Converts `value` to a string using `Object.prototype.toString`.
				 *
				 * @private
				 * @param {*} value The value to convert.
				 * @returns {string} Returns the converted string.
				 */
				function objectToString(value) {
					return nativeObjectToString.call(value);
				}

				module.exports = objectToString;
			},
			{}
		],
		'../node_modules/lodash/_baseGetTag.js': [
			function (require, module, exports) {
				var Symbol = require('./_Symbol'),
					getRawTag = require('./_getRawTag'),
					objectToString = require('./_objectToString');

				/** `Object#toString` result references. */
				var nullTag = '[object Null]',
					undefinedTag = '[object Undefined]';

				/** Built-in value references. */
				var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

				/**
				 * The base implementation of `getTag` without fallbacks for buggy environments.
				 *
				 * @private
				 * @param {*} value The value to query.
				 * @returns {string} Returns the `toStringTag`.
				 */
				function baseGetTag(value) {
					if (value == null) {
						return value === undefined ? undefinedTag : nullTag;
					}
					return symToStringTag && symToStringTag in Object(value)
						? getRawTag(value)
						: objectToString(value);
				}

				module.exports = baseGetTag;
			},
			{
				'./_Symbol': '../node_modules/lodash/_Symbol.js',
				'./_getRawTag': '../node_modules/lodash/_getRawTag.js',
				'./_objectToString': '../node_modules/lodash/_objectToString.js'
			}
		],
		'../node_modules/lodash/isObjectLike.js': [
			function (require, module, exports) {
				/**
				 * Checks if `value` is object-like. A value is object-like if it's not `null`
				 * and has a `typeof` result of "object".
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
				 * @example
				 *
				 * _.isObjectLike({});
				 * // => true
				 *
				 * _.isObjectLike([1, 2, 3]);
				 * // => true
				 *
				 * _.isObjectLike(_.noop);
				 * // => false
				 *
				 * _.isObjectLike(null);
				 * // => false
				 */
				function isObjectLike(value) {
					return value != null && typeof value == 'object';
				}

				module.exports = isObjectLike;
			},
			{}
		],
		'../node_modules/lodash/isSymbol.js': [
			function (require, module, exports) {
				var baseGetTag = require('./_baseGetTag'),
					isObjectLike = require('./isObjectLike');

				/** `Object#toString` result references. */
				var symbolTag = '[object Symbol]';

				/**
				 * Checks if `value` is classified as a `Symbol` primitive or object.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
				 * @example
				 *
				 * _.isSymbol(Symbol.iterator);
				 * // => true
				 *
				 * _.isSymbol('abc');
				 * // => false
				 */
				function isSymbol(value) {
					return (
						typeof value == 'symbol' || (isObjectLike(value) && baseGetTag(value) == symbolTag)
					);
				}

				module.exports = isSymbol;
			},
			{
				'./_baseGetTag': '../node_modules/lodash/_baseGetTag.js',
				'./isObjectLike': '../node_modules/lodash/isObjectLike.js'
			}
		],
		'../node_modules/lodash/_isKey.js': [
			function (require, module, exports) {
				var isArray = require('./isArray'),
					isSymbol = require('./isSymbol');

				/** Used to match property names within property paths. */
				var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
					reIsPlainProp = /^\w*$/;

				/**
				 * Checks if `value` is a property name and not a property path.
				 *
				 * @private
				 * @param {*} value The value to check.
				 * @param {Object} [object] The object to query keys on.
				 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
				 */
				function isKey(value, object) {
					if (isArray(value)) {
						return false;
					}
					var type = typeof value;
					if (
						type == 'number' ||
						type == 'symbol' ||
						type == 'boolean' ||
						value == null ||
						isSymbol(value)
					) {
						return true;
					}
					return (
						reIsPlainProp.test(value) ||
						!reIsDeepProp.test(value) ||
						(object != null && value in Object(object))
					);
				}

				module.exports = isKey;
			},
			{
				'./isArray': '../node_modules/lodash/isArray.js',
				'./isSymbol': '../node_modules/lodash/isSymbol.js'
			}
		],
		'../node_modules/lodash/isObject.js': [
			function (require, module, exports) {
				/**
				 * Checks if `value` is the
				 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
				 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
				 * @example
				 *
				 * _.isObject({});
				 * // => true
				 *
				 * _.isObject([1, 2, 3]);
				 * // => true
				 *
				 * _.isObject(_.noop);
				 * // => true
				 *
				 * _.isObject(null);
				 * // => false
				 */
				function isObject(value) {
					var type = typeof value;
					return value != null && (type == 'object' || type == 'function');
				}

				module.exports = isObject;
			},
			{}
		],
		'../node_modules/lodash/isFunction.js': [
			function (require, module, exports) {
				var baseGetTag = require('./_baseGetTag'),
					isObject = require('./isObject');

				/** `Object#toString` result references. */
				var asyncTag = '[object AsyncFunction]',
					funcTag = '[object Function]',
					genTag = '[object GeneratorFunction]',
					proxyTag = '[object Proxy]';

				/**
				 * Checks if `value` is classified as a `Function` object.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Lang
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
				 * @example
				 *
				 * _.isFunction(_);
				 * // => true
				 *
				 * _.isFunction(/abc/);
				 * // => false
				 */
				function isFunction(value) {
					if (!isObject(value)) {
						return false;
					}
					// The use of `Object#toString` avoids issues with the `typeof` operator
					// in Safari 9 which returns 'object' for typed arrays and other constructors.
					var tag = baseGetTag(value);
					return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
				}

				module.exports = isFunction;
			},
			{
				'./_baseGetTag': '../node_modules/lodash/_baseGetTag.js',
				'./isObject': '../node_modules/lodash/isObject.js'
			}
		],
		'../node_modules/lodash/_coreJsData.js': [
			function (require, module, exports) {
				var root = require('./_root');

				/** Used to detect overreaching core-js shims. */
				var coreJsData = root['__core-js_shared__'];

				module.exports = coreJsData;
			},
			{ './_root': '../node_modules/lodash/_root.js' }
		],
		'../node_modules/lodash/_isMasked.js': [
			function (require, module, exports) {
				var coreJsData = require('./_coreJsData');

				/** Used to detect methods masquerading as native. */
				var maskSrcKey = (function () {
					var uid = /[^.]+$/.exec(
						(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || ''
					);
					return uid ? 'Symbol(src)_1.' + uid : '';
				})();

				/**
				 * Checks if `func` has its source masked.
				 *
				 * @private
				 * @param {Function} func The function to check.
				 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
				 */
				function isMasked(func) {
					return !!maskSrcKey && maskSrcKey in func;
				}

				module.exports = isMasked;
			},
			{ './_coreJsData': '../node_modules/lodash/_coreJsData.js' }
		],
		'../node_modules/lodash/_toSource.js': [
			function (require, module, exports) {
				/** Used for built-in method references. */
				var funcProto = Function.prototype;

				/** Used to resolve the decompiled source of functions. */
				var funcToString = funcProto.toString;

				/**
				 * Converts `func` to its source code.
				 *
				 * @private
				 * @param {Function} func The function to convert.
				 * @returns {string} Returns the source code.
				 */
				function toSource(func) {
					if (func != null) {
						try {
							return funcToString.call(func);
						} catch (e) {}
						try {
							return func + '';
						} catch (e) {}
					}
					return '';
				}

				module.exports = toSource;
			},
			{}
		],
		'../node_modules/lodash/_baseIsNative.js': [
			function (require, module, exports) {
				var isFunction = require('./isFunction'),
					isMasked = require('./_isMasked'),
					isObject = require('./isObject'),
					toSource = require('./_toSource');

				/**
				 * Used to match `RegExp`
				 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
				 */
				var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

				/** Used to detect host constructors (Safari). */
				var reIsHostCtor = /^\[object .+?Constructor\]$/;

				/** Used for built-in method references. */
				var funcProto = Function.prototype,
					objectProto = Object.prototype;

				/** Used to resolve the decompiled source of functions. */
				var funcToString = funcProto.toString;

				/** Used to check objects for own properties. */
				var hasOwnProperty = objectProto.hasOwnProperty;

				/** Used to detect if a method is native. */
				var reIsNative = RegExp(
					'^' +
						funcToString
							.call(hasOwnProperty)
							.replace(reRegExpChar, '\\$&')
							.replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
						'$'
				);

				/**
				 * The base implementation of `_.isNative` without bad shim checks.
				 *
				 * @private
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is a native function,
				 *  else `false`.
				 */
				function baseIsNative(value) {
					if (!isObject(value) || isMasked(value)) {
						return false;
					}
					var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
					return pattern.test(toSource(value));
				}

				module.exports = baseIsNative;
			},
			{
				'./isFunction': '../node_modules/lodash/isFunction.js',
				'./_isMasked': '../node_modules/lodash/_isMasked.js',
				'./isObject': '../node_modules/lodash/isObject.js',
				'./_toSource': '../node_modules/lodash/_toSource.js'
			}
		],
		'../node_modules/lodash/_getValue.js': [
			function (require, module, exports) {
				/**
				 * Gets the value at `key` of `object`.
				 *
				 * @private
				 * @param {Object} [object] The object to query.
				 * @param {string} key The key of the property to get.
				 * @returns {*} Returns the property value.
				 */
				function getValue(object, key) {
					return object == null ? undefined : object[key];
				}

				module.exports = getValue;
			},
			{}
		],
		'../node_modules/lodash/_getNative.js': [
			function (require, module, exports) {
				var baseIsNative = require('./_baseIsNative'),
					getValue = require('./_getValue');

				/**
				 * Gets the native function at `key` of `object`.
				 *
				 * @private
				 * @param {Object} object The object to query.
				 * @param {string} key The key of the method to get.
				 * @returns {*} Returns the function if it's native, else `undefined`.
				 */
				function getNative(object, key) {
					var value = getValue(object, key);
					return baseIsNative(value) ? value : undefined;
				}

				module.exports = getNative;
			},
			{
				'./_baseIsNative': '../node_modules/lodash/_baseIsNative.js',
				'./_getValue': '../node_modules/lodash/_getValue.js'
			}
		],
		'../node_modules/lodash/_nativeCreate.js': [
			function (require, module, exports) {
				var getNative = require('./_getNative');

				/* Built-in method references that are verified to be native. */
				var nativeCreate = getNative(Object, 'create');

				module.exports = nativeCreate;
			},
			{ './_getNative': '../node_modules/lodash/_getNative.js' }
		],
		'../node_modules/lodash/_hashClear.js': [
			function (require, module, exports) {
				var nativeCreate = require('./_nativeCreate');

				/**
				 * Removes all key-value entries from the hash.
				 *
				 * @private
				 * @name clear
				 * @memberOf Hash
				 */
				function hashClear() {
					this.__data__ = nativeCreate ? nativeCreate(null) : {};
					this.size = 0;
				}

				module.exports = hashClear;
			},
			{ './_nativeCreate': '../node_modules/lodash/_nativeCreate.js' }
		],
		'../node_modules/lodash/_hashDelete.js': [
			function (require, module, exports) {
				/**
				 * Removes `key` and its value from the hash.
				 *
				 * @private
				 * @name delete
				 * @memberOf Hash
				 * @param {Object} hash The hash to modify.
				 * @param {string} key The key of the value to remove.
				 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
				 */
				function hashDelete(key) {
					var result = this.has(key) && delete this.__data__[key];
					this.size -= result ? 1 : 0;
					return result;
				}

				module.exports = hashDelete;
			},
			{}
		],
		'../node_modules/lodash/_hashGet.js': [
			function (require, module, exports) {
				var nativeCreate = require('./_nativeCreate');

				/** Used to stand-in for `undefined` hash values. */
				var HASH_UNDEFINED = '__lodash_hash_undefined__';

				/** Used for built-in method references. */
				var objectProto = Object.prototype;

				/** Used to check objects for own properties. */
				var hasOwnProperty = objectProto.hasOwnProperty;

				/**
				 * Gets the hash value for `key`.
				 *
				 * @private
				 * @name get
				 * @memberOf Hash
				 * @param {string} key The key of the value to get.
				 * @returns {*} Returns the entry value.
				 */
				function hashGet(key) {
					var data = this.__data__;
					if (nativeCreate) {
						var result = data[key];
						return result === HASH_UNDEFINED ? undefined : result;
					}
					return hasOwnProperty.call(data, key) ? data[key] : undefined;
				}

				module.exports = hashGet;
			},
			{ './_nativeCreate': '../node_modules/lodash/_nativeCreate.js' }
		],
		'../node_modules/lodash/_hashHas.js': [
			function (require, module, exports) {
				var nativeCreate = require('./_nativeCreate');

				/** Used for built-in method references. */
				var objectProto = Object.prototype;

				/** Used to check objects for own properties. */
				var hasOwnProperty = objectProto.hasOwnProperty;

				/**
				 * Checks if a hash value for `key` exists.
				 *
				 * @private
				 * @name has
				 * @memberOf Hash
				 * @param {string} key The key of the entry to check.
				 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
				 */
				function hashHas(key) {
					var data = this.__data__;
					return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
				}

				module.exports = hashHas;
			},
			{ './_nativeCreate': '../node_modules/lodash/_nativeCreate.js' }
		],
		'../node_modules/lodash/_hashSet.js': [
			function (require, module, exports) {
				var nativeCreate = require('./_nativeCreate');

				/** Used to stand-in for `undefined` hash values. */
				var HASH_UNDEFINED = '__lodash_hash_undefined__';

				/**
				 * Sets the hash `key` to `value`.
				 *
				 * @private
				 * @name set
				 * @memberOf Hash
				 * @param {string} key The key of the value to set.
				 * @param {*} value The value to set.
				 * @returns {Object} Returns the hash instance.
				 */
				function hashSet(key, value) {
					var data = this.__data__;
					this.size += this.has(key) ? 0 : 1;
					data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
					return this;
				}

				module.exports = hashSet;
			},
			{ './_nativeCreate': '../node_modules/lodash/_nativeCreate.js' }
		],
		'../node_modules/lodash/_Hash.js': [
			function (require, module, exports) {
				var hashClear = require('./_hashClear'),
					hashDelete = require('./_hashDelete'),
					hashGet = require('./_hashGet'),
					hashHas = require('./_hashHas'),
					hashSet = require('./_hashSet');

				/**
				 * Creates a hash object.
				 *
				 * @private
				 * @constructor
				 * @param {Array} [entries] The key-value pairs to cache.
				 */
				function Hash(entries) {
					var index = -1,
						length = entries == null ? 0 : entries.length;

					this.clear();
					while (++index < length) {
						var entry = entries[index];
						this.set(entry[0], entry[1]);
					}
				}

				// Add methods to `Hash`.
				Hash.prototype.clear = hashClear;
				Hash.prototype['delete'] = hashDelete;
				Hash.prototype.get = hashGet;
				Hash.prototype.has = hashHas;
				Hash.prototype.set = hashSet;

				module.exports = Hash;
			},
			{
				'./_hashClear': '../node_modules/lodash/_hashClear.js',
				'./_hashDelete': '../node_modules/lodash/_hashDelete.js',
				'./_hashGet': '../node_modules/lodash/_hashGet.js',
				'./_hashHas': '../node_modules/lodash/_hashHas.js',
				'./_hashSet': '../node_modules/lodash/_hashSet.js'
			}
		],
		'../node_modules/lodash/_listCacheClear.js': [
			function (require, module, exports) {
				/**
				 * Removes all key-value entries from the list cache.
				 *
				 * @private
				 * @name clear
				 * @memberOf ListCache
				 */
				function listCacheClear() {
					this.__data__ = [];
					this.size = 0;
				}

				module.exports = listCacheClear;
			},
			{}
		],
		'../node_modules/lodash/eq.js': [
			function (require, module, exports) {
				/**
				 * Performs a
				 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
				 * comparison between two values to determine if they are equivalent.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to compare.
				 * @param {*} other The other value to compare.
				 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
				 * @example
				 *
				 * var object = { 'a': 1 };
				 * var other = { 'a': 1 };
				 *
				 * _.eq(object, object);
				 * // => true
				 *
				 * _.eq(object, other);
				 * // => false
				 *
				 * _.eq('a', 'a');
				 * // => true
				 *
				 * _.eq('a', Object('a'));
				 * // => false
				 *
				 * _.eq(NaN, NaN);
				 * // => true
				 */
				function eq(value, other) {
					return value === other || (value !== value && other !== other);
				}

				module.exports = eq;
			},
			{}
		],
		'../node_modules/lodash/_assocIndexOf.js': [
			function (require, module, exports) {
				var eq = require('./eq');

				/**
				 * Gets the index at which the `key` is found in `array` of key-value pairs.
				 *
				 * @private
				 * @param {Array} array The array to inspect.
				 * @param {*} key The key to search for.
				 * @returns {number} Returns the index of the matched value, else `-1`.
				 */
				function assocIndexOf(array, key) {
					var length = array.length;
					while (length--) {
						if (eq(array[length][0], key)) {
							return length;
						}
					}
					return -1;
				}

				module.exports = assocIndexOf;
			},
			{ './eq': '../node_modules/lodash/eq.js' }
		],
		'../node_modules/lodash/_listCacheDelete.js': [
			function (require, module, exports) {
				var assocIndexOf = require('./_assocIndexOf');

				/** Used for built-in method references. */
				var arrayProto = Array.prototype;

				/** Built-in value references. */
				var splice = arrayProto.splice;

				/**
				 * Removes `key` and its value from the list cache.
				 *
				 * @private
				 * @name delete
				 * @memberOf ListCache
				 * @param {string} key The key of the value to remove.
				 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
				 */
				function listCacheDelete(key) {
					var data = this.__data__,
						index = assocIndexOf(data, key);

					if (index < 0) {
						return false;
					}
					var lastIndex = data.length - 1;
					if (index == lastIndex) {
						data.pop();
					} else {
						splice.call(data, index, 1);
					}
					--this.size;
					return true;
				}

				module.exports = listCacheDelete;
			},
			{ './_assocIndexOf': '../node_modules/lodash/_assocIndexOf.js' }
		],
		'../node_modules/lodash/_listCacheGet.js': [
			function (require, module, exports) {
				var assocIndexOf = require('./_assocIndexOf');

				/**
				 * Gets the list cache value for `key`.
				 *
				 * @private
				 * @name get
				 * @memberOf ListCache
				 * @param {string} key The key of the value to get.
				 * @returns {*} Returns the entry value.
				 */
				function listCacheGet(key) {
					var data = this.__data__,
						index = assocIndexOf(data, key);

					return index < 0 ? undefined : data[index][1];
				}

				module.exports = listCacheGet;
			},
			{ './_assocIndexOf': '../node_modules/lodash/_assocIndexOf.js' }
		],
		'../node_modules/lodash/_listCacheHas.js': [
			function (require, module, exports) {
				var assocIndexOf = require('./_assocIndexOf');

				/**
				 * Checks if a list cache value for `key` exists.
				 *
				 * @private
				 * @name has
				 * @memberOf ListCache
				 * @param {string} key The key of the entry to check.
				 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
				 */
				function listCacheHas(key) {
					return assocIndexOf(this.__data__, key) > -1;
				}

				module.exports = listCacheHas;
			},
			{ './_assocIndexOf': '../node_modules/lodash/_assocIndexOf.js' }
		],
		'../node_modules/lodash/_listCacheSet.js': [
			function (require, module, exports) {
				var assocIndexOf = require('./_assocIndexOf');

				/**
				 * Sets the list cache `key` to `value`.
				 *
				 * @private
				 * @name set
				 * @memberOf ListCache
				 * @param {string} key The key of the value to set.
				 * @param {*} value The value to set.
				 * @returns {Object} Returns the list cache instance.
				 */
				function listCacheSet(key, value) {
					var data = this.__data__,
						index = assocIndexOf(data, key);

					if (index < 0) {
						++this.size;
						data.push([key, value]);
					} else {
						data[index][1] = value;
					}
					return this;
				}

				module.exports = listCacheSet;
			},
			{ './_assocIndexOf': '../node_modules/lodash/_assocIndexOf.js' }
		],
		'../node_modules/lodash/_ListCache.js': [
			function (require, module, exports) {
				var listCacheClear = require('./_listCacheClear'),
					listCacheDelete = require('./_listCacheDelete'),
					listCacheGet = require('./_listCacheGet'),
					listCacheHas = require('./_listCacheHas'),
					listCacheSet = require('./_listCacheSet');

				/**
				 * Creates an list cache object.
				 *
				 * @private
				 * @constructor
				 * @param {Array} [entries] The key-value pairs to cache.
				 */
				function ListCache(entries) {
					var index = -1,
						length = entries == null ? 0 : entries.length;

					this.clear();
					while (++index < length) {
						var entry = entries[index];
						this.set(entry[0], entry[1]);
					}
				}

				// Add methods to `ListCache`.
				ListCache.prototype.clear = listCacheClear;
				ListCache.prototype['delete'] = listCacheDelete;
				ListCache.prototype.get = listCacheGet;
				ListCache.prototype.has = listCacheHas;
				ListCache.prototype.set = listCacheSet;

				module.exports = ListCache;
			},
			{
				'./_listCacheClear': '../node_modules/lodash/_listCacheClear.js',
				'./_listCacheDelete': '../node_modules/lodash/_listCacheDelete.js',
				'./_listCacheGet': '../node_modules/lodash/_listCacheGet.js',
				'./_listCacheHas': '../node_modules/lodash/_listCacheHas.js',
				'./_listCacheSet': '../node_modules/lodash/_listCacheSet.js'
			}
		],
		'../node_modules/lodash/_Map.js': [
			function (require, module, exports) {
				var getNative = require('./_getNative'),
					root = require('./_root');

				/* Built-in method references that are verified to be native. */
				var Map = getNative(root, 'Map');

				module.exports = Map;
			},
			{
				'./_getNative': '../node_modules/lodash/_getNative.js',
				'./_root': '../node_modules/lodash/_root.js'
			}
		],
		'../node_modules/lodash/_mapCacheClear.js': [
			function (require, module, exports) {
				var Hash = require('./_Hash'),
					ListCache = require('./_ListCache'),
					Map = require('./_Map');

				/**
				 * Removes all key-value entries from the map.
				 *
				 * @private
				 * @name clear
				 * @memberOf MapCache
				 */
				function mapCacheClear() {
					this.size = 0;
					this.__data__ = {
						hash: new Hash(),
						map: new (Map || ListCache)(),
						string: new Hash()
					};
				}

				module.exports = mapCacheClear;
			},
			{
				'./_Hash': '../node_modules/lodash/_Hash.js',
				'./_ListCache': '../node_modules/lodash/_ListCache.js',
				'./_Map': '../node_modules/lodash/_Map.js'
			}
		],
		'../node_modules/lodash/_isKeyable.js': [
			function (require, module, exports) {
				/**
				 * Checks if `value` is suitable for use as unique object key.
				 *
				 * @private
				 * @param {*} value The value to check.
				 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
				 */
				function isKeyable(value) {
					var type = typeof value;
					return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean'
						? value !== '__proto__'
						: value === null;
				}

				module.exports = isKeyable;
			},
			{}
		],
		'../node_modules/lodash/_getMapData.js': [
			function (require, module, exports) {
				var isKeyable = require('./_isKeyable');

				/**
				 * Gets the data for `map`.
				 *
				 * @private
				 * @param {Object} map The map to query.
				 * @param {string} key The reference key.
				 * @returns {*} Returns the map data.
				 */
				function getMapData(map, key) {
					var data = map.__data__;
					return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
				}

				module.exports = getMapData;
			},
			{ './_isKeyable': '../node_modules/lodash/_isKeyable.js' }
		],
		'../node_modules/lodash/_mapCacheDelete.js': [
			function (require, module, exports) {
				var getMapData = require('./_getMapData');

				/**
				 * Removes `key` and its value from the map.
				 *
				 * @private
				 * @name delete
				 * @memberOf MapCache
				 * @param {string} key The key of the value to remove.
				 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
				 */
				function mapCacheDelete(key) {
					var result = getMapData(this, key)['delete'](key);
					this.size -= result ? 1 : 0;
					return result;
				}

				module.exports = mapCacheDelete;
			},
			{ './_getMapData': '../node_modules/lodash/_getMapData.js' }
		],
		'../node_modules/lodash/_mapCacheGet.js': [
			function (require, module, exports) {
				var getMapData = require('./_getMapData');

				/**
				 * Gets the map value for `key`.
				 *
				 * @private
				 * @name get
				 * @memberOf MapCache
				 * @param {string} key The key of the value to get.
				 * @returns {*} Returns the entry value.
				 */
				function mapCacheGet(key) {
					return getMapData(this, key).get(key);
				}

				module.exports = mapCacheGet;
			},
			{ './_getMapData': '../node_modules/lodash/_getMapData.js' }
		],
		'../node_modules/lodash/_mapCacheHas.js': [
			function (require, module, exports) {
				var getMapData = require('./_getMapData');

				/**
				 * Checks if a map value for `key` exists.
				 *
				 * @private
				 * @name has
				 * @memberOf MapCache
				 * @param {string} key The key of the entry to check.
				 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
				 */
				function mapCacheHas(key) {
					return getMapData(this, key).has(key);
				}

				module.exports = mapCacheHas;
			},
			{ './_getMapData': '../node_modules/lodash/_getMapData.js' }
		],
		'../node_modules/lodash/_mapCacheSet.js': [
			function (require, module, exports) {
				var getMapData = require('./_getMapData');

				/**
				 * Sets the map `key` to `value`.
				 *
				 * @private
				 * @name set
				 * @memberOf MapCache
				 * @param {string} key The key of the value to set.
				 * @param {*} value The value to set.
				 * @returns {Object} Returns the map cache instance.
				 */
				function mapCacheSet(key, value) {
					var data = getMapData(this, key),
						size = data.size;

					data.set(key, value);
					this.size += data.size == size ? 0 : 1;
					return this;
				}

				module.exports = mapCacheSet;
			},
			{ './_getMapData': '../node_modules/lodash/_getMapData.js' }
		],
		'../node_modules/lodash/_MapCache.js': [
			function (require, module, exports) {
				var mapCacheClear = require('./_mapCacheClear'),
					mapCacheDelete = require('./_mapCacheDelete'),
					mapCacheGet = require('./_mapCacheGet'),
					mapCacheHas = require('./_mapCacheHas'),
					mapCacheSet = require('./_mapCacheSet');

				/**
				 * Creates a map cache object to store key-value pairs.
				 *
				 * @private
				 * @constructor
				 * @param {Array} [entries] The key-value pairs to cache.
				 */
				function MapCache(entries) {
					var index = -1,
						length = entries == null ? 0 : entries.length;

					this.clear();
					while (++index < length) {
						var entry = entries[index];
						this.set(entry[0], entry[1]);
					}
				}

				// Add methods to `MapCache`.
				MapCache.prototype.clear = mapCacheClear;
				MapCache.prototype['delete'] = mapCacheDelete;
				MapCache.prototype.get = mapCacheGet;
				MapCache.prototype.has = mapCacheHas;
				MapCache.prototype.set = mapCacheSet;

				module.exports = MapCache;
			},
			{
				'./_mapCacheClear': '../node_modules/lodash/_mapCacheClear.js',
				'./_mapCacheDelete': '../node_modules/lodash/_mapCacheDelete.js',
				'./_mapCacheGet': '../node_modules/lodash/_mapCacheGet.js',
				'./_mapCacheHas': '../node_modules/lodash/_mapCacheHas.js',
				'./_mapCacheSet': '../node_modules/lodash/_mapCacheSet.js'
			}
		],
		'../node_modules/lodash/memoize.js': [
			function (require, module, exports) {
				var MapCache = require('./_MapCache');

				/** Error message constants. */
				var FUNC_ERROR_TEXT = 'Expected a function';

				/**
				 * Creates a function that memoizes the result of `func`. If `resolver` is
				 * provided, it determines the cache key for storing the result based on the
				 * arguments provided to the memoized function. By default, the first argument
				 * provided to the memoized function is used as the map cache key. The `func`
				 * is invoked with the `this` binding of the memoized function.
				 *
				 * **Note:** The cache is exposed as the `cache` property on the memoized
				 * function. Its creation may be customized by replacing the `_.memoize.Cache`
				 * constructor with one whose instances implement the
				 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
				 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
				 *
				 * @static
				 * @memberOf _
				 * @since 0.1.0
				 * @category Function
				 * @param {Function} func The function to have its output memoized.
				 * @param {Function} [resolver] The function to resolve the cache key.
				 * @returns {Function} Returns the new memoized function.
				 * @example
				 *
				 * var object = { 'a': 1, 'b': 2 };
				 * var other = { 'c': 3, 'd': 4 };
				 *
				 * var values = _.memoize(_.values);
				 * values(object);
				 * // => [1, 2]
				 *
				 * values(other);
				 * // => [3, 4]
				 *
				 * object.a = 2;
				 * values(object);
				 * // => [1, 2]
				 *
				 * // Modify the result cache.
				 * values.cache.set(object, ['a', 'b']);
				 * values(object);
				 * // => ['a', 'b']
				 *
				 * // Replace `_.memoize.Cache`.
				 * _.memoize.Cache = WeakMap;
				 */
				function memoize(func, resolver) {
					if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
						throw new TypeError(FUNC_ERROR_TEXT);
					}
					var memoized = function () {
						var args = arguments,
							key = resolver ? resolver.apply(this, args) : args[0],
							cache = memoized.cache;

						if (cache.has(key)) {
							return cache.get(key);
						}
						var result = func.apply(this, args);
						memoized.cache = cache.set(key, result) || cache;
						return result;
					};
					memoized.cache = new (memoize.Cache || MapCache)();
					return memoized;
				}

				// Expose `MapCache`.
				memoize.Cache = MapCache;

				module.exports = memoize;
			},
			{ './_MapCache': '../node_modules/lodash/_MapCache.js' }
		],
		'../node_modules/lodash/_memoizeCapped.js': [
			function (require, module, exports) {
				var memoize = require('./memoize');

				/** Used as the maximum memoize cache size. */
				var MAX_MEMOIZE_SIZE = 500;

				/**
				 * A specialized version of `_.memoize` which clears the memoized function's
				 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
				 *
				 * @private
				 * @param {Function} func The function to have its output memoized.
				 * @returns {Function} Returns the new memoized function.
				 */
				function memoizeCapped(func) {
					var result = memoize(func, function (key) {
						if (cache.size === MAX_MEMOIZE_SIZE) {
							cache.clear();
						}
						return key;
					});

					var cache = result.cache;
					return result;
				}

				module.exports = memoizeCapped;
			},
			{ './memoize': '../node_modules/lodash/memoize.js' }
		],
		'../node_modules/lodash/_stringToPath.js': [
			function (require, module, exports) {
				var memoizeCapped = require('./_memoizeCapped');

				/** Used to match property names within property paths. */
				var rePropName =
					/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

				/** Used to match backslashes in property paths. */
				var reEscapeChar = /\\(\\)?/g;

				/**
				 * Converts `string` to a property path array.
				 *
				 * @private
				 * @param {string} string The string to convert.
				 * @returns {Array} Returns the property path array.
				 */
				var stringToPath = memoizeCapped(function (string) {
					var result = [];
					if (string.charCodeAt(0) === 46 /* . */) {
						result.push('');
					}
					string.replace(rePropName, function (match, number, quote, subString) {
						result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
					});
					return result;
				});

				module.exports = stringToPath;
			},
			{ './_memoizeCapped': '../node_modules/lodash/_memoizeCapped.js' }
		],
		'../node_modules/lodash/_arrayMap.js': [
			function (require, module, exports) {
				/**
				 * A specialized version of `_.map` for arrays without support for iteratee
				 * shorthands.
				 *
				 * @private
				 * @param {Array} [array] The array to iterate over.
				 * @param {Function} iteratee The function invoked per iteration.
				 * @returns {Array} Returns the new mapped array.
				 */
				function arrayMap(array, iteratee) {
					var index = -1,
						length = array == null ? 0 : array.length,
						result = Array(length);

					while (++index < length) {
						result[index] = iteratee(array[index], index, array);
					}
					return result;
				}

				module.exports = arrayMap;
			},
			{}
		],
		'../node_modules/lodash/_baseToString.js': [
			function (require, module, exports) {
				var Symbol = require('./_Symbol'),
					arrayMap = require('./_arrayMap'),
					isArray = require('./isArray'),
					isSymbol = require('./isSymbol');

				/** Used as references for various `Number` constants. */
				var INFINITY = 1 / 0;

				/** Used to convert symbols to primitives and strings. */
				var symbolProto = Symbol ? Symbol.prototype : undefined,
					symbolToString = symbolProto ? symbolProto.toString : undefined;

				/**
				 * The base implementation of `_.toString` which doesn't convert nullish
				 * values to empty strings.
				 *
				 * @private
				 * @param {*} value The value to process.
				 * @returns {string} Returns the string.
				 */
				function baseToString(value) {
					// Exit early for strings to avoid a performance hit in some environments.
					if (typeof value == 'string') {
						return value;
					}
					if (isArray(value)) {
						// Recursively convert values (susceptible to call stack limits).
						return arrayMap(value, baseToString) + '';
					}
					if (isSymbol(value)) {
						return symbolToString ? symbolToString.call(value) : '';
					}
					var result = value + '';
					return result == '0' && 1 / value == -INFINITY ? '-0' : result;
				}

				module.exports = baseToString;
			},
			{
				'./_Symbol': '../node_modules/lodash/_Symbol.js',
				'./_arrayMap': '../node_modules/lodash/_arrayMap.js',
				'./isArray': '../node_modules/lodash/isArray.js',
				'./isSymbol': '../node_modules/lodash/isSymbol.js'
			}
		],
		'../node_modules/lodash/toString.js': [
			function (require, module, exports) {
				var baseToString = require('./_baseToString');

				/**
				 * Converts `value` to a string. An empty string is returned for `null`
				 * and `undefined` values. The sign of `-0` is preserved.
				 *
				 * @static
				 * @memberOf _
				 * @since 4.0.0
				 * @category Lang
				 * @param {*} value The value to convert.
				 * @returns {string} Returns the converted string.
				 * @example
				 *
				 * _.toString(null);
				 * // => ''
				 *
				 * _.toString(-0);
				 * // => '-0'
				 *
				 * _.toString([1, 2, 3]);
				 * // => '1,2,3'
				 */
				function toString(value) {
					return value == null ? '' : baseToString(value);
				}

				module.exports = toString;
			},
			{ './_baseToString': '../node_modules/lodash/_baseToString.js' }
		],
		'../node_modules/lodash/_castPath.js': [
			function (require, module, exports) {
				var isArray = require('./isArray'),
					isKey = require('./_isKey'),
					stringToPath = require('./_stringToPath'),
					toString = require('./toString');

				/**
				 * Casts `value` to a path array if it's not one.
				 *
				 * @private
				 * @param {*} value The value to inspect.
				 * @param {Object} [object] The object to query keys on.
				 * @returns {Array} Returns the cast property path array.
				 */
				function castPath(value, object) {
					if (isArray(value)) {
						return value;
					}
					return isKey(value, object) ? [value] : stringToPath(toString(value));
				}

				module.exports = castPath;
			},
			{
				'./isArray': '../node_modules/lodash/isArray.js',
				'./_isKey': '../node_modules/lodash/_isKey.js',
				'./_stringToPath': '../node_modules/lodash/_stringToPath.js',
				'./toString': '../node_modules/lodash/toString.js'
			}
		],
		'../node_modules/lodash/_toKey.js': [
			function (require, module, exports) {
				var isSymbol = require('./isSymbol');

				/** Used as references for various `Number` constants. */
				var INFINITY = 1 / 0;

				/**
				 * Converts `value` to a string key if it's not a string or symbol.
				 *
				 * @private
				 * @param {*} value The value to inspect.
				 * @returns {string|symbol} Returns the key.
				 */
				function toKey(value) {
					if (typeof value == 'string' || isSymbol(value)) {
						return value;
					}
					var result = value + '';
					return result == '0' && 1 / value == -INFINITY ? '-0' : result;
				}

				module.exports = toKey;
			},
			{ './isSymbol': '../node_modules/lodash/isSymbol.js' }
		],
		'../node_modules/lodash/_baseGet.js': [
			function (require, module, exports) {
				var castPath = require('./_castPath'),
					toKey = require('./_toKey');

				/**
				 * The base implementation of `_.get` without support for default values.
				 *
				 * @private
				 * @param {Object} object The object to query.
				 * @param {Array|string} path The path of the property to get.
				 * @returns {*} Returns the resolved value.
				 */
				function baseGet(object, path) {
					path = castPath(path, object);

					var index = 0,
						length = path.length;

					while (object != null && index < length) {
						object = object[toKey(path[index++])];
					}
					return index && index == length ? object : undefined;
				}

				module.exports = baseGet;
			},
			{
				'./_castPath': '../node_modules/lodash/_castPath.js',
				'./_toKey': '../node_modules/lodash/_toKey.js'
			}
		],
		'../node_modules/lodash/get.js': [
			function (require, module, exports) {
				var baseGet = require('./_baseGet');

				/**
				 * Gets the value at `path` of `object`. If the resolved value is
				 * `undefined`, the `defaultValue` is returned in its place.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.7.0
				 * @category Object
				 * @param {Object} object The object to query.
				 * @param {Array|string} path The path of the property to get.
				 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
				 * @returns {*} Returns the resolved value.
				 * @example
				 *
				 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
				 *
				 * _.get(object, 'a[0].b.c');
				 * // => 3
				 *
				 * _.get(object, ['a', '0', 'b', 'c']);
				 * // => 3
				 *
				 * _.get(object, 'a.b.c', 'default');
				 * // => 'default'
				 */
				function get(object, path, defaultValue) {
					var result = object == null ? undefined : baseGet(object, path);
					return result === undefined ? defaultValue : result;
				}

				module.exports = get;
			},
			{ './_baseGet': '../node_modules/lodash/_baseGet.js' }
		],
		'../node_modules/lodash/_defineProperty.js': [
			function (require, module, exports) {
				var getNative = require('./_getNative');

				var defineProperty = (function () {
					try {
						var func = getNative(Object, 'defineProperty');
						func({}, '', {});
						return func;
					} catch (e) {}
				})();

				module.exports = defineProperty;
			},
			{ './_getNative': '../node_modules/lodash/_getNative.js' }
		],
		'../node_modules/lodash/_baseAssignValue.js': [
			function (require, module, exports) {
				var defineProperty = require('./_defineProperty');

				/**
				 * The base implementation of `assignValue` and `assignMergeValue` without
				 * value checks.
				 *
				 * @private
				 * @param {Object} object The object to modify.
				 * @param {string} key The key of the property to assign.
				 * @param {*} value The value to assign.
				 */
				function baseAssignValue(object, key, value) {
					if (key == '__proto__' && defineProperty) {
						defineProperty(object, key, {
							configurable: true,
							enumerable: true,
							value: value,
							writable: true
						});
					} else {
						object[key] = value;
					}
				}

				module.exports = baseAssignValue;
			},
			{ './_defineProperty': '../node_modules/lodash/_defineProperty.js' }
		],
		'../node_modules/lodash/_assignValue.js': [
			function (require, module, exports) {
				var baseAssignValue = require('./_baseAssignValue'),
					eq = require('./eq');

				/** Used for built-in method references. */
				var objectProto = Object.prototype;

				/** Used to check objects for own properties. */
				var hasOwnProperty = objectProto.hasOwnProperty;

				/**
				 * Assigns `value` to `key` of `object` if the existing value is not equivalent
				 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
				 * for equality comparisons.
				 *
				 * @private
				 * @param {Object} object The object to modify.
				 * @param {string} key The key of the property to assign.
				 * @param {*} value The value to assign.
				 */
				function assignValue(object, key, value) {
					var objValue = object[key];
					if (
						!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
						(value === undefined && !(key in object))
					) {
						baseAssignValue(object, key, value);
					}
				}

				module.exports = assignValue;
			},
			{
				'./_baseAssignValue': '../node_modules/lodash/_baseAssignValue.js',
				'./eq': '../node_modules/lodash/eq.js'
			}
		],
		'../node_modules/lodash/_isIndex.js': [
			function (require, module, exports) {
				/** Used as references for various `Number` constants. */
				var MAX_SAFE_INTEGER = 9007199254740991;

				/** Used to detect unsigned integer values. */
				var reIsUint = /^(?:0|[1-9]\d*)$/;

				/**
				 * Checks if `value` is a valid array-like index.
				 *
				 * @private
				 * @param {*} value The value to check.
				 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
				 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
				 */
				function isIndex(value, length) {
					var type = typeof value;
					length = length == null ? MAX_SAFE_INTEGER : length;

					return (
						!!length &&
						(type == 'number' || (type != 'symbol' && reIsUint.test(value))) &&
						value > -1 &&
						value % 1 == 0 &&
						value < length
					);
				}

				module.exports = isIndex;
			},
			{}
		],
		'../node_modules/lodash/_baseSet.js': [
			function (require, module, exports) {
				var assignValue = require('./_assignValue'),
					castPath = require('./_castPath'),
					isIndex = require('./_isIndex'),
					isObject = require('./isObject'),
					toKey = require('./_toKey');

				/**
				 * The base implementation of `_.set`.
				 *
				 * @private
				 * @param {Object} object The object to modify.
				 * @param {Array|string} path The path of the property to set.
				 * @param {*} value The value to set.
				 * @param {Function} [customizer] The function to customize path creation.
				 * @returns {Object} Returns `object`.
				 */
				function baseSet(object, path, value, customizer) {
					if (!isObject(object)) {
						return object;
					}
					path = castPath(path, object);

					var index = -1,
						length = path.length,
						lastIndex = length - 1,
						nested = object;

					while (nested != null && ++index < length) {
						var key = toKey(path[index]),
							newValue = value;

						if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
							return object;
						}

						if (index != lastIndex) {
							var objValue = nested[key];
							newValue = customizer ? customizer(objValue, key, nested) : undefined;
							if (newValue === undefined) {
								newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
							}
						}
						assignValue(nested, key, newValue);
						nested = nested[key];
					}
					return object;
				}

				module.exports = baseSet;
			},
			{
				'./_assignValue': '../node_modules/lodash/_assignValue.js',
				'./_castPath': '../node_modules/lodash/_castPath.js',
				'./_isIndex': '../node_modules/lodash/_isIndex.js',
				'./isObject': '../node_modules/lodash/isObject.js',
				'./_toKey': '../node_modules/lodash/_toKey.js'
			}
		],
		'../node_modules/lodash/set.js': [
			function (require, module, exports) {
				var baseSet = require('./_baseSet');

				/**
				 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
				 * it's created. Arrays are created for missing index properties while objects
				 * are created for all other missing properties. Use `_.setWith` to customize
				 * `path` creation.
				 *
				 * **Note:** This method mutates `object`.
				 *
				 * @static
				 * @memberOf _
				 * @since 3.7.0
				 * @category Object
				 * @param {Object} object The object to modify.
				 * @param {Array|string} path The path of the property to set.
				 * @param {*} value The value to set.
				 * @returns {Object} Returns `object`.
				 * @example
				 *
				 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
				 *
				 * _.set(object, 'a[0].b.c', 4);
				 * console.log(object.a[0].b.c);
				 * // => 4
				 *
				 * _.set(object, ['x', '0', 'y', 'z'], 5);
				 * console.log(object.x[0].y.z);
				 * // => 5
				 */
				function set(object, path, value) {
					return object == null ? object : baseSet(object, path, value);
				}

				module.exports = set;
			},
			{ './_baseSet': '../node_modules/lodash/_baseSet.js' }
		],
		'../node_modules/@taquito/rpc/dist/taquito-rpc.es5.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.castToBigNumber = castToBigNumber;
				exports.defaultRPCOptions =
					exports.defaultChain =
					exports.VERSION =
					exports.RpcClientCache =
					exports.RpcClient =
					exports.OpKind =
						void 0;

				var _httpUtils = require('@taquito/http-utils');

				var _bignumber = _interopRequireDefault(require('bignumber.js'));

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj };
				}

				function _typeof(obj) {
					if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
						_typeof = function (obj) {
							return typeof obj;
						};
					} else {
						_typeof = function (obj) {
							return obj &&
								typeof Symbol === 'function' &&
								obj.constructor === Symbol &&
								obj !== Symbol.prototype
								? 'symbol'
								: typeof obj;
						};
					}
					return _typeof(obj);
				}

				/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
				var __assign = function () {
					__assign =
						Object.assign ||
						function __assign(t) {
							for (var s, i = 1, n = arguments.length; i < n; i++) {
								s = arguments[i];

								for (var p in s) {
									if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
								}
							}

							return t;
						};

					return __assign.apply(this, arguments);
				};

				function __rest(s, e) {
					var t = {};

					for (var p in s) {
						if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
					}

					if (s != null && typeof Object.getOwnPropertySymbols === 'function')
						for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
							if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
								t[p[i]] = s[p[i]];
						}
					return t;
				}

				function __awaiter(thisArg, _arguments, P, generator) {
					function adopt(value) {
						return value instanceof P
							? value
							: new P(function (resolve) {
									resolve(value);
							  });
					}

					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) {
							try {
								step(generator.next(value));
							} catch (e) {
								reject(e);
							}
						}

						function rejected(value) {
							try {
								step(generator['throw'](value));
							} catch (e) {
								reject(e);
							}
						}

						function step(result) {
							result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
						}

						step((generator = generator.apply(thisArg, _arguments || [])).next());
					});
				}

				function __generator(thisArg, body) {
					var _ = {
							label: 0,
							sent: function () {
								if (t[0] & 1) throw t[1];
								return t[1];
							},
							trys: [],
							ops: []
						},
						f,
						y,
						t,
						g;
					return (
						(g = {
							next: verb(0),
							throw: verb(1),
							return: verb(2)
						}),
						typeof Symbol === 'function' &&
							(g[Symbol.iterator] = function () {
								return this;
							}),
						g
					);

					function verb(n) {
						return function (v) {
							return step([n, v]);
						};
					}

					function step(op) {
						if (f) throw new TypeError('Generator is already executing.');

						while (_) {
							try {
								if (
									((f = 1),
									y &&
										(t =
											op[0] & 2
												? y['return']
												: op[0]
												? y['throw'] || ((t = y['return']) && t.call(y), 0)
												: y.next) &&
										!(t = t.call(y, op[1])).done)
								)
									return t;
								if (((y = 0), t)) op = [op[0] & 2, t.value];

								switch (op[0]) {
									case 0:
									case 1:
										t = op;
										break;

									case 4:
										_.label++;
										return {
											value: op[1],
											done: false
										};

									case 5:
										_.label++;
										y = op[1];
										op = [0];
										continue;

									case 7:
										op = _.ops.pop();

										_.trys.pop();

										continue;

									default:
										if (
											!((t = _.trys), (t = t.length > 0 && t[t.length - 1])) &&
											(op[0] === 6 || op[0] === 2)
										) {
											_ = 0;
											continue;
										}

										if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
											_.label = op[1];
											break;
										}

										if (op[0] === 6 && _.label < t[1]) {
											_.label = t[1];
											t = op;
											break;
										}

										if (t && _.label < t[2]) {
											_.label = t[2];

											_.ops.push(op);

											break;
										}

										if (t[2]) _.ops.pop();

										_.trys.pop();

										continue;
								}

								op = body.call(thisArg, _);
							} catch (e) {
								op = [6, e];
								y = 0;
							} finally {
								f = t = 0;
							}
						}

						if (op[0] & 5) throw op[1];
						return {
							value: op[0] ? op[1] : void 0,
							done: true
						};
					}
				}

				var defaultChain = 'main';
				exports.defaultChain = defaultChain;
				var defaultRPCOptions = {
					block: 'head'
				};
				exports.defaultRPCOptions = defaultRPCOptions;

				var getByPath = require('lodash/get');

				var setByPath = require('lodash/set');
				/**
				 * Casts object/array items to BigNumber
				 * keys support lodash path notation
				 * @param data input object or array
				 * @param keys keys for processing or all items if not defined
				 *
				 * @see https://lodash.com/docs/#get
				 *
				 */

				function castToBigNumber(data, keys) {
					var returnArray = Array.isArray(data);

					if (typeof keys === 'undefined') {
						keys = Object.keys(data);
					}

					var response = returnArray ? [] : {};
					keys.forEach(function (key) {
						var item = getByPath(data, key);
						var res;

						if (typeof item === 'undefined') {
							return;
						}

						if (Array.isArray(item)) {
							res = castToBigNumber(item);
							setByPath(response, key, res);
							return;
						}

						res = new _bignumber.default(item);
						setByPath(response, key, res);
					});
					return response;
				}

				var defaultTtl = 1000;
				/***
				 * @description RpcClientCache acts as a decorator over the RpcClient instance by caching responses for the period defined by the ttl.
				 */

				var RpcClientCache =
					/** @class */
					(function () {
						/**
						 *
						 * @param rpcClient rpcClient responsible of the interaction with Tezos network through an rpc node
						 * @param ttl number representing the time to live (default 1000 milliseconds)
						 *
						 * @example new RpcClientCache(new RpcClient('https://mainnet.api.tez.ie/'))
						 */
						function RpcClientCache(rpcClient, ttl) {
							if (ttl === void 0) {
								ttl = defaultTtl;
							}

							this.rpcClient = rpcClient;
							this.ttl = ttl;
							this._cache = {};
						}

						RpcClientCache.prototype.getAllCachedData = function () {
							return this._cache;
						};
						/**
						 * @description Remove all the data in the cache.
						 *
						 */

						RpcClientCache.prototype.deleteAllCachedData = function () {
							for (var key in this._cache) {
								delete this._cache[key];
							}
						};

						RpcClientCache.prototype.formatCacheKey = function (
							rpcUrl,
							rpcMethodName,
							rpcMethodParams,
							rpcMethodData
						) {
							var paramsToString = '';
							rpcMethodParams.forEach(function (param) {
								paramsToString =
									_typeof(param) === 'object'
										? paramsToString + JSON.stringify(param) + '/'
										: paramsToString + param + '/';
							});
							return rpcMethodData
								? rpcUrl +
										'/' +
										rpcMethodName +
										'/' +
										paramsToString +
										'/' +
										JSON.stringify(rpcMethodData)
								: rpcUrl + '/' + rpcMethodName + '/' + paramsToString;
						};

						RpcClientCache.prototype.has = function (key) {
							return key in this._cache;
						};

						RpcClientCache.prototype.get = function (key) {
							return this._cache[key].response;
						};

						RpcClientCache.prototype.put = function (key, response) {
							var _a;

							var _this = this;

							var handle = setTimeout(function () {
								return _this.remove(key);
							}, this.ttl);
							Object.assign(
								this._cache,
								((_a = {}),
								(_a[key] = {
									handle: handle,
									response: response
								}),
								_a)
							);
						};

						RpcClientCache.prototype.remove = function (key) {
							if (key in this._cache) {
								delete this._cache[key];
							}
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Get the block's hash, its unique identifier.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-hash
						 */

						RpcClientCache.prototype.getBlockHash = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getBlockHash', [
												block
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getBlockHash({
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description List the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-live-blocks
						 */

						RpcClientCache.prototype.getLiveBlocks = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getLiveBlocks', [
												block
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getLiveBlocks({
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param address address from which we want to retrieve the balance
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Access the balance of a contract.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-balance
						 */

						RpcClientCache.prototype.getBalance = function (address, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getBalance', [
												block,
												address
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getBalance(address, {
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param address contract address from which we want to retrieve the storage
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Access the data of the contract.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-storage
						 */

						RpcClientCache.prototype.getStorage = function (address, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getStorage', [
												block,
												address
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getStorage(address, {
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param address contract address from which we want to retrieve the script
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Access the code and data of the contract.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script
						 */

						RpcClientCache.prototype.getScript = function (address, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getScript', [
												block,
												address
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getScript(address, {
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param address contract address from which we want to retrieve
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Access the complete status of a contract.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id
						 */

						RpcClientCache.prototype.getContract = function (address, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getContract', [
												block,
												address
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getContract(address, {
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param address contract address from which we want to retrieve the manager
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Access the manager key of a contract.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-manager-key
						 */

						RpcClientCache.prototype.getManagerKey = function (address, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getManagerKey', [
												block,
												address
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getManagerKey(address, {
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param address contract address from which we want to retrieve the delegate (baker)
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Access the delegate of a contract, if any.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-delegate
						 */

						RpcClientCache.prototype.getDelegate = function (address, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getDelegate', [
												block,
												address
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getDelegate(address, {
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param address contract address from which we want to retrieve the big map key
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Access the value associated with a key in the big map storage of the contract.
						 *
						 * @deprecated Deprecated in favor of getBigMapKeyByID
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get
						 */

						RpcClientCache.prototype.getBigMapKey = function (address, key, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var keyUrl, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											keyUrl = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getBigMapKey', [
												block,
												address,
												key
											]);
											if (!this.has(keyUrl)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(keyUrl)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getBigMapKey(address, key, {
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(keyUrl, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param id Big Map ID
						 * @param expr Expression hash to query (A b58check encoded Blake2b hash of the expression (The expression can be packed using the pack_data method))
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Access the value associated with a key in a big map.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr
						 */

						RpcClientCache.prototype.getBigMapExpr = function (id, expr, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getBigMapExpr', [
												block,
												id,
												expr
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getBigMapExpr(id, expr, {
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param address delegate address which we want to retrieve
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Fetches information about a delegate from RPC.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-delegates-pkh
						 */

						RpcClientCache.prototype.getDelegates = function (address, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getDelegates', [
												block,
												address
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getDelegates(address, {
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description All constants
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-constants
						 */

						RpcClientCache.prototype.getConstants = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getConstants', [
												block
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getConstants({
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls. See examples for various available sytaxes.
						 *
						 * @description All the information about a block
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id
						 * @example getBlock() will default to /main/chains/block/head.
						 * @example getBlock({ block: head~2 }) will return an offset of 2 blocks.
						 * @example getBlock({ block: BL8fTiWcSxWCjiMVnDkbh6EuhqVPZzgWheJ2dqwrxYRm9AephXh~2 }) will return an offset of 2 blocks from given block hash..
						 */

						RpcClientCache.prototype.getBlock = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getBlock', [block]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getBlock({
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description The whole block header
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-header
						 */

						RpcClientCache.prototype.getBlockHeader = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getBlockHeader', [
												block
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getBlockHeader({
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description All the metadata associated to the block
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-metadata
						 */

						RpcClientCache.prototype.getBlockMetadata = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getBlockMetadata', [
												block
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getBlockMetadata({
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param args contains optional query arguments
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Retrieves the list of delegates allowed to bake a block.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-baking-rights
						 */

						RpcClientCache.prototype.getBakingRights = function (args, _a) {
							if (args === void 0) {
								args = {};
							}

							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getBakingRights', [
												block,
												args
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getBakingRights(args, {
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param args contains optional query arguments
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Retrieves the list of delegates allowed to bake a block.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-endorsing-rights
						 */

						RpcClientCache.prototype.getEndorsingRights = function (args, _a) {
							if (args === void 0) {
								args = {};
							}

							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getEndorsingRights', [
												block,
												args
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getEndorsingRights(args, {
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Ballots casted so far during a voting period
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballot-list
						 */

						RpcClientCache.prototype.getBallotList = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getBallotList', [
												block
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getBallotList({
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Sum of ballots casted so far during a voting period.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballots
						 */

						RpcClientCache.prototype.getBallots = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getBallots', [block]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getBallots({
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Current period kind.
						 *
						 * @deprecated Deprecated in favor of getCurrentPeriod
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-period-kind
						 */

						RpcClientCache.prototype.getCurrentPeriodKind = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(
												this.rpcClient.getRpcUrl(),
												'getCurrentPeriodKind',
												[block]
											);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getCurrentPeriodKind({
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Current proposal under evaluation.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-proposal
						 */

						RpcClientCache.prototype.getCurrentProposal = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getCurrentProposal', [
												block
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getCurrentProposal({
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Current expected quorum.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-quorum
						 */

						RpcClientCache.prototype.getCurrentQuorum = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getCurrentQuorum', [
												block
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getCurrentQuorum({
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description List of delegates with their voting weight, in number of rolls.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-listings
						 */

						RpcClientCache.prototype.getVotesListings = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getVotesListings', [
												block
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getVotesListings({
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description List of proposals with number of supporters.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-proposals
						 */

						RpcClientCache.prototype.getProposals = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getProposals', [
												block
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getProposals({
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param data operation contents to forge
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Forge an operation returning the unsigned bytes
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-forge-operations
						 */

						RpcClientCache.prototype.forgeOperations = function (data, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_c) {
									return [
										2,
										/*return*/
										this.rpcClient.forgeOperations(data, {
											block: block
										})
									];
								});
							});
						};
						/**
						 *
						 * @param signedOpBytes signed bytes to inject
						 *
						 * @description Inject an operation in node and broadcast it. Returns the ID of the operation. The `signedOperationContents` should be constructed using a contextual RPCs from the latest block and signed by the client. By default, the RPC will wait for the operation to be (pre-)validated before answering. See RPCs under /blocks/prevalidation for more details on the prevalidation context.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#post-injection-operation
						 */

						RpcClientCache.prototype.injectOperation = function (signedOpBytes) {
							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_a) {
									return [
										2,
										/*return*/
										this.rpcClient.injectOperation(signedOpBytes)
									];
								});
							});
						};
						/**
						 *
						 * @param ops Operations to apply
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Simulate the validation of an operation
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-preapply-operations
						 */

						RpcClientCache.prototype.preapplyOperations = function (ops, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_c) {
									return [
										2,
										/*return*/
										this.rpcClient.preapplyOperations(ops, {
											block: block
										})
									];
								});
							});
						};
						/**
						 *
						 * @param contract address of the contract we want to get the entrypoints of
						 *
						 * @description Return the list of entrypoints of the contract
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-entrypoints
						 *
						 * @version 005_PsBABY5H
						 */

						RpcClientCache.prototype.getEntrypoints = function (contract, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getEntrypoints', [
												block,
												contract
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getEntrypoints(contract, {
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 * @param op Operation to run
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Run an operation without signature checks
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-operation
						 */

						RpcClientCache.prototype.runOperation = function (op, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_c) {
									return [
										2,
										/*return*/
										this.rpcClient.runOperation(op, {
											block: block
										})
									];
								});
							});
						};
						/**
						 * @param code Code to run
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Run a piece of code in the current context
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-code
						 */

						RpcClientCache.prototype.runCode = function (code, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_c) {
									return [
										2,
										/*return*/
										this.rpcClient.runCode(code, {
											block: block
										})
									];
								});
							});
						};

						RpcClientCache.prototype.getChainId = function () {
							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getChainId', []);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getChainId()
											];

										case 2:
											response = _a.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param data Data to pack
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Computes the serialized version of a data expression using the same algorithm as script instruction PACK
						 *
						 * @example packData({ data: { string: "test" }, type: { prim: "string" } })
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-pack-data
						 */

						RpcClientCache.prototype.packData = function (data, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'packData', [
												block,
												data
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.packData(data, {
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @description Return rpc root url
						 */

						RpcClientCache.prototype.getRpcUrl = function () {
							return this.rpcClient.getRpcUrl();
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Voting period of current block.
						 *
						 * @example getCurrentPeriod() will default to current voting period for /main/chains/block/head.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-period
						 */

						RpcClientCache.prototype.getCurrentPeriod = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getCurrentPeriod', [
												block
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getCurrentPeriod({
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Voting period of next block.
						 *
						 * @example getSuccessorPeriod() will default to successor voting period for /main/chains/block/head.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-successor-period
						 */

						RpcClientCache.prototype.getSuccessorPeriod = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getSuccessorPeriod', [
												block
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getSuccessorPeriod({
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param id Sapling state ID
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Access the value associated with a sapling state ID.
						 *
						 * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-sapling-sapling-state-id-get-diff
						 */

						RpcClientCache.prototype.getSaplingDiffById = function (id, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(this.rpcClient.getRpcUrl(), 'getSaplingDiffById', [
												block,
												id
											]);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getSaplingDiffById(id, {
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param contract address of the contract we want to get the sapling diff
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Access the value associated with a sapling state.
						 *
						 * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-single-sapling-get-diff
						 */

						RpcClientCache.prototype.getSaplingDiffByContract = function (contract, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var key, response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											key = this.formatCacheKey(
												this.rpcClient.getRpcUrl(),
												'getSaplingDiffByContract',
												[block, contract]
											);
											if (!this.has(key)) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												this.get(key)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpcClient.getSaplingDiffByContract(contract, {
													block: block
												})
											];

										case 2:
											response = _c.sent();
											this.put(key, response);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};

						return RpcClientCache;
					})();

				exports.RpcClientCache = RpcClientCache;
				var OpKind;
				exports.OpKind = OpKind;

				(function (OpKind) {
					OpKind['ORIGINATION'] = 'origination';
					OpKind['DELEGATION'] = 'delegation';
					OpKind['REVEAL'] = 'reveal';
					OpKind['TRANSACTION'] = 'transaction';
					OpKind['ACTIVATION'] = 'activate_account';
					OpKind['ENDORSEMENT'] = 'endorsement';
					OpKind['ENDORSEMENT_WITH_SLOT'] = 'endorsement_with_slot';
					OpKind['SEED_NONCE_REVELATION'] = 'seed_nonce_revelation';
					OpKind['DOUBLE_ENDORSEMENT_EVIDENCE'] = 'double_endorsement_evidence';
					OpKind['DOUBLE_BAKING_EVIDENCE'] = 'double_baking_evidence';
					OpKind['PROPOSALS'] = 'proposals';
					OpKind['BALLOT'] = 'ballot';
					OpKind['FAILING_NOOP'] = 'failing_noop';
				})(OpKind || (exports.OpKind = OpKind = {})); // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!

				/* tslint:disable */

				var VERSION = {
					commitHash: '68be71fd14ffd87bd0a0f91dab60d69c8665e88c',
					version: '10.2.0'
				};
				/* tslint:enable */

				/***
				 * @description RpcClient allows interaction with Tezos network through an rpc node
				 */

				exports.VERSION = VERSION;

				var RpcClient =
					/** @class */
					(function () {
						/**
						 *
						 * @param url rpc root url
						 * @param chain chain (default main)
						 * @param httpBackend Http backend that issue http request.
						 * You can override it by providing your own if you which to hook in the request/response
						 *
						 * @example new RpcClient('https://mainnet.api.tez.ie/', 'main') this will use https://mainnet.api.tez.ie//chains/main
						 */
						function RpcClient(url, chain, httpBackend) {
							if (chain === void 0) {
								chain = defaultChain;
							}

							if (httpBackend === void 0) {
								httpBackend = new _httpUtils.HttpBackend();
							}

							this.url = url;
							this.chain = chain;
							this.httpBackend = httpBackend;
						}

						RpcClient.prototype.createURL = function (path) {
							// Trim trailing slashes because it is assumed to be included in path
							return '' + this.url.replace(/\/+$/g, '') + path;
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Get the block's hash, its unique identifier.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-hash
						 */

						RpcClient.prototype.getBlockHash = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var hash;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' + this.chain + '/blocks/' + block + '/hash'
													),
													method: 'GET'
												})
											];

										case 1:
											hash = _c.sent();
											return [
												2,
												/*return*/
												hash
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description List the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-live-blocks
						 */

						RpcClient.prototype.getLiveBlocks = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var blocks;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' + this.chain + '/blocks/' + block + '/live_blocks'
													),
													method: 'GET'
												})
											];

										case 1:
											blocks = _c.sent();
											return [
												2,
												/*return*/
												blocks
											];
									}
								});
							});
						};
						/**
						 *
						 * @param address address from which we want to retrieve the balance
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Access the balance of a contract.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-balance
						 */

						RpcClient.prototype.getBalance = function (address, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var balance;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' +
															this.chain +
															'/blocks/' +
															block +
															'/context/contracts/' +
															address +
															'/balance'
													),
													method: 'GET'
												})
											];

										case 1:
											balance = _c.sent();
											return [
												2,
												/*return*/
												new _bignumber.default(balance)
											];
									}
								});
							});
						};
						/**
						 *
						 * @param address contract address from which we want to retrieve the storage
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Access the data of the contract.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-storage
						 */

						RpcClient.prototype.getStorage = function (address, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_c) {
									return [
										2,
										/*return*/
										this.httpBackend.createRequest({
											url: this.createURL(
												'/chains/' +
													this.chain +
													'/blocks/' +
													block +
													'/context/contracts/' +
													address +
													'/storage'
											),
											method: 'GET'
										})
									];
								});
							});
						};
						/**
						 *
						 * @param address contract address from which we want to retrieve the script
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Access the code and data of the contract.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script
						 */

						RpcClient.prototype.getScript = function (address, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_c) {
									return [
										2,
										/*return*/
										this.httpBackend.createRequest({
											url: this.createURL(
												'/chains/' +
													this.chain +
													'/blocks/' +
													block +
													'/context/contracts/' +
													address +
													'/script'
											),
											method: 'GET'
										})
									];
								});
							});
						};
						/**
						 *
						 * @param address contract address from which we want to retrieve
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Access the complete status of a contract.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id
						 */

						RpcClient.prototype.getContract = function (address, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var contractResponse;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' +
															this.chain +
															'/blocks/' +
															block +
															'/context/contracts/' +
															address
													),
													method: 'GET'
												})
											];

										case 1:
											contractResponse = _c.sent();
											return [
												2,
												/*return*/
												__assign(__assign({}, contractResponse), {
													balance: new _bignumber.default(contractResponse.balance)
												})
											];
									}
								});
							});
						};
						/**
						 *
						 * @param address contract address from which we want to retrieve the manager
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Access the manager key of a contract.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-manager-key
						 */

						RpcClient.prototype.getManagerKey = function (address, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_c) {
									return [
										2,
										/*return*/
										this.httpBackend.createRequest({
											url: this.createURL(
												'/chains/' +
													this.chain +
													'/blocks/' +
													block +
													'/context/contracts/' +
													address +
													'/manager_key'
											),
											method: 'GET'
										})
									];
								});
							});
						};
						/**
						 *
						 * @param address contract address from which we want to retrieve the delegate (baker)
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Access the delegate of a contract, if any.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-delegate
						 */

						RpcClient.prototype.getDelegate = function (address, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var delegate, ex_1;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											_c.trys.push([0, 2, , 3]);

											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' +
															this.chain +
															'/blocks/' +
															block +
															'/context/contracts/' +
															address +
															'/delegate'
													),
													method: 'GET'
												})
											];

										case 1:
											delegate = _c.sent();
											return [3 /*break*/, 3];

										case 2:
											ex_1 = _c.sent();

											if (
												ex_1 instanceof _httpUtils.HttpResponseError &&
												ex_1.status === _httpUtils.STATUS_CODE.NOT_FOUND
											) {
												delegate = null;
											} else {
												throw ex_1;
											}

											return [3 /*break*/, 3];

										case 3:
											return [
												2,
												/*return*/
												delegate
											];
									}
								});
							});
						};
						/**
						 *
						 * @param address contract address from which we want to retrieve the big map key
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Access the value associated with a key in the big map storage of the contract.
						 *
						 * @deprecated Deprecated in favor of getBigMapKeyByID
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get
						 */

						RpcClient.prototype.getBigMapKey = function (address, key, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_c) {
									return [
										2,
										/*return*/
										this.httpBackend.createRequest(
											{
												url: this.createURL(
													'/chains/' +
														this.chain +
														'/blocks/' +
														block +
														'/context/contracts/' +
														address +
														'/big_map_get'
												),
												method: 'POST'
											},
											key
										)
									];
								});
							});
						};
						/**
						 *
						 * @param id Big Map ID
						 * @param expr Expression hash to query (A b58check encoded Blake2b hash of the expression (The expression can be packed using the pack_data method))
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Access the value associated with a key in a big map.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr
						 */

						RpcClient.prototype.getBigMapExpr = function (id, expr, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_c) {
									return [
										2,
										/*return*/
										this.httpBackend.createRequest({
											url: this.createURL(
												'/chains/' +
													this.chain +
													'/blocks/' +
													block +
													'/context/big_maps/' +
													id +
													'/' +
													expr
											),
											method: 'GET'
										})
									];
								});
							});
						};
						/**
						 *
						 * @param address delegate address which we want to retrieve
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Fetches information about a delegate from RPC.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-delegates-pkh
						 */

						RpcClient.prototype.getDelegates = function (address, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' +
															this.chain +
															'/blocks/' +
															block +
															'/context/delegates/' +
															address
													),
													method: 'GET'
												})
											];

										case 1:
											response = _c.sent();
											return [
												2,
												/*return*/
												{
													deactivated: response.deactivated,
													balance: new _bignumber.default(response.balance),
													frozen_balance: new _bignumber.default(response.frozen_balance),
													frozen_balance_by_cycle: response.frozen_balance_by_cycle.map(function (
														_a
													) {
														var deposit = _a.deposit,
															deposits = _a.deposits,
															fees = _a.fees,
															rewards = _a.rewards,
															rest = __rest(_a, ['deposit', 'deposits', 'fees', 'rewards']);

														var castedToBigNumber = castToBigNumber(
															{
																deposit: deposit,
																deposits: deposits,
																fees: fees,
																rewards: rewards
															},
															['deposit', 'deposits', 'fees', 'rewards']
														);
														return __assign(__assign({}, rest), {
															deposit: castedToBigNumber.deposit,
															deposits: castedToBigNumber.deposits,
															fees: castedToBigNumber.fees,
															rewards: castedToBigNumber.rewards
														});
													}),
													staking_balance: new _bignumber.default(response.staking_balance),
													delegated_contracts: response.delegated_contracts,
													delegated_balance: new _bignumber.default(response.delegated_balance),
													grace_period: response.grace_period,
													voting_power: response.voting_power
												}
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description All constants
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-constants
						 */

						RpcClient.prototype.getConstants = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var response, castedResponse;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' + this.chain + '/blocks/' + block + '/context/constants'
													),
													method: 'GET'
												})
											];

										case 1:
											response = _c.sent();
											castedResponse = castToBigNumber(response, [
												'time_between_blocks',
												'hard_gas_limit_per_operation',
												'hard_gas_limit_per_block',
												'proof_of_work_threshold',
												'tokens_per_roll',
												'seed_nonce_revelation_tip',
												'block_security_deposit',
												'endorsement_security_deposit',
												'block_reward',
												'endorsement_reward',
												'cost_per_byte',
												'hard_storage_limit_per_operation',
												'test_chain_duration',
												'baking_reward_per_endorsement',
												'delay_per_missing_endorsement',
												'minimal_block_delay',
												'liquidity_baking_subsidy'
											]);
											return [
												2,
												/*return*/
												__assign(__assign({}, response), castedResponse)
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls. See examples for various available sytaxes.
						 *
						 * @description All the information about a block
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id
						 * @example getBlock() will default to /main/chains/block/head.
						 * @example getBlock({ block: head~2 }) will return an offset of 2 blocks.
						 * @example getBlock({ block: BL8fTiWcSxWCjiMVnDkbh6EuhqVPZzgWheJ2dqwrxYRm9AephXh~2 }) will return an offset of 2 blocks from given block hash..
						 */

						RpcClient.prototype.getBlock = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL('/chains/' + this.chain + '/blocks/' + block),
													method: 'GET'
												})
											];

										case 1:
											response = _c.sent();
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description The whole block header
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-header
						 */

						RpcClient.prototype.getBlockHeader = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' + this.chain + '/blocks/' + block + '/header'
													),
													method: 'GET'
												})
											];

										case 1:
											response = _c.sent();
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description All the metadata associated to the block
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-metadata
						 */

						RpcClient.prototype.getBlockMetadata = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' + this.chain + '/blocks/' + block + '/metadata'
													),
													method: 'GET'
												})
											];

										case 1:
											response = _c.sent();
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param args contains optional query arguments
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Retrieves the list of delegates allowed to bake a block.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-baking-rights
						 */

						RpcClient.prototype.getBakingRights = function (args, _a) {
							if (args === void 0) {
								args = {};
							}

							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' + this.chain + '/blocks/' + block + '/helpers/baking_rights'
													),
													method: 'GET',
													query: args
												})
											];

										case 1:
											response = _c.sent();
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param args contains optional query arguments
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Retrieves the list of delegates allowed to bake a block.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-endorsing-rights
						 */

						RpcClient.prototype.getEndorsingRights = function (args, _a) {
							if (args === void 0) {
								args = {};
							}

							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' +
															this.chain +
															'/blocks/' +
															block +
															'/helpers/endorsing_rights'
													),
													method: 'GET',
													query: args
												})
											];

										case 1:
											response = _c.sent();
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Ballots casted so far during a voting period
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballot-list
						 */

						RpcClient.prototype.getBallotList = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' + this.chain + '/blocks/' + block + '/votes/ballot_list'
													),
													method: 'GET'
												})
											];

										case 1:
											response = _c.sent();
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Sum of ballots casted so far during a voting period.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballots
						 */

						RpcClient.prototype.getBallots = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' + this.chain + '/blocks/' + block + '/votes/ballots'
													),
													method: 'GET'
												})
											];

										case 1:
											response = _c.sent();
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Current period kind.
						 *
						 * @deprecated Deprecated in favor of getCurrentPeriod
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-period-kind
						 */

						RpcClient.prototype.getCurrentPeriodKind = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' +
															this.chain +
															'/blocks/' +
															block +
															'/votes/current_period_kind'
													),
													method: 'GET'
												})
											];

										case 1:
											response = _c.sent();
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Current proposal under evaluation.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-proposal
						 */

						RpcClient.prototype.getCurrentProposal = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' + this.chain + '/blocks/' + block + '/votes/current_proposal'
													),
													method: 'GET'
												})
											];

										case 1:
											response = _c.sent();
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Current expected quorum.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-quorum
						 */

						RpcClient.prototype.getCurrentQuorum = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' + this.chain + '/blocks/' + block + '/votes/current_quorum'
													),
													method: 'GET'
												})
											];

										case 1:
											response = _c.sent();
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description List of delegates with their voting weight, in number of rolls.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-listings
						 */

						RpcClient.prototype.getVotesListings = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' + this.chain + '/blocks/' + block + '/votes/listings'
													),
													method: 'GET'
												})
											];

										case 1:
											response = _c.sent();
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description List of proposals with number of supporters.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-proposals
						 */

						RpcClient.prototype.getProposals = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' + this.chain + '/blocks/' + block + '/votes/proposals'
													),
													method: 'GET'
												})
											];

										case 1:
											response = _c.sent();
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param data operation contents to forge
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Forge an operation returning the unsigned bytes
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-forge-operations
						 */

						RpcClient.prototype.forgeOperations = function (data, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_c) {
									return [
										2,
										/*return*/
										this.httpBackend.createRequest(
											{
												url: this.createURL(
													'/chains/' + this.chain + '/blocks/' + block + '/helpers/forge/operations'
												),
												method: 'POST'
											},
											data
										)
									];
								});
							});
						};
						/**
						 *
						 * @param signedOpBytes signed bytes to inject
						 *
						 * @description Inject an operation in node and broadcast it. Returns the ID of the operation. The `signedOperationContents` should be constructed using a contextual RPCs from the latest block and signed by the client. By default, the RPC will wait for the operation to be (pre-)validated before answering. See RPCs under /blocks/prevalidation for more details on the prevalidation context.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#post-injection-operation
						 */

						RpcClient.prototype.injectOperation = function (signedOpBytes) {
							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_a) {
									return [
										2,
										/*return*/
										this.httpBackend.createRequest(
											{
												url: this.createURL('/injection/operation'),
												method: 'POST'
											},
											signedOpBytes
										)
									];
								});
							});
						};
						/**
						 *
						 * @param ops Operations to apply
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Simulate the validation of an operation
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-preapply-operations
						 */

						RpcClient.prototype.preapplyOperations = function (ops, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest(
													{
														url: this.createURL(
															'/chains/' +
																this.chain +
																'/blocks/' +
																block +
																'/helpers/preapply/operations'
														),
														method: 'POST'
													},
													ops
												)
											];

										case 1:
											response = _c.sent();
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param contract address of the contract we want to get the entrypoints of
						 *
						 * @description Return the list of entrypoints of the contract
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-entrypoints
						 *
						 * @version 005_PsBABY5H
						 */

						RpcClient.prototype.getEntrypoints = function (contract, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var contractResponse;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' +
															this.chain +
															'/blocks/' +
															block +
															'/context/contracts/' +
															contract +
															'/entrypoints'
													),
													method: 'GET'
												})
											];

										case 1:
											contractResponse = _c.sent();
											return [
												2,
												/*return*/
												contractResponse
											];
									}
								});
							});
						};
						/**
						 * @param op Operation to run
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Run an operation without signature checks
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-operation
						 */

						RpcClient.prototype.runOperation = function (op, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest(
													{
														url: this.createURL(
															'/chains/' +
																this.chain +
																'/blocks/' +
																block +
																'/helpers/scripts/run_operation'
														),
														method: 'POST'
													},
													op
												)
											];

										case 1:
											response = _c.sent();
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 * @param code Code to run
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Run a piece of code in the current context
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-code
						 */

						RpcClient.prototype.runCode = function (code, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest(
													{
														url: this.createURL(
															'/chains/' +
																this.chain +
																'/blocks/' +
																block +
																'/helpers/scripts/run_code'
														),
														method: 'POST'
													},
													code
												)
											];

										case 1:
											response = _c.sent();
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};

						RpcClient.prototype.getChainId = function () {
							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_a) {
									return [
										2,
										/*return*/
										this.httpBackend.createRequest({
											url: this.createURL('/chains/' + this.chain + '/chain_id'),
											method: 'GET'
										})
									];
								});
							});
						};
						/**
						 *
						 * @param data Data to pack
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Computes the serialized version of a data expression using the same algorithm as script instruction PACK
						 *
						 * @example packData({ data: { string: "test" }, type: { prim: "string" } })
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-pack-data
						 */

						RpcClient.prototype.packData = function (data, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var _c, gas, rest, formattedGas, tryBigNumber;

								return __generator(this, function (_d) {
									switch (_d.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest(
													{
														url: this.createURL(
															'/chains/' +
																this.chain +
																'/blocks/' +
																block +
																'/helpers/scripts/pack_data'
														),
														method: 'POST'
													},
													data
												)
											];

										case 1:
											(_c = _d.sent()), (gas = _c.gas), (rest = __rest(_c, ['gas']));
											formattedGas = gas;
											tryBigNumber = new _bignumber.default(gas || '');

											if (!tryBigNumber.isNaN()) {
												formattedGas = tryBigNumber;
											}

											return [
												2,
												/*return*/
												__assign(
													{
														gas: formattedGas
													},
													rest
												)
											];
									}
								});
							});
						};
						/**
						 *
						 * @description Return rpc root url
						 */

						RpcClient.prototype.getRpcUrl = function () {
							return this.url;
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Voting period of current block.
						 *
						 * @example getCurrentPeriod() will default to current voting period for /main/chains/block/head.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-period
						 */

						RpcClient.prototype.getCurrentPeriod = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' + this.chain + '/blocks/' + block + '/votes/current_period'
													),
													method: 'GET'
												})
											];

										case 1:
											response = _c.sent();
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Voting period of next block.
						 *
						 * @example getSuccessorPeriod() will default to successor voting period for /main/chains/block/head.
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-successor-period
						 */

						RpcClient.prototype.getSuccessorPeriod = function (_a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								var response;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.httpBackend.createRequest({
													url: this.createURL(
														'/chains/' + this.chain + '/blocks/' + block + '/votes/successor_period'
													),
													method: 'GET'
												})
											];

										case 1:
											response = _c.sent();
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};
						/**
						 *
						 * @param id Sapling state ID
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Access the value associated with a sapling state ID.
						 *
						 * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-sapling-sapling-state-id-get-diff
						 */

						RpcClient.prototype.getSaplingDiffById = function (id, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_c) {
									return [
										2,
										/*return*/
										this.httpBackend.createRequest({
											url: this.createURL(
												'/chains/' +
													this.chain +
													'/blocks/' +
													block +
													'/context/sapling/' +
													id +
													'/get_diff'
											),
											method: 'GET'
										})
									];
								});
							});
						};
						/**
						 *
						 * @param contract address of the contract we want to get the sapling diff
						 * @param options contains generic configuration for rpc calls
						 *
						 * @description Access the value associated with a sapling state.
						 *
						 * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-single-sapling-get-diff
						 */

						RpcClient.prototype.getSaplingDiffByContract = function (contract, _a) {
							var _b = _a === void 0 ? defaultRPCOptions : _a,
								block = _b.block;

							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_c) {
									return [
										2,
										/*return*/
										this.httpBackend.createRequest({
											url: this.createURL(
												'/chains/' +
													this.chain +
													'/blocks/' +
													block +
													'/context/contracts/' +
													contract +
													'/single_sapling_get_diff'
											),
											method: 'GET'
										})
									];
								});
							});
						};

						return RpcClient;
					})();

				exports.RpcClient = RpcClient;
			},
			{
				'@taquito/http-utils': '../node_modules/@taquito/http-utils/dist/taquito-http-utils.es5.js',
				'bignumber.js': '../node_modules/bignumber.js/bignumber.js',
				'lodash/get': '../node_modules/lodash/get.js',
				'lodash/set': '../node_modules/lodash/set.js'
			}
		],
		'../node_modules/tslib/tslib.es6.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.__extends = __extends;
				exports.__rest = __rest;
				exports.__decorate = __decorate;
				exports.__param = __param;
				exports.__metadata = __metadata;
				exports.__awaiter = __awaiter;
				exports.__generator = __generator;
				exports.__createBinding = __createBinding;
				exports.__exportStar = __exportStar;
				exports.__values = __values;
				exports.__read = __read;
				exports.__spread = __spread;
				exports.__spreadArrays = __spreadArrays;
				exports.__await = __await;
				exports.__asyncGenerator = __asyncGenerator;
				exports.__asyncDelegator = __asyncDelegator;
				exports.__asyncValues = __asyncValues;
				exports.__makeTemplateObject = __makeTemplateObject;
				exports.__importStar = __importStar;
				exports.__importDefault = __importDefault;
				exports.__classPrivateFieldGet = __classPrivateFieldGet;
				exports.__classPrivateFieldSet = __classPrivateFieldSet;
				exports.__assign = void 0;

				/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

				/* global Reflect, Promise */
				var extendStatics = function (d, b) {
					extendStatics =
						Object.setPrototypeOf ||
						({
							__proto__: []
						} instanceof Array &&
							function (d, b) {
								d.__proto__ = b;
							}) ||
						function (d, b) {
							for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
						};

					return extendStatics(d, b);
				};

				function __extends(d, b) {
					extendStatics(d, b);

					function __() {
						this.constructor = d;
					}

					d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
				}

				var __assign = function () {
					exports.__assign = __assign =
						Object.assign ||
						function __assign(t) {
							for (var s, i = 1, n = arguments.length; i < n; i++) {
								s = arguments[i];

								for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
							}

							return t;
						};

					return __assign.apply(this, arguments);
				};

				exports.__assign = __assign;

				function __rest(s, e) {
					var t = {};

					for (var p in s)
						if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

					if (s != null && typeof Object.getOwnPropertySymbols === 'function')
						for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
							if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
								t[p[i]] = s[p[i]];
						}
					return t;
				}

				function __decorate(decorators, target, key, desc) {
					var c = arguments.length,
						r =
							c < 3
								? target
								: desc === null
								? (desc = Object.getOwnPropertyDescriptor(target, key))
								: desc,
						d;
					if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
						r = Reflect.decorate(decorators, target, key, desc);
					else
						for (var i = decorators.length - 1; i >= 0; i--)
							if ((d = decorators[i]))
								r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
					return c > 3 && r && Object.defineProperty(target, key, r), r;
				}

				function __param(paramIndex, decorator) {
					return function (target, key) {
						decorator(target, key, paramIndex);
					};
				}

				function __metadata(metadataKey, metadataValue) {
					if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function')
						return Reflect.metadata(metadataKey, metadataValue);
				}

				function __awaiter(thisArg, _arguments, P, generator) {
					function adopt(value) {
						return value instanceof P
							? value
							: new P(function (resolve) {
									resolve(value);
							  });
					}

					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) {
							try {
								step(generator.next(value));
							} catch (e) {
								reject(e);
							}
						}

						function rejected(value) {
							try {
								step(generator['throw'](value));
							} catch (e) {
								reject(e);
							}
						}

						function step(result) {
							result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
						}

						step((generator = generator.apply(thisArg, _arguments || [])).next());
					});
				}

				function __generator(thisArg, body) {
					var _ = {
							label: 0,
							sent: function () {
								if (t[0] & 1) throw t[1];
								return t[1];
							},
							trys: [],
							ops: []
						},
						f,
						y,
						t,
						g;
					return (
						(g = {
							next: verb(0),
							throw: verb(1),
							return: verb(2)
						}),
						typeof Symbol === 'function' &&
							(g[Symbol.iterator] = function () {
								return this;
							}),
						g
					);

					function verb(n) {
						return function (v) {
							return step([n, v]);
						};
					}

					function step(op) {
						if (f) throw new TypeError('Generator is already executing.');

						while (_)
							try {
								if (
									((f = 1),
									y &&
										(t =
											op[0] & 2
												? y['return']
												: op[0]
												? y['throw'] || ((t = y['return']) && t.call(y), 0)
												: y.next) &&
										!(t = t.call(y, op[1])).done)
								)
									return t;
								if (((y = 0), t)) op = [op[0] & 2, t.value];

								switch (op[0]) {
									case 0:
									case 1:
										t = op;
										break;

									case 4:
										_.label++;
										return {
											value: op[1],
											done: false
										};

									case 5:
										_.label++;
										y = op[1];
										op = [0];
										continue;

									case 7:
										op = _.ops.pop();

										_.trys.pop();

										continue;

									default:
										if (
											!((t = _.trys), (t = t.length > 0 && t[t.length - 1])) &&
											(op[0] === 6 || op[0] === 2)
										) {
											_ = 0;
											continue;
										}

										if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
											_.label = op[1];
											break;
										}

										if (op[0] === 6 && _.label < t[1]) {
											_.label = t[1];
											t = op;
											break;
										}

										if (t && _.label < t[2]) {
											_.label = t[2];

											_.ops.push(op);

											break;
										}

										if (t[2]) _.ops.pop();

										_.trys.pop();

										continue;
								}

								op = body.call(thisArg, _);
							} catch (e) {
								op = [6, e];
								y = 0;
							} finally {
								f = t = 0;
							}

						if (op[0] & 5) throw op[1];
						return {
							value: op[0] ? op[1] : void 0,
							done: true
						};
					}
				}

				function __createBinding(o, m, k, k2) {
					if (k2 === undefined) k2 = k;
					o[k2] = m[k];
				}

				function __exportStar(m, exports) {
					for (var p in m) if (p !== 'default' && !exports.hasOwnProperty(p)) exports[p] = m[p];
				}

				function __values(o) {
					var s = typeof Symbol === 'function' && Symbol.iterator,
						m = s && o[s],
						i = 0;
					if (m) return m.call(o);
					if (o && typeof o.length === 'number')
						return {
							next: function () {
								if (o && i >= o.length) o = void 0;
								return {
									value: o && o[i++],
									done: !o
								};
							}
						};
					throw new TypeError(s ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
				}

				function __read(o, n) {
					var m = typeof Symbol === 'function' && o[Symbol.iterator];
					if (!m) return o;
					var i = m.call(o),
						r,
						ar = [],
						e;

					try {
						while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
					} catch (error) {
						e = {
							error: error
						};
					} finally {
						try {
							if (r && !r.done && (m = i['return'])) m.call(i);
						} finally {
							if (e) throw e.error;
						}
					}

					return ar;
				}

				function __spread() {
					for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

					return ar;
				}

				function __spreadArrays() {
					for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

					for (var r = Array(s), k = 0, i = 0; i < il; i++)
						for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

					return r;
				}

				function __await(v) {
					return this instanceof __await ? ((this.v = v), this) : new __await(v);
				}

				function __asyncGenerator(thisArg, _arguments, generator) {
					if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.');
					var g = generator.apply(thisArg, _arguments || []),
						i,
						q = [];
					return (
						(i = {}),
						verb('next'),
						verb('throw'),
						verb('return'),
						(i[Symbol.asyncIterator] = function () {
							return this;
						}),
						i
					);

					function verb(n) {
						if (g[n])
							i[n] = function (v) {
								return new Promise(function (a, b) {
									q.push([n, v, a, b]) > 1 || resume(n, v);
								});
							};
					}

					function resume(n, v) {
						try {
							step(g[n](v));
						} catch (e) {
							settle(q[0][3], e);
						}
					}

					function step(r) {
						r.value instanceof __await
							? Promise.resolve(r.value.v).then(fulfill, reject)
							: settle(q[0][2], r);
					}

					function fulfill(value) {
						resume('next', value);
					}

					function reject(value) {
						resume('throw', value);
					}

					function settle(f, v) {
						if ((f(v), q.shift(), q.length)) resume(q[0][0], q[0][1]);
					}
				}

				function __asyncDelegator(o) {
					var i, p;
					return (
						(i = {}),
						verb('next'),
						verb('throw', function (e) {
							throw e;
						}),
						verb('return'),
						(i[Symbol.iterator] = function () {
							return this;
						}),
						i
					);

					function verb(n, f) {
						i[n] = o[n]
							? function (v) {
									return (p = !p)
										? {
												value: __await(o[n](v)),
												done: n === 'return'
										  }
										: f
										? f(v)
										: v;
							  }
							: f;
					}
				}

				function __asyncValues(o) {
					if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.');
					var m = o[Symbol.asyncIterator],
						i;
					return m
						? m.call(o)
						: ((o = typeof __values === 'function' ? __values(o) : o[Symbol.iterator]()),
						  (i = {}),
						  verb('next'),
						  verb('throw'),
						  verb('return'),
						  (i[Symbol.asyncIterator] = function () {
								return this;
						  }),
						  i);

					function verb(n) {
						i[n] =
							o[n] &&
							function (v) {
								return new Promise(function (resolve, reject) {
									(v = o[n](v)), settle(resolve, reject, v.done, v.value);
								});
							};
					}

					function settle(resolve, reject, d, v) {
						Promise.resolve(v).then(function (v) {
							resolve({
								value: v,
								done: d
							});
						}, reject);
					}
				}

				function __makeTemplateObject(cooked, raw) {
					if (Object.defineProperty) {
						Object.defineProperty(cooked, 'raw', {
							value: raw
						});
					} else {
						cooked.raw = raw;
					}

					return cooked;
				}

				function __importStar(mod) {
					if (mod && mod.__esModule) return mod;
					var result = {};
					if (mod != null)
						for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
					result.default = mod;
					return result;
				}

				function __importDefault(mod) {
					return mod && mod.__esModule
						? mod
						: {
								default: mod
						  };
				}

				function __classPrivateFieldGet(receiver, privateMap) {
					if (!privateMap.has(receiver)) {
						throw new TypeError('attempted to get private field on non-instance');
					}

					return privateMap.get(receiver);
				}

				function __classPrivateFieldSet(receiver, privateMap, value) {
					if (!privateMap.has(receiver)) {
						throw new TypeError('attempted to set private field on non-instance');
					}

					privateMap.set(receiver, value);
					return value;
				}
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/util/isFunction.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.isFunction = isFunction;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				function isFunction(x) {
					return typeof x === 'function';
				}
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/config.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.config = void 0;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				var _enable_super_gross_mode_that_will_cause_bad_things = false;
				var config = {
					Promise: undefined,

					set useDeprecatedSynchronousErrorHandling(value) {
						if (value) {
							var error =
								/*@__PURE__*/
								new Error();
							/*@__PURE__*/

							console.warn(
								'DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' +
									error.stack
							);
						} else if (_enable_super_gross_mode_that_will_cause_bad_things) {
							/*@__PURE__*/
							console.log('RxJS: Back to a better error behavior. Thank you. <3');
						}

						_enable_super_gross_mode_that_will_cause_bad_things = value;
					},

					get useDeprecatedSynchronousErrorHandling() {
						return _enable_super_gross_mode_that_will_cause_bad_things;
					}
				};
				exports.config = config;
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/util/hostReportError.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.hostReportError = hostReportError;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				function hostReportError(err) {
					setTimeout(function () {
						throw err;
					}, 0);
				}
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/Observer.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.empty = void 0;

				var _config = require('./config');

				var _hostReportError = require('./util/hostReportError');

				/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */
				var empty = {
					closed: true,
					next: function (value) {},
					error: function (err) {
						if (_config.config.useDeprecatedSynchronousErrorHandling) {
							throw err;
						} else {
							(0, _hostReportError.hostReportError)(err);
						}
					},
					complete: function () {}
				};
				exports.empty = empty;
			},
			{
				'./config': '../node_modules/rxjs/_esm5/internal/config.js',
				'./util/hostReportError': '../node_modules/rxjs/_esm5/internal/util/hostReportError.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/util/isArray.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.isArray = void 0;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				var isArray =
					/*@__PURE__*/
					(function () {
						return (
							Array.isArray ||
							function (x) {
								return x && typeof x.length === 'number';
							}
						);
					})();

				exports.isArray = isArray;
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/util/isObject.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.isObject = isObject;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				function isObject(x) {
					return x !== null && typeof x === 'object';
				}
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.UnsubscriptionError = void 0;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				var UnsubscriptionErrorImpl =
					/*@__PURE__*/
					(function () {
						function UnsubscriptionErrorImpl(errors) {
							Error.call(this);
							this.message = errors
								? errors.length +
								  ' errors occurred during unsubscription:\n' +
								  errors
										.map(function (err, i) {
											return i + 1 + ') ' + err.toString();
										})
										.join('\n  ')
								: '';
							this.name = 'UnsubscriptionError';
							this.errors = errors;
							return this;
						}

						UnsubscriptionErrorImpl.prototype =
							/*@__PURE__*/
							Object.create(Error.prototype);
						return UnsubscriptionErrorImpl;
					})();

				var UnsubscriptionError = UnsubscriptionErrorImpl;
				exports.UnsubscriptionError = UnsubscriptionError;
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/Subscription.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.Subscription = void 0;

				var _isArray = require('./util/isArray');

				var _isObject = require('./util/isObject');

				var _isFunction = require('./util/isFunction');

				var _UnsubscriptionError = require('./util/UnsubscriptionError');

				/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */
				var Subscription =
					/*@__PURE__*/
					(function () {
						function Subscription(unsubscribe) {
							this.closed = false;
							this._parentOrParents = null;
							this._subscriptions = null;

							if (unsubscribe) {
								this._ctorUnsubscribe = true;
								this._unsubscribe = unsubscribe;
							}
						}

						Subscription.prototype.unsubscribe = function () {
							var errors;

							if (this.closed) {
								return;
							}

							var _a = this,
								_parentOrParents = _a._parentOrParents,
								_ctorUnsubscribe = _a._ctorUnsubscribe,
								_unsubscribe = _a._unsubscribe,
								_subscriptions = _a._subscriptions;

							this.closed = true;
							this._parentOrParents = null;
							this._subscriptions = null;

							if (_parentOrParents instanceof Subscription) {
								_parentOrParents.remove(this);
							} else if (_parentOrParents !== null) {
								for (var index = 0; index < _parentOrParents.length; ++index) {
									var parent_1 = _parentOrParents[index];
									parent_1.remove(this);
								}
							}

							if ((0, _isFunction.isFunction)(_unsubscribe)) {
								if (_ctorUnsubscribe) {
									this._unsubscribe = undefined;
								}

								try {
									_unsubscribe.call(this);
								} catch (e) {
									errors =
										e instanceof _UnsubscriptionError.UnsubscriptionError
											? flattenUnsubscriptionErrors(e.errors)
											: [e];
								}
							}

							if ((0, _isArray.isArray)(_subscriptions)) {
								var index = -1;
								var len = _subscriptions.length;

								while (++index < len) {
									var sub = _subscriptions[index];

									if ((0, _isObject.isObject)(sub)) {
										try {
											sub.unsubscribe();
										} catch (e) {
											errors = errors || [];

											if (e instanceof _UnsubscriptionError.UnsubscriptionError) {
												errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
											} else {
												errors.push(e);
											}
										}
									}
								}
							}

							if (errors) {
								throw new _UnsubscriptionError.UnsubscriptionError(errors);
							}
						};

						Subscription.prototype.add = function (teardown) {
							var subscription = teardown;

							if (!teardown) {
								return Subscription.EMPTY;
							}

							switch (typeof teardown) {
								case 'function':
									subscription = new Subscription(teardown);

								case 'object':
									if (
										subscription === this ||
										subscription.closed ||
										typeof subscription.unsubscribe !== 'function'
									) {
										return subscription;
									} else if (this.closed) {
										subscription.unsubscribe();
										return subscription;
									} else if (!(subscription instanceof Subscription)) {
										var tmp = subscription;
										subscription = new Subscription();
										subscription._subscriptions = [tmp];
									}

									break;

								default: {
									throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
								}
							}

							var _parentOrParents = subscription._parentOrParents;

							if (_parentOrParents === null) {
								subscription._parentOrParents = this;
							} else if (_parentOrParents instanceof Subscription) {
								if (_parentOrParents === this) {
									return subscription;
								}

								subscription._parentOrParents = [_parentOrParents, this];
							} else if (_parentOrParents.indexOf(this) === -1) {
								_parentOrParents.push(this);
							} else {
								return subscription;
							}

							var subscriptions = this._subscriptions;

							if (subscriptions === null) {
								this._subscriptions = [subscription];
							} else {
								subscriptions.push(subscription);
							}

							return subscription;
						};

						Subscription.prototype.remove = function (subscription) {
							var subscriptions = this._subscriptions;

							if (subscriptions) {
								var subscriptionIndex = subscriptions.indexOf(subscription);

								if (subscriptionIndex !== -1) {
									subscriptions.splice(subscriptionIndex, 1);
								}
							}
						};

						Subscription.EMPTY = (function (empty) {
							empty.closed = true;
							return empty;
						})(new Subscription());

						return Subscription;
					})();

				exports.Subscription = Subscription;

				function flattenUnsubscriptionErrors(errors) {
					return errors.reduce(function (errs, err) {
						return errs.concat(
							err instanceof _UnsubscriptionError.UnsubscriptionError ? err.errors : err
						);
					}, []);
				}
			},
			{
				'./util/isArray': '../node_modules/rxjs/_esm5/internal/util/isArray.js',
				'./util/isObject': '../node_modules/rxjs/_esm5/internal/util/isObject.js',
				'./util/isFunction': '../node_modules/rxjs/_esm5/internal/util/isFunction.js',
				'./util/UnsubscriptionError':
					'../node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.$$rxSubscriber = exports.rxSubscriber = void 0;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				var rxSubscriber =
					/*@__PURE__*/
					(function () {
						return typeof Symbol === 'function'
							? /*@__PURE__*/
							  Symbol('rxSubscriber')
							: '@@rxSubscriber_' +
									/*@__PURE__*/
									Math.random();
					})();

				exports.rxSubscriber = rxSubscriber;
				var $$rxSubscriber = rxSubscriber;
				exports.$$rxSubscriber = $$rxSubscriber;
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/Subscriber.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.SafeSubscriber = exports.Subscriber = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _isFunction = require('./util/isFunction');

				var _Observer = require('./Observer');

				var _Subscription = require('./Subscription');

				var _rxSubscriber = require('../internal/symbol/rxSubscriber');

				var _config = require('./config');

				var _hostReportError = require('./util/hostReportError');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */
				var Subscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(Subscriber, _super);

						function Subscriber(destinationOrNext, error, complete) {
							var _this = _super.call(this) || this;

							_this.syncErrorValue = null;
							_this.syncErrorThrown = false;
							_this.syncErrorThrowable = false;
							_this.isStopped = false;

							switch (arguments.length) {
								case 0:
									_this.destination = _Observer.empty;
									break;

								case 1:
									if (!destinationOrNext) {
										_this.destination = _Observer.empty;
										break;
									}

									if (typeof destinationOrNext === 'object') {
										if (destinationOrNext instanceof Subscriber) {
											_this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
											_this.destination = destinationOrNext;
											destinationOrNext.add(_this);
										} else {
											_this.syncErrorThrowable = true;
											_this.destination = new SafeSubscriber(_this, destinationOrNext);
										}

										break;
									}

								default:
									_this.syncErrorThrowable = true;
									_this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
									break;
							}

							return _this;
						}

						Subscriber.prototype[_rxSubscriber.rxSubscriber] = function () {
							return this;
						};

						Subscriber.create = function (next, error, complete) {
							var subscriber = new Subscriber(next, error, complete);
							subscriber.syncErrorThrowable = false;
							return subscriber;
						};

						Subscriber.prototype.next = function (value) {
							if (!this.isStopped) {
								this._next(value);
							}
						};

						Subscriber.prototype.error = function (err) {
							if (!this.isStopped) {
								this.isStopped = true;

								this._error(err);
							}
						};

						Subscriber.prototype.complete = function () {
							if (!this.isStopped) {
								this.isStopped = true;

								this._complete();
							}
						};

						Subscriber.prototype.unsubscribe = function () {
							if (this.closed) {
								return;
							}

							this.isStopped = true;

							_super.prototype.unsubscribe.call(this);
						};

						Subscriber.prototype._next = function (value) {
							this.destination.next(value);
						};

						Subscriber.prototype._error = function (err) {
							this.destination.error(err);
							this.unsubscribe();
						};

						Subscriber.prototype._complete = function () {
							this.destination.complete();
							this.unsubscribe();
						};

						Subscriber.prototype._unsubscribeAndRecycle = function () {
							var _parentOrParents = this._parentOrParents;
							this._parentOrParents = null;
							this.unsubscribe();
							this.closed = false;
							this.isStopped = false;
							this._parentOrParents = _parentOrParents;
							return this;
						};

						return Subscriber;
					})(_Subscription.Subscription);

				exports.Subscriber = Subscriber;

				var SafeSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(SafeSubscriber, _super);

						function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
							var _this = _super.call(this) || this;

							_this._parentSubscriber = _parentSubscriber;
							var next;
							var context = _this;

							if ((0, _isFunction.isFunction)(observerOrNext)) {
								next = observerOrNext;
							} else if (observerOrNext) {
								next = observerOrNext.next;
								error = observerOrNext.error;
								complete = observerOrNext.complete;

								if (observerOrNext !== _Observer.empty) {
									context = Object.create(observerOrNext);

									if ((0, _isFunction.isFunction)(context.unsubscribe)) {
										_this.add(context.unsubscribe.bind(context));
									}

									context.unsubscribe = _this.unsubscribe.bind(_this);
								}
							}

							_this._context = context;
							_this._next = next;
							_this._error = error;
							_this._complete = complete;
							return _this;
						}

						SafeSubscriber.prototype.next = function (value) {
							if (!this.isStopped && this._next) {
								var _parentSubscriber = this._parentSubscriber;

								if (
									!_config.config.useDeprecatedSynchronousErrorHandling ||
									!_parentSubscriber.syncErrorThrowable
								) {
									this.__tryOrUnsub(this._next, value);
								} else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
									this.unsubscribe();
								}
							}
						};

						SafeSubscriber.prototype.error = function (err) {
							if (!this.isStopped) {
								var _parentSubscriber = this._parentSubscriber;
								var useDeprecatedSynchronousErrorHandling =
									_config.config.useDeprecatedSynchronousErrorHandling;

								if (this._error) {
									if (
										!useDeprecatedSynchronousErrorHandling ||
										!_parentSubscriber.syncErrorThrowable
									) {
										this.__tryOrUnsub(this._error, err);

										this.unsubscribe();
									} else {
										this.__tryOrSetError(_parentSubscriber, this._error, err);

										this.unsubscribe();
									}
								} else if (!_parentSubscriber.syncErrorThrowable) {
									this.unsubscribe();

									if (useDeprecatedSynchronousErrorHandling) {
										throw err;
									}

									(0, _hostReportError.hostReportError)(err);
								} else {
									if (useDeprecatedSynchronousErrorHandling) {
										_parentSubscriber.syncErrorValue = err;
										_parentSubscriber.syncErrorThrown = true;
									} else {
										(0, _hostReportError.hostReportError)(err);
									}

									this.unsubscribe();
								}
							}
						};

						SafeSubscriber.prototype.complete = function () {
							var _this = this;

							if (!this.isStopped) {
								var _parentSubscriber = this._parentSubscriber;

								if (this._complete) {
									var wrappedComplete = function () {
										return _this._complete.call(_this._context);
									};

									if (
										!_config.config.useDeprecatedSynchronousErrorHandling ||
										!_parentSubscriber.syncErrorThrowable
									) {
										this.__tryOrUnsub(wrappedComplete);

										this.unsubscribe();
									} else {
										this.__tryOrSetError(_parentSubscriber, wrappedComplete);

										this.unsubscribe();
									}
								} else {
									this.unsubscribe();
								}
							}
						};

						SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
							try {
								fn.call(this._context, value);
							} catch (err) {
								this.unsubscribe();

								if (_config.config.useDeprecatedSynchronousErrorHandling) {
									throw err;
								} else {
									(0, _hostReportError.hostReportError)(err);
								}
							}
						};

						SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
							if (!_config.config.useDeprecatedSynchronousErrorHandling) {
								throw new Error('bad call');
							}

							try {
								fn.call(this._context, value);
							} catch (err) {
								if (_config.config.useDeprecatedSynchronousErrorHandling) {
									parent.syncErrorValue = err;
									parent.syncErrorThrown = true;
									return true;
								} else {
									(0, _hostReportError.hostReportError)(err);
									return true;
								}
							}

							return false;
						};

						SafeSubscriber.prototype._unsubscribe = function () {
							var _parentSubscriber = this._parentSubscriber;
							this._context = null;
							this._parentSubscriber = null;

							_parentSubscriber.unsubscribe();
						};

						return SafeSubscriber;
					})(Subscriber);

				exports.SafeSubscriber = SafeSubscriber;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'./util/isFunction': '../node_modules/rxjs/_esm5/internal/util/isFunction.js',
				'./Observer': '../node_modules/rxjs/_esm5/internal/Observer.js',
				'./Subscription': '../node_modules/rxjs/_esm5/internal/Subscription.js',
				'../internal/symbol/rxSubscriber':
					'../node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js',
				'./config': '../node_modules/rxjs/_esm5/internal/config.js',
				'./util/hostReportError': '../node_modules/rxjs/_esm5/internal/util/hostReportError.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/util/canReportError.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.canReportError = canReportError;

				var _Subscriber = require('../Subscriber');

				/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */
				function canReportError(observer) {
					while (observer) {
						var _a = observer,
							closed_1 = _a.closed,
							destination = _a.destination,
							isStopped = _a.isStopped;

						if (closed_1 || isStopped) {
							return false;
						} else if (destination && destination instanceof _Subscriber.Subscriber) {
							observer = destination;
						} else {
							observer = null;
						}
					}

					return true;
				}
			},
			{ '../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js' }
		],
		'../node_modules/rxjs/_esm5/internal/util/toSubscriber.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.toSubscriber = toSubscriber;

				var _Subscriber = require('../Subscriber');

				var _rxSubscriber = require('../symbol/rxSubscriber');

				var _Observer = require('../Observer');

				/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
				function toSubscriber(nextOrObserver, error, complete) {
					if (nextOrObserver) {
						if (nextOrObserver instanceof _Subscriber.Subscriber) {
							return nextOrObserver;
						}

						if (nextOrObserver[_rxSubscriber.rxSubscriber]) {
							return nextOrObserver[_rxSubscriber.rxSubscriber]();
						}
					}

					if (!nextOrObserver && !error && !complete) {
						return new _Subscriber.Subscriber(_Observer.empty);
					}

					return new _Subscriber.Subscriber(nextOrObserver, error, complete);
				}
			},
			{
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../symbol/rxSubscriber': '../node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js',
				'../Observer': '../node_modules/rxjs/_esm5/internal/Observer.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/symbol/observable.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.observable = void 0;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				var observable =
					/*@__PURE__*/
					(function () {
						return (typeof Symbol === 'function' && Symbol.observable) || '@@observable';
					})();

				exports.observable = observable;
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/util/identity.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.identity = identity;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				function identity(x) {
					return x;
				}
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/util/pipe.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.pipe = pipe;
				exports.pipeFromArray = pipeFromArray;

				var _identity = require('./identity');

				/** PURE_IMPORTS_START _identity PURE_IMPORTS_END */
				function pipe() {
					var fns = [];

					for (var _i = 0; _i < arguments.length; _i++) {
						fns[_i] = arguments[_i];
					}

					return pipeFromArray(fns);
				}

				function pipeFromArray(fns) {
					if (fns.length === 0) {
						return _identity.identity;
					}

					if (fns.length === 1) {
						return fns[0];
					}

					return function piped(input) {
						return fns.reduce(function (prev, fn) {
							return fn(prev);
						}, input);
					};
				}
			},
			{ './identity': '../node_modules/rxjs/_esm5/internal/util/identity.js' }
		],
		'../node_modules/rxjs/_esm5/internal/Observable.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.Observable = void 0;

				var _canReportError = require('./util/canReportError');

				var _toSubscriber = require('./util/toSubscriber');

				var _observable = require('./symbol/observable');

				var _pipe = require('./util/pipe');

				var _config = require('./config');

				/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
				var Observable =
					/*@__PURE__*/
					(function () {
						function Observable(subscribe) {
							this._isScalar = false;

							if (subscribe) {
								this._subscribe = subscribe;
							}
						}

						Observable.prototype.lift = function (operator) {
							var observable = new Observable();
							observable.source = this;
							observable.operator = operator;
							return observable;
						};

						Observable.prototype.subscribe = function (observerOrNext, error, complete) {
							var operator = this.operator;
							var sink = (0, _toSubscriber.toSubscriber)(observerOrNext, error, complete);

							if (operator) {
								sink.add(operator.call(sink, this.source));
							} else {
								sink.add(
									this.source ||
										(_config.config.useDeprecatedSynchronousErrorHandling &&
											!sink.syncErrorThrowable)
										? this._subscribe(sink)
										: this._trySubscribe(sink)
								);
							}

							if (_config.config.useDeprecatedSynchronousErrorHandling) {
								if (sink.syncErrorThrowable) {
									sink.syncErrorThrowable = false;

									if (sink.syncErrorThrown) {
										throw sink.syncErrorValue;
									}
								}
							}

							return sink;
						};

						Observable.prototype._trySubscribe = function (sink) {
							try {
								return this._subscribe(sink);
							} catch (err) {
								if (_config.config.useDeprecatedSynchronousErrorHandling) {
									sink.syncErrorThrown = true;
									sink.syncErrorValue = err;
								}

								if ((0, _canReportError.canReportError)(sink)) {
									sink.error(err);
								} else {
									console.warn(err);
								}
							}
						};

						Observable.prototype.forEach = function (next, promiseCtor) {
							var _this = this;

							promiseCtor = getPromiseCtor(promiseCtor);
							return new promiseCtor(function (resolve, reject) {
								var subscription;
								subscription = _this.subscribe(
									function (value) {
										try {
											next(value);
										} catch (err) {
											reject(err);

											if (subscription) {
												subscription.unsubscribe();
											}
										}
									},
									reject,
									resolve
								);
							});
						};

						Observable.prototype._subscribe = function (subscriber) {
							var source = this.source;
							return source && source.subscribe(subscriber);
						};

						Observable.prototype[_observable.observable] = function () {
							return this;
						};

						Observable.prototype.pipe = function () {
							var operations = [];

							for (var _i = 0; _i < arguments.length; _i++) {
								operations[_i] = arguments[_i];
							}

							if (operations.length === 0) {
								return this;
							}

							return (0, _pipe.pipeFromArray)(operations)(this);
						};

						Observable.prototype.toPromise = function (promiseCtor) {
							var _this = this;

							promiseCtor = getPromiseCtor(promiseCtor);
							return new promiseCtor(function (resolve, reject) {
								var value;

								_this.subscribe(
									function (x) {
										return (value = x);
									},
									function (err) {
										return reject(err);
									},
									function () {
										return resolve(value);
									}
								);
							});
						};

						Observable.create = function (subscribe) {
							return new Observable(subscribe);
						};

						return Observable;
					})();

				exports.Observable = Observable;

				function getPromiseCtor(promiseCtor) {
					if (!promiseCtor) {
						promiseCtor = _config.config.Promise || Promise;
					}

					if (!promiseCtor) {
						throw new Error('no Promise impl found');
					}

					return promiseCtor;
				}
			},
			{
				'./util/canReportError': '../node_modules/rxjs/_esm5/internal/util/canReportError.js',
				'./util/toSubscriber': '../node_modules/rxjs/_esm5/internal/util/toSubscriber.js',
				'./symbol/observable': '../node_modules/rxjs/_esm5/internal/symbol/observable.js',
				'./util/pipe': '../node_modules/rxjs/_esm5/internal/util/pipe.js',
				'./config': '../node_modules/rxjs/_esm5/internal/config.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.ObjectUnsubscribedError = void 0;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				var ObjectUnsubscribedErrorImpl =
					/*@__PURE__*/
					(function () {
						function ObjectUnsubscribedErrorImpl() {
							Error.call(this);
							this.message = 'object unsubscribed';
							this.name = 'ObjectUnsubscribedError';
							return this;
						}

						ObjectUnsubscribedErrorImpl.prototype =
							/*@__PURE__*/
							Object.create(Error.prototype);
						return ObjectUnsubscribedErrorImpl;
					})();

				var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
				exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/SubjectSubscription.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.SubjectSubscription = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscription = require('./Subscription');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
				var SubjectSubscription =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(SubjectSubscription, _super);

						function SubjectSubscription(subject, subscriber) {
							var _this = _super.call(this) || this;

							_this.subject = subject;
							_this.subscriber = subscriber;
							_this.closed = false;
							return _this;
						}

						SubjectSubscription.prototype.unsubscribe = function () {
							if (this.closed) {
								return;
							}

							this.closed = true;
							var subject = this.subject;
							var observers = subject.observers;
							this.subject = null;

							if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
								return;
							}

							var subscriberIndex = observers.indexOf(this.subscriber);

							if (subscriberIndex !== -1) {
								observers.splice(subscriberIndex, 1);
							}
						};

						return SubjectSubscription;
					})(_Subscription.Subscription);

				exports.SubjectSubscription = SubjectSubscription;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'./Subscription': '../node_modules/rxjs/_esm5/internal/Subscription.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/Subject.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.AnonymousSubject = exports.Subject = exports.SubjectSubscriber = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Observable = require('./Observable');

				var _Subscriber = require('./Subscriber');

				var _Subscription = require('./Subscription');

				var _ObjectUnsubscribedError = require('./util/ObjectUnsubscribedError');

				var _SubjectSubscription = require('./SubjectSubscription');

				var _rxSubscriber = require('../internal/symbol/rxSubscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */
				var SubjectSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(SubjectSubscriber, _super);

						function SubjectSubscriber(destination) {
							var _this = _super.call(this, destination) || this;

							_this.destination = destination;
							return _this;
						}

						return SubjectSubscriber;
					})(_Subscriber.Subscriber);

				exports.SubjectSubscriber = SubjectSubscriber;

				var Subject =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(Subject, _super);

						function Subject() {
							var _this = _super.call(this) || this;

							_this.observers = [];
							_this.closed = false;
							_this.isStopped = false;
							_this.hasError = false;
							_this.thrownError = null;
							return _this;
						}

						Subject.prototype[_rxSubscriber.rxSubscriber] = function () {
							return new SubjectSubscriber(this);
						};

						Subject.prototype.lift = function (operator) {
							var subject = new AnonymousSubject(this, this);
							subject.operator = operator;
							return subject;
						};

						Subject.prototype.next = function (value) {
							if (this.closed) {
								throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
							}

							if (!this.isStopped) {
								var observers = this.observers;
								var len = observers.length;
								var copy = observers.slice();

								for (var i = 0; i < len; i++) {
									copy[i].next(value);
								}
							}
						};

						Subject.prototype.error = function (err) {
							if (this.closed) {
								throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
							}

							this.hasError = true;
							this.thrownError = err;
							this.isStopped = true;
							var observers = this.observers;
							var len = observers.length;
							var copy = observers.slice();

							for (var i = 0; i < len; i++) {
								copy[i].error(err);
							}

							this.observers.length = 0;
						};

						Subject.prototype.complete = function () {
							if (this.closed) {
								throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
							}

							this.isStopped = true;
							var observers = this.observers;
							var len = observers.length;
							var copy = observers.slice();

							for (var i = 0; i < len; i++) {
								copy[i].complete();
							}

							this.observers.length = 0;
						};

						Subject.prototype.unsubscribe = function () {
							this.isStopped = true;
							this.closed = true;
							this.observers = null;
						};

						Subject.prototype._trySubscribe = function (subscriber) {
							if (this.closed) {
								throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
							} else {
								return _super.prototype._trySubscribe.call(this, subscriber);
							}
						};

						Subject.prototype._subscribe = function (subscriber) {
							if (this.closed) {
								throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
							} else if (this.hasError) {
								subscriber.error(this.thrownError);
								return _Subscription.Subscription.EMPTY;
							} else if (this.isStopped) {
								subscriber.complete();
								return _Subscription.Subscription.EMPTY;
							} else {
								this.observers.push(subscriber);
								return new _SubjectSubscription.SubjectSubscription(this, subscriber);
							}
						};

						Subject.prototype.asObservable = function () {
							var observable = new _Observable.Observable();
							observable.source = this;
							return observable;
						};

						Subject.create = function (destination, source) {
							return new AnonymousSubject(destination, source);
						};

						return Subject;
					})(_Observable.Observable);

				exports.Subject = Subject;

				var AnonymousSubject =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(AnonymousSubject, _super);

						function AnonymousSubject(destination, source) {
							var _this = _super.call(this) || this;

							_this.destination = destination;
							_this.source = source;
							return _this;
						}

						AnonymousSubject.prototype.next = function (value) {
							var destination = this.destination;

							if (destination && destination.next) {
								destination.next(value);
							}
						};

						AnonymousSubject.prototype.error = function (err) {
							var destination = this.destination;

							if (destination && destination.error) {
								this.destination.error(err);
							}
						};

						AnonymousSubject.prototype.complete = function () {
							var destination = this.destination;

							if (destination && destination.complete) {
								this.destination.complete();
							}
						};

						AnonymousSubject.prototype._subscribe = function (subscriber) {
							var source = this.source;

							if (source) {
								return this.source.subscribe(subscriber);
							} else {
								return _Subscription.Subscription.EMPTY;
							}
						};

						return AnonymousSubject;
					})(Subject);

				exports.AnonymousSubject = AnonymousSubject;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'./Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'./Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'./Subscription': '../node_modules/rxjs/_esm5/internal/Subscription.js',
				'./util/ObjectUnsubscribedError':
					'../node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js',
				'./SubjectSubscription': '../node_modules/rxjs/_esm5/internal/SubjectSubscription.js',
				'../internal/symbol/rxSubscriber':
					'../node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/refCount.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.refCount = refCount;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				function refCount() {
					return function refCountOperatorFunction(source) {
						return source.lift(new RefCountOperator(source));
					};
				}

				var RefCountOperator =
					/*@__PURE__*/
					(function () {
						function RefCountOperator(connectable) {
							this.connectable = connectable;
						}

						RefCountOperator.prototype.call = function (subscriber, source) {
							var connectable = this.connectable;
							connectable._refCount++;
							var refCounter = new RefCountSubscriber(subscriber, connectable);
							var subscription = source.subscribe(refCounter);

							if (!refCounter.closed) {
								refCounter.connection = connectable.connect();
							}

							return subscription;
						};

						return RefCountOperator;
					})();

				var RefCountSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(RefCountSubscriber, _super);

						function RefCountSubscriber(destination, connectable) {
							var _this = _super.call(this, destination) || this;

							_this.connectable = connectable;
							return _this;
						}

						RefCountSubscriber.prototype._unsubscribe = function () {
							var connectable = this.connectable;

							if (!connectable) {
								this.connection = null;
								return;
							}

							this.connectable = null;
							var refCount = connectable._refCount;

							if (refCount <= 0) {
								this.connection = null;
								return;
							}

							connectable._refCount = refCount - 1;

							if (refCount > 1) {
								this.connection = null;
								return;
							}

							var connection = this.connection;
							var sharedConnection = connectable._connection;
							this.connection = null;

							if (sharedConnection && (!connection || sharedConnection === connection)) {
								sharedConnection.unsubscribe();
							}
						};

						return RefCountSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.connectableObservableDescriptor = exports.ConnectableObservable = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subject = require('../Subject');

				var _Observable = require('../Observable');

				var _Subscriber = require('../Subscriber');

				var _Subscription = require('../Subscription');

				var _refCount = require('../operators/refCount');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */
				var ConnectableObservable =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(ConnectableObservable, _super);

						function ConnectableObservable(source, subjectFactory) {
							var _this = _super.call(this) || this;

							_this.source = source;
							_this.subjectFactory = subjectFactory;
							_this._refCount = 0;
							_this._isComplete = false;
							return _this;
						}

						ConnectableObservable.prototype._subscribe = function (subscriber) {
							return this.getSubject().subscribe(subscriber);
						};

						ConnectableObservable.prototype.getSubject = function () {
							var subject = this._subject;

							if (!subject || subject.isStopped) {
								this._subject = this.subjectFactory();
							}

							return this._subject;
						};

						ConnectableObservable.prototype.connect = function () {
							var connection = this._connection;

							if (!connection) {
								this._isComplete = false;
								connection = this._connection = new _Subscription.Subscription();
								connection.add(
									this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this))
								);

								if (connection.closed) {
									this._connection = null;
									connection = _Subscription.Subscription.EMPTY;
								}
							}

							return connection;
						};

						ConnectableObservable.prototype.refCount = function () {
							return (0, _refCount.refCount)()(this);
						};

						return ConnectableObservable;
					})(_Observable.Observable);

				exports.ConnectableObservable = ConnectableObservable;

				var connectableObservableDescriptor =
					/*@__PURE__*/
					(function () {
						var connectableProto = ConnectableObservable.prototype;
						return {
							operator: {
								value: null
							},
							_refCount: {
								value: 0,
								writable: true
							},
							_subject: {
								value: null,
								writable: true
							},
							_connection: {
								value: null,
								writable: true
							},
							_subscribe: {
								value: connectableProto._subscribe
							},
							_isComplete: {
								value: connectableProto._isComplete,
								writable: true
							},
							getSubject: {
								value: connectableProto.getSubject
							},
							connect: {
								value: connectableProto.connect
							},
							refCount: {
								value: connectableProto.refCount
							}
						};
					})();

				exports.connectableObservableDescriptor = connectableObservableDescriptor;

				var ConnectableSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(ConnectableSubscriber, _super);

						function ConnectableSubscriber(destination, connectable) {
							var _this = _super.call(this, destination) || this;

							_this.connectable = connectable;
							return _this;
						}

						ConnectableSubscriber.prototype._error = function (err) {
							this._unsubscribe();

							_super.prototype._error.call(this, err);
						};

						ConnectableSubscriber.prototype._complete = function () {
							this.connectable._isComplete = true;

							this._unsubscribe();

							_super.prototype._complete.call(this);
						};

						ConnectableSubscriber.prototype._unsubscribe = function () {
							var connectable = this.connectable;

							if (connectable) {
								this.connectable = null;
								var connection = connectable._connection;
								connectable._refCount = 0;
								connectable._subject = null;
								connectable._connection = null;

								if (connection) {
									connection.unsubscribe();
								}
							}
						};

						return ConnectableSubscriber;
					})(_Subject.SubjectSubscriber);

				var RefCountOperator =
					/*@__PURE__*/
					(function () {
						function RefCountOperator(connectable) {
							this.connectable = connectable;
						}

						RefCountOperator.prototype.call = function (subscriber, source) {
							var connectable = this.connectable;
							connectable._refCount++;
							var refCounter = new RefCountSubscriber(subscriber, connectable);
							var subscription = source.subscribe(refCounter);

							if (!refCounter.closed) {
								refCounter.connection = connectable.connect();
							}

							return subscription;
						};

						return RefCountOperator;
					})();

				var RefCountSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(RefCountSubscriber, _super);

						function RefCountSubscriber(destination, connectable) {
							var _this = _super.call(this, destination) || this;

							_this.connectable = connectable;
							return _this;
						}

						RefCountSubscriber.prototype._unsubscribe = function () {
							var connectable = this.connectable;

							if (!connectable) {
								this.connection = null;
								return;
							}

							this.connectable = null;
							var refCount = connectable._refCount;

							if (refCount <= 0) {
								this.connection = null;
								return;
							}

							connectable._refCount = refCount - 1;

							if (refCount > 1) {
								this.connection = null;
								return;
							}

							var connection = this.connection;
							var sharedConnection = connectable._connection;
							this.connection = null;

							if (sharedConnection && (!connection || sharedConnection === connection)) {
								sharedConnection.unsubscribe();
							}
						};

						return RefCountSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subject': '../node_modules/rxjs/_esm5/internal/Subject.js',
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../Subscription': '../node_modules/rxjs/_esm5/internal/Subscription.js',
				'../operators/refCount': '../node_modules/rxjs/_esm5/internal/operators/refCount.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/groupBy.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.groupBy = groupBy;
				exports.GroupedObservable = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				var _Subscription = require('../Subscription');

				var _Observable = require('../Observable');

				var _Subject = require('../Subject');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */
				function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
					return function (source) {
						return source.lift(
							new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector)
						);
					};
				}

				var GroupByOperator =
					/*@__PURE__*/
					(function () {
						function GroupByOperator(
							keySelector,
							elementSelector,
							durationSelector,
							subjectSelector
						) {
							this.keySelector = keySelector;
							this.elementSelector = elementSelector;
							this.durationSelector = durationSelector;
							this.subjectSelector = subjectSelector;
						}

						GroupByOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new GroupBySubscriber(
									subscriber,
									this.keySelector,
									this.elementSelector,
									this.durationSelector,
									this.subjectSelector
								)
							);
						};

						return GroupByOperator;
					})();

				var GroupBySubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(GroupBySubscriber, _super);

						function GroupBySubscriber(
							destination,
							keySelector,
							elementSelector,
							durationSelector,
							subjectSelector
						) {
							var _this = _super.call(this, destination) || this;

							_this.keySelector = keySelector;
							_this.elementSelector = elementSelector;
							_this.durationSelector = durationSelector;
							_this.subjectSelector = subjectSelector;
							_this.groups = null;
							_this.attemptedToUnsubscribe = false;
							_this.count = 0;
							return _this;
						}

						GroupBySubscriber.prototype._next = function (value) {
							var key;

							try {
								key = this.keySelector(value);
							} catch (err) {
								this.error(err);
								return;
							}

							this._group(value, key);
						};

						GroupBySubscriber.prototype._group = function (value, key) {
							var groups = this.groups;

							if (!groups) {
								groups = this.groups = new Map();
							}

							var group = groups.get(key);
							var element;

							if (this.elementSelector) {
								try {
									element = this.elementSelector(value);
								} catch (err) {
									this.error(err);
								}
							} else {
								element = value;
							}

							if (!group) {
								group = this.subjectSelector ? this.subjectSelector() : new _Subject.Subject();
								groups.set(key, group);
								var groupedObservable = new GroupedObservable(key, group, this);
								this.destination.next(groupedObservable);

								if (this.durationSelector) {
									var duration = void 0;

									try {
										duration = this.durationSelector(new GroupedObservable(key, group));
									} catch (err) {
										this.error(err);
										return;
									}

									this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
								}
							}

							if (!group.closed) {
								group.next(element);
							}
						};

						GroupBySubscriber.prototype._error = function (err) {
							var groups = this.groups;

							if (groups) {
								groups.forEach(function (group, key) {
									group.error(err);
								});
								groups.clear();
							}

							this.destination.error(err);
						};

						GroupBySubscriber.prototype._complete = function () {
							var groups = this.groups;

							if (groups) {
								groups.forEach(function (group, key) {
									group.complete();
								});
								groups.clear();
							}

							this.destination.complete();
						};

						GroupBySubscriber.prototype.removeGroup = function (key) {
							this.groups.delete(key);
						};

						GroupBySubscriber.prototype.unsubscribe = function () {
							if (!this.closed) {
								this.attemptedToUnsubscribe = true;

								if (this.count === 0) {
									_super.prototype.unsubscribe.call(this);
								}
							}
						};

						return GroupBySubscriber;
					})(_Subscriber.Subscriber);

				var GroupDurationSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(GroupDurationSubscriber, _super);

						function GroupDurationSubscriber(key, group, parent) {
							var _this = _super.call(this, group) || this;

							_this.key = key;
							_this.group = group;
							_this.parent = parent;
							return _this;
						}

						GroupDurationSubscriber.prototype._next = function (value) {
							this.complete();
						};

						GroupDurationSubscriber.prototype._unsubscribe = function () {
							var _a = this,
								parent = _a.parent,
								key = _a.key;

							this.key = this.parent = null;

							if (parent) {
								parent.removeGroup(key);
							}
						};

						return GroupDurationSubscriber;
					})(_Subscriber.Subscriber);

				var GroupedObservable =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(GroupedObservable, _super);

						function GroupedObservable(key, groupSubject, refCountSubscription) {
							var _this = _super.call(this) || this;

							_this.key = key;
							_this.groupSubject = groupSubject;
							_this.refCountSubscription = refCountSubscription;
							return _this;
						}

						GroupedObservable.prototype._subscribe = function (subscriber) {
							var subscription = new _Subscription.Subscription();

							var _a = this,
								refCountSubscription = _a.refCountSubscription,
								groupSubject = _a.groupSubject;

							if (refCountSubscription && !refCountSubscription.closed) {
								subscription.add(new InnerRefCountSubscription(refCountSubscription));
							}

							subscription.add(groupSubject.subscribe(subscriber));
							return subscription;
						};

						return GroupedObservable;
					})(_Observable.Observable);

				exports.GroupedObservable = GroupedObservable;

				var InnerRefCountSubscription =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(InnerRefCountSubscription, _super);

						function InnerRefCountSubscription(parent) {
							var _this = _super.call(this) || this;

							_this.parent = parent;
							parent.count++;
							return _this;
						}

						InnerRefCountSubscription.prototype.unsubscribe = function () {
							var parent = this.parent;

							if (!parent.closed && !this.closed) {
								_super.prototype.unsubscribe.call(this);

								parent.count -= 1;

								if (parent.count === 0 && parent.attemptedToUnsubscribe) {
									parent.unsubscribe();
								}
							}
						};

						return InnerRefCountSubscription;
					})(_Subscription.Subscription);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../Subscription': '../node_modules/rxjs/_esm5/internal/Subscription.js',
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../Subject': '../node_modules/rxjs/_esm5/internal/Subject.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/BehaviorSubject.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.BehaviorSubject = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subject = require('./Subject');

				var _ObjectUnsubscribedError = require('./util/ObjectUnsubscribedError');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */
				var BehaviorSubject =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(BehaviorSubject, _super);

						function BehaviorSubject(_value) {
							var _this = _super.call(this) || this;

							_this._value = _value;
							return _this;
						}

						Object.defineProperty(BehaviorSubject.prototype, 'value', {
							get: function () {
								return this.getValue();
							},
							enumerable: true,
							configurable: true
						});

						BehaviorSubject.prototype._subscribe = function (subscriber) {
							var subscription = _super.prototype._subscribe.call(this, subscriber);

							if (subscription && !subscription.closed) {
								subscriber.next(this._value);
							}

							return subscription;
						};

						BehaviorSubject.prototype.getValue = function () {
							if (this.hasError) {
								throw this.thrownError;
							} else if (this.closed) {
								throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
							} else {
								return this._value;
							}
						};

						BehaviorSubject.prototype.next = function (value) {
							_super.prototype.next.call(this, (this._value = value));
						};

						return BehaviorSubject;
					})(_Subject.Subject);

				exports.BehaviorSubject = BehaviorSubject;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'./Subject': '../node_modules/rxjs/_esm5/internal/Subject.js',
				'./util/ObjectUnsubscribedError':
					'../node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/scheduler/Action.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.Action = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscription = require('../Subscription');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
				var Action =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(Action, _super);

						function Action(scheduler, work) {
							return _super.call(this) || this;
						}

						Action.prototype.schedule = function (state, delay) {
							if (delay === void 0) {
								delay = 0;
							}

							return this;
						};

						return Action;
					})(_Subscription.Subscription);

				exports.Action = Action;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscription': '../node_modules/rxjs/_esm5/internal/Subscription.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.AsyncAction = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Action = require('./Action');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */
				var AsyncAction =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(AsyncAction, _super);

						function AsyncAction(scheduler, work) {
							var _this = _super.call(this, scheduler, work) || this;

							_this.scheduler = scheduler;
							_this.work = work;
							_this.pending = false;
							return _this;
						}

						AsyncAction.prototype.schedule = function (state, delay) {
							if (delay === void 0) {
								delay = 0;
							}

							if (this.closed) {
								return this;
							}

							this.state = state;
							var id = this.id;
							var scheduler = this.scheduler;

							if (id != null) {
								this.id = this.recycleAsyncId(scheduler, id, delay);
							}

							this.pending = true;
							this.delay = delay;
							this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
							return this;
						};

						AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
							if (delay === void 0) {
								delay = 0;
							}

							return setInterval(scheduler.flush.bind(scheduler, this), delay);
						};

						AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
							if (delay === void 0) {
								delay = 0;
							}

							if (delay !== null && this.delay === delay && this.pending === false) {
								return id;
							}

							clearInterval(id);
							return undefined;
						};

						AsyncAction.prototype.execute = function (state, delay) {
							if (this.closed) {
								return new Error('executing a cancelled action');
							}

							this.pending = false;

							var error = this._execute(state, delay);

							if (error) {
								return error;
							} else if (this.pending === false && this.id != null) {
								this.id = this.recycleAsyncId(this.scheduler, this.id, null);
							}
						};

						AsyncAction.prototype._execute = function (state, delay) {
							var errored = false;
							var errorValue = undefined;

							try {
								this.work(state);
							} catch (e) {
								errored = true;
								errorValue = (!!e && e) || new Error(e);
							}

							if (errored) {
								this.unsubscribe();
								return errorValue;
							}
						};

						AsyncAction.prototype._unsubscribe = function () {
							var id = this.id;
							var scheduler = this.scheduler;
							var actions = scheduler.actions;
							var index = actions.indexOf(this);
							this.work = null;
							this.state = null;
							this.pending = false;
							this.scheduler = null;

							if (index !== -1) {
								actions.splice(index, 1);
							}

							if (id != null) {
								this.id = this.recycleAsyncId(scheduler, id, null);
							}

							this.delay = null;
						};

						return AsyncAction;
					})(_Action.Action);

				exports.AsyncAction = AsyncAction;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'./Action': '../node_modules/rxjs/_esm5/internal/scheduler/Action.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.QueueAction = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _AsyncAction = require('./AsyncAction');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
				var QueueAction =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(QueueAction, _super);

						function QueueAction(scheduler, work) {
							var _this = _super.call(this, scheduler, work) || this;

							_this.scheduler = scheduler;
							_this.work = work;
							return _this;
						}

						QueueAction.prototype.schedule = function (state, delay) {
							if (delay === void 0) {
								delay = 0;
							}

							if (delay > 0) {
								return _super.prototype.schedule.call(this, state, delay);
							}

							this.delay = delay;
							this.state = state;
							this.scheduler.flush(this);
							return this;
						};

						QueueAction.prototype.execute = function (state, delay) {
							return delay > 0 || this.closed
								? _super.prototype.execute.call(this, state, delay)
								: this._execute(state, delay);
						};

						QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
							if (delay === void 0) {
								delay = 0;
							}

							if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
								return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
							}

							return scheduler.flush(this);
						};

						return QueueAction;
					})(_AsyncAction.AsyncAction);

				exports.QueueAction = QueueAction;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'./AsyncAction': '../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/Scheduler.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.Scheduler = void 0;

				var Scheduler =
					/*@__PURE__*/
					(function () {
						function Scheduler(SchedulerAction, now) {
							if (now === void 0) {
								now = Scheduler.now;
							}

							this.SchedulerAction = SchedulerAction;
							this.now = now;
						}

						Scheduler.prototype.schedule = function (work, delay, state) {
							if (delay === void 0) {
								delay = 0;
							}

							return new this.SchedulerAction(this, work).schedule(state, delay);
						};

						Scheduler.now = function () {
							return Date.now();
						};

						return Scheduler;
					})();

				exports.Scheduler = Scheduler;
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.AsyncScheduler = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Scheduler = require('../Scheduler');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */
				var AsyncScheduler =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(AsyncScheduler, _super);

						function AsyncScheduler(SchedulerAction, now) {
							if (now === void 0) {
								now = _Scheduler.Scheduler.now;
							}

							var _this =
								_super.call(this, SchedulerAction, function () {
									if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
										return AsyncScheduler.delegate.now();
									} else {
										return now();
									}
								}) || this;

							_this.actions = [];
							_this.active = false;
							_this.scheduled = undefined;
							return _this;
						}

						AsyncScheduler.prototype.schedule = function (work, delay, state) {
							if (delay === void 0) {
								delay = 0;
							}

							if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
								return AsyncScheduler.delegate.schedule(work, delay, state);
							} else {
								return _super.prototype.schedule.call(this, work, delay, state);
							}
						};

						AsyncScheduler.prototype.flush = function (action) {
							var actions = this.actions;

							if (this.active) {
								actions.push(action);
								return;
							}

							var error;
							this.active = true;

							do {
								if ((error = action.execute(action.state, action.delay))) {
									break;
								}
							} while ((action = actions.shift()));

							this.active = false;

							if (error) {
								while ((action = actions.shift())) {
									action.unsubscribe();
								}

								throw error;
							}
						};

						return AsyncScheduler;
					})(_Scheduler.Scheduler);

				exports.AsyncScheduler = AsyncScheduler;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Scheduler': '../node_modules/rxjs/_esm5/internal/Scheduler.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.QueueScheduler = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _AsyncScheduler = require('./AsyncScheduler');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
				var QueueScheduler =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(QueueScheduler, _super);

						function QueueScheduler() {
							return (_super !== null && _super.apply(this, arguments)) || this;
						}

						return QueueScheduler;
					})(_AsyncScheduler.AsyncScheduler);

				exports.QueueScheduler = QueueScheduler;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'./AsyncScheduler': '../node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/scheduler/queue.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.queue = exports.queueScheduler = void 0;

				var _QueueAction = require('./QueueAction');

				var _QueueScheduler = require('./QueueScheduler');

				/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */
				var queueScheduler =
					/*@__PURE__*/
					new _QueueScheduler.QueueScheduler(_QueueAction.QueueAction);
				exports.queueScheduler = queueScheduler;
				var queue = queueScheduler;
				exports.queue = queue;
			},
			{
				'./QueueAction': '../node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js',
				'./QueueScheduler': '../node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/empty.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.empty = empty;
				exports.EMPTY = void 0;

				var _Observable = require('../Observable');

				/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
				var EMPTY =
					/*@__PURE__*/
					new _Observable.Observable(function (subscriber) {
						return subscriber.complete();
					});
				exports.EMPTY = EMPTY;

				function empty(scheduler) {
					return scheduler ? emptyScheduled(scheduler) : EMPTY;
				}

				function emptyScheduled(scheduler) {
					return new _Observable.Observable(function (subscriber) {
						return scheduler.schedule(function () {
							return subscriber.complete();
						});
					});
				}
			},
			{ '../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js' }
		],
		'../node_modules/rxjs/_esm5/internal/util/isScheduler.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.isScheduler = isScheduler;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				function isScheduler(value) {
					return value && typeof value.schedule === 'function';
				}
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/util/subscribeToArray.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.subscribeToArray = void 0;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				var subscribeToArray = function (array) {
					return function (subscriber) {
						for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
							subscriber.next(array[i]);
						}

						subscriber.complete();
					};
				};

				exports.subscribeToArray = subscribeToArray;
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.scheduleArray = scheduleArray;

				var _Observable = require('../Observable');

				var _Subscription = require('../Subscription');

				/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
				function scheduleArray(input, scheduler) {
					return new _Observable.Observable(function (subscriber) {
						var sub = new _Subscription.Subscription();
						var i = 0;
						sub.add(
							scheduler.schedule(function () {
								if (i === input.length) {
									subscriber.complete();
									return;
								}

								subscriber.next(input[i++]);

								if (!subscriber.closed) {
									sub.add(this.schedule());
								}
							})
						);
						return sub;
					});
				}
			},
			{
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../Subscription': '../node_modules/rxjs/_esm5/internal/Subscription.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/fromArray.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.fromArray = fromArray;

				var _Observable = require('../Observable');

				var _subscribeToArray = require('../util/subscribeToArray');

				var _scheduleArray = require('../scheduled/scheduleArray');

				/** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */
				function fromArray(input, scheduler) {
					if (!scheduler) {
						return new _Observable.Observable((0, _subscribeToArray.subscribeToArray)(input));
					} else {
						return (0, _scheduleArray.scheduleArray)(input, scheduler);
					}
				}
			},
			{
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../util/subscribeToArray': '../node_modules/rxjs/_esm5/internal/util/subscribeToArray.js',
				'../scheduled/scheduleArray':
					'../node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/of.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.of = of;

				var _isScheduler = require('../util/isScheduler');

				var _fromArray = require('./fromArray');

				var _scheduleArray = require('../scheduled/scheduleArray');

				/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_scheduled_scheduleArray PURE_IMPORTS_END */
				function of() {
					var args = [];

					for (var _i = 0; _i < arguments.length; _i++) {
						args[_i] = arguments[_i];
					}

					var scheduler = args[args.length - 1];

					if ((0, _isScheduler.isScheduler)(scheduler)) {
						args.pop();
						return (0, _scheduleArray.scheduleArray)(args, scheduler);
					} else {
						return (0, _fromArray.fromArray)(args);
					}
				}
			},
			{
				'../util/isScheduler': '../node_modules/rxjs/_esm5/internal/util/isScheduler.js',
				'./fromArray': '../node_modules/rxjs/_esm5/internal/observable/fromArray.js',
				'../scheduled/scheduleArray':
					'../node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/throwError.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.throwError = throwError;

				var _Observable = require('../Observable');

				/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
				function throwError(error, scheduler) {
					if (!scheduler) {
						return new _Observable.Observable(function (subscriber) {
							return subscriber.error(error);
						});
					} else {
						return new _Observable.Observable(function (subscriber) {
							return scheduler.schedule(dispatch, 0, {
								error: error,
								subscriber: subscriber
							});
						});
					}
				}

				function dispatch(_a) {
					var error = _a.error,
						subscriber = _a.subscriber;
					subscriber.error(error);
				}
			},
			{ '../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js' }
		],
		'../node_modules/rxjs/_esm5/internal/Notification.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.Notification = exports.NotificationKind = void 0;

				var _empty = require('./observable/empty');

				var _of = require('./observable/of');

				var _throwError = require('./observable/throwError');

				/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */
				var NotificationKind;
				/*@__PURE__*/

				exports.NotificationKind = NotificationKind;

				(function (NotificationKind) {
					NotificationKind['NEXT'] = 'N';
					NotificationKind['ERROR'] = 'E';
					NotificationKind['COMPLETE'] = 'C';
				})(NotificationKind || (exports.NotificationKind = NotificationKind = {}));

				var Notification =
					/*@__PURE__*/
					(function () {
						function Notification(kind, value, error) {
							this.kind = kind;
							this.value = value;
							this.error = error;
							this.hasValue = kind === 'N';
						}

						Notification.prototype.observe = function (observer) {
							switch (this.kind) {
								case 'N':
									return observer.next && observer.next(this.value);

								case 'E':
									return observer.error && observer.error(this.error);

								case 'C':
									return observer.complete && observer.complete();
							}
						};

						Notification.prototype.do = function (next, error, complete) {
							var kind = this.kind;

							switch (kind) {
								case 'N':
									return next && next(this.value);

								case 'E':
									return error && error(this.error);

								case 'C':
									return complete && complete();
							}
						};

						Notification.prototype.accept = function (nextOrObserver, error, complete) {
							if (nextOrObserver && typeof nextOrObserver.next === 'function') {
								return this.observe(nextOrObserver);
							} else {
								return this.do(nextOrObserver, error, complete);
							}
						};

						Notification.prototype.toObservable = function () {
							var kind = this.kind;

							switch (kind) {
								case 'N':
									return (0, _of.of)(this.value);

								case 'E':
									return (0, _throwError.throwError)(this.error);

								case 'C':
									return (0, _empty.empty)();
							}

							throw new Error('unexpected notification kind value');
						};

						Notification.createNext = function (value) {
							if (typeof value !== 'undefined') {
								return new Notification('N', value);
							}

							return Notification.undefinedValueNotification;
						};

						Notification.createError = function (err) {
							return new Notification('E', undefined, err);
						};

						Notification.createComplete = function () {
							return Notification.completeNotification;
						};

						Notification.completeNotification = new Notification('C');
						Notification.undefinedValueNotification = new Notification('N', undefined);
						return Notification;
					})();

				exports.Notification = Notification;
			},
			{
				'./observable/empty': '../node_modules/rxjs/_esm5/internal/observable/empty.js',
				'./observable/of': '../node_modules/rxjs/_esm5/internal/observable/of.js',
				'./observable/throwError': '../node_modules/rxjs/_esm5/internal/observable/throwError.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/observeOn.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.observeOn = observeOn;
				exports.ObserveOnMessage = exports.ObserveOnSubscriber = exports.ObserveOnOperator = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				var _Notification = require('../Notification');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */
				function observeOn(scheduler, delay) {
					if (delay === void 0) {
						delay = 0;
					}

					return function observeOnOperatorFunction(source) {
						return source.lift(new ObserveOnOperator(scheduler, delay));
					};
				}

				var ObserveOnOperator =
					/*@__PURE__*/
					(function () {
						function ObserveOnOperator(scheduler, delay) {
							if (delay === void 0) {
								delay = 0;
							}

							this.scheduler = scheduler;
							this.delay = delay;
						}

						ObserveOnOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new ObserveOnSubscriber(subscriber, this.scheduler, this.delay)
							);
						};

						return ObserveOnOperator;
					})();

				exports.ObserveOnOperator = ObserveOnOperator;

				var ObserveOnSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(ObserveOnSubscriber, _super);

						function ObserveOnSubscriber(destination, scheduler, delay) {
							if (delay === void 0) {
								delay = 0;
							}

							var _this = _super.call(this, destination) || this;

							_this.scheduler = scheduler;
							_this.delay = delay;
							return _this;
						}

						ObserveOnSubscriber.dispatch = function (arg) {
							var notification = arg.notification,
								destination = arg.destination;
							notification.observe(destination);
							this.unsubscribe();
						};

						ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
							var destination = this.destination;
							destination.add(
								this.scheduler.schedule(
									ObserveOnSubscriber.dispatch,
									this.delay,
									new ObserveOnMessage(notification, this.destination)
								)
							);
						};

						ObserveOnSubscriber.prototype._next = function (value) {
							this.scheduleMessage(_Notification.Notification.createNext(value));
						};

						ObserveOnSubscriber.prototype._error = function (err) {
							this.scheduleMessage(_Notification.Notification.createError(err));
							this.unsubscribe();
						};

						ObserveOnSubscriber.prototype._complete = function () {
							this.scheduleMessage(_Notification.Notification.createComplete());
							this.unsubscribe();
						};

						return ObserveOnSubscriber;
					})(_Subscriber.Subscriber);

				exports.ObserveOnSubscriber = ObserveOnSubscriber;

				var ObserveOnMessage =
					/*@__PURE__*/
					(function () {
						function ObserveOnMessage(notification, destination) {
							this.notification = notification;
							this.destination = destination;
						}

						return ObserveOnMessage;
					})();

				exports.ObserveOnMessage = ObserveOnMessage;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../Notification': '../node_modules/rxjs/_esm5/internal/Notification.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/ReplaySubject.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.ReplaySubject = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subject = require('./Subject');

				var _queue = require('./scheduler/queue');

				var _Subscription = require('./Subscription');

				var _observeOn = require('./operators/observeOn');

				var _ObjectUnsubscribedError = require('./util/ObjectUnsubscribedError');

				var _SubjectSubscription = require('./SubjectSubscription');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */
				var ReplaySubject =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(ReplaySubject, _super);

						function ReplaySubject(bufferSize, windowTime, scheduler) {
							if (bufferSize === void 0) {
								bufferSize = Number.POSITIVE_INFINITY;
							}

							if (windowTime === void 0) {
								windowTime = Number.POSITIVE_INFINITY;
							}

							var _this = _super.call(this) || this;

							_this.scheduler = scheduler;
							_this._events = [];
							_this._infiniteTimeWindow = false;
							_this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
							_this._windowTime = windowTime < 1 ? 1 : windowTime;

							if (windowTime === Number.POSITIVE_INFINITY) {
								_this._infiniteTimeWindow = true;
								_this.next = _this.nextInfiniteTimeWindow;
							} else {
								_this.next = _this.nextTimeWindow;
							}

							return _this;
						}

						ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
							if (!this.isStopped) {
								var _events = this._events;

								_events.push(value);

								if (_events.length > this._bufferSize) {
									_events.shift();
								}
							}

							_super.prototype.next.call(this, value);
						};

						ReplaySubject.prototype.nextTimeWindow = function (value) {
							if (!this.isStopped) {
								this._events.push(new ReplayEvent(this._getNow(), value));

								this._trimBufferThenGetEvents();
							}

							_super.prototype.next.call(this, value);
						};

						ReplaySubject.prototype._subscribe = function (subscriber) {
							var _infiniteTimeWindow = this._infiniteTimeWindow;

							var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();

							var scheduler = this.scheduler;
							var len = _events.length;
							var subscription;

							if (this.closed) {
								throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
							} else if (this.isStopped || this.hasError) {
								subscription = _Subscription.Subscription.EMPTY;
							} else {
								this.observers.push(subscriber);
								subscription = new _SubjectSubscription.SubjectSubscription(this, subscriber);
							}

							if (scheduler) {
								subscriber.add(
									(subscriber = new _observeOn.ObserveOnSubscriber(subscriber, scheduler))
								);
							}

							if (_infiniteTimeWindow) {
								for (var i = 0; i < len && !subscriber.closed; i++) {
									subscriber.next(_events[i]);
								}
							} else {
								for (var i = 0; i < len && !subscriber.closed; i++) {
									subscriber.next(_events[i].value);
								}
							}

							if (this.hasError) {
								subscriber.error(this.thrownError);
							} else if (this.isStopped) {
								subscriber.complete();
							}

							return subscription;
						};

						ReplaySubject.prototype._getNow = function () {
							return (this.scheduler || _queue.queue).now();
						};

						ReplaySubject.prototype._trimBufferThenGetEvents = function () {
							var now = this._getNow();

							var _bufferSize = this._bufferSize;
							var _windowTime = this._windowTime;
							var _events = this._events;
							var eventsCount = _events.length;
							var spliceCount = 0;

							while (spliceCount < eventsCount) {
								if (now - _events[spliceCount].time < _windowTime) {
									break;
								}

								spliceCount++;
							}

							if (eventsCount > _bufferSize) {
								spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
							}

							if (spliceCount > 0) {
								_events.splice(0, spliceCount);
							}

							return _events;
						};

						return ReplaySubject;
					})(_Subject.Subject);

				exports.ReplaySubject = ReplaySubject;

				var ReplayEvent =
					/*@__PURE__*/
					(function () {
						function ReplayEvent(time, value) {
							this.time = time;
							this.value = value;
						}

						return ReplayEvent;
					})();
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'./Subject': '../node_modules/rxjs/_esm5/internal/Subject.js',
				'./scheduler/queue': '../node_modules/rxjs/_esm5/internal/scheduler/queue.js',
				'./Subscription': '../node_modules/rxjs/_esm5/internal/Subscription.js',
				'./operators/observeOn': '../node_modules/rxjs/_esm5/internal/operators/observeOn.js',
				'./util/ObjectUnsubscribedError':
					'../node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js',
				'./SubjectSubscription': '../node_modules/rxjs/_esm5/internal/SubjectSubscription.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/AsyncSubject.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.AsyncSubject = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subject = require('./Subject');

				var _Subscription = require('./Subscription');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */
				var AsyncSubject =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(AsyncSubject, _super);

						function AsyncSubject() {
							var _this = (_super !== null && _super.apply(this, arguments)) || this;

							_this.value = null;
							_this.hasNext = false;
							_this.hasCompleted = false;
							return _this;
						}

						AsyncSubject.prototype._subscribe = function (subscriber) {
							if (this.hasError) {
								subscriber.error(this.thrownError);
								return _Subscription.Subscription.EMPTY;
							} else if (this.hasCompleted && this.hasNext) {
								subscriber.next(this.value);
								subscriber.complete();
								return _Subscription.Subscription.EMPTY;
							}

							return _super.prototype._subscribe.call(this, subscriber);
						};

						AsyncSubject.prototype.next = function (value) {
							if (!this.hasCompleted) {
								this.value = value;
								this.hasNext = true;
							}
						};

						AsyncSubject.prototype.error = function (error) {
							if (!this.hasCompleted) {
								_super.prototype.error.call(this, error);
							}
						};

						AsyncSubject.prototype.complete = function () {
							this.hasCompleted = true;

							if (this.hasNext) {
								_super.prototype.next.call(this, this.value);
							}

							_super.prototype.complete.call(this);
						};

						return AsyncSubject;
					})(_Subject.Subject);

				exports.AsyncSubject = AsyncSubject;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'./Subject': '../node_modules/rxjs/_esm5/internal/Subject.js',
				'./Subscription': '../node_modules/rxjs/_esm5/internal/Subscription.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/util/Immediate.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.TestTools = exports.Immediate = void 0;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				var nextHandle = 1;

				var RESOLVED =
					/*@__PURE__*/
					(function () {
						return (
							/*@__PURE__*/
							Promise.resolve()
						);
					})();

				var activeHandles = {};

				function findAndClearHandle(handle) {
					if (handle in activeHandles) {
						delete activeHandles[handle];
						return true;
					}

					return false;
				}

				var Immediate = {
					setImmediate: function (cb) {
						var handle = nextHandle++;
						activeHandles[handle] = true;
						RESOLVED.then(function () {
							return findAndClearHandle(handle) && cb();
						});
						return handle;
					},
					clearImmediate: function (handle) {
						findAndClearHandle(handle);
					}
				};
				exports.Immediate = Immediate;
				var TestTools = {
					pending: function () {
						return Object.keys(activeHandles).length;
					}
				};
				exports.TestTools = TestTools;
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.AsapAction = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Immediate = require('../util/Immediate');

				var _AsyncAction = require('./AsyncAction');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */
				var AsapAction =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(AsapAction, _super);

						function AsapAction(scheduler, work) {
							var _this = _super.call(this, scheduler, work) || this;

							_this.scheduler = scheduler;
							_this.work = work;
							return _this;
						}

						AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
							if (delay === void 0) {
								delay = 0;
							}

							if (delay !== null && delay > 0) {
								return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
							}

							scheduler.actions.push(this);
							return (
								scheduler.scheduled ||
								(scheduler.scheduled = _Immediate.Immediate.setImmediate(
									scheduler.flush.bind(scheduler, null)
								))
							);
						};

						AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
							if (delay === void 0) {
								delay = 0;
							}

							if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
								return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
							}

							if (scheduler.actions.length === 0) {
								_Immediate.Immediate.clearImmediate(id);

								scheduler.scheduled = undefined;
							}

							return undefined;
						};

						return AsapAction;
					})(_AsyncAction.AsyncAction);

				exports.AsapAction = AsapAction;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../util/Immediate': '../node_modules/rxjs/_esm5/internal/util/Immediate.js',
				'./AsyncAction': '../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.AsapScheduler = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _AsyncScheduler = require('./AsyncScheduler');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
				var AsapScheduler =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(AsapScheduler, _super);

						function AsapScheduler() {
							return (_super !== null && _super.apply(this, arguments)) || this;
						}

						AsapScheduler.prototype.flush = function (action) {
							this.active = true;
							this.scheduled = undefined;
							var actions = this.actions;
							var error;
							var index = -1;
							var count = actions.length;
							action = action || actions.shift();

							do {
								if ((error = action.execute(action.state, action.delay))) {
									break;
								}
							} while (++index < count && (action = actions.shift()));

							this.active = false;

							if (error) {
								while (++index < count && (action = actions.shift())) {
									action.unsubscribe();
								}

								throw error;
							}
						};

						return AsapScheduler;
					})(_AsyncScheduler.AsyncScheduler);

				exports.AsapScheduler = AsapScheduler;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'./AsyncScheduler': '../node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/scheduler/asap.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.asap = exports.asapScheduler = void 0;

				var _AsapAction = require('./AsapAction');

				var _AsapScheduler = require('./AsapScheduler');

				/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */
				var asapScheduler =
					/*@__PURE__*/
					new _AsapScheduler.AsapScheduler(_AsapAction.AsapAction);
				exports.asapScheduler = asapScheduler;
				var asap = asapScheduler;
				exports.asap = asap;
			},
			{
				'./AsapAction': '../node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js',
				'./AsapScheduler': '../node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/scheduler/async.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.async = exports.asyncScheduler = void 0;

				var _AsyncAction = require('./AsyncAction');

				var _AsyncScheduler = require('./AsyncScheduler');

				/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
				var asyncScheduler =
					/*@__PURE__*/
					new _AsyncScheduler.AsyncScheduler(_AsyncAction.AsyncAction);
				exports.asyncScheduler = asyncScheduler;
				var async = asyncScheduler;
				exports.async = async;
			},
			{
				'./AsyncAction': '../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js',
				'./AsyncScheduler': '../node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameAction.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.AnimationFrameAction = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _AsyncAction = require('./AsyncAction');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
				var AnimationFrameAction =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(AnimationFrameAction, _super);

						function AnimationFrameAction(scheduler, work) {
							var _this = _super.call(this, scheduler, work) || this;

							_this.scheduler = scheduler;
							_this.work = work;
							return _this;
						}

						AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
							if (delay === void 0) {
								delay = 0;
							}

							if (delay !== null && delay > 0) {
								return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
							}

							scheduler.actions.push(this);
							return (
								scheduler.scheduled ||
								(scheduler.scheduled = requestAnimationFrame(function () {
									return scheduler.flush(null);
								}))
							);
						};

						AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
							if (delay === void 0) {
								delay = 0;
							}

							if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
								return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
							}

							if (scheduler.actions.length === 0) {
								cancelAnimationFrame(id);
								scheduler.scheduled = undefined;
							}

							return undefined;
						};

						return AnimationFrameAction;
					})(_AsyncAction.AsyncAction);

				exports.AnimationFrameAction = AnimationFrameAction;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'./AsyncAction': '../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameScheduler.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.AnimationFrameScheduler = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _AsyncScheduler = require('./AsyncScheduler');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
				var AnimationFrameScheduler =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(AnimationFrameScheduler, _super);

						function AnimationFrameScheduler() {
							return (_super !== null && _super.apply(this, arguments)) || this;
						}

						AnimationFrameScheduler.prototype.flush = function (action) {
							this.active = true;
							this.scheduled = undefined;
							var actions = this.actions;
							var error;
							var index = -1;
							var count = actions.length;
							action = action || actions.shift();

							do {
								if ((error = action.execute(action.state, action.delay))) {
									break;
								}
							} while (++index < count && (action = actions.shift()));

							this.active = false;

							if (error) {
								while (++index < count && (action = actions.shift())) {
									action.unsubscribe();
								}

								throw error;
							}
						};

						return AnimationFrameScheduler;
					})(_AsyncScheduler.AsyncScheduler);

				exports.AnimationFrameScheduler = AnimationFrameScheduler;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'./AsyncScheduler': '../node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/scheduler/animationFrame.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.animationFrame = exports.animationFrameScheduler = void 0;

				var _AnimationFrameAction = require('./AnimationFrameAction');

				var _AnimationFrameScheduler = require('./AnimationFrameScheduler');

				/** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */
				var animationFrameScheduler =
					/*@__PURE__*/
					new _AnimationFrameScheduler.AnimationFrameScheduler(
						_AnimationFrameAction.AnimationFrameAction
					);
				exports.animationFrameScheduler = animationFrameScheduler;
				var animationFrame = animationFrameScheduler;
				exports.animationFrame = animationFrame;
			},
			{
				'./AnimationFrameAction':
					'../node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameAction.js',
				'./AnimationFrameScheduler':
					'../node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameScheduler.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/scheduler/VirtualTimeScheduler.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.VirtualAction = exports.VirtualTimeScheduler = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _AsyncAction = require('./AsyncAction');

				var _AsyncScheduler = require('./AsyncScheduler');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
				var VirtualTimeScheduler =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(VirtualTimeScheduler, _super);

						function VirtualTimeScheduler(SchedulerAction, maxFrames) {
							if (SchedulerAction === void 0) {
								SchedulerAction = VirtualAction;
							}

							if (maxFrames === void 0) {
								maxFrames = Number.POSITIVE_INFINITY;
							}

							var _this =
								_super.call(this, SchedulerAction, function () {
									return _this.frame;
								}) || this;

							_this.maxFrames = maxFrames;
							_this.frame = 0;
							_this.index = -1;
							return _this;
						}

						VirtualTimeScheduler.prototype.flush = function () {
							var _a = this,
								actions = _a.actions,
								maxFrames = _a.maxFrames;

							var error, action;

							while ((action = actions[0]) && action.delay <= maxFrames) {
								actions.shift();
								this.frame = action.delay;

								if ((error = action.execute(action.state, action.delay))) {
									break;
								}
							}

							if (error) {
								while ((action = actions.shift())) {
									action.unsubscribe();
								}

								throw error;
							}
						};

						VirtualTimeScheduler.frameTimeFactor = 10;
						return VirtualTimeScheduler;
					})(_AsyncScheduler.AsyncScheduler);

				exports.VirtualTimeScheduler = VirtualTimeScheduler;

				var VirtualAction =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(VirtualAction, _super);

						function VirtualAction(scheduler, work, index) {
							if (index === void 0) {
								index = scheduler.index += 1;
							}

							var _this = _super.call(this, scheduler, work) || this;

							_this.scheduler = scheduler;
							_this.work = work;
							_this.index = index;
							_this.active = true;
							_this.index = scheduler.index = index;
							return _this;
						}

						VirtualAction.prototype.schedule = function (state, delay) {
							if (delay === void 0) {
								delay = 0;
							}

							if (!this.id) {
								return _super.prototype.schedule.call(this, state, delay);
							}

							this.active = false;
							var action = new VirtualAction(this.scheduler, this.work);
							this.add(action);
							return action.schedule(state, delay);
						};

						VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
							if (delay === void 0) {
								delay = 0;
							}

							this.delay = scheduler.frame + delay;
							var actions = scheduler.actions;
							actions.push(this);
							actions.sort(VirtualAction.sortActions);
							return true;
						};

						VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
							if (delay === void 0) {
								delay = 0;
							}

							return undefined;
						};

						VirtualAction.prototype._execute = function (state, delay) {
							if (this.active === true) {
								return _super.prototype._execute.call(this, state, delay);
							}
						};

						VirtualAction.sortActions = function (a, b) {
							if (a.delay === b.delay) {
								if (a.index === b.index) {
									return 0;
								} else if (a.index > b.index) {
									return 1;
								} else {
									return -1;
								}
							} else if (a.delay > b.delay) {
								return 1;
							} else {
								return -1;
							}
						};

						return VirtualAction;
					})(_AsyncAction.AsyncAction);

				exports.VirtualAction = VirtualAction;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'./AsyncAction': '../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js',
				'./AsyncScheduler': '../node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/util/noop.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.noop = noop;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				function noop() {}
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/util/isObservable.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.isObservable = isObservable;

				var _Observable = require('../Observable');

				/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
				function isObservable(obj) {
					return (
						!!obj &&
						(obj instanceof _Observable.Observable ||
							(typeof obj.lift === 'function' && typeof obj.subscribe === 'function'))
					);
				}
			},
			{ '../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js' }
		],
		'../node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.ArgumentOutOfRangeError = void 0;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				var ArgumentOutOfRangeErrorImpl =
					/*@__PURE__*/
					(function () {
						function ArgumentOutOfRangeErrorImpl() {
							Error.call(this);
							this.message = 'argument out of range';
							this.name = 'ArgumentOutOfRangeError';
							return this;
						}

						ArgumentOutOfRangeErrorImpl.prototype =
							/*@__PURE__*/
							Object.create(Error.prototype);
						return ArgumentOutOfRangeErrorImpl;
					})();

				var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
				exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/util/EmptyError.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.EmptyError = void 0;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				var EmptyErrorImpl =
					/*@__PURE__*/
					(function () {
						function EmptyErrorImpl() {
							Error.call(this);
							this.message = 'no elements in sequence';
							this.name = 'EmptyError';
							return this;
						}

						EmptyErrorImpl.prototype =
							/*@__PURE__*/
							Object.create(Error.prototype);
						return EmptyErrorImpl;
					})();

				var EmptyError = EmptyErrorImpl;
				exports.EmptyError = EmptyError;
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/util/TimeoutError.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.TimeoutError = void 0;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				var TimeoutErrorImpl =
					/*@__PURE__*/
					(function () {
						function TimeoutErrorImpl() {
							Error.call(this);
							this.message = 'Timeout has occurred';
							this.name = 'TimeoutError';
							return this;
						}

						TimeoutErrorImpl.prototype =
							/*@__PURE__*/
							Object.create(Error.prototype);
						return TimeoutErrorImpl;
					})();

				var TimeoutError = TimeoutErrorImpl;
				exports.TimeoutError = TimeoutError;
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/operators/map.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.map = map;
				exports.MapOperator = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				function map(project, thisArg) {
					return function mapOperation(source) {
						if (typeof project !== 'function') {
							throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
						}

						return source.lift(new MapOperator(project, thisArg));
					};
				}

				var MapOperator =
					/*@__PURE__*/
					(function () {
						function MapOperator(project, thisArg) {
							this.project = project;
							this.thisArg = thisArg;
						}

						MapOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
						};

						return MapOperator;
					})();

				exports.MapOperator = MapOperator;

				var MapSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(MapSubscriber, _super);

						function MapSubscriber(destination, project, thisArg) {
							var _this = _super.call(this, destination) || this;

							_this.project = project;
							_this.count = 0;
							_this.thisArg = thisArg || _this;
							return _this;
						}

						MapSubscriber.prototype._next = function (value) {
							var result;

							try {
								result = this.project.call(this.thisArg, value, this.count++);
							} catch (err) {
								this.destination.error(err);
								return;
							}

							this.destination.next(result);
						};

						return MapSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/bindCallback.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.bindCallback = bindCallback;

				var _Observable = require('../Observable');

				var _AsyncSubject = require('../AsyncSubject');

				var _map = require('../operators/map');

				var _canReportError = require('../util/canReportError');

				var _isArray = require('../util/isArray');

				var _isScheduler = require('../util/isScheduler');

				/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isArray,_util_isScheduler PURE_IMPORTS_END */
				function bindCallback(callbackFunc, resultSelector, scheduler) {
					if (resultSelector) {
						if ((0, _isScheduler.isScheduler)(resultSelector)) {
							scheduler = resultSelector;
						} else {
							return function () {
								var args = [];

								for (var _i = 0; _i < arguments.length; _i++) {
									args[_i] = arguments[_i];
								}

								return bindCallback(callbackFunc, scheduler)
									.apply(void 0, args)
									.pipe(
										(0, _map.map)(function (args) {
											return (0, _isArray.isArray)(args)
												? resultSelector.apply(void 0, args)
												: resultSelector(args);
										})
									);
							};
						}
					}

					return function () {
						var args = [];

						for (var _i = 0; _i < arguments.length; _i++) {
							args[_i] = arguments[_i];
						}

						var context = this;
						var subject;
						var params = {
							context: context,
							subject: subject,
							callbackFunc: callbackFunc,
							scheduler: scheduler
						};
						return new _Observable.Observable(function (subscriber) {
							if (!scheduler) {
								if (!subject) {
									subject = new _AsyncSubject.AsyncSubject();

									var handler = function () {
										var innerArgs = [];

										for (var _i = 0; _i < arguments.length; _i++) {
											innerArgs[_i] = arguments[_i];
										}

										subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
										subject.complete();
									};

									try {
										callbackFunc.apply(context, args.concat([handler]));
									} catch (err) {
										if ((0, _canReportError.canReportError)(subject)) {
											subject.error(err);
										} else {
											console.warn(err);
										}
									}
								}

								return subject.subscribe(subscriber);
							} else {
								var state = {
									args: args,
									subscriber: subscriber,
									params: params
								};
								return scheduler.schedule(dispatch, 0, state);
							}
						});
					};
				}

				function dispatch(state) {
					var _this = this;

					var self = this;
					var args = state.args,
						subscriber = state.subscriber,
						params = state.params;
					var callbackFunc = params.callbackFunc,
						context = params.context,
						scheduler = params.scheduler;
					var subject = params.subject;

					if (!subject) {
						subject = params.subject = new _AsyncSubject.AsyncSubject();

						var handler = function () {
							var innerArgs = [];

							for (var _i = 0; _i < arguments.length; _i++) {
								innerArgs[_i] = arguments[_i];
							}

							var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;

							_this.add(
								scheduler.schedule(dispatchNext, 0, {
									value: value,
									subject: subject
								})
							);
						};

						try {
							callbackFunc.apply(context, args.concat([handler]));
						} catch (err) {
							subject.error(err);
						}
					}

					this.add(subject.subscribe(subscriber));
				}

				function dispatchNext(state) {
					var value = state.value,
						subject = state.subject;
					subject.next(value);
					subject.complete();
				}

				function dispatchError(state) {
					var err = state.err,
						subject = state.subject;
					subject.error(err);
				}
			},
			{
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../AsyncSubject': '../node_modules/rxjs/_esm5/internal/AsyncSubject.js',
				'../operators/map': '../node_modules/rxjs/_esm5/internal/operators/map.js',
				'../util/canReportError': '../node_modules/rxjs/_esm5/internal/util/canReportError.js',
				'../util/isArray': '../node_modules/rxjs/_esm5/internal/util/isArray.js',
				'../util/isScheduler': '../node_modules/rxjs/_esm5/internal/util/isScheduler.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/bindNodeCallback.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.bindNodeCallback = bindNodeCallback;

				var _Observable = require('../Observable');

				var _AsyncSubject = require('../AsyncSubject');

				var _map = require('../operators/map');

				var _canReportError = require('../util/canReportError');

				var _isScheduler = require('../util/isScheduler');

				var _isArray = require('../util/isArray');

				/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isScheduler,_util_isArray PURE_IMPORTS_END */
				function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
					if (resultSelector) {
						if ((0, _isScheduler.isScheduler)(resultSelector)) {
							scheduler = resultSelector;
						} else {
							return function () {
								var args = [];

								for (var _i = 0; _i < arguments.length; _i++) {
									args[_i] = arguments[_i];
								}

								return bindNodeCallback(callbackFunc, scheduler)
									.apply(void 0, args)
									.pipe(
										(0, _map.map)(function (args) {
											return (0, _isArray.isArray)(args)
												? resultSelector.apply(void 0, args)
												: resultSelector(args);
										})
									);
							};
						}
					}

					return function () {
						var args = [];

						for (var _i = 0; _i < arguments.length; _i++) {
							args[_i] = arguments[_i];
						}

						var params = {
							subject: undefined,
							args: args,
							callbackFunc: callbackFunc,
							scheduler: scheduler,
							context: this
						};
						return new _Observable.Observable(function (subscriber) {
							var context = params.context;
							var subject = params.subject;

							if (!scheduler) {
								if (!subject) {
									subject = params.subject = new _AsyncSubject.AsyncSubject();

									var handler = function () {
										var innerArgs = [];

										for (var _i = 0; _i < arguments.length; _i++) {
											innerArgs[_i] = arguments[_i];
										}

										var err = innerArgs.shift();

										if (err) {
											subject.error(err);
											return;
										}

										subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
										subject.complete();
									};

									try {
										callbackFunc.apply(context, args.concat([handler]));
									} catch (err) {
										if ((0, _canReportError.canReportError)(subject)) {
											subject.error(err);
										} else {
											console.warn(err);
										}
									}
								}

								return subject.subscribe(subscriber);
							} else {
								return scheduler.schedule(dispatch, 0, {
									params: params,
									subscriber: subscriber,
									context: context
								});
							}
						});
					};
				}

				function dispatch(state) {
					var _this = this;

					var params = state.params,
						subscriber = state.subscriber,
						context = state.context;
					var callbackFunc = params.callbackFunc,
						args = params.args,
						scheduler = params.scheduler;
					var subject = params.subject;

					if (!subject) {
						subject = params.subject = new _AsyncSubject.AsyncSubject();

						var handler = function () {
							var innerArgs = [];

							for (var _i = 0; _i < arguments.length; _i++) {
								innerArgs[_i] = arguments[_i];
							}

							var err = innerArgs.shift();

							if (err) {
								_this.add(
									scheduler.schedule(dispatchError, 0, {
										err: err,
										subject: subject
									})
								);
							} else {
								var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;

								_this.add(
									scheduler.schedule(dispatchNext, 0, {
										value: value,
										subject: subject
									})
								);
							}
						};

						try {
							callbackFunc.apply(context, args.concat([handler]));
						} catch (err) {
							this.add(
								scheduler.schedule(dispatchError, 0, {
									err: err,
									subject: subject
								})
							);
						}
					}

					this.add(subject.subscribe(subscriber));
				}

				function dispatchNext(arg) {
					var value = arg.value,
						subject = arg.subject;
					subject.next(value);
					subject.complete();
				}

				function dispatchError(arg) {
					var err = arg.err,
						subject = arg.subject;
					subject.error(err);
				}
			},
			{
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../AsyncSubject': '../node_modules/rxjs/_esm5/internal/AsyncSubject.js',
				'../operators/map': '../node_modules/rxjs/_esm5/internal/operators/map.js',
				'../util/canReportError': '../node_modules/rxjs/_esm5/internal/util/canReportError.js',
				'../util/isScheduler': '../node_modules/rxjs/_esm5/internal/util/isScheduler.js',
				'../util/isArray': '../node_modules/rxjs/_esm5/internal/util/isArray.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/OuterSubscriber.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.OuterSubscriber = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('./Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				var OuterSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(OuterSubscriber, _super);

						function OuterSubscriber() {
							return (_super !== null && _super.apply(this, arguments)) || this;
						}

						OuterSubscriber.prototype.notifyNext = function (
							outerValue,
							innerValue,
							outerIndex,
							innerIndex,
							innerSub
						) {
							this.destination.next(innerValue);
						};

						OuterSubscriber.prototype.notifyError = function (error, innerSub) {
							this.destination.error(error);
						};

						OuterSubscriber.prototype.notifyComplete = function (innerSub) {
							this.destination.complete();
						};

						return OuterSubscriber;
					})(_Subscriber.Subscriber);

				exports.OuterSubscriber = OuterSubscriber;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'./Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/InnerSubscriber.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.InnerSubscriber = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('./Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				var InnerSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(InnerSubscriber, _super);

						function InnerSubscriber(parent, outerValue, outerIndex) {
							var _this = _super.call(this) || this;

							_this.parent = parent;
							_this.outerValue = outerValue;
							_this.outerIndex = outerIndex;
							_this.index = 0;
							return _this;
						}

						InnerSubscriber.prototype._next = function (value) {
							this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
						};

						InnerSubscriber.prototype._error = function (error) {
							this.parent.notifyError(error, this);
							this.unsubscribe();
						};

						InnerSubscriber.prototype._complete = function () {
							this.parent.notifyComplete(this);
							this.unsubscribe();
						};

						return InnerSubscriber;
					})(_Subscriber.Subscriber);

				exports.InnerSubscriber = InnerSubscriber;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'./Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.subscribeToPromise = void 0;

				var _hostReportError = require('./hostReportError');

				/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */
				var subscribeToPromise = function (promise) {
					return function (subscriber) {
						promise
							.then(
								function (value) {
									if (!subscriber.closed) {
										subscriber.next(value);
										subscriber.complete();
									}
								},
								function (err) {
									return subscriber.error(err);
								}
							)
							.then(null, _hostReportError.hostReportError);
						return subscriber;
					};
				};

				exports.subscribeToPromise = subscribeToPromise;
			},
			{ './hostReportError': '../node_modules/rxjs/_esm5/internal/util/hostReportError.js' }
		],
		'../node_modules/rxjs/_esm5/internal/symbol/iterator.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.getSymbolIterator = getSymbolIterator;
				exports.$$iterator = exports.iterator = void 0;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				function getSymbolIterator() {
					if (typeof Symbol !== 'function' || !Symbol.iterator) {
						return '@@iterator';
					}

					return Symbol.iterator;
				}

				var iterator =
					/*@__PURE__*/
					getSymbolIterator();
				exports.iterator = iterator;
				var $$iterator = iterator;
				exports.$$iterator = $$iterator;
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.subscribeToIterable = void 0;

				var _iterator = require('../symbol/iterator');

				/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
				var subscribeToIterable = function (iterable) {
					return function (subscriber) {
						var iterator = iterable[_iterator.iterator]();

						do {
							var item = void 0;

							try {
								item = iterator.next();
							} catch (err) {
								subscriber.error(err);
								return subscriber;
							}

							if (item.done) {
								subscriber.complete();
								break;
							}

							subscriber.next(item.value);

							if (subscriber.closed) {
								break;
							}
						} while (true);

						if (typeof iterator.return === 'function') {
							subscriber.add(function () {
								if (iterator.return) {
									iterator.return();
								}
							});
						}

						return subscriber;
					};
				};

				exports.subscribeToIterable = subscribeToIterable;
			},
			{ '../symbol/iterator': '../node_modules/rxjs/_esm5/internal/symbol/iterator.js' }
		],
		'../node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.subscribeToObservable = void 0;

				var _observable = require('../symbol/observable');

				/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
				var subscribeToObservable = function (obj) {
					return function (subscriber) {
						var obs = obj[_observable.observable]();

						if (typeof obs.subscribe !== 'function') {
							throw new TypeError('Provided object does not correctly implement Symbol.observable');
						} else {
							return obs.subscribe(subscriber);
						}
					};
				};

				exports.subscribeToObservable = subscribeToObservable;
			},
			{ '../symbol/observable': '../node_modules/rxjs/_esm5/internal/symbol/observable.js' }
		],
		'../node_modules/rxjs/_esm5/internal/util/isArrayLike.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.isArrayLike = void 0;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				var isArrayLike = function (x) {
					return x && typeof x.length === 'number' && typeof x !== 'function';
				};

				exports.isArrayLike = isArrayLike;
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/util/isPromise.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.isPromise = isPromise;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				function isPromise(value) {
					return (
						!!value && typeof value.subscribe !== 'function' && typeof value.then === 'function'
					);
				}
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/util/subscribeTo.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.subscribeTo = void 0;

				var _subscribeToArray = require('./subscribeToArray');

				var _subscribeToPromise = require('./subscribeToPromise');

				var _subscribeToIterable = require('./subscribeToIterable');

				var _subscribeToObservable = require('./subscribeToObservable');

				var _isArrayLike = require('./isArrayLike');

				var _isPromise = require('./isPromise');

				var _isObject = require('./isObject');

				var _iterator = require('../symbol/iterator');

				var _observable = require('../symbol/observable');

				/** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */
				var subscribeTo = function (result) {
					if (!!result && typeof result[_observable.observable] === 'function') {
						return (0, _subscribeToObservable.subscribeToObservable)(result);
					} else if ((0, _isArrayLike.isArrayLike)(result)) {
						return (0, _subscribeToArray.subscribeToArray)(result);
					} else if ((0, _isPromise.isPromise)(result)) {
						return (0, _subscribeToPromise.subscribeToPromise)(result);
					} else if (!!result && typeof result[_iterator.iterator] === 'function') {
						return (0, _subscribeToIterable.subscribeToIterable)(result);
					} else {
						var value = (0, _isObject.isObject)(result) ? 'an invalid object' : "'" + result + "'";
						var msg =
							'You provided ' +
							value +
							' where a stream was expected.' +
							' You can provide an Observable, Promise, Array, or Iterable.';
						throw new TypeError(msg);
					}
				};

				exports.subscribeTo = subscribeTo;
			},
			{
				'./subscribeToArray': '../node_modules/rxjs/_esm5/internal/util/subscribeToArray.js',
				'./subscribeToPromise': '../node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js',
				'./subscribeToIterable': '../node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js',
				'./subscribeToObservable':
					'../node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js',
				'./isArrayLike': '../node_modules/rxjs/_esm5/internal/util/isArrayLike.js',
				'./isPromise': '../node_modules/rxjs/_esm5/internal/util/isPromise.js',
				'./isObject': '../node_modules/rxjs/_esm5/internal/util/isObject.js',
				'../symbol/iterator': '../node_modules/rxjs/_esm5/internal/symbol/iterator.js',
				'../symbol/observable': '../node_modules/rxjs/_esm5/internal/symbol/observable.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.subscribeToResult = subscribeToResult;

				var _InnerSubscriber = require('../InnerSubscriber');

				var _subscribeTo = require('./subscribeTo');

				var _Observable = require('../Observable');

				/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo,_Observable PURE_IMPORTS_END */
				function subscribeToResult(
					outerSubscriber,
					result,
					outerValue,
					outerIndex,
					innerSubscriber
				) {
					if (innerSubscriber === void 0) {
						innerSubscriber = new _InnerSubscriber.InnerSubscriber(
							outerSubscriber,
							outerValue,
							outerIndex
						);
					}

					if (innerSubscriber.closed) {
						return undefined;
					}

					if (result instanceof _Observable.Observable) {
						return result.subscribe(innerSubscriber);
					}

					return (0, _subscribeTo.subscribeTo)(result)(innerSubscriber);
				}
			},
			{
				'../InnerSubscriber': '../node_modules/rxjs/_esm5/internal/InnerSubscriber.js',
				'./subscribeTo': '../node_modules/rxjs/_esm5/internal/util/subscribeTo.js',
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/combineLatest.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.combineLatest = combineLatest;
				exports.CombineLatestSubscriber = exports.CombineLatestOperator = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _isScheduler = require('../util/isScheduler');

				var _isArray = require('../util/isArray');

				var _OuterSubscriber = require('../OuterSubscriber');

				var _subscribeToResult = require('../util/subscribeToResult');

				var _fromArray = require('./fromArray');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */
				var NONE = {};

				function combineLatest() {
					var observables = [];

					for (var _i = 0; _i < arguments.length; _i++) {
						observables[_i] = arguments[_i];
					}

					var resultSelector = undefined;
					var scheduler = undefined;

					if ((0, _isScheduler.isScheduler)(observables[observables.length - 1])) {
						scheduler = observables.pop();
					}

					if (typeof observables[observables.length - 1] === 'function') {
						resultSelector = observables.pop();
					}

					if (observables.length === 1 && (0, _isArray.isArray)(observables[0])) {
						observables = observables[0];
					}

					return (0, _fromArray.fromArray)(observables, scheduler).lift(
						new CombineLatestOperator(resultSelector)
					);
				}

				var CombineLatestOperator =
					/*@__PURE__*/
					(function () {
						function CombineLatestOperator(resultSelector) {
							this.resultSelector = resultSelector;
						}

						CombineLatestOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
						};

						return CombineLatestOperator;
					})();

				exports.CombineLatestOperator = CombineLatestOperator;

				var CombineLatestSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(CombineLatestSubscriber, _super);

						function CombineLatestSubscriber(destination, resultSelector) {
							var _this = _super.call(this, destination) || this;

							_this.resultSelector = resultSelector;
							_this.active = 0;
							_this.values = [];
							_this.observables = [];
							return _this;
						}

						CombineLatestSubscriber.prototype._next = function (observable) {
							this.values.push(NONE);
							this.observables.push(observable);
						};

						CombineLatestSubscriber.prototype._complete = function () {
							var observables = this.observables;
							var len = observables.length;

							if (len === 0) {
								this.destination.complete();
							} else {
								this.active = len;
								this.toRespond = len;

								for (var i = 0; i < len; i++) {
									var observable = observables[i];
									this.add(
										(0, _subscribeToResult.subscribeToResult)(this, observable, undefined, i)
									);
								}
							}
						};

						CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
							if ((this.active -= 1) === 0) {
								this.destination.complete();
							}
						};

						CombineLatestSubscriber.prototype.notifyNext = function (
							_outerValue,
							innerValue,
							outerIndex
						) {
							var values = this.values;
							var oldVal = values[outerIndex];
							var toRespond = !this.toRespond
								? 0
								: oldVal === NONE
								? --this.toRespond
								: this.toRespond;
							values[outerIndex] = innerValue;

							if (toRespond === 0) {
								if (this.resultSelector) {
									this._tryResultSelector(values);
								} else {
									this.destination.next(values.slice());
								}
							}
						};

						CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
							var result;

							try {
								result = this.resultSelector.apply(this, values);
							} catch (err) {
								this.destination.error(err);
								return;
							}

							this.destination.next(result);
						};

						return CombineLatestSubscriber;
					})(_OuterSubscriber.OuterSubscriber);

				exports.CombineLatestSubscriber = CombineLatestSubscriber;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../util/isScheduler': '../node_modules/rxjs/_esm5/internal/util/isScheduler.js',
				'../util/isArray': '../node_modules/rxjs/_esm5/internal/util/isArray.js',
				'../OuterSubscriber': '../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
				'../util/subscribeToResult':
					'../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
				'./fromArray': '../node_modules/rxjs/_esm5/internal/observable/fromArray.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.scheduleObservable = scheduleObservable;

				var _Observable = require('../Observable');

				var _Subscription = require('../Subscription');

				var _observable = require('../symbol/observable');

				/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable PURE_IMPORTS_END */
				function scheduleObservable(input, scheduler) {
					return new _Observable.Observable(function (subscriber) {
						var sub = new _Subscription.Subscription();
						sub.add(
							scheduler.schedule(function () {
								var observable = input[_observable.observable]();

								sub.add(
									observable.subscribe({
										next: function (value) {
											sub.add(
												scheduler.schedule(function () {
													return subscriber.next(value);
												})
											);
										},
										error: function (err) {
											sub.add(
												scheduler.schedule(function () {
													return subscriber.error(err);
												})
											);
										},
										complete: function () {
											sub.add(
												scheduler.schedule(function () {
													return subscriber.complete();
												})
											);
										}
									})
								);
							})
						);
						return sub;
					});
				}
			},
			{
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../Subscription': '../node_modules/rxjs/_esm5/internal/Subscription.js',
				'../symbol/observable': '../node_modules/rxjs/_esm5/internal/symbol/observable.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.schedulePromise = schedulePromise;

				var _Observable = require('../Observable');

				var _Subscription = require('../Subscription');

				/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
				function schedulePromise(input, scheduler) {
					return new _Observable.Observable(function (subscriber) {
						var sub = new _Subscription.Subscription();
						sub.add(
							scheduler.schedule(function () {
								return input.then(
									function (value) {
										sub.add(
											scheduler.schedule(function () {
												subscriber.next(value);
												sub.add(
													scheduler.schedule(function () {
														return subscriber.complete();
													})
												);
											})
										);
									},
									function (err) {
										sub.add(
											scheduler.schedule(function () {
												return subscriber.error(err);
											})
										);
									}
								);
							})
						);
						return sub;
					});
				}
			},
			{
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../Subscription': '../node_modules/rxjs/_esm5/internal/Subscription.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.scheduleIterable = scheduleIterable;

				var _Observable = require('../Observable');

				var _Subscription = require('../Subscription');

				var _iterator = require('../symbol/iterator');

				/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator PURE_IMPORTS_END */
				function scheduleIterable(input, scheduler) {
					if (!input) {
						throw new Error('Iterable cannot be null');
					}

					return new _Observable.Observable(function (subscriber) {
						var sub = new _Subscription.Subscription();
						var iterator;
						sub.add(function () {
							if (iterator && typeof iterator.return === 'function') {
								iterator.return();
							}
						});
						sub.add(
							scheduler.schedule(function () {
								iterator = input[_iterator.iterator]();
								sub.add(
									scheduler.schedule(function () {
										if (subscriber.closed) {
											return;
										}

										var value;
										var done;

										try {
											var result = iterator.next();
											value = result.value;
											done = result.done;
										} catch (err) {
											subscriber.error(err);
											return;
										}

										if (done) {
											subscriber.complete();
										} else {
											subscriber.next(value);
											this.schedule();
										}
									})
								);
							})
						);
						return sub;
					});
				}
			},
			{
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../Subscription': '../node_modules/rxjs/_esm5/internal/Subscription.js',
				'../symbol/iterator': '../node_modules/rxjs/_esm5/internal/symbol/iterator.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/util/isInteropObservable.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.isInteropObservable = isInteropObservable;

				var _observable = require('../symbol/observable');

				/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
				function isInteropObservable(input) {
					return input && typeof input[_observable.observable] === 'function';
				}
			},
			{ '../symbol/observable': '../node_modules/rxjs/_esm5/internal/symbol/observable.js' }
		],
		'../node_modules/rxjs/_esm5/internal/util/isIterable.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.isIterable = isIterable;

				var _iterator = require('../symbol/iterator');

				/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
				function isIterable(input) {
					return input && typeof input[_iterator.iterator] === 'function';
				}
			},
			{ '../symbol/iterator': '../node_modules/rxjs/_esm5/internal/symbol/iterator.js' }
		],
		'../node_modules/rxjs/_esm5/internal/scheduled/scheduled.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.scheduled = scheduled;

				var _scheduleObservable = require('./scheduleObservable');

				var _schedulePromise = require('./schedulePromise');

				var _scheduleArray = require('./scheduleArray');

				var _scheduleIterable = require('./scheduleIterable');

				var _isInteropObservable = require('../util/isInteropObservable');

				var _isPromise = require('../util/isPromise');

				var _isArrayLike = require('../util/isArrayLike');

				var _isIterable = require('../util/isIterable');

				/** PURE_IMPORTS_START _scheduleObservable,_schedulePromise,_scheduleArray,_scheduleIterable,_util_isInteropObservable,_util_isPromise,_util_isArrayLike,_util_isIterable PURE_IMPORTS_END */
				function scheduled(input, scheduler) {
					if (input != null) {
						if ((0, _isInteropObservable.isInteropObservable)(input)) {
							return (0, _scheduleObservable.scheduleObservable)(input, scheduler);
						} else if ((0, _isPromise.isPromise)(input)) {
							return (0, _schedulePromise.schedulePromise)(input, scheduler);
						} else if ((0, _isArrayLike.isArrayLike)(input)) {
							return (0, _scheduleArray.scheduleArray)(input, scheduler);
						} else if ((0, _isIterable.isIterable)(input) || typeof input === 'string') {
							return (0, _scheduleIterable.scheduleIterable)(input, scheduler);
						}
					}

					throw new TypeError(((input !== null && typeof input) || input) + ' is not observable');
				}
			},
			{
				'./scheduleObservable':
					'../node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js',
				'./schedulePromise': '../node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js',
				'./scheduleArray': '../node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js',
				'./scheduleIterable': '../node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js',
				'../util/isInteropObservable':
					'../node_modules/rxjs/_esm5/internal/util/isInteropObservable.js',
				'../util/isPromise': '../node_modules/rxjs/_esm5/internal/util/isPromise.js',
				'../util/isArrayLike': '../node_modules/rxjs/_esm5/internal/util/isArrayLike.js',
				'../util/isIterable': '../node_modules/rxjs/_esm5/internal/util/isIterable.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/from.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.from = from;

				var _Observable = require('../Observable');

				var _subscribeTo = require('../util/subscribeTo');

				var _scheduled = require('../scheduled/scheduled');

				/** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */
				function from(input, scheduler) {
					if (!scheduler) {
						if (input instanceof _Observable.Observable) {
							return input;
						}

						return new _Observable.Observable((0, _subscribeTo.subscribeTo)(input));
					} else {
						return (0, _scheduled.scheduled)(input, scheduler);
					}
				}
			},
			{
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../util/subscribeTo': '../node_modules/rxjs/_esm5/internal/util/subscribeTo.js',
				'../scheduled/scheduled': '../node_modules/rxjs/_esm5/internal/scheduled/scheduled.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/innerSubscribe.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.innerSubscribe = innerSubscribe;
				exports.ComplexOuterSubscriber =
					exports.SimpleOuterSubscriber =
					exports.ComplexInnerSubscriber =
					exports.SimpleInnerSubscriber =
						void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('./Subscriber');

				var _Observable = require('./Observable');

				var _subscribeTo = require('./util/subscribeTo');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_util_subscribeTo PURE_IMPORTS_END */
				var SimpleInnerSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(SimpleInnerSubscriber, _super);

						function SimpleInnerSubscriber(parent) {
							var _this = _super.call(this) || this;

							_this.parent = parent;
							return _this;
						}

						SimpleInnerSubscriber.prototype._next = function (value) {
							this.parent.notifyNext(value);
						};

						SimpleInnerSubscriber.prototype._error = function (error) {
							this.parent.notifyError(error);
							this.unsubscribe();
						};

						SimpleInnerSubscriber.prototype._complete = function () {
							this.parent.notifyComplete();
							this.unsubscribe();
						};

						return SimpleInnerSubscriber;
					})(_Subscriber.Subscriber);

				exports.SimpleInnerSubscriber = SimpleInnerSubscriber;

				var ComplexInnerSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(ComplexInnerSubscriber, _super);

						function ComplexInnerSubscriber(parent, outerValue, outerIndex) {
							var _this = _super.call(this) || this;

							_this.parent = parent;
							_this.outerValue = outerValue;
							_this.outerIndex = outerIndex;
							return _this;
						}

						ComplexInnerSubscriber.prototype._next = function (value) {
							this.parent.notifyNext(this.outerValue, value, this.outerIndex, this);
						};

						ComplexInnerSubscriber.prototype._error = function (error) {
							this.parent.notifyError(error);
							this.unsubscribe();
						};

						ComplexInnerSubscriber.prototype._complete = function () {
							this.parent.notifyComplete(this);
							this.unsubscribe();
						};

						return ComplexInnerSubscriber;
					})(_Subscriber.Subscriber);

				exports.ComplexInnerSubscriber = ComplexInnerSubscriber;

				var SimpleOuterSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(SimpleOuterSubscriber, _super);

						function SimpleOuterSubscriber() {
							return (_super !== null && _super.apply(this, arguments)) || this;
						}

						SimpleOuterSubscriber.prototype.notifyNext = function (innerValue) {
							this.destination.next(innerValue);
						};

						SimpleOuterSubscriber.prototype.notifyError = function (err) {
							this.destination.error(err);
						};

						SimpleOuterSubscriber.prototype.notifyComplete = function () {
							this.destination.complete();
						};

						return SimpleOuterSubscriber;
					})(_Subscriber.Subscriber);

				exports.SimpleOuterSubscriber = SimpleOuterSubscriber;

				var ComplexOuterSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(ComplexOuterSubscriber, _super);

						function ComplexOuterSubscriber() {
							return (_super !== null && _super.apply(this, arguments)) || this;
						}

						ComplexOuterSubscriber.prototype.notifyNext = function (
							_outerValue,
							innerValue,
							_outerIndex,
							_innerSub
						) {
							this.destination.next(innerValue);
						};

						ComplexOuterSubscriber.prototype.notifyError = function (error) {
							this.destination.error(error);
						};

						ComplexOuterSubscriber.prototype.notifyComplete = function (_innerSub) {
							this.destination.complete();
						};

						return ComplexOuterSubscriber;
					})(_Subscriber.Subscriber);

				exports.ComplexOuterSubscriber = ComplexOuterSubscriber;

				function innerSubscribe(result, innerSubscriber) {
					if (innerSubscriber.closed) {
						return undefined;
					}

					if (result instanceof _Observable.Observable) {
						return result.subscribe(innerSubscriber);
					}

					var subscription;

					try {
						subscription = (0, _subscribeTo.subscribeTo)(result)(innerSubscriber);
					} catch (error) {
						innerSubscriber.error(error);
					}

					return subscription;
				}
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'./Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'./Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'./util/subscribeTo': '../node_modules/rxjs/_esm5/internal/util/subscribeTo.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/mergeMap.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.mergeMap = mergeMap;
				exports.flatMap = exports.MergeMapSubscriber = exports.MergeMapOperator = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _map = require('./map');

				var _from = require('../observable/from');

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */
				function mergeMap(project, resultSelector, concurrent) {
					if (concurrent === void 0) {
						concurrent = Number.POSITIVE_INFINITY;
					}

					if (typeof resultSelector === 'function') {
						return function (source) {
							return source.pipe(
								mergeMap(function (a, i) {
									return (0, _from.from)(project(a, i)).pipe(
										(0, _map.map)(function (b, ii) {
											return resultSelector(a, b, i, ii);
										})
									);
								}, concurrent)
							);
						};
					} else if (typeof resultSelector === 'number') {
						concurrent = resultSelector;
					}

					return function (source) {
						return source.lift(new MergeMapOperator(project, concurrent));
					};
				}

				var MergeMapOperator =
					/*@__PURE__*/
					(function () {
						function MergeMapOperator(project, concurrent) {
							if (concurrent === void 0) {
								concurrent = Number.POSITIVE_INFINITY;
							}

							this.project = project;
							this.concurrent = concurrent;
						}

						MergeMapOperator.prototype.call = function (observer, source) {
							return source.subscribe(
								new MergeMapSubscriber(observer, this.project, this.concurrent)
							);
						};

						return MergeMapOperator;
					})();

				exports.MergeMapOperator = MergeMapOperator;

				var MergeMapSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(MergeMapSubscriber, _super);

						function MergeMapSubscriber(destination, project, concurrent) {
							if (concurrent === void 0) {
								concurrent = Number.POSITIVE_INFINITY;
							}

							var _this = _super.call(this, destination) || this;

							_this.project = project;
							_this.concurrent = concurrent;
							_this.hasCompleted = false;
							_this.buffer = [];
							_this.active = 0;
							_this.index = 0;
							return _this;
						}

						MergeMapSubscriber.prototype._next = function (value) {
							if (this.active < this.concurrent) {
								this._tryNext(value);
							} else {
								this.buffer.push(value);
							}
						};

						MergeMapSubscriber.prototype._tryNext = function (value) {
							var result;
							var index = this.index++;

							try {
								result = this.project(value, index);
							} catch (err) {
								this.destination.error(err);
								return;
							}

							this.active++;

							this._innerSub(result);
						};

						MergeMapSubscriber.prototype._innerSub = function (ish) {
							var innerSubscriber = new _innerSubscribe.SimpleInnerSubscriber(this);
							var destination = this.destination;
							destination.add(innerSubscriber);
							var innerSubscription = (0, _innerSubscribe.innerSubscribe)(ish, innerSubscriber);

							if (innerSubscription !== innerSubscriber) {
								destination.add(innerSubscription);
							}
						};

						MergeMapSubscriber.prototype._complete = function () {
							this.hasCompleted = true;

							if (this.active === 0 && this.buffer.length === 0) {
								this.destination.complete();
							}

							this.unsubscribe();
						};

						MergeMapSubscriber.prototype.notifyNext = function (innerValue) {
							this.destination.next(innerValue);
						};

						MergeMapSubscriber.prototype.notifyComplete = function () {
							var buffer = this.buffer;
							this.active--;

							if (buffer.length > 0) {
								this._next(buffer.shift());
							} else if (this.active === 0 && this.hasCompleted) {
								this.destination.complete();
							}
						};

						return MergeMapSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);

				exports.MergeMapSubscriber = MergeMapSubscriber;
				var flatMap = mergeMap;
				exports.flatMap = flatMap;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'./map': '../node_modules/rxjs/_esm5/internal/operators/map.js',
				'../observable/from': '../node_modules/rxjs/_esm5/internal/observable/from.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/mergeAll.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.mergeAll = mergeAll;

				var _mergeMap = require('./mergeMap');

				var _identity = require('../util/identity');

				/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */
				function mergeAll(concurrent) {
					if (concurrent === void 0) {
						concurrent = Number.POSITIVE_INFINITY;
					}

					return (0, _mergeMap.mergeMap)(_identity.identity, concurrent);
				}
			},
			{
				'./mergeMap': '../node_modules/rxjs/_esm5/internal/operators/mergeMap.js',
				'../util/identity': '../node_modules/rxjs/_esm5/internal/util/identity.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/concatAll.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.concatAll = concatAll;

				var _mergeAll = require('./mergeAll');

				/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */
				function concatAll() {
					return (0, _mergeAll.mergeAll)(1);
				}
			},
			{ './mergeAll': '../node_modules/rxjs/_esm5/internal/operators/mergeAll.js' }
		],
		'../node_modules/rxjs/_esm5/internal/observable/concat.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.concat = concat;

				var _of = require('./of');

				var _concatAll = require('../operators/concatAll');

				/** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */
				function concat() {
					var observables = [];

					for (var _i = 0; _i < arguments.length; _i++) {
						observables[_i] = arguments[_i];
					}

					return (0, _concatAll.concatAll)()(_of.of.apply(void 0, observables));
				}
			},
			{
				'./of': '../node_modules/rxjs/_esm5/internal/observable/of.js',
				'../operators/concatAll': '../node_modules/rxjs/_esm5/internal/operators/concatAll.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/defer.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.defer = defer;

				var _Observable = require('../Observable');

				var _from = require('./from');

				var _empty = require('./empty');

				/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
				function defer(observableFactory) {
					return new _Observable.Observable(function (subscriber) {
						var input;

						try {
							input = observableFactory();
						} catch (err) {
							subscriber.error(err);
							return undefined;
						}

						var source = input ? (0, _from.from)(input) : (0, _empty.empty)();
						return source.subscribe(subscriber);
					});
				}
			},
			{
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'./from': '../node_modules/rxjs/_esm5/internal/observable/from.js',
				'./empty': '../node_modules/rxjs/_esm5/internal/observable/empty.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/forkJoin.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.forkJoin = forkJoin;

				var _Observable = require('../Observable');

				var _isArray = require('../util/isArray');

				var _map = require('../operators/map');

				var _isObject = require('../util/isObject');

				var _from = require('./from');

				/** PURE_IMPORTS_START _Observable,_util_isArray,_operators_map,_util_isObject,_from PURE_IMPORTS_END */
				function forkJoin() {
					var sources = [];

					for (var _i = 0; _i < arguments.length; _i++) {
						sources[_i] = arguments[_i];
					}

					if (sources.length === 1) {
						var first_1 = sources[0];

						if ((0, _isArray.isArray)(first_1)) {
							return forkJoinInternal(first_1, null);
						}

						if (
							(0, _isObject.isObject)(first_1) &&
							Object.getPrototypeOf(first_1) === Object.prototype
						) {
							var keys = Object.keys(first_1);
							return forkJoinInternal(
								keys.map(function (key) {
									return first_1[key];
								}),
								keys
							);
						}
					}

					if (typeof sources[sources.length - 1] === 'function') {
						var resultSelector_1 = sources.pop();
						sources =
							sources.length === 1 && (0, _isArray.isArray)(sources[0]) ? sources[0] : sources;
						return forkJoinInternal(sources, null).pipe(
							(0, _map.map)(function (args) {
								return resultSelector_1.apply(void 0, args);
							})
						);
					}

					return forkJoinInternal(sources, null);
				}

				function forkJoinInternal(sources, keys) {
					return new _Observable.Observable(function (subscriber) {
						var len = sources.length;

						if (len === 0) {
							subscriber.complete();
							return;
						}

						var values = new Array(len);
						var completed = 0;
						var emitted = 0;

						var _loop_1 = function (i) {
							var source = (0, _from.from)(sources[i]);
							var hasValue = false;
							subscriber.add(
								source.subscribe({
									next: function (value) {
										if (!hasValue) {
											hasValue = true;
											emitted++;
										}

										values[i] = value;
									},
									error: function (err) {
										return subscriber.error(err);
									},
									complete: function () {
										completed++;

										if (completed === len || !hasValue) {
											if (emitted === len) {
												subscriber.next(
													keys
														? keys.reduce(function (result, key, i) {
																return (result[key] = values[i]), result;
														  }, {})
														: values
												);
											}

											subscriber.complete();
										}
									}
								})
							);
						};

						for (var i = 0; i < len; i++) {
							_loop_1(i);
						}
					});
				}
			},
			{
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../util/isArray': '../node_modules/rxjs/_esm5/internal/util/isArray.js',
				'../operators/map': '../node_modules/rxjs/_esm5/internal/operators/map.js',
				'../util/isObject': '../node_modules/rxjs/_esm5/internal/util/isObject.js',
				'./from': '../node_modules/rxjs/_esm5/internal/observable/from.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/fromEvent.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.fromEvent = fromEvent;

				var _Observable = require('../Observable');

				var _isArray = require('../util/isArray');

				var _isFunction = require('../util/isFunction');

				var _map = require('../operators/map');

				/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
				var toString =
					/*@__PURE__*/
					(function () {
						return Object.prototype.toString;
					})();

				function fromEvent(target, eventName, options, resultSelector) {
					if ((0, _isFunction.isFunction)(options)) {
						resultSelector = options;
						options = undefined;
					}

					if (resultSelector) {
						return fromEvent(target, eventName, options).pipe(
							(0, _map.map)(function (args) {
								return (0, _isArray.isArray)(args)
									? resultSelector.apply(void 0, args)
									: resultSelector(args);
							})
						);
					}

					return new _Observable.Observable(function (subscriber) {
						function handler(e) {
							if (arguments.length > 1) {
								subscriber.next(Array.prototype.slice.call(arguments));
							} else {
								subscriber.next(e);
							}
						}

						setupSubscription(target, eventName, handler, subscriber, options);
					});
				}

				function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
					var unsubscribe;

					if (isEventTarget(sourceObj)) {
						var source_1 = sourceObj;
						sourceObj.addEventListener(eventName, handler, options);

						unsubscribe = function () {
							return source_1.removeEventListener(eventName, handler, options);
						};
					} else if (isJQueryStyleEventEmitter(sourceObj)) {
						var source_2 = sourceObj;
						sourceObj.on(eventName, handler);

						unsubscribe = function () {
							return source_2.off(eventName, handler);
						};
					} else if (isNodeStyleEventEmitter(sourceObj)) {
						var source_3 = sourceObj;
						sourceObj.addListener(eventName, handler);

						unsubscribe = function () {
							return source_3.removeListener(eventName, handler);
						};
					} else if (sourceObj && sourceObj.length) {
						for (var i = 0, len = sourceObj.length; i < len; i++) {
							setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
						}
					} else {
						throw new TypeError('Invalid event target');
					}

					subscriber.add(unsubscribe);
				}

				function isNodeStyleEventEmitter(sourceObj) {
					return (
						sourceObj &&
						typeof sourceObj.addListener === 'function' &&
						typeof sourceObj.removeListener === 'function'
					);
				}

				function isJQueryStyleEventEmitter(sourceObj) {
					return (
						sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function'
					);
				}

				function isEventTarget(sourceObj) {
					return (
						sourceObj &&
						typeof sourceObj.addEventListener === 'function' &&
						typeof sourceObj.removeEventListener === 'function'
					);
				}
			},
			{
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../util/isArray': '../node_modules/rxjs/_esm5/internal/util/isArray.js',
				'../util/isFunction': '../node_modules/rxjs/_esm5/internal/util/isFunction.js',
				'../operators/map': '../node_modules/rxjs/_esm5/internal/operators/map.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/fromEventPattern.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.fromEventPattern = fromEventPattern;

				var _Observable = require('../Observable');

				var _isArray = require('../util/isArray');

				var _isFunction = require('../util/isFunction');

				var _map = require('../operators/map');

				/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
				function fromEventPattern(addHandler, removeHandler, resultSelector) {
					if (resultSelector) {
						return fromEventPattern(addHandler, removeHandler).pipe(
							(0, _map.map)(function (args) {
								return (0, _isArray.isArray)(args)
									? resultSelector.apply(void 0, args)
									: resultSelector(args);
							})
						);
					}

					return new _Observable.Observable(function (subscriber) {
						var handler = function () {
							var e = [];

							for (var _i = 0; _i < arguments.length; _i++) {
								e[_i] = arguments[_i];
							}

							return subscriber.next(e.length === 1 ? e[0] : e);
						};

						var retValue;

						try {
							retValue = addHandler(handler);
						} catch (err) {
							subscriber.error(err);
							return undefined;
						}

						if (!(0, _isFunction.isFunction)(removeHandler)) {
							return undefined;
						}

						return function () {
							return removeHandler(handler, retValue);
						};
					});
				}
			},
			{
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../util/isArray': '../node_modules/rxjs/_esm5/internal/util/isArray.js',
				'../util/isFunction': '../node_modules/rxjs/_esm5/internal/util/isFunction.js',
				'../operators/map': '../node_modules/rxjs/_esm5/internal/operators/map.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/generate.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.generate = generate;

				var _Observable = require('../Observable');

				var _identity = require('../util/identity');

				var _isScheduler = require('../util/isScheduler');

				/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */
				function generate(
					initialStateOrOptions,
					condition,
					iterate,
					resultSelectorOrObservable,
					scheduler
				) {
					var resultSelector;
					var initialState;

					if (arguments.length == 1) {
						var options = initialStateOrOptions;
						initialState = options.initialState;
						condition = options.condition;
						iterate = options.iterate;
						resultSelector = options.resultSelector || _identity.identity;
						scheduler = options.scheduler;
					} else if (
						resultSelectorOrObservable === undefined ||
						(0, _isScheduler.isScheduler)(resultSelectorOrObservable)
					) {
						initialState = initialStateOrOptions;
						resultSelector = _identity.identity;
						scheduler = resultSelectorOrObservable;
					} else {
						initialState = initialStateOrOptions;
						resultSelector = resultSelectorOrObservable;
					}

					return new _Observable.Observable(function (subscriber) {
						var state = initialState;

						if (scheduler) {
							return scheduler.schedule(dispatch, 0, {
								subscriber: subscriber,
								iterate: iterate,
								condition: condition,
								resultSelector: resultSelector,
								state: state
							});
						}

						do {
							if (condition) {
								var conditionResult = void 0;

								try {
									conditionResult = condition(state);
								} catch (err) {
									subscriber.error(err);
									return undefined;
								}

								if (!conditionResult) {
									subscriber.complete();
									break;
								}
							}

							var value = void 0;

							try {
								value = resultSelector(state);
							} catch (err) {
								subscriber.error(err);
								return undefined;
							}

							subscriber.next(value);

							if (subscriber.closed) {
								break;
							}

							try {
								state = iterate(state);
							} catch (err) {
								subscriber.error(err);
								return undefined;
							}
						} while (true);

						return undefined;
					});
				}

				function dispatch(state) {
					var subscriber = state.subscriber,
						condition = state.condition;

					if (subscriber.closed) {
						return undefined;
					}

					if (state.needIterate) {
						try {
							state.state = state.iterate(state.state);
						} catch (err) {
							subscriber.error(err);
							return undefined;
						}
					} else {
						state.needIterate = true;
					}

					if (condition) {
						var conditionResult = void 0;

						try {
							conditionResult = condition(state.state);
						} catch (err) {
							subscriber.error(err);
							return undefined;
						}

						if (!conditionResult) {
							subscriber.complete();
							return undefined;
						}

						if (subscriber.closed) {
							return undefined;
						}
					}

					var value;

					try {
						value = state.resultSelector(state.state);
					} catch (err) {
						subscriber.error(err);
						return undefined;
					}

					if (subscriber.closed) {
						return undefined;
					}

					subscriber.next(value);

					if (subscriber.closed) {
						return undefined;
					}

					return this.schedule(state);
				}
			},
			{
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../util/identity': '../node_modules/rxjs/_esm5/internal/util/identity.js',
				'../util/isScheduler': '../node_modules/rxjs/_esm5/internal/util/isScheduler.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/iif.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.iif = iif;

				var _defer = require('./defer');

				var _empty = require('./empty');

				/** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */
				function iif(condition, trueResult, falseResult) {
					if (trueResult === void 0) {
						trueResult = _empty.EMPTY;
					}

					if (falseResult === void 0) {
						falseResult = _empty.EMPTY;
					}

					return (0, _defer.defer)(function () {
						return condition() ? trueResult : falseResult;
					});
				}
			},
			{
				'./defer': '../node_modules/rxjs/_esm5/internal/observable/defer.js',
				'./empty': '../node_modules/rxjs/_esm5/internal/observable/empty.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/util/isNumeric.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.isNumeric = isNumeric;

				var _isArray = require('./isArray');

				/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */
				function isNumeric(val) {
					return !(0, _isArray.isArray)(val) && val - parseFloat(val) + 1 >= 0;
				}
			},
			{ './isArray': '../node_modules/rxjs/_esm5/internal/util/isArray.js' }
		],
		'../node_modules/rxjs/_esm5/internal/observable/interval.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.interval = interval;

				var _Observable = require('../Observable');

				var _async = require('../scheduler/async');

				var _isNumeric = require('../util/isNumeric');

				/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */
				function interval(period, scheduler) {
					if (period === void 0) {
						period = 0;
					}

					if (scheduler === void 0) {
						scheduler = _async.async;
					}

					if (!(0, _isNumeric.isNumeric)(period) || period < 0) {
						period = 0;
					}

					if (!scheduler || typeof scheduler.schedule !== 'function') {
						scheduler = _async.async;
					}

					return new _Observable.Observable(function (subscriber) {
						subscriber.add(
							scheduler.schedule(dispatch, period, {
								subscriber: subscriber,
								counter: 0,
								period: period
							})
						);
						return subscriber;
					});
				}

				function dispatch(state) {
					var subscriber = state.subscriber,
						counter = state.counter,
						period = state.period;
					subscriber.next(counter);
					this.schedule(
						{
							subscriber: subscriber,
							counter: counter + 1,
							period: period
						},
						period
					);
				}
			},
			{
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../scheduler/async': '../node_modules/rxjs/_esm5/internal/scheduler/async.js',
				'../util/isNumeric': '../node_modules/rxjs/_esm5/internal/util/isNumeric.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/merge.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.merge = merge;

				var _Observable = require('../Observable');

				var _isScheduler = require('../util/isScheduler');

				var _mergeAll = require('../operators/mergeAll');

				var _fromArray = require('./fromArray');

				/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */
				function merge() {
					var observables = [];

					for (var _i = 0; _i < arguments.length; _i++) {
						observables[_i] = arguments[_i];
					}

					var concurrent = Number.POSITIVE_INFINITY;
					var scheduler = null;
					var last = observables[observables.length - 1];

					if ((0, _isScheduler.isScheduler)(last)) {
						scheduler = observables.pop();

						if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
							concurrent = observables.pop();
						}
					} else if (typeof last === 'number') {
						concurrent = observables.pop();
					}

					if (
						scheduler === null &&
						observables.length === 1 &&
						observables[0] instanceof _Observable.Observable
					) {
						return observables[0];
					}

					return (0, _mergeAll.mergeAll)(concurrent)(
						(0, _fromArray.fromArray)(observables, scheduler)
					);
				}
			},
			{
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../util/isScheduler': '../node_modules/rxjs/_esm5/internal/util/isScheduler.js',
				'../operators/mergeAll': '../node_modules/rxjs/_esm5/internal/operators/mergeAll.js',
				'./fromArray': '../node_modules/rxjs/_esm5/internal/observable/fromArray.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/never.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.never = never;
				exports.NEVER = void 0;

				var _Observable = require('../Observable');

				var _noop = require('../util/noop');

				/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */
				var NEVER =
					/*@__PURE__*/
					new _Observable.Observable(_noop.noop);
				exports.NEVER = NEVER;

				function never() {
					return NEVER;
				}
			},
			{
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../util/noop': '../node_modules/rxjs/_esm5/internal/util/noop.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/onErrorResumeNext.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.onErrorResumeNext = onErrorResumeNext;

				var _Observable = require('../Observable');

				var _from = require('./from');

				var _isArray = require('../util/isArray');

				var _empty = require('./empty');

				/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */
				function onErrorResumeNext() {
					var sources = [];

					for (var _i = 0; _i < arguments.length; _i++) {
						sources[_i] = arguments[_i];
					}

					if (sources.length === 0) {
						return _empty.EMPTY;
					}

					var first = sources[0],
						remainder = sources.slice(1);

					if (sources.length === 1 && (0, _isArray.isArray)(first)) {
						return onErrorResumeNext.apply(void 0, first);
					}

					return new _Observable.Observable(function (subscriber) {
						var subNext = function () {
							return subscriber.add(
								onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber)
							);
						};

						return (0, _from.from)(first).subscribe({
							next: function (value) {
								subscriber.next(value);
							},
							error: subNext,
							complete: subNext
						});
					});
				}
			},
			{
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'./from': '../node_modules/rxjs/_esm5/internal/observable/from.js',
				'../util/isArray': '../node_modules/rxjs/_esm5/internal/util/isArray.js',
				'./empty': '../node_modules/rxjs/_esm5/internal/observable/empty.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/pairs.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.pairs = pairs;
				exports.dispatch = dispatch;

				var _Observable = require('../Observable');

				var _Subscription = require('../Subscription');

				/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
				function pairs(obj, scheduler) {
					if (!scheduler) {
						return new _Observable.Observable(function (subscriber) {
							var keys = Object.keys(obj);

							for (var i = 0; i < keys.length && !subscriber.closed; i++) {
								var key = keys[i];

								if (obj.hasOwnProperty(key)) {
									subscriber.next([key, obj[key]]);
								}
							}

							subscriber.complete();
						});
					} else {
						return new _Observable.Observable(function (subscriber) {
							var keys = Object.keys(obj);
							var subscription = new _Subscription.Subscription();
							subscription.add(
								scheduler.schedule(dispatch, 0, {
									keys: keys,
									index: 0,
									subscriber: subscriber,
									subscription: subscription,
									obj: obj
								})
							);
							return subscription;
						});
					}
				}

				function dispatch(state) {
					var keys = state.keys,
						index = state.index,
						subscriber = state.subscriber,
						subscription = state.subscription,
						obj = state.obj;

					if (!subscriber.closed) {
						if (index < keys.length) {
							var key = keys[index];
							subscriber.next([key, obj[key]]);
							subscription.add(
								this.schedule({
									keys: keys,
									index: index + 1,
									subscriber: subscriber,
									subscription: subscription,
									obj: obj
								})
							);
						} else {
							subscriber.complete();
						}
					}
				}
			},
			{
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../Subscription': '../node_modules/rxjs/_esm5/internal/Subscription.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/util/not.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.not = not;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				function not(pred, thisArg) {
					function notPred() {
						return !notPred.pred.apply(notPred.thisArg, arguments);
					}

					notPred.pred = pred;
					notPred.thisArg = thisArg;
					return notPred;
				}
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/operators/filter.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.filter = filter;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				function filter(predicate, thisArg) {
					return function filterOperatorFunction(source) {
						return source.lift(new FilterOperator(predicate, thisArg));
					};
				}

				var FilterOperator =
					/*@__PURE__*/
					(function () {
						function FilterOperator(predicate, thisArg) {
							this.predicate = predicate;
							this.thisArg = thisArg;
						}

						FilterOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new FilterSubscriber(subscriber, this.predicate, this.thisArg)
							);
						};

						return FilterOperator;
					})();

				var FilterSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(FilterSubscriber, _super);

						function FilterSubscriber(destination, predicate, thisArg) {
							var _this = _super.call(this, destination) || this;

							_this.predicate = predicate;
							_this.thisArg = thisArg;
							_this.count = 0;
							return _this;
						}

						FilterSubscriber.prototype._next = function (value) {
							var result;

							try {
								result = this.predicate.call(this.thisArg, value, this.count++);
							} catch (err) {
								this.destination.error(err);
								return;
							}

							if (result) {
								this.destination.next(value);
							}
						};

						return FilterSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/partition.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.partition = partition;

				var _not = require('../util/not');

				var _subscribeTo = require('../util/subscribeTo');

				var _filter = require('../operators/filter');

				var _Observable = require('../Observable');

				/** PURE_IMPORTS_START _util_not,_util_subscribeTo,_operators_filter,_Observable PURE_IMPORTS_END */
				function partition(source, predicate, thisArg) {
					return [
						(0, _filter.filter)(
							predicate,
							thisArg
						)(new _Observable.Observable((0, _subscribeTo.subscribeTo)(source))),
						(0, _filter.filter)((0, _not.not)(predicate, thisArg))(
							new _Observable.Observable((0, _subscribeTo.subscribeTo)(source))
						)
					];
				}
			},
			{
				'../util/not': '../node_modules/rxjs/_esm5/internal/util/not.js',
				'../util/subscribeTo': '../node_modules/rxjs/_esm5/internal/util/subscribeTo.js',
				'../operators/filter': '../node_modules/rxjs/_esm5/internal/operators/filter.js',
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/race.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.race = race;
				exports.RaceSubscriber = exports.RaceOperator = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _isArray = require('../util/isArray');

				var _fromArray = require('./fromArray');

				var _OuterSubscriber = require('../OuterSubscriber');

				var _subscribeToResult = require('../util/subscribeToResult');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
				function race() {
					var observables = [];

					for (var _i = 0; _i < arguments.length; _i++) {
						observables[_i] = arguments[_i];
					}

					if (observables.length === 1) {
						if ((0, _isArray.isArray)(observables[0])) {
							observables = observables[0];
						} else {
							return observables[0];
						}
					}

					return (0, _fromArray.fromArray)(observables, undefined).lift(new RaceOperator());
				}

				var RaceOperator =
					/*@__PURE__*/
					(function () {
						function RaceOperator() {}

						RaceOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new RaceSubscriber(subscriber));
						};

						return RaceOperator;
					})();

				exports.RaceOperator = RaceOperator;

				var RaceSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(RaceSubscriber, _super);

						function RaceSubscriber(destination) {
							var _this = _super.call(this, destination) || this;

							_this.hasFirst = false;
							_this.observables = [];
							_this.subscriptions = [];
							return _this;
						}

						RaceSubscriber.prototype._next = function (observable) {
							this.observables.push(observable);
						};

						RaceSubscriber.prototype._complete = function () {
							var observables = this.observables;
							var len = observables.length;

							if (len === 0) {
								this.destination.complete();
							} else {
								for (var i = 0; i < len && !this.hasFirst; i++) {
									var observable = observables[i];
									var subscription = (0, _subscribeToResult.subscribeToResult)(
										this,
										observable,
										undefined,
										i
									);

									if (this.subscriptions) {
										this.subscriptions.push(subscription);
									}

									this.add(subscription);
								}

								this.observables = null;
							}
						};

						RaceSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
							if (!this.hasFirst) {
								this.hasFirst = true;

								for (var i = 0; i < this.subscriptions.length; i++) {
									if (i !== outerIndex) {
										var subscription = this.subscriptions[i];
										subscription.unsubscribe();
										this.remove(subscription);
									}
								}

								this.subscriptions = null;
							}

							this.destination.next(innerValue);
						};

						return RaceSubscriber;
					})(_OuterSubscriber.OuterSubscriber);

				exports.RaceSubscriber = RaceSubscriber;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../util/isArray': '../node_modules/rxjs/_esm5/internal/util/isArray.js',
				'./fromArray': '../node_modules/rxjs/_esm5/internal/observable/fromArray.js',
				'../OuterSubscriber': '../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
				'../util/subscribeToResult': '../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/range.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.range = range;
				exports.dispatch = dispatch;

				var _Observable = require('../Observable');

				/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
				function range(start, count, scheduler) {
					if (start === void 0) {
						start = 0;
					}

					return new _Observable.Observable(function (subscriber) {
						if (count === undefined) {
							count = start;
							start = 0;
						}

						var index = 0;
						var current = start;

						if (scheduler) {
							return scheduler.schedule(dispatch, 0, {
								index: index,
								count: count,
								start: start,
								subscriber: subscriber
							});
						} else {
							do {
								if (index++ >= count) {
									subscriber.complete();
									break;
								}

								subscriber.next(current++);

								if (subscriber.closed) {
									break;
								}
							} while (true);
						}

						return undefined;
					});
				}

				function dispatch(state) {
					var start = state.start,
						index = state.index,
						count = state.count,
						subscriber = state.subscriber;

					if (index >= count) {
						subscriber.complete();
						return;
					}

					subscriber.next(start);

					if (subscriber.closed) {
						return;
					}

					state.index = index + 1;
					state.start = start + 1;
					this.schedule(state);
				}
			},
			{ '../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js' }
		],
		'../node_modules/rxjs/_esm5/internal/observable/timer.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.timer = timer;

				var _Observable = require('../Observable');

				var _async = require('../scheduler/async');

				var _isNumeric = require('../util/isNumeric');

				var _isScheduler = require('../util/isScheduler');

				/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
				function timer(dueTime, periodOrScheduler, scheduler) {
					if (dueTime === void 0) {
						dueTime = 0;
					}

					var period = -1;

					if ((0, _isNumeric.isNumeric)(periodOrScheduler)) {
						period = (Number(periodOrScheduler) < 1 && 1) || Number(periodOrScheduler);
					} else if ((0, _isScheduler.isScheduler)(periodOrScheduler)) {
						scheduler = periodOrScheduler;
					}

					if (!(0, _isScheduler.isScheduler)(scheduler)) {
						scheduler = _async.async;
					}

					return new _Observable.Observable(function (subscriber) {
						var due = (0, _isNumeric.isNumeric)(dueTime) ? dueTime : +dueTime - scheduler.now();
						return scheduler.schedule(dispatch, due, {
							index: 0,
							period: period,
							subscriber: subscriber
						});
					});
				}

				function dispatch(state) {
					var index = state.index,
						period = state.period,
						subscriber = state.subscriber;
					subscriber.next(index);

					if (subscriber.closed) {
						return;
					} else if (period === -1) {
						return subscriber.complete();
					}

					state.index = index + 1;
					this.schedule(state, period);
				}
			},
			{
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../scheduler/async': '../node_modules/rxjs/_esm5/internal/scheduler/async.js',
				'../util/isNumeric': '../node_modules/rxjs/_esm5/internal/util/isNumeric.js',
				'../util/isScheduler': '../node_modules/rxjs/_esm5/internal/util/isScheduler.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/using.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.using = using;

				var _Observable = require('../Observable');

				var _from = require('./from');

				var _empty = require('./empty');

				/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
				function using(resourceFactory, observableFactory) {
					return new _Observable.Observable(function (subscriber) {
						var resource;

						try {
							resource = resourceFactory();
						} catch (err) {
							subscriber.error(err);
							return undefined;
						}

						var result;

						try {
							result = observableFactory(resource);
						} catch (err) {
							subscriber.error(err);
							return undefined;
						}

						var source = result ? (0, _from.from)(result) : _empty.EMPTY;
						var subscription = source.subscribe(subscriber);
						return function () {
							subscription.unsubscribe();

							if (resource) {
								resource.unsubscribe();
							}
						};
					});
				}
			},
			{
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'./from': '../node_modules/rxjs/_esm5/internal/observable/from.js',
				'./empty': '../node_modules/rxjs/_esm5/internal/observable/empty.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/zip.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.zip = zip;
				exports.ZipSubscriber = exports.ZipOperator = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _fromArray = require('./fromArray');

				var _isArray = require('../util/isArray');

				var _Subscriber = require('../Subscriber');

				var _iterator = require('../../internal/symbol/iterator');

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_.._internal_symbol_iterator,_innerSubscribe PURE_IMPORTS_END */
				function zip() {
					var observables = [];

					for (var _i = 0; _i < arguments.length; _i++) {
						observables[_i] = arguments[_i];
					}

					var resultSelector = observables[observables.length - 1];

					if (typeof resultSelector === 'function') {
						observables.pop();
					}

					return (0, _fromArray.fromArray)(observables, undefined).lift(
						new ZipOperator(resultSelector)
					);
				}

				var ZipOperator =
					/*@__PURE__*/
					(function () {
						function ZipOperator(resultSelector) {
							this.resultSelector = resultSelector;
						}

						ZipOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
						};

						return ZipOperator;
					})();

				exports.ZipOperator = ZipOperator;

				var ZipSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(ZipSubscriber, _super);

						function ZipSubscriber(destination, resultSelector, values) {
							if (values === void 0) {
								values = Object.create(null);
							}

							var _this = _super.call(this, destination) || this;

							_this.resultSelector = resultSelector;
							_this.iterators = [];
							_this.active = 0;
							_this.resultSelector =
								typeof resultSelector === 'function' ? resultSelector : undefined;
							return _this;
						}

						ZipSubscriber.prototype._next = function (value) {
							var iterators = this.iterators;

							if ((0, _isArray.isArray)(value)) {
								iterators.push(new StaticArrayIterator(value));
							} else if (typeof value[_iterator.iterator] === 'function') {
								iterators.push(new StaticIterator(value[_iterator.iterator]()));
							} else {
								iterators.push(new ZipBufferIterator(this.destination, this, value));
							}
						};

						ZipSubscriber.prototype._complete = function () {
							var iterators = this.iterators;
							var len = iterators.length;
							this.unsubscribe();

							if (len === 0) {
								this.destination.complete();
								return;
							}

							this.active = len;

							for (var i = 0; i < len; i++) {
								var iterator = iterators[i];

								if (iterator.stillUnsubscribed) {
									var destination = this.destination;
									destination.add(iterator.subscribe());
								} else {
									this.active--;
								}
							}
						};

						ZipSubscriber.prototype.notifyInactive = function () {
							this.active--;

							if (this.active === 0) {
								this.destination.complete();
							}
						};

						ZipSubscriber.prototype.checkIterators = function () {
							var iterators = this.iterators;
							var len = iterators.length;
							var destination = this.destination;

							for (var i = 0; i < len; i++) {
								var iterator = iterators[i];

								if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
									return;
								}
							}

							var shouldComplete = false;
							var args = [];

							for (var i = 0; i < len; i++) {
								var iterator = iterators[i];
								var result = iterator.next();

								if (iterator.hasCompleted()) {
									shouldComplete = true;
								}

								if (result.done) {
									destination.complete();
									return;
								}

								args.push(result.value);
							}

							if (this.resultSelector) {
								this._tryresultSelector(args);
							} else {
								destination.next(args);
							}

							if (shouldComplete) {
								destination.complete();
							}
						};

						ZipSubscriber.prototype._tryresultSelector = function (args) {
							var result;

							try {
								result = this.resultSelector.apply(this, args);
							} catch (err) {
								this.destination.error(err);
								return;
							}

							this.destination.next(result);
						};

						return ZipSubscriber;
					})(_Subscriber.Subscriber);

				exports.ZipSubscriber = ZipSubscriber;

				var StaticIterator =
					/*@__PURE__*/
					(function () {
						function StaticIterator(iterator) {
							this.iterator = iterator;
							this.nextResult = iterator.next();
						}

						StaticIterator.prototype.hasValue = function () {
							return true;
						};

						StaticIterator.prototype.next = function () {
							var result = this.nextResult;
							this.nextResult = this.iterator.next();
							return result;
						};

						StaticIterator.prototype.hasCompleted = function () {
							var nextResult = this.nextResult;
							return Boolean(nextResult && nextResult.done);
						};

						return StaticIterator;
					})();

				var StaticArrayIterator =
					/*@__PURE__*/
					(function () {
						function StaticArrayIterator(array) {
							this.array = array;
							this.index = 0;
							this.length = 0;
							this.length = array.length;
						}

						StaticArrayIterator.prototype[_iterator.iterator] = function () {
							return this;
						};

						StaticArrayIterator.prototype.next = function (value) {
							var i = this.index++;
							var array = this.array;
							return i < this.length
								? {
										value: array[i],
										done: false
								  }
								: {
										value: null,
										done: true
								  };
						};

						StaticArrayIterator.prototype.hasValue = function () {
							return this.array.length > this.index;
						};

						StaticArrayIterator.prototype.hasCompleted = function () {
							return this.array.length === this.index;
						};

						return StaticArrayIterator;
					})();

				var ZipBufferIterator =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(ZipBufferIterator, _super);

						function ZipBufferIterator(destination, parent, observable) {
							var _this = _super.call(this, destination) || this;

							_this.parent = parent;
							_this.observable = observable;
							_this.stillUnsubscribed = true;
							_this.buffer = [];
							_this.isComplete = false;
							return _this;
						}

						ZipBufferIterator.prototype[_iterator.iterator] = function () {
							return this;
						};

						ZipBufferIterator.prototype.next = function () {
							var buffer = this.buffer;

							if (buffer.length === 0 && this.isComplete) {
								return {
									value: null,
									done: true
								};
							} else {
								return {
									value: buffer.shift(),
									done: false
								};
							}
						};

						ZipBufferIterator.prototype.hasValue = function () {
							return this.buffer.length > 0;
						};

						ZipBufferIterator.prototype.hasCompleted = function () {
							return this.buffer.length === 0 && this.isComplete;
						};

						ZipBufferIterator.prototype.notifyComplete = function () {
							if (this.buffer.length > 0) {
								this.isComplete = true;
								this.parent.notifyInactive();
							} else {
								this.destination.complete();
							}
						};

						ZipBufferIterator.prototype.notifyNext = function (innerValue) {
							this.buffer.push(innerValue);
							this.parent.checkIterators();
						};

						ZipBufferIterator.prototype.subscribe = function () {
							return (0, _innerSubscribe.innerSubscribe)(
								this.observable,
								new _innerSubscribe.SimpleInnerSubscriber(this)
							);
						};

						return ZipBufferIterator;
					})(_innerSubscribe.SimpleOuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'./fromArray': '../node_modules/rxjs/_esm5/internal/observable/fromArray.js',
				'../util/isArray': '../node_modules/rxjs/_esm5/internal/util/isArray.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../../internal/symbol/iterator': '../node_modules/rxjs/_esm5/internal/symbol/iterator.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/index.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				Object.defineProperty(exports, 'Observable', {
					enumerable: true,
					get: function () {
						return _Observable.Observable;
					}
				});
				Object.defineProperty(exports, 'ConnectableObservable', {
					enumerable: true,
					get: function () {
						return _ConnectableObservable.ConnectableObservable;
					}
				});
				Object.defineProperty(exports, 'GroupedObservable', {
					enumerable: true,
					get: function () {
						return _groupBy.GroupedObservable;
					}
				});
				Object.defineProperty(exports, 'observable', {
					enumerable: true,
					get: function () {
						return _observable.observable;
					}
				});
				Object.defineProperty(exports, 'Subject', {
					enumerable: true,
					get: function () {
						return _Subject.Subject;
					}
				});
				Object.defineProperty(exports, 'BehaviorSubject', {
					enumerable: true,
					get: function () {
						return _BehaviorSubject.BehaviorSubject;
					}
				});
				Object.defineProperty(exports, 'ReplaySubject', {
					enumerable: true,
					get: function () {
						return _ReplaySubject.ReplaySubject;
					}
				});
				Object.defineProperty(exports, 'AsyncSubject', {
					enumerable: true,
					get: function () {
						return _AsyncSubject.AsyncSubject;
					}
				});
				Object.defineProperty(exports, 'asap', {
					enumerable: true,
					get: function () {
						return _asap.asap;
					}
				});
				Object.defineProperty(exports, 'asapScheduler', {
					enumerable: true,
					get: function () {
						return _asap.asapScheduler;
					}
				});
				Object.defineProperty(exports, 'async', {
					enumerable: true,
					get: function () {
						return _async.async;
					}
				});
				Object.defineProperty(exports, 'asyncScheduler', {
					enumerable: true,
					get: function () {
						return _async.asyncScheduler;
					}
				});
				Object.defineProperty(exports, 'queue', {
					enumerable: true,
					get: function () {
						return _queue.queue;
					}
				});
				Object.defineProperty(exports, 'queueScheduler', {
					enumerable: true,
					get: function () {
						return _queue.queueScheduler;
					}
				});
				Object.defineProperty(exports, 'animationFrame', {
					enumerable: true,
					get: function () {
						return _animationFrame.animationFrame;
					}
				});
				Object.defineProperty(exports, 'animationFrameScheduler', {
					enumerable: true,
					get: function () {
						return _animationFrame.animationFrameScheduler;
					}
				});
				Object.defineProperty(exports, 'VirtualTimeScheduler', {
					enumerable: true,
					get: function () {
						return _VirtualTimeScheduler.VirtualTimeScheduler;
					}
				});
				Object.defineProperty(exports, 'VirtualAction', {
					enumerable: true,
					get: function () {
						return _VirtualTimeScheduler.VirtualAction;
					}
				});
				Object.defineProperty(exports, 'Scheduler', {
					enumerable: true,
					get: function () {
						return _Scheduler.Scheduler;
					}
				});
				Object.defineProperty(exports, 'Subscription', {
					enumerable: true,
					get: function () {
						return _Subscription.Subscription;
					}
				});
				Object.defineProperty(exports, 'Subscriber', {
					enumerable: true,
					get: function () {
						return _Subscriber.Subscriber;
					}
				});
				Object.defineProperty(exports, 'Notification', {
					enumerable: true,
					get: function () {
						return _Notification.Notification;
					}
				});
				Object.defineProperty(exports, 'NotificationKind', {
					enumerable: true,
					get: function () {
						return _Notification.NotificationKind;
					}
				});
				Object.defineProperty(exports, 'pipe', {
					enumerable: true,
					get: function () {
						return _pipe.pipe;
					}
				});
				Object.defineProperty(exports, 'noop', {
					enumerable: true,
					get: function () {
						return _noop.noop;
					}
				});
				Object.defineProperty(exports, 'identity', {
					enumerable: true,
					get: function () {
						return _identity.identity;
					}
				});
				Object.defineProperty(exports, 'isObservable', {
					enumerable: true,
					get: function () {
						return _isObservable.isObservable;
					}
				});
				Object.defineProperty(exports, 'ArgumentOutOfRangeError', {
					enumerable: true,
					get: function () {
						return _ArgumentOutOfRangeError.ArgumentOutOfRangeError;
					}
				});
				Object.defineProperty(exports, 'EmptyError', {
					enumerable: true,
					get: function () {
						return _EmptyError.EmptyError;
					}
				});
				Object.defineProperty(exports, 'ObjectUnsubscribedError', {
					enumerable: true,
					get: function () {
						return _ObjectUnsubscribedError.ObjectUnsubscribedError;
					}
				});
				Object.defineProperty(exports, 'UnsubscriptionError', {
					enumerable: true,
					get: function () {
						return _UnsubscriptionError.UnsubscriptionError;
					}
				});
				Object.defineProperty(exports, 'TimeoutError', {
					enumerable: true,
					get: function () {
						return _TimeoutError.TimeoutError;
					}
				});
				Object.defineProperty(exports, 'bindCallback', {
					enumerable: true,
					get: function () {
						return _bindCallback.bindCallback;
					}
				});
				Object.defineProperty(exports, 'bindNodeCallback', {
					enumerable: true,
					get: function () {
						return _bindNodeCallback.bindNodeCallback;
					}
				});
				Object.defineProperty(exports, 'combineLatest', {
					enumerable: true,
					get: function () {
						return _combineLatest.combineLatest;
					}
				});
				Object.defineProperty(exports, 'concat', {
					enumerable: true,
					get: function () {
						return _concat.concat;
					}
				});
				Object.defineProperty(exports, 'defer', {
					enumerable: true,
					get: function () {
						return _defer.defer;
					}
				});
				Object.defineProperty(exports, 'empty', {
					enumerable: true,
					get: function () {
						return _empty.empty;
					}
				});
				Object.defineProperty(exports, 'EMPTY', {
					enumerable: true,
					get: function () {
						return _empty.EMPTY;
					}
				});
				Object.defineProperty(exports, 'forkJoin', {
					enumerable: true,
					get: function () {
						return _forkJoin.forkJoin;
					}
				});
				Object.defineProperty(exports, 'from', {
					enumerable: true,
					get: function () {
						return _from.from;
					}
				});
				Object.defineProperty(exports, 'fromEvent', {
					enumerable: true,
					get: function () {
						return _fromEvent.fromEvent;
					}
				});
				Object.defineProperty(exports, 'fromEventPattern', {
					enumerable: true,
					get: function () {
						return _fromEventPattern.fromEventPattern;
					}
				});
				Object.defineProperty(exports, 'generate', {
					enumerable: true,
					get: function () {
						return _generate.generate;
					}
				});
				Object.defineProperty(exports, 'iif', {
					enumerable: true,
					get: function () {
						return _iif.iif;
					}
				});
				Object.defineProperty(exports, 'interval', {
					enumerable: true,
					get: function () {
						return _interval.interval;
					}
				});
				Object.defineProperty(exports, 'merge', {
					enumerable: true,
					get: function () {
						return _merge.merge;
					}
				});
				Object.defineProperty(exports, 'never', {
					enumerable: true,
					get: function () {
						return _never.never;
					}
				});
				Object.defineProperty(exports, 'NEVER', {
					enumerable: true,
					get: function () {
						return _never.NEVER;
					}
				});
				Object.defineProperty(exports, 'of', {
					enumerable: true,
					get: function () {
						return _of.of;
					}
				});
				Object.defineProperty(exports, 'onErrorResumeNext', {
					enumerable: true,
					get: function () {
						return _onErrorResumeNext.onErrorResumeNext;
					}
				});
				Object.defineProperty(exports, 'pairs', {
					enumerable: true,
					get: function () {
						return _pairs.pairs;
					}
				});
				Object.defineProperty(exports, 'partition', {
					enumerable: true,
					get: function () {
						return _partition.partition;
					}
				});
				Object.defineProperty(exports, 'race', {
					enumerable: true,
					get: function () {
						return _race.race;
					}
				});
				Object.defineProperty(exports, 'range', {
					enumerable: true,
					get: function () {
						return _range.range;
					}
				});
				Object.defineProperty(exports, 'throwError', {
					enumerable: true,
					get: function () {
						return _throwError.throwError;
					}
				});
				Object.defineProperty(exports, 'timer', {
					enumerable: true,
					get: function () {
						return _timer.timer;
					}
				});
				Object.defineProperty(exports, 'using', {
					enumerable: true,
					get: function () {
						return _using.using;
					}
				});
				Object.defineProperty(exports, 'zip', {
					enumerable: true,
					get: function () {
						return _zip.zip;
					}
				});
				Object.defineProperty(exports, 'scheduled', {
					enumerable: true,
					get: function () {
						return _scheduled.scheduled;
					}
				});
				Object.defineProperty(exports, 'config', {
					enumerable: true,
					get: function () {
						return _config.config;
					}
				});

				var _Observable = require('./internal/Observable');

				var _ConnectableObservable = require('./internal/observable/ConnectableObservable');

				var _groupBy = require('./internal/operators/groupBy');

				var _observable = require('./internal/symbol/observable');

				var _Subject = require('./internal/Subject');

				var _BehaviorSubject = require('./internal/BehaviorSubject');

				var _ReplaySubject = require('./internal/ReplaySubject');

				var _AsyncSubject = require('./internal/AsyncSubject');

				var _asap = require('./internal/scheduler/asap');

				var _async = require('./internal/scheduler/async');

				var _queue = require('./internal/scheduler/queue');

				var _animationFrame = require('./internal/scheduler/animationFrame');

				var _VirtualTimeScheduler = require('./internal/scheduler/VirtualTimeScheduler');

				var _Scheduler = require('./internal/Scheduler');

				var _Subscription = require('./internal/Subscription');

				var _Subscriber = require('./internal/Subscriber');

				var _Notification = require('./internal/Notification');

				var _pipe = require('./internal/util/pipe');

				var _noop = require('./internal/util/noop');

				var _identity = require('./internal/util/identity');

				var _isObservable = require('./internal/util/isObservable');

				var _ArgumentOutOfRangeError = require('./internal/util/ArgumentOutOfRangeError');

				var _EmptyError = require('./internal/util/EmptyError');

				var _ObjectUnsubscribedError = require('./internal/util/ObjectUnsubscribedError');

				var _UnsubscriptionError = require('./internal/util/UnsubscriptionError');

				var _TimeoutError = require('./internal/util/TimeoutError');

				var _bindCallback = require('./internal/observable/bindCallback');

				var _bindNodeCallback = require('./internal/observable/bindNodeCallback');

				var _combineLatest = require('./internal/observable/combineLatest');

				var _concat = require('./internal/observable/concat');

				var _defer = require('./internal/observable/defer');

				var _empty = require('./internal/observable/empty');

				var _forkJoin = require('./internal/observable/forkJoin');

				var _from = require('./internal/observable/from');

				var _fromEvent = require('./internal/observable/fromEvent');

				var _fromEventPattern = require('./internal/observable/fromEventPattern');

				var _generate = require('./internal/observable/generate');

				var _iif = require('./internal/observable/iif');

				var _interval = require('./internal/observable/interval');

				var _merge = require('./internal/observable/merge');

				var _never = require('./internal/observable/never');

				var _of = require('./internal/observable/of');

				var _onErrorResumeNext = require('./internal/observable/onErrorResumeNext');

				var _pairs = require('./internal/observable/pairs');

				var _partition = require('./internal/observable/partition');

				var _race = require('./internal/observable/race');

				var _range = require('./internal/observable/range');

				var _throwError = require('./internal/observable/throwError');

				var _timer = require('./internal/observable/timer');

				var _using = require('./internal/observable/using');

				var _zip = require('./internal/observable/zip');

				var _scheduled = require('./internal/scheduled/scheduled');

				var _config = require('./internal/config');
			},
			{
				'./internal/Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'./internal/observable/ConnectableObservable':
					'../node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js',
				'./internal/operators/groupBy': '../node_modules/rxjs/_esm5/internal/operators/groupBy.js',
				'./internal/symbol/observable': '../node_modules/rxjs/_esm5/internal/symbol/observable.js',
				'./internal/Subject': '../node_modules/rxjs/_esm5/internal/Subject.js',
				'./internal/BehaviorSubject': '../node_modules/rxjs/_esm5/internal/BehaviorSubject.js',
				'./internal/ReplaySubject': '../node_modules/rxjs/_esm5/internal/ReplaySubject.js',
				'./internal/AsyncSubject': '../node_modules/rxjs/_esm5/internal/AsyncSubject.js',
				'./internal/scheduler/asap': '../node_modules/rxjs/_esm5/internal/scheduler/asap.js',
				'./internal/scheduler/async': '../node_modules/rxjs/_esm5/internal/scheduler/async.js',
				'./internal/scheduler/queue': '../node_modules/rxjs/_esm5/internal/scheduler/queue.js',
				'./internal/scheduler/animationFrame':
					'../node_modules/rxjs/_esm5/internal/scheduler/animationFrame.js',
				'./internal/scheduler/VirtualTimeScheduler':
					'../node_modules/rxjs/_esm5/internal/scheduler/VirtualTimeScheduler.js',
				'./internal/Scheduler': '../node_modules/rxjs/_esm5/internal/Scheduler.js',
				'./internal/Subscription': '../node_modules/rxjs/_esm5/internal/Subscription.js',
				'./internal/Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'./internal/Notification': '../node_modules/rxjs/_esm5/internal/Notification.js',
				'./internal/util/pipe': '../node_modules/rxjs/_esm5/internal/util/pipe.js',
				'./internal/util/noop': '../node_modules/rxjs/_esm5/internal/util/noop.js',
				'./internal/util/identity': '../node_modules/rxjs/_esm5/internal/util/identity.js',
				'./internal/util/isObservable': '../node_modules/rxjs/_esm5/internal/util/isObservable.js',
				'./internal/util/ArgumentOutOfRangeError':
					'../node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js',
				'./internal/util/EmptyError': '../node_modules/rxjs/_esm5/internal/util/EmptyError.js',
				'./internal/util/ObjectUnsubscribedError':
					'../node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js',
				'./internal/util/UnsubscriptionError':
					'../node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js',
				'./internal/util/TimeoutError': '../node_modules/rxjs/_esm5/internal/util/TimeoutError.js',
				'./internal/observable/bindCallback':
					'../node_modules/rxjs/_esm5/internal/observable/bindCallback.js',
				'./internal/observable/bindNodeCallback':
					'../node_modules/rxjs/_esm5/internal/observable/bindNodeCallback.js',
				'./internal/observable/combineLatest':
					'../node_modules/rxjs/_esm5/internal/observable/combineLatest.js',
				'./internal/observable/concat': '../node_modules/rxjs/_esm5/internal/observable/concat.js',
				'./internal/observable/defer': '../node_modules/rxjs/_esm5/internal/observable/defer.js',
				'./internal/observable/empty': '../node_modules/rxjs/_esm5/internal/observable/empty.js',
				'./internal/observable/forkJoin':
					'../node_modules/rxjs/_esm5/internal/observable/forkJoin.js',
				'./internal/observable/from': '../node_modules/rxjs/_esm5/internal/observable/from.js',
				'./internal/observable/fromEvent':
					'../node_modules/rxjs/_esm5/internal/observable/fromEvent.js',
				'./internal/observable/fromEventPattern':
					'../node_modules/rxjs/_esm5/internal/observable/fromEventPattern.js',
				'./internal/observable/generate':
					'../node_modules/rxjs/_esm5/internal/observable/generate.js',
				'./internal/observable/iif': '../node_modules/rxjs/_esm5/internal/observable/iif.js',
				'./internal/observable/interval':
					'../node_modules/rxjs/_esm5/internal/observable/interval.js',
				'./internal/observable/merge': '../node_modules/rxjs/_esm5/internal/observable/merge.js',
				'./internal/observable/never': '../node_modules/rxjs/_esm5/internal/observable/never.js',
				'./internal/observable/of': '../node_modules/rxjs/_esm5/internal/observable/of.js',
				'./internal/observable/onErrorResumeNext':
					'../node_modules/rxjs/_esm5/internal/observable/onErrorResumeNext.js',
				'./internal/observable/pairs': '../node_modules/rxjs/_esm5/internal/observable/pairs.js',
				'./internal/observable/partition':
					'../node_modules/rxjs/_esm5/internal/observable/partition.js',
				'./internal/observable/race': '../node_modules/rxjs/_esm5/internal/observable/race.js',
				'./internal/observable/range': '../node_modules/rxjs/_esm5/internal/observable/range.js',
				'./internal/observable/throwError':
					'../node_modules/rxjs/_esm5/internal/observable/throwError.js',
				'./internal/observable/timer': '../node_modules/rxjs/_esm5/internal/observable/timer.js',
				'./internal/observable/using': '../node_modules/rxjs/_esm5/internal/observable/using.js',
				'./internal/observable/zip': '../node_modules/rxjs/_esm5/internal/observable/zip.js',
				'./internal/scheduled/scheduled':
					'../node_modules/rxjs/_esm5/internal/scheduled/scheduled.js',
				'./internal/config': '../node_modules/rxjs/_esm5/internal/config.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/audit.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.audit = audit;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */
				function audit(durationSelector) {
					return function auditOperatorFunction(source) {
						return source.lift(new AuditOperator(durationSelector));
					};
				}

				var AuditOperator =
					/*@__PURE__*/
					(function () {
						function AuditOperator(durationSelector) {
							this.durationSelector = durationSelector;
						}

						AuditOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
						};

						return AuditOperator;
					})();

				var AuditSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(AuditSubscriber, _super);

						function AuditSubscriber(destination, durationSelector) {
							var _this = _super.call(this, destination) || this;

							_this.durationSelector = durationSelector;
							_this.hasValue = false;
							return _this;
						}

						AuditSubscriber.prototype._next = function (value) {
							this.value = value;
							this.hasValue = true;

							if (!this.throttled) {
								var duration = void 0;

								try {
									var durationSelector = this.durationSelector;
									duration = durationSelector(value);
								} catch (err) {
									return this.destination.error(err);
								}

								var innerSubscription = (0, _innerSubscribe.innerSubscribe)(
									duration,
									new _innerSubscribe.SimpleInnerSubscriber(this)
								);

								if (!innerSubscription || innerSubscription.closed) {
									this.clearThrottle();
								} else {
									this.add((this.throttled = innerSubscription));
								}
							}
						};

						AuditSubscriber.prototype.clearThrottle = function () {
							var _a = this,
								value = _a.value,
								hasValue = _a.hasValue,
								throttled = _a.throttled;

							if (throttled) {
								this.remove(throttled);
								this.throttled = undefined;
								throttled.unsubscribe();
							}

							if (hasValue) {
								this.value = undefined;
								this.hasValue = false;
								this.destination.next(value);
							}
						};

						AuditSubscriber.prototype.notifyNext = function () {
							this.clearThrottle();
						};

						AuditSubscriber.prototype.notifyComplete = function () {
							this.clearThrottle();
						};

						return AuditSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/auditTime.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.auditTime = auditTime;

				var _async = require('../scheduler/async');

				var _audit = require('./audit');

				var _timer = require('../observable/timer');

				/** PURE_IMPORTS_START _scheduler_async,_audit,_observable_timer PURE_IMPORTS_END */
				function auditTime(duration, scheduler) {
					if (scheduler === void 0) {
						scheduler = _async.async;
					}

					return (0, _audit.audit)(function () {
						return (0, _timer.timer)(duration, scheduler);
					});
				}
			},
			{
				'../scheduler/async': '../node_modules/rxjs/_esm5/internal/scheduler/async.js',
				'./audit': '../node_modules/rxjs/_esm5/internal/operators/audit.js',
				'../observable/timer': '../node_modules/rxjs/_esm5/internal/observable/timer.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/buffer.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.buffer = buffer;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */
				function buffer(closingNotifier) {
					return function bufferOperatorFunction(source) {
						return source.lift(new BufferOperator(closingNotifier));
					};
				}

				var BufferOperator =
					/*@__PURE__*/
					(function () {
						function BufferOperator(closingNotifier) {
							this.closingNotifier = closingNotifier;
						}

						BufferOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
						};

						return BufferOperator;
					})();

				var BufferSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(BufferSubscriber, _super);

						function BufferSubscriber(destination, closingNotifier) {
							var _this = _super.call(this, destination) || this;

							_this.buffer = [];

							_this.add(
								(0, _innerSubscribe.innerSubscribe)(
									closingNotifier,
									new _innerSubscribe.SimpleInnerSubscriber(_this)
								)
							);

							return _this;
						}

						BufferSubscriber.prototype._next = function (value) {
							this.buffer.push(value);
						};

						BufferSubscriber.prototype.notifyNext = function () {
							var buffer = this.buffer;
							this.buffer = [];
							this.destination.next(buffer);
						};

						return BufferSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/bufferCount.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.bufferCount = bufferCount;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				function bufferCount(bufferSize, startBufferEvery) {
					if (startBufferEvery === void 0) {
						startBufferEvery = null;
					}

					return function bufferCountOperatorFunction(source) {
						return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
					};
				}

				var BufferCountOperator =
					/*@__PURE__*/
					(function () {
						function BufferCountOperator(bufferSize, startBufferEvery) {
							this.bufferSize = bufferSize;
							this.startBufferEvery = startBufferEvery;

							if (!startBufferEvery || bufferSize === startBufferEvery) {
								this.subscriberClass = BufferCountSubscriber;
							} else {
								this.subscriberClass = BufferSkipCountSubscriber;
							}
						}

						BufferCountOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery)
							);
						};

						return BufferCountOperator;
					})();

				var BufferCountSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(BufferCountSubscriber, _super);

						function BufferCountSubscriber(destination, bufferSize) {
							var _this = _super.call(this, destination) || this;

							_this.bufferSize = bufferSize;
							_this.buffer = [];
							return _this;
						}

						BufferCountSubscriber.prototype._next = function (value) {
							var buffer = this.buffer;
							buffer.push(value);

							if (buffer.length == this.bufferSize) {
								this.destination.next(buffer);
								this.buffer = [];
							}
						};

						BufferCountSubscriber.prototype._complete = function () {
							var buffer = this.buffer;

							if (buffer.length > 0) {
								this.destination.next(buffer);
							}

							_super.prototype._complete.call(this);
						};

						return BufferCountSubscriber;
					})(_Subscriber.Subscriber);

				var BufferSkipCountSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(BufferSkipCountSubscriber, _super);

						function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
							var _this = _super.call(this, destination) || this;

							_this.bufferSize = bufferSize;
							_this.startBufferEvery = startBufferEvery;
							_this.buffers = [];
							_this.count = 0;
							return _this;
						}

						BufferSkipCountSubscriber.prototype._next = function (value) {
							var _a = this,
								bufferSize = _a.bufferSize,
								startBufferEvery = _a.startBufferEvery,
								buffers = _a.buffers,
								count = _a.count;

							this.count++;

							if (count % startBufferEvery === 0) {
								buffers.push([]);
							}

							for (var i = buffers.length; i--; ) {
								var buffer = buffers[i];
								buffer.push(value);

								if (buffer.length === bufferSize) {
									buffers.splice(i, 1);
									this.destination.next(buffer);
								}
							}
						};

						BufferSkipCountSubscriber.prototype._complete = function () {
							var _a = this,
								buffers = _a.buffers,
								destination = _a.destination;

							while (buffers.length > 0) {
								var buffer = buffers.shift();

								if (buffer.length > 0) {
									destination.next(buffer);
								}
							}

							_super.prototype._complete.call(this);
						};

						return BufferSkipCountSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/bufferTime.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.bufferTime = bufferTime;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _async = require('../scheduler/async');

				var _Subscriber = require('../Subscriber');

				var _isScheduler = require('../util/isScheduler');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */
				function bufferTime(bufferTimeSpan) {
					var length = arguments.length;
					var scheduler = _async.async;

					if ((0, _isScheduler.isScheduler)(arguments[arguments.length - 1])) {
						scheduler = arguments[arguments.length - 1];
						length--;
					}

					var bufferCreationInterval = null;

					if (length >= 2) {
						bufferCreationInterval = arguments[1];
					}

					var maxBufferSize = Number.POSITIVE_INFINITY;

					if (length >= 3) {
						maxBufferSize = arguments[2];
					}

					return function bufferTimeOperatorFunction(source) {
						return source.lift(
							new BufferTimeOperator(
								bufferTimeSpan,
								bufferCreationInterval,
								maxBufferSize,
								scheduler
							)
						);
					};
				}

				var BufferTimeOperator =
					/*@__PURE__*/
					(function () {
						function BufferTimeOperator(
							bufferTimeSpan,
							bufferCreationInterval,
							maxBufferSize,
							scheduler
						) {
							this.bufferTimeSpan = bufferTimeSpan;
							this.bufferCreationInterval = bufferCreationInterval;
							this.maxBufferSize = maxBufferSize;
							this.scheduler = scheduler;
						}

						BufferTimeOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new BufferTimeSubscriber(
									subscriber,
									this.bufferTimeSpan,
									this.bufferCreationInterval,
									this.maxBufferSize,
									this.scheduler
								)
							);
						};

						return BufferTimeOperator;
					})();

				var Context =
					/*@__PURE__*/
					(function () {
						function Context() {
							this.buffer = [];
						}

						return Context;
					})();

				var BufferTimeSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(BufferTimeSubscriber, _super);

						function BufferTimeSubscriber(
							destination,
							bufferTimeSpan,
							bufferCreationInterval,
							maxBufferSize,
							scheduler
						) {
							var _this = _super.call(this, destination) || this;

							_this.bufferTimeSpan = bufferTimeSpan;
							_this.bufferCreationInterval = bufferCreationInterval;
							_this.maxBufferSize = maxBufferSize;
							_this.scheduler = scheduler;
							_this.contexts = [];

							var context = _this.openContext();

							_this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;

							if (_this.timespanOnly) {
								var timeSpanOnlyState = {
									subscriber: _this,
									context: context,
									bufferTimeSpan: bufferTimeSpan
								};

								_this.add(
									(context.closeAction = scheduler.schedule(
										dispatchBufferTimeSpanOnly,
										bufferTimeSpan,
										timeSpanOnlyState
									))
								);
							} else {
								var closeState = {
									subscriber: _this,
									context: context
								};
								var creationState = {
									bufferTimeSpan: bufferTimeSpan,
									bufferCreationInterval: bufferCreationInterval,
									subscriber: _this,
									scheduler: scheduler
								};

								_this.add(
									(context.closeAction = scheduler.schedule(
										dispatchBufferClose,
										bufferTimeSpan,
										closeState
									))
								);

								_this.add(
									scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState)
								);
							}

							return _this;
						}

						BufferTimeSubscriber.prototype._next = function (value) {
							var contexts = this.contexts;
							var len = contexts.length;
							var filledBufferContext;

							for (var i = 0; i < len; i++) {
								var context_1 = contexts[i];
								var buffer = context_1.buffer;
								buffer.push(value);

								if (buffer.length == this.maxBufferSize) {
									filledBufferContext = context_1;
								}
							}

							if (filledBufferContext) {
								this.onBufferFull(filledBufferContext);
							}
						};

						BufferTimeSubscriber.prototype._error = function (err) {
							this.contexts.length = 0;

							_super.prototype._error.call(this, err);
						};

						BufferTimeSubscriber.prototype._complete = function () {
							var _a = this,
								contexts = _a.contexts,
								destination = _a.destination;

							while (contexts.length > 0) {
								var context_2 = contexts.shift();
								destination.next(context_2.buffer);
							}

							_super.prototype._complete.call(this);
						};

						BufferTimeSubscriber.prototype._unsubscribe = function () {
							this.contexts = null;
						};

						BufferTimeSubscriber.prototype.onBufferFull = function (context) {
							this.closeContext(context);
							var closeAction = context.closeAction;
							closeAction.unsubscribe();
							this.remove(closeAction);

							if (!this.closed && this.timespanOnly) {
								context = this.openContext();
								var bufferTimeSpan = this.bufferTimeSpan;
								var timeSpanOnlyState = {
									subscriber: this,
									context: context,
									bufferTimeSpan: bufferTimeSpan
								};
								this.add(
									(context.closeAction = this.scheduler.schedule(
										dispatchBufferTimeSpanOnly,
										bufferTimeSpan,
										timeSpanOnlyState
									))
								);
							}
						};

						BufferTimeSubscriber.prototype.openContext = function () {
							var context = new Context();
							this.contexts.push(context);
							return context;
						};

						BufferTimeSubscriber.prototype.closeContext = function (context) {
							this.destination.next(context.buffer);
							var contexts = this.contexts;
							var spliceIndex = contexts ? contexts.indexOf(context) : -1;

							if (spliceIndex >= 0) {
								contexts.splice(contexts.indexOf(context), 1);
							}
						};

						return BufferTimeSubscriber;
					})(_Subscriber.Subscriber);

				function dispatchBufferTimeSpanOnly(state) {
					var subscriber = state.subscriber;
					var prevContext = state.context;

					if (prevContext) {
						subscriber.closeContext(prevContext);
					}

					if (!subscriber.closed) {
						state.context = subscriber.openContext();
						state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
					}
				}

				function dispatchBufferCreation(state) {
					var bufferCreationInterval = state.bufferCreationInterval,
						bufferTimeSpan = state.bufferTimeSpan,
						subscriber = state.subscriber,
						scheduler = state.scheduler;
					var context = subscriber.openContext();
					var action = this;

					if (!subscriber.closed) {
						subscriber.add(
							(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {
								subscriber: subscriber,
								context: context
							}))
						);
						action.schedule(state, bufferCreationInterval);
					}
				}

				function dispatchBufferClose(arg) {
					var subscriber = arg.subscriber,
						context = arg.context;
					subscriber.closeContext(context);
				}
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../scheduler/async': '../node_modules/rxjs/_esm5/internal/scheduler/async.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../util/isScheduler': '../node_modules/rxjs/_esm5/internal/util/isScheduler.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/bufferToggle.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.bufferToggle = bufferToggle;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscription = require('../Subscription');

				var _subscribeToResult = require('../util/subscribeToResult');

				var _OuterSubscriber = require('../OuterSubscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscription,_util_subscribeToResult,_OuterSubscriber PURE_IMPORTS_END */
				function bufferToggle(openings, closingSelector) {
					return function bufferToggleOperatorFunction(source) {
						return source.lift(new BufferToggleOperator(openings, closingSelector));
					};
				}

				var BufferToggleOperator =
					/*@__PURE__*/
					(function () {
						function BufferToggleOperator(openings, closingSelector) {
							this.openings = openings;
							this.closingSelector = closingSelector;
						}

						BufferToggleOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector)
							);
						};

						return BufferToggleOperator;
					})();

				var BufferToggleSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(BufferToggleSubscriber, _super);

						function BufferToggleSubscriber(destination, openings, closingSelector) {
							var _this = _super.call(this, destination) || this;

							_this.closingSelector = closingSelector;
							_this.contexts = [];

							_this.add((0, _subscribeToResult.subscribeToResult)(_this, openings));

							return _this;
						}

						BufferToggleSubscriber.prototype._next = function (value) {
							var contexts = this.contexts;
							var len = contexts.length;

							for (var i = 0; i < len; i++) {
								contexts[i].buffer.push(value);
							}
						};

						BufferToggleSubscriber.prototype._error = function (err) {
							var contexts = this.contexts;

							while (contexts.length > 0) {
								var context_1 = contexts.shift();
								context_1.subscription.unsubscribe();
								context_1.buffer = null;
								context_1.subscription = null;
							}

							this.contexts = null;

							_super.prototype._error.call(this, err);
						};

						BufferToggleSubscriber.prototype._complete = function () {
							var contexts = this.contexts;

							while (contexts.length > 0) {
								var context_2 = contexts.shift();
								this.destination.next(context_2.buffer);
								context_2.subscription.unsubscribe();
								context_2.buffer = null;
								context_2.subscription = null;
							}

							this.contexts = null;

							_super.prototype._complete.call(this);
						};

						BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue) {
							outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
						};

						BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
							this.closeBuffer(innerSub.context);
						};

						BufferToggleSubscriber.prototype.openBuffer = function (value) {
							try {
								var closingSelector = this.closingSelector;
								var closingNotifier = closingSelector.call(this, value);

								if (closingNotifier) {
									this.trySubscribe(closingNotifier);
								}
							} catch (err) {
								this._error(err);
							}
						};

						BufferToggleSubscriber.prototype.closeBuffer = function (context) {
							var contexts = this.contexts;

							if (contexts && context) {
								var buffer = context.buffer,
									subscription = context.subscription;
								this.destination.next(buffer);
								contexts.splice(contexts.indexOf(context), 1);
								this.remove(subscription);
								subscription.unsubscribe();
							}
						};

						BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
							var contexts = this.contexts;
							var buffer = [];
							var subscription = new _Subscription.Subscription();
							var context = {
								buffer: buffer,
								subscription: subscription
							};
							contexts.push(context);
							var innerSubscription = (0, _subscribeToResult.subscribeToResult)(
								this,
								closingNotifier,
								context
							);

							if (!innerSubscription || innerSubscription.closed) {
								this.closeBuffer(context);
							} else {
								innerSubscription.context = context;
								this.add(innerSubscription);
								subscription.add(innerSubscription);
							}
						};

						return BufferToggleSubscriber;
					})(_OuterSubscriber.OuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscription': '../node_modules/rxjs/_esm5/internal/Subscription.js',
				'../util/subscribeToResult':
					'../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
				'../OuterSubscriber': '../node_modules/rxjs/_esm5/internal/OuterSubscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/bufferWhen.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.bufferWhen = bufferWhen;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscription = require('../Subscription');

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscription,_innerSubscribe PURE_IMPORTS_END */
				function bufferWhen(closingSelector) {
					return function (source) {
						return source.lift(new BufferWhenOperator(closingSelector));
					};
				}

				var BufferWhenOperator =
					/*@__PURE__*/
					(function () {
						function BufferWhenOperator(closingSelector) {
							this.closingSelector = closingSelector;
						}

						BufferWhenOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
						};

						return BufferWhenOperator;
					})();

				var BufferWhenSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(BufferWhenSubscriber, _super);

						function BufferWhenSubscriber(destination, closingSelector) {
							var _this = _super.call(this, destination) || this;

							_this.closingSelector = closingSelector;
							_this.subscribing = false;

							_this.openBuffer();

							return _this;
						}

						BufferWhenSubscriber.prototype._next = function (value) {
							this.buffer.push(value);
						};

						BufferWhenSubscriber.prototype._complete = function () {
							var buffer = this.buffer;

							if (buffer) {
								this.destination.next(buffer);
							}

							_super.prototype._complete.call(this);
						};

						BufferWhenSubscriber.prototype._unsubscribe = function () {
							this.buffer = undefined;
							this.subscribing = false;
						};

						BufferWhenSubscriber.prototype.notifyNext = function () {
							this.openBuffer();
						};

						BufferWhenSubscriber.prototype.notifyComplete = function () {
							if (this.subscribing) {
								this.complete();
							} else {
								this.openBuffer();
							}
						};

						BufferWhenSubscriber.prototype.openBuffer = function () {
							var closingSubscription = this.closingSubscription;

							if (closingSubscription) {
								this.remove(closingSubscription);
								closingSubscription.unsubscribe();
							}

							var buffer = this.buffer;

							if (this.buffer) {
								this.destination.next(buffer);
							}

							this.buffer = [];
							var closingNotifier;

							try {
								var closingSelector = this.closingSelector;
								closingNotifier = closingSelector();
							} catch (err) {
								return this.error(err);
							}

							closingSubscription = new _Subscription.Subscription();
							this.closingSubscription = closingSubscription;
							this.add(closingSubscription);
							this.subscribing = true;
							closingSubscription.add(
								(0, _innerSubscribe.innerSubscribe)(
									closingNotifier,
									new _innerSubscribe.SimpleInnerSubscriber(this)
								)
							);
							this.subscribing = false;
						};

						return BufferWhenSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscription': '../node_modules/rxjs/_esm5/internal/Subscription.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/catchError.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.catchError = catchError;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */
				function catchError(selector) {
					return function catchErrorOperatorFunction(source) {
						var operator = new CatchOperator(selector);
						var caught = source.lift(operator);
						return (operator.caught = caught);
					};
				}

				var CatchOperator =
					/*@__PURE__*/
					(function () {
						function CatchOperator(selector) {
							this.selector = selector;
						}

						CatchOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
						};

						return CatchOperator;
					})();

				var CatchSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(CatchSubscriber, _super);

						function CatchSubscriber(destination, selector, caught) {
							var _this = _super.call(this, destination) || this;

							_this.selector = selector;
							_this.caught = caught;
							return _this;
						}

						CatchSubscriber.prototype.error = function (err) {
							if (!this.isStopped) {
								var result = void 0;

								try {
									result = this.selector(err, this.caught);
								} catch (err2) {
									_super.prototype.error.call(this, err2);

									return;
								}

								this._unsubscribeAndRecycle();

								var innerSubscriber = new _innerSubscribe.SimpleInnerSubscriber(this);
								this.add(innerSubscriber);
								var innerSubscription = (0, _innerSubscribe.innerSubscribe)(
									result,
									innerSubscriber
								);

								if (innerSubscription !== innerSubscriber) {
									this.add(innerSubscription);
								}
							}
						};

						return CatchSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/combineAll.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.combineAll = combineAll;

				var _combineLatest = require('../observable/combineLatest');

				/** PURE_IMPORTS_START _observable_combineLatest PURE_IMPORTS_END */
				function combineAll(project) {
					return function (source) {
						return source.lift(new _combineLatest.CombineLatestOperator(project));
					};
				}
			},
			{
				'../observable/combineLatest':
					'../node_modules/rxjs/_esm5/internal/observable/combineLatest.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/combineLatest.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.combineLatest = combineLatest;

				var _isArray = require('../util/isArray');

				var _combineLatest = require('../observable/combineLatest');

				var _from = require('../observable/from');

				/** PURE_IMPORTS_START _util_isArray,_observable_combineLatest,_observable_from PURE_IMPORTS_END */
				var none = {};

				function combineLatest() {
					var observables = [];

					for (var _i = 0; _i < arguments.length; _i++) {
						observables[_i] = arguments[_i];
					}

					var project = null;

					if (typeof observables[observables.length - 1] === 'function') {
						project = observables.pop();
					}

					if (observables.length === 1 && (0, _isArray.isArray)(observables[0])) {
						observables = observables[0].slice();
					}

					return function (source) {
						return source.lift.call(
							(0, _from.from)([source].concat(observables)),
							new _combineLatest.CombineLatestOperator(project)
						);
					};
				}
			},
			{
				'../util/isArray': '../node_modules/rxjs/_esm5/internal/util/isArray.js',
				'../observable/combineLatest':
					'../node_modules/rxjs/_esm5/internal/observable/combineLatest.js',
				'../observable/from': '../node_modules/rxjs/_esm5/internal/observable/from.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/concat.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.concat = concat;

				var _concat = require('../observable/concat');

				/** PURE_IMPORTS_START _observable_concat PURE_IMPORTS_END */
				function concat() {
					var observables = [];

					for (var _i = 0; _i < arguments.length; _i++) {
						observables[_i] = arguments[_i];
					}

					return function (source) {
						return source.lift.call(_concat.concat.apply(void 0, [source].concat(observables)));
					};
				}
			},
			{ '../observable/concat': '../node_modules/rxjs/_esm5/internal/observable/concat.js' }
		],
		'../node_modules/rxjs/_esm5/internal/operators/concatMap.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.concatMap = concatMap;

				var _mergeMap = require('./mergeMap');

				/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */
				function concatMap(project, resultSelector) {
					return (0, _mergeMap.mergeMap)(project, resultSelector, 1);
				}
			},
			{ './mergeMap': '../node_modules/rxjs/_esm5/internal/operators/mergeMap.js' }
		],
		'../node_modules/rxjs/_esm5/internal/operators/concatMapTo.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.concatMapTo = concatMapTo;

				var _concatMap = require('./concatMap');

				/** PURE_IMPORTS_START _concatMap PURE_IMPORTS_END */
				function concatMapTo(innerObservable, resultSelector) {
					return (0, _concatMap.concatMap)(function () {
						return innerObservable;
					}, resultSelector);
				}
			},
			{ './concatMap': '../node_modules/rxjs/_esm5/internal/operators/concatMap.js' }
		],
		'../node_modules/rxjs/_esm5/internal/operators/count.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.count = count;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				function count(predicate) {
					return function (source) {
						return source.lift(new CountOperator(predicate, source));
					};
				}

				var CountOperator =
					/*@__PURE__*/
					(function () {
						function CountOperator(predicate, source) {
							this.predicate = predicate;
							this.source = source;
						}

						CountOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
						};

						return CountOperator;
					})();

				var CountSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(CountSubscriber, _super);

						function CountSubscriber(destination, predicate, source) {
							var _this = _super.call(this, destination) || this;

							_this.predicate = predicate;
							_this.source = source;
							_this.count = 0;
							_this.index = 0;
							return _this;
						}

						CountSubscriber.prototype._next = function (value) {
							if (this.predicate) {
								this._tryPredicate(value);
							} else {
								this.count++;
							}
						};

						CountSubscriber.prototype._tryPredicate = function (value) {
							var result;

							try {
								result = this.predicate(value, this.index++, this.source);
							} catch (err) {
								this.destination.error(err);
								return;
							}

							if (result) {
								this.count++;
							}
						};

						CountSubscriber.prototype._complete = function () {
							this.destination.next(this.count);
							this.destination.complete();
						};

						return CountSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/debounce.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.debounce = debounce;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */
				function debounce(durationSelector) {
					return function (source) {
						return source.lift(new DebounceOperator(durationSelector));
					};
				}

				var DebounceOperator =
					/*@__PURE__*/
					(function () {
						function DebounceOperator(durationSelector) {
							this.durationSelector = durationSelector;
						}

						DebounceOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
						};

						return DebounceOperator;
					})();

				var DebounceSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(DebounceSubscriber, _super);

						function DebounceSubscriber(destination, durationSelector) {
							var _this = _super.call(this, destination) || this;

							_this.durationSelector = durationSelector;
							_this.hasValue = false;
							return _this;
						}

						DebounceSubscriber.prototype._next = function (value) {
							try {
								var result = this.durationSelector.call(this, value);

								if (result) {
									this._tryNext(value, result);
								}
							} catch (err) {
								this.destination.error(err);
							}
						};

						DebounceSubscriber.prototype._complete = function () {
							this.emitValue();
							this.destination.complete();
						};

						DebounceSubscriber.prototype._tryNext = function (value, duration) {
							var subscription = this.durationSubscription;
							this.value = value;
							this.hasValue = true;

							if (subscription) {
								subscription.unsubscribe();
								this.remove(subscription);
							}

							subscription = (0, _innerSubscribe.innerSubscribe)(
								duration,
								new _innerSubscribe.SimpleInnerSubscriber(this)
							);

							if (subscription && !subscription.closed) {
								this.add((this.durationSubscription = subscription));
							}
						};

						DebounceSubscriber.prototype.notifyNext = function () {
							this.emitValue();
						};

						DebounceSubscriber.prototype.notifyComplete = function () {
							this.emitValue();
						};

						DebounceSubscriber.prototype.emitValue = function () {
							if (this.hasValue) {
								var value = this.value;
								var subscription = this.durationSubscription;

								if (subscription) {
									this.durationSubscription = undefined;
									subscription.unsubscribe();
									this.remove(subscription);
								}

								this.value = undefined;
								this.hasValue = false;

								_super.prototype._next.call(this, value);
							}
						};

						return DebounceSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/debounceTime.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.debounceTime = debounceTime;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				var _async = require('../scheduler/async');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
				function debounceTime(dueTime, scheduler) {
					if (scheduler === void 0) {
						scheduler = _async.async;
					}

					return function (source) {
						return source.lift(new DebounceTimeOperator(dueTime, scheduler));
					};
				}

				var DebounceTimeOperator =
					/*@__PURE__*/
					(function () {
						function DebounceTimeOperator(dueTime, scheduler) {
							this.dueTime = dueTime;
							this.scheduler = scheduler;
						}

						DebounceTimeOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler)
							);
						};

						return DebounceTimeOperator;
					})();

				var DebounceTimeSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(DebounceTimeSubscriber, _super);

						function DebounceTimeSubscriber(destination, dueTime, scheduler) {
							var _this = _super.call(this, destination) || this;

							_this.dueTime = dueTime;
							_this.scheduler = scheduler;
							_this.debouncedSubscription = null;
							_this.lastValue = null;
							_this.hasValue = false;
							return _this;
						}

						DebounceTimeSubscriber.prototype._next = function (value) {
							this.clearDebounce();
							this.lastValue = value;
							this.hasValue = true;
							this.add(
								(this.debouncedSubscription = this.scheduler.schedule(
									dispatchNext,
									this.dueTime,
									this
								))
							);
						};

						DebounceTimeSubscriber.prototype._complete = function () {
							this.debouncedNext();
							this.destination.complete();
						};

						DebounceTimeSubscriber.prototype.debouncedNext = function () {
							this.clearDebounce();

							if (this.hasValue) {
								var lastValue = this.lastValue;
								this.lastValue = null;
								this.hasValue = false;
								this.destination.next(lastValue);
							}
						};

						DebounceTimeSubscriber.prototype.clearDebounce = function () {
							var debouncedSubscription = this.debouncedSubscription;

							if (debouncedSubscription !== null) {
								this.remove(debouncedSubscription);
								debouncedSubscription.unsubscribe();
								this.debouncedSubscription = null;
							}
						};

						return DebounceTimeSubscriber;
					})(_Subscriber.Subscriber);

				function dispatchNext(subscriber) {
					subscriber.debouncedNext();
				}
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../scheduler/async': '../node_modules/rxjs/_esm5/internal/scheduler/async.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.defaultIfEmpty = defaultIfEmpty;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				function defaultIfEmpty(defaultValue) {
					if (defaultValue === void 0) {
						defaultValue = null;
					}

					return function (source) {
						return source.lift(new DefaultIfEmptyOperator(defaultValue));
					};
				}

				var DefaultIfEmptyOperator =
					/*@__PURE__*/
					(function () {
						function DefaultIfEmptyOperator(defaultValue) {
							this.defaultValue = defaultValue;
						}

						DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
						};

						return DefaultIfEmptyOperator;
					})();

				var DefaultIfEmptySubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(DefaultIfEmptySubscriber, _super);

						function DefaultIfEmptySubscriber(destination, defaultValue) {
							var _this = _super.call(this, destination) || this;

							_this.defaultValue = defaultValue;
							_this.isEmpty = true;
							return _this;
						}

						DefaultIfEmptySubscriber.prototype._next = function (value) {
							this.isEmpty = false;
							this.destination.next(value);
						};

						DefaultIfEmptySubscriber.prototype._complete = function () {
							if (this.isEmpty) {
								this.destination.next(this.defaultValue);
							}

							this.destination.complete();
						};

						return DefaultIfEmptySubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/util/isDate.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.isDate = isDate;

				/** PURE_IMPORTS_START  PURE_IMPORTS_END */
				function isDate(value) {
					return value instanceof Date && !isNaN(+value);
				}
			},
			{}
		],
		'../node_modules/rxjs/_esm5/internal/operators/delay.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.delay = delay;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _async = require('../scheduler/async');

				var _isDate = require('../util/isDate');

				var _Subscriber = require('../Subscriber');

				var _Notification = require('../Notification');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */
				function delay(delay, scheduler) {
					if (scheduler === void 0) {
						scheduler = _async.async;
					}

					var absoluteDelay = (0, _isDate.isDate)(delay);
					var delayFor = absoluteDelay ? +delay - scheduler.now() : Math.abs(delay);
					return function (source) {
						return source.lift(new DelayOperator(delayFor, scheduler));
					};
				}

				var DelayOperator =
					/*@__PURE__*/
					(function () {
						function DelayOperator(delay, scheduler) {
							this.delay = delay;
							this.scheduler = scheduler;
						}

						DelayOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
						};

						return DelayOperator;
					})();

				var DelaySubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(DelaySubscriber, _super);

						function DelaySubscriber(destination, delay, scheduler) {
							var _this = _super.call(this, destination) || this;

							_this.delay = delay;
							_this.scheduler = scheduler;
							_this.queue = [];
							_this.active = false;
							_this.errored = false;
							return _this;
						}

						DelaySubscriber.dispatch = function (state) {
							var source = state.source;
							var queue = source.queue;
							var scheduler = state.scheduler;
							var destination = state.destination;

							while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
								queue.shift().notification.observe(destination);
							}

							if (queue.length > 0) {
								var delay_1 = Math.max(0, queue[0].time - scheduler.now());
								this.schedule(state, delay_1);
							} else {
								this.unsubscribe();
								source.active = false;
							}
						};

						DelaySubscriber.prototype._schedule = function (scheduler) {
							this.active = true;
							var destination = this.destination;
							destination.add(
								scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
									source: this,
									destination: this.destination,
									scheduler: scheduler
								})
							);
						};

						DelaySubscriber.prototype.scheduleNotification = function (notification) {
							if (this.errored === true) {
								return;
							}

							var scheduler = this.scheduler;
							var message = new DelayMessage(scheduler.now() + this.delay, notification);
							this.queue.push(message);

							if (this.active === false) {
								this._schedule(scheduler);
							}
						};

						DelaySubscriber.prototype._next = function (value) {
							this.scheduleNotification(_Notification.Notification.createNext(value));
						};

						DelaySubscriber.prototype._error = function (err) {
							this.errored = true;
							this.queue = [];
							this.destination.error(err);
							this.unsubscribe();
						};

						DelaySubscriber.prototype._complete = function () {
							this.scheduleNotification(_Notification.Notification.createComplete());
							this.unsubscribe();
						};

						return DelaySubscriber;
					})(_Subscriber.Subscriber);

				var DelayMessage =
					/*@__PURE__*/
					(function () {
						function DelayMessage(time, notification) {
							this.time = time;
							this.notification = notification;
						}

						return DelayMessage;
					})();
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../scheduler/async': '../node_modules/rxjs/_esm5/internal/scheduler/async.js',
				'../util/isDate': '../node_modules/rxjs/_esm5/internal/util/isDate.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../Notification': '../node_modules/rxjs/_esm5/internal/Notification.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/delayWhen.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.delayWhen = delayWhen;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				var _Observable = require('../Observable');

				var _OuterSubscriber = require('../OuterSubscriber');

				var _subscribeToResult = require('../util/subscribeToResult');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
				function delayWhen(delayDurationSelector, subscriptionDelay) {
					if (subscriptionDelay) {
						return function (source) {
							return new SubscriptionDelayObservable(source, subscriptionDelay).lift(
								new DelayWhenOperator(delayDurationSelector)
							);
						};
					}

					return function (source) {
						return source.lift(new DelayWhenOperator(delayDurationSelector));
					};
				}

				var DelayWhenOperator =
					/*@__PURE__*/
					(function () {
						function DelayWhenOperator(delayDurationSelector) {
							this.delayDurationSelector = delayDurationSelector;
						}

						DelayWhenOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new DelayWhenSubscriber(subscriber, this.delayDurationSelector)
							);
						};

						return DelayWhenOperator;
					})();

				var DelayWhenSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(DelayWhenSubscriber, _super);

						function DelayWhenSubscriber(destination, delayDurationSelector) {
							var _this = _super.call(this, destination) || this;

							_this.delayDurationSelector = delayDurationSelector;
							_this.completed = false;
							_this.delayNotifierSubscriptions = [];
							_this.index = 0;
							return _this;
						}

						DelayWhenSubscriber.prototype.notifyNext = function (
							outerValue,
							_innerValue,
							_outerIndex,
							_innerIndex,
							innerSub
						) {
							this.destination.next(outerValue);
							this.removeSubscription(innerSub);
							this.tryComplete();
						};

						DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
							this._error(error);
						};

						DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
							var value = this.removeSubscription(innerSub);

							if (value) {
								this.destination.next(value);
							}

							this.tryComplete();
						};

						DelayWhenSubscriber.prototype._next = function (value) {
							var index = this.index++;

							try {
								var delayNotifier = this.delayDurationSelector(value, index);

								if (delayNotifier) {
									this.tryDelay(delayNotifier, value);
								}
							} catch (err) {
								this.destination.error(err);
							}
						};

						DelayWhenSubscriber.prototype._complete = function () {
							this.completed = true;
							this.tryComplete();
							this.unsubscribe();
						};

						DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
							subscription.unsubscribe();
							var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);

							if (subscriptionIdx !== -1) {
								this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
							}

							return subscription.outerValue;
						};

						DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
							var notifierSubscription = (0, _subscribeToResult.subscribeToResult)(
								this,
								delayNotifier,
								value
							);

							if (notifierSubscription && !notifierSubscription.closed) {
								var destination = this.destination;
								destination.add(notifierSubscription);
								this.delayNotifierSubscriptions.push(notifierSubscription);
							}
						};

						DelayWhenSubscriber.prototype.tryComplete = function () {
							if (this.completed && this.delayNotifierSubscriptions.length === 0) {
								this.destination.complete();
							}
						};

						return DelayWhenSubscriber;
					})(_OuterSubscriber.OuterSubscriber);

				var SubscriptionDelayObservable =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(SubscriptionDelayObservable, _super);

						function SubscriptionDelayObservable(source, subscriptionDelay) {
							var _this = _super.call(this) || this;

							_this.source = source;
							_this.subscriptionDelay = subscriptionDelay;
							return _this;
						}

						SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
							this.subscriptionDelay.subscribe(
								new SubscriptionDelaySubscriber(subscriber, this.source)
							);
						};

						return SubscriptionDelayObservable;
					})(_Observable.Observable);

				var SubscriptionDelaySubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(SubscriptionDelaySubscriber, _super);

						function SubscriptionDelaySubscriber(parent, source) {
							var _this = _super.call(this) || this;

							_this.parent = parent;
							_this.source = source;
							_this.sourceSubscribed = false;
							return _this;
						}

						SubscriptionDelaySubscriber.prototype._next = function (unused) {
							this.subscribeToSource();
						};

						SubscriptionDelaySubscriber.prototype._error = function (err) {
							this.unsubscribe();
							this.parent.error(err);
						};

						SubscriptionDelaySubscriber.prototype._complete = function () {
							this.unsubscribe();
							this.subscribeToSource();
						};

						SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
							if (!this.sourceSubscribed) {
								this.sourceSubscribed = true;
								this.unsubscribe();
								this.source.subscribe(this.parent);
							}
						};

						return SubscriptionDelaySubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../OuterSubscriber': '../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
				'../util/subscribeToResult': '../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/dematerialize.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.dematerialize = dematerialize;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				function dematerialize() {
					return function dematerializeOperatorFunction(source) {
						return source.lift(new DeMaterializeOperator());
					};
				}

				var DeMaterializeOperator =
					/*@__PURE__*/
					(function () {
						function DeMaterializeOperator() {}

						DeMaterializeOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new DeMaterializeSubscriber(subscriber));
						};

						return DeMaterializeOperator;
					})();

				var DeMaterializeSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(DeMaterializeSubscriber, _super);

						function DeMaterializeSubscriber(destination) {
							return _super.call(this, destination) || this;
						}

						DeMaterializeSubscriber.prototype._next = function (value) {
							value.observe(this.destination);
						};

						return DeMaterializeSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/distinct.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.distinct = distinct;
				exports.DistinctSubscriber = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */
				function distinct(keySelector, flushes) {
					return function (source) {
						return source.lift(new DistinctOperator(keySelector, flushes));
					};
				}

				var DistinctOperator =
					/*@__PURE__*/
					(function () {
						function DistinctOperator(keySelector, flushes) {
							this.keySelector = keySelector;
							this.flushes = flushes;
						}

						DistinctOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new DistinctSubscriber(subscriber, this.keySelector, this.flushes)
							);
						};

						return DistinctOperator;
					})();

				var DistinctSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(DistinctSubscriber, _super);

						function DistinctSubscriber(destination, keySelector, flushes) {
							var _this = _super.call(this, destination) || this;

							_this.keySelector = keySelector;
							_this.values = new Set();

							if (flushes) {
								_this.add(
									(0, _innerSubscribe.innerSubscribe)(
										flushes,
										new _innerSubscribe.SimpleInnerSubscriber(_this)
									)
								);
							}

							return _this;
						}

						DistinctSubscriber.prototype.notifyNext = function () {
							this.values.clear();
						};

						DistinctSubscriber.prototype.notifyError = function (error) {
							this._error(error);
						};

						DistinctSubscriber.prototype._next = function (value) {
							if (this.keySelector) {
								this._useKeySelector(value);
							} else {
								this._finalizeNext(value, value);
							}
						};

						DistinctSubscriber.prototype._useKeySelector = function (value) {
							var key;
							var destination = this.destination;

							try {
								key = this.keySelector(value);
							} catch (err) {
								destination.error(err);
								return;
							}

							this._finalizeNext(key, value);
						};

						DistinctSubscriber.prototype._finalizeNext = function (key, value) {
							var values = this.values;

							if (!values.has(key)) {
								values.add(key);
								this.destination.next(value);
							}
						};

						return DistinctSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);

				exports.DistinctSubscriber = DistinctSubscriber;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.distinctUntilChanged = distinctUntilChanged;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				function distinctUntilChanged(compare, keySelector) {
					return function (source) {
						return source.lift(new DistinctUntilChangedOperator(compare, keySelector));
					};
				}

				var DistinctUntilChangedOperator =
					/*@__PURE__*/
					(function () {
						function DistinctUntilChangedOperator(compare, keySelector) {
							this.compare = compare;
							this.keySelector = keySelector;
						}

						DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector)
							);
						};

						return DistinctUntilChangedOperator;
					})();

				var DistinctUntilChangedSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(DistinctUntilChangedSubscriber, _super);

						function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
							var _this = _super.call(this, destination) || this;

							_this.keySelector = keySelector;
							_this.hasKey = false;

							if (typeof compare === 'function') {
								_this.compare = compare;
							}

							return _this;
						}

						DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
							return x === y;
						};

						DistinctUntilChangedSubscriber.prototype._next = function (value) {
							var key;

							try {
								var keySelector = this.keySelector;
								key = keySelector ? keySelector(value) : value;
							} catch (err) {
								return this.destination.error(err);
							}

							var result = false;

							if (this.hasKey) {
								try {
									var compare = this.compare;
									result = compare(this.key, key);
								} catch (err) {
									return this.destination.error(err);
								}
							} else {
								this.hasKey = true;
							}

							if (!result) {
								this.key = key;
								this.destination.next(value);
							}
						};

						return DistinctUntilChangedSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/distinctUntilKeyChanged.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.distinctUntilKeyChanged = distinctUntilKeyChanged;

				var _distinctUntilChanged = require('./distinctUntilChanged');

				/** PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END */
				function distinctUntilKeyChanged(key, compare) {
					return (0, _distinctUntilChanged.distinctUntilChanged)(function (x, y) {
						return compare ? compare(x[key], y[key]) : x[key] === y[key];
					});
				}
			},
			{
				'./distinctUntilChanged':
					'../node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.throwIfEmpty = throwIfEmpty;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _EmptyError = require('../util/EmptyError');

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_util_EmptyError,_Subscriber PURE_IMPORTS_END */
				function throwIfEmpty(errorFactory) {
					if (errorFactory === void 0) {
						errorFactory = defaultErrorFactory;
					}

					return function (source) {
						return source.lift(new ThrowIfEmptyOperator(errorFactory));
					};
				}

				var ThrowIfEmptyOperator =
					/*@__PURE__*/
					(function () {
						function ThrowIfEmptyOperator(errorFactory) {
							this.errorFactory = errorFactory;
						}

						ThrowIfEmptyOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
						};

						return ThrowIfEmptyOperator;
					})();

				var ThrowIfEmptySubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(ThrowIfEmptySubscriber, _super);

						function ThrowIfEmptySubscriber(destination, errorFactory) {
							var _this = _super.call(this, destination) || this;

							_this.errorFactory = errorFactory;
							_this.hasValue = false;
							return _this;
						}

						ThrowIfEmptySubscriber.prototype._next = function (value) {
							this.hasValue = true;
							this.destination.next(value);
						};

						ThrowIfEmptySubscriber.prototype._complete = function () {
							if (!this.hasValue) {
								var err = void 0;

								try {
									err = this.errorFactory();
								} catch (e) {
									err = e;
								}

								this.destination.error(err);
							} else {
								return this.destination.complete();
							}
						};

						return ThrowIfEmptySubscriber;
					})(_Subscriber.Subscriber);

				function defaultErrorFactory() {
					return new _EmptyError.EmptyError();
				}
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../util/EmptyError': '../node_modules/rxjs/_esm5/internal/util/EmptyError.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/take.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.take = take;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				var _ArgumentOutOfRangeError = require('../util/ArgumentOutOfRangeError');

				var _empty = require('../observable/empty');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
				function take(count) {
					return function (source) {
						if (count === 0) {
							return (0, _empty.empty)();
						} else {
							return source.lift(new TakeOperator(count));
						}
					};
				}

				var TakeOperator =
					/*@__PURE__*/
					(function () {
						function TakeOperator(total) {
							this.total = total;

							if (this.total < 0) {
								throw new _ArgumentOutOfRangeError.ArgumentOutOfRangeError();
							}
						}

						TakeOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new TakeSubscriber(subscriber, this.total));
						};

						return TakeOperator;
					})();

				var TakeSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(TakeSubscriber, _super);

						function TakeSubscriber(destination, total) {
							var _this = _super.call(this, destination) || this;

							_this.total = total;
							_this.count = 0;
							return _this;
						}

						TakeSubscriber.prototype._next = function (value) {
							var total = this.total;
							var count = ++this.count;

							if (count <= total) {
								this.destination.next(value);

								if (count === total) {
									this.destination.complete();
									this.unsubscribe();
								}
							}
						};

						return TakeSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../util/ArgumentOutOfRangeError':
					'../node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js',
				'../observable/empty': '../node_modules/rxjs/_esm5/internal/observable/empty.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/elementAt.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.elementAt = elementAt;

				var _ArgumentOutOfRangeError = require('../util/ArgumentOutOfRangeError');

				var _filter = require('./filter');

				var _throwIfEmpty = require('./throwIfEmpty');

				var _defaultIfEmpty = require('./defaultIfEmpty');

				var _take = require('./take');

				/** PURE_IMPORTS_START _util_ArgumentOutOfRangeError,_filter,_throwIfEmpty,_defaultIfEmpty,_take PURE_IMPORTS_END */
				function elementAt(index, defaultValue) {
					if (index < 0) {
						throw new _ArgumentOutOfRangeError.ArgumentOutOfRangeError();
					}

					var hasDefaultValue = arguments.length >= 2;
					return function (source) {
						return source.pipe(
							(0, _filter.filter)(function (v, i) {
								return i === index;
							}),
							(0, _take.take)(1),
							hasDefaultValue
								? (0, _defaultIfEmpty.defaultIfEmpty)(defaultValue)
								: (0, _throwIfEmpty.throwIfEmpty)(function () {
										return new _ArgumentOutOfRangeError.ArgumentOutOfRangeError();
								  })
						);
					};
				}
			},
			{
				'../util/ArgumentOutOfRangeError':
					'../node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js',
				'./filter': '../node_modules/rxjs/_esm5/internal/operators/filter.js',
				'./throwIfEmpty': '../node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js',
				'./defaultIfEmpty': '../node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js',
				'./take': '../node_modules/rxjs/_esm5/internal/operators/take.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/endWith.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.endWith = endWith;

				var _concat = require('../observable/concat');

				var _of = require('../observable/of');

				/** PURE_IMPORTS_START _observable_concat,_observable_of PURE_IMPORTS_END */
				function endWith() {
					var array = [];

					for (var _i = 0; _i < arguments.length; _i++) {
						array[_i] = arguments[_i];
					}

					return function (source) {
						return (0, _concat.concat)(source, _of.of.apply(void 0, array));
					};
				}
			},
			{
				'../observable/concat': '../node_modules/rxjs/_esm5/internal/observable/concat.js',
				'../observable/of': '../node_modules/rxjs/_esm5/internal/observable/of.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/every.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.every = every;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				function every(predicate, thisArg) {
					return function (source) {
						return source.lift(new EveryOperator(predicate, thisArg, source));
					};
				}

				var EveryOperator =
					/*@__PURE__*/
					(function () {
						function EveryOperator(predicate, thisArg, source) {
							this.predicate = predicate;
							this.thisArg = thisArg;
							this.source = source;
						}

						EveryOperator.prototype.call = function (observer, source) {
							return source.subscribe(
								new EverySubscriber(observer, this.predicate, this.thisArg, this.source)
							);
						};

						return EveryOperator;
					})();

				var EverySubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(EverySubscriber, _super);

						function EverySubscriber(destination, predicate, thisArg, source) {
							var _this = _super.call(this, destination) || this;

							_this.predicate = predicate;
							_this.thisArg = thisArg;
							_this.source = source;
							_this.index = 0;
							_this.thisArg = thisArg || _this;
							return _this;
						}

						EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
							this.destination.next(everyValueMatch);
							this.destination.complete();
						};

						EverySubscriber.prototype._next = function (value) {
							var result = false;

							try {
								result = this.predicate.call(this.thisArg, value, this.index++, this.source);
							} catch (err) {
								this.destination.error(err);
								return;
							}

							if (!result) {
								this.notifyComplete(false);
							}
						};

						EverySubscriber.prototype._complete = function () {
							this.notifyComplete(true);
						};

						return EverySubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/exhaust.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.exhaust = exhaust;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */
				function exhaust() {
					return function (source) {
						return source.lift(new SwitchFirstOperator());
					};
				}

				var SwitchFirstOperator =
					/*@__PURE__*/
					(function () {
						function SwitchFirstOperator() {}

						SwitchFirstOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new SwitchFirstSubscriber(subscriber));
						};

						return SwitchFirstOperator;
					})();

				var SwitchFirstSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(SwitchFirstSubscriber, _super);

						function SwitchFirstSubscriber(destination) {
							var _this = _super.call(this, destination) || this;

							_this.hasCompleted = false;
							_this.hasSubscription = false;
							return _this;
						}

						SwitchFirstSubscriber.prototype._next = function (value) {
							if (!this.hasSubscription) {
								this.hasSubscription = true;
								this.add(
									(0, _innerSubscribe.innerSubscribe)(
										value,
										new _innerSubscribe.SimpleInnerSubscriber(this)
									)
								);
							}
						};

						SwitchFirstSubscriber.prototype._complete = function () {
							this.hasCompleted = true;

							if (!this.hasSubscription) {
								this.destination.complete();
							}
						};

						SwitchFirstSubscriber.prototype.notifyComplete = function () {
							this.hasSubscription = false;

							if (this.hasCompleted) {
								this.destination.complete();
							}
						};

						return SwitchFirstSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/exhaustMap.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.exhaustMap = exhaustMap;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _map = require('./map');

				var _from = require('../observable/from');

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */
				function exhaustMap(project, resultSelector) {
					if (resultSelector) {
						return function (source) {
							return source.pipe(
								exhaustMap(function (a, i) {
									return (0, _from.from)(project(a, i)).pipe(
										(0, _map.map)(function (b, ii) {
											return resultSelector(a, b, i, ii);
										})
									);
								})
							);
						};
					}

					return function (source) {
						return source.lift(new ExhaustMapOperator(project));
					};
				}

				var ExhaustMapOperator =
					/*@__PURE__*/
					(function () {
						function ExhaustMapOperator(project) {
							this.project = project;
						}

						ExhaustMapOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
						};

						return ExhaustMapOperator;
					})();

				var ExhaustMapSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(ExhaustMapSubscriber, _super);

						function ExhaustMapSubscriber(destination, project) {
							var _this = _super.call(this, destination) || this;

							_this.project = project;
							_this.hasSubscription = false;
							_this.hasCompleted = false;
							_this.index = 0;
							return _this;
						}

						ExhaustMapSubscriber.prototype._next = function (value) {
							if (!this.hasSubscription) {
								this.tryNext(value);
							}
						};

						ExhaustMapSubscriber.prototype.tryNext = function (value) {
							var result;
							var index = this.index++;

							try {
								result = this.project(value, index);
							} catch (err) {
								this.destination.error(err);
								return;
							}

							this.hasSubscription = true;

							this._innerSub(result);
						};

						ExhaustMapSubscriber.prototype._innerSub = function (result) {
							var innerSubscriber = new _innerSubscribe.SimpleInnerSubscriber(this);
							var destination = this.destination;
							destination.add(innerSubscriber);
							var innerSubscription = (0, _innerSubscribe.innerSubscribe)(result, innerSubscriber);

							if (innerSubscription !== innerSubscriber) {
								destination.add(innerSubscription);
							}
						};

						ExhaustMapSubscriber.prototype._complete = function () {
							this.hasCompleted = true;

							if (!this.hasSubscription) {
								this.destination.complete();
							}

							this.unsubscribe();
						};

						ExhaustMapSubscriber.prototype.notifyNext = function (innerValue) {
							this.destination.next(innerValue);
						};

						ExhaustMapSubscriber.prototype.notifyError = function (err) {
							this.destination.error(err);
						};

						ExhaustMapSubscriber.prototype.notifyComplete = function () {
							this.hasSubscription = false;

							if (this.hasCompleted) {
								this.destination.complete();
							}
						};

						return ExhaustMapSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'./map': '../node_modules/rxjs/_esm5/internal/operators/map.js',
				'../observable/from': '../node_modules/rxjs/_esm5/internal/observable/from.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/expand.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.expand = expand;
				exports.ExpandSubscriber = exports.ExpandOperator = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */
				function expand(project, concurrent, scheduler) {
					if (concurrent === void 0) {
						concurrent = Number.POSITIVE_INFINITY;
					}

					concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
					return function (source) {
						return source.lift(new ExpandOperator(project, concurrent, scheduler));
					};
				}

				var ExpandOperator =
					/*@__PURE__*/
					(function () {
						function ExpandOperator(project, concurrent, scheduler) {
							this.project = project;
							this.concurrent = concurrent;
							this.scheduler = scheduler;
						}

						ExpandOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler)
							);
						};

						return ExpandOperator;
					})();

				exports.ExpandOperator = ExpandOperator;

				var ExpandSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(ExpandSubscriber, _super);

						function ExpandSubscriber(destination, project, concurrent, scheduler) {
							var _this = _super.call(this, destination) || this;

							_this.project = project;
							_this.concurrent = concurrent;
							_this.scheduler = scheduler;
							_this.index = 0;
							_this.active = 0;
							_this.hasCompleted = false;

							if (concurrent < Number.POSITIVE_INFINITY) {
								_this.buffer = [];
							}

							return _this;
						}

						ExpandSubscriber.dispatch = function (arg) {
							var subscriber = arg.subscriber,
								result = arg.result,
								value = arg.value,
								index = arg.index;
							subscriber.subscribeToProjection(result, value, index);
						};

						ExpandSubscriber.prototype._next = function (value) {
							var destination = this.destination;

							if (destination.closed) {
								this._complete();

								return;
							}

							var index = this.index++;

							if (this.active < this.concurrent) {
								destination.next(value);

								try {
									var project = this.project;
									var result = project(value, index);

									if (!this.scheduler) {
										this.subscribeToProjection(result, value, index);
									} else {
										var state = {
											subscriber: this,
											result: result,
											value: value,
											index: index
										};
										var destination_1 = this.destination;
										destination_1.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
									}
								} catch (e) {
									destination.error(e);
								}
							} else {
								this.buffer.push(value);
							}
						};

						ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
							this.active++;
							var destination = this.destination;
							destination.add(
								(0, _innerSubscribe.innerSubscribe)(
									result,
									new _innerSubscribe.SimpleInnerSubscriber(this)
								)
							);
						};

						ExpandSubscriber.prototype._complete = function () {
							this.hasCompleted = true;

							if (this.hasCompleted && this.active === 0) {
								this.destination.complete();
							}

							this.unsubscribe();
						};

						ExpandSubscriber.prototype.notifyNext = function (innerValue) {
							this._next(innerValue);
						};

						ExpandSubscriber.prototype.notifyComplete = function () {
							var buffer = this.buffer;
							this.active--;

							if (buffer && buffer.length > 0) {
								this._next(buffer.shift());
							}

							if (this.hasCompleted && this.active === 0) {
								this.destination.complete();
							}
						};

						return ExpandSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);

				exports.ExpandSubscriber = ExpandSubscriber;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/finalize.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.finalize = finalize;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				var _Subscription = require('../Subscription');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */
				function finalize(callback) {
					return function (source) {
						return source.lift(new FinallyOperator(callback));
					};
				}

				var FinallyOperator =
					/*@__PURE__*/
					(function () {
						function FinallyOperator(callback) {
							this.callback = callback;
						}

						FinallyOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new FinallySubscriber(subscriber, this.callback));
						};

						return FinallyOperator;
					})();

				var FinallySubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(FinallySubscriber, _super);

						function FinallySubscriber(destination, callback) {
							var _this = _super.call(this, destination) || this;

							_this.add(new _Subscription.Subscription(callback));

							return _this;
						}

						return FinallySubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../Subscription': '../node_modules/rxjs/_esm5/internal/Subscription.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/find.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.find = find;
				exports.FindValueSubscriber = exports.FindValueOperator = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				function find(predicate, thisArg) {
					if (typeof predicate !== 'function') {
						throw new TypeError('predicate is not a function');
					}

					return function (source) {
						return source.lift(new FindValueOperator(predicate, source, false, thisArg));
					};
				}

				var FindValueOperator =
					/*@__PURE__*/
					(function () {
						function FindValueOperator(predicate, source, yieldIndex, thisArg) {
							this.predicate = predicate;
							this.source = source;
							this.yieldIndex = yieldIndex;
							this.thisArg = thisArg;
						}

						FindValueOperator.prototype.call = function (observer, source) {
							return source.subscribe(
								new FindValueSubscriber(
									observer,
									this.predicate,
									this.source,
									this.yieldIndex,
									this.thisArg
								)
							);
						};

						return FindValueOperator;
					})();

				exports.FindValueOperator = FindValueOperator;

				var FindValueSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(FindValueSubscriber, _super);

						function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
							var _this = _super.call(this, destination) || this;

							_this.predicate = predicate;
							_this.source = source;
							_this.yieldIndex = yieldIndex;
							_this.thisArg = thisArg;
							_this.index = 0;
							return _this;
						}

						FindValueSubscriber.prototype.notifyComplete = function (value) {
							var destination = this.destination;
							destination.next(value);
							destination.complete();
							this.unsubscribe();
						};

						FindValueSubscriber.prototype._next = function (value) {
							var _a = this,
								predicate = _a.predicate,
								thisArg = _a.thisArg;

							var index = this.index++;

							try {
								var result = predicate.call(thisArg || this, value, index, this.source);

								if (result) {
									this.notifyComplete(this.yieldIndex ? index : value);
								}
							} catch (err) {
								this.destination.error(err);
							}
						};

						FindValueSubscriber.prototype._complete = function () {
							this.notifyComplete(this.yieldIndex ? -1 : undefined);
						};

						return FindValueSubscriber;
					})(_Subscriber.Subscriber);

				exports.FindValueSubscriber = FindValueSubscriber;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/findIndex.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.findIndex = findIndex;

				var _find = require('../operators/find');

				/** PURE_IMPORTS_START _operators_find PURE_IMPORTS_END */
				function findIndex(predicate, thisArg) {
					return function (source) {
						return source.lift(new _find.FindValueOperator(predicate, source, true, thisArg));
					};
				}
			},
			{ '../operators/find': '../node_modules/rxjs/_esm5/internal/operators/find.js' }
		],
		'../node_modules/rxjs/_esm5/internal/operators/first.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.first = first;

				var _EmptyError = require('../util/EmptyError');

				var _filter = require('./filter');

				var _take = require('./take');

				var _defaultIfEmpty = require('./defaultIfEmpty');

				var _throwIfEmpty = require('./throwIfEmpty');

				var _identity = require('../util/identity');

				/** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */
				function first(predicate, defaultValue) {
					var hasDefaultValue = arguments.length >= 2;
					return function (source) {
						return source.pipe(
							predicate
								? (0, _filter.filter)(function (v, i) {
										return predicate(v, i, source);
								  })
								: _identity.identity,
							(0, _take.take)(1),
							hasDefaultValue
								? (0, _defaultIfEmpty.defaultIfEmpty)(defaultValue)
								: (0, _throwIfEmpty.throwIfEmpty)(function () {
										return new _EmptyError.EmptyError();
								  })
						);
					};
				}
			},
			{
				'../util/EmptyError': '../node_modules/rxjs/_esm5/internal/util/EmptyError.js',
				'./filter': '../node_modules/rxjs/_esm5/internal/operators/filter.js',
				'./take': '../node_modules/rxjs/_esm5/internal/operators/take.js',
				'./defaultIfEmpty': '../node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js',
				'./throwIfEmpty': '../node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js',
				'../util/identity': '../node_modules/rxjs/_esm5/internal/util/identity.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/ignoreElements.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.ignoreElements = ignoreElements;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				function ignoreElements() {
					return function ignoreElementsOperatorFunction(source) {
						return source.lift(new IgnoreElementsOperator());
					};
				}

				var IgnoreElementsOperator =
					/*@__PURE__*/
					(function () {
						function IgnoreElementsOperator() {}

						IgnoreElementsOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new IgnoreElementsSubscriber(subscriber));
						};

						return IgnoreElementsOperator;
					})();

				var IgnoreElementsSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(IgnoreElementsSubscriber, _super);

						function IgnoreElementsSubscriber() {
							return (_super !== null && _super.apply(this, arguments)) || this;
						}

						IgnoreElementsSubscriber.prototype._next = function (unused) {};

						return IgnoreElementsSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/isEmpty.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.isEmpty = isEmpty;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				function isEmpty() {
					return function (source) {
						return source.lift(new IsEmptyOperator());
					};
				}

				var IsEmptyOperator =
					/*@__PURE__*/
					(function () {
						function IsEmptyOperator() {}

						IsEmptyOperator.prototype.call = function (observer, source) {
							return source.subscribe(new IsEmptySubscriber(observer));
						};

						return IsEmptyOperator;
					})();

				var IsEmptySubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(IsEmptySubscriber, _super);

						function IsEmptySubscriber(destination) {
							return _super.call(this, destination) || this;
						}

						IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
							var destination = this.destination;
							destination.next(isEmpty);
							destination.complete();
						};

						IsEmptySubscriber.prototype._next = function (value) {
							this.notifyComplete(false);
						};

						IsEmptySubscriber.prototype._complete = function () {
							this.notifyComplete(true);
						};

						return IsEmptySubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/takeLast.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.takeLast = takeLast;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				var _ArgumentOutOfRangeError = require('../util/ArgumentOutOfRangeError');

				var _empty = require('../observable/empty');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
				function takeLast(count) {
					return function takeLastOperatorFunction(source) {
						if (count === 0) {
							return (0, _empty.empty)();
						} else {
							return source.lift(new TakeLastOperator(count));
						}
					};
				}

				var TakeLastOperator =
					/*@__PURE__*/
					(function () {
						function TakeLastOperator(total) {
							this.total = total;

							if (this.total < 0) {
								throw new _ArgumentOutOfRangeError.ArgumentOutOfRangeError();
							}
						}

						TakeLastOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
						};

						return TakeLastOperator;
					})();

				var TakeLastSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(TakeLastSubscriber, _super);

						function TakeLastSubscriber(destination, total) {
							var _this = _super.call(this, destination) || this;

							_this.total = total;
							_this.ring = new Array();
							_this.count = 0;
							return _this;
						}

						TakeLastSubscriber.prototype._next = function (value) {
							var ring = this.ring;
							var total = this.total;
							var count = this.count++;

							if (ring.length < total) {
								ring.push(value);
							} else {
								var index = count % total;
								ring[index] = value;
							}
						};

						TakeLastSubscriber.prototype._complete = function () {
							var destination = this.destination;
							var count = this.count;

							if (count > 0) {
								var total = this.count >= this.total ? this.total : this.count;
								var ring = this.ring;

								for (var i = 0; i < total; i++) {
									var idx = count++ % total;
									destination.next(ring[idx]);
								}
							}

							destination.complete();
						};

						return TakeLastSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../util/ArgumentOutOfRangeError':
					'../node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js',
				'../observable/empty': '../node_modules/rxjs/_esm5/internal/observable/empty.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/last.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.last = last;

				var _EmptyError = require('../util/EmptyError');

				var _filter = require('./filter');

				var _takeLast = require('./takeLast');

				var _throwIfEmpty = require('./throwIfEmpty');

				var _defaultIfEmpty = require('./defaultIfEmpty');

				var _identity = require('../util/identity');

				/** PURE_IMPORTS_START _util_EmptyError,_filter,_takeLast,_throwIfEmpty,_defaultIfEmpty,_util_identity PURE_IMPORTS_END */
				function last(predicate, defaultValue) {
					var hasDefaultValue = arguments.length >= 2;
					return function (source) {
						return source.pipe(
							predicate
								? (0, _filter.filter)(function (v, i) {
										return predicate(v, i, source);
								  })
								: _identity.identity,
							(0, _takeLast.takeLast)(1),
							hasDefaultValue
								? (0, _defaultIfEmpty.defaultIfEmpty)(defaultValue)
								: (0, _throwIfEmpty.throwIfEmpty)(function () {
										return new _EmptyError.EmptyError();
								  })
						);
					};
				}
			},
			{
				'../util/EmptyError': '../node_modules/rxjs/_esm5/internal/util/EmptyError.js',
				'./filter': '../node_modules/rxjs/_esm5/internal/operators/filter.js',
				'./takeLast': '../node_modules/rxjs/_esm5/internal/operators/takeLast.js',
				'./throwIfEmpty': '../node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js',
				'./defaultIfEmpty': '../node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js',
				'../util/identity': '../node_modules/rxjs/_esm5/internal/util/identity.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/mapTo.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.mapTo = mapTo;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				function mapTo(value) {
					return function (source) {
						return source.lift(new MapToOperator(value));
					};
				}

				var MapToOperator =
					/*@__PURE__*/
					(function () {
						function MapToOperator(value) {
							this.value = value;
						}

						MapToOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new MapToSubscriber(subscriber, this.value));
						};

						return MapToOperator;
					})();

				var MapToSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(MapToSubscriber, _super);

						function MapToSubscriber(destination, value) {
							var _this = _super.call(this, destination) || this;

							_this.value = value;
							return _this;
						}

						MapToSubscriber.prototype._next = function (x) {
							this.destination.next(this.value);
						};

						return MapToSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/materialize.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.materialize = materialize;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				var _Notification = require('../Notification');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */
				function materialize() {
					return function materializeOperatorFunction(source) {
						return source.lift(new MaterializeOperator());
					};
				}

				var MaterializeOperator =
					/*@__PURE__*/
					(function () {
						function MaterializeOperator() {}

						MaterializeOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new MaterializeSubscriber(subscriber));
						};

						return MaterializeOperator;
					})();

				var MaterializeSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(MaterializeSubscriber, _super);

						function MaterializeSubscriber(destination) {
							return _super.call(this, destination) || this;
						}

						MaterializeSubscriber.prototype._next = function (value) {
							this.destination.next(_Notification.Notification.createNext(value));
						};

						MaterializeSubscriber.prototype._error = function (err) {
							var destination = this.destination;
							destination.next(_Notification.Notification.createError(err));
							destination.complete();
						};

						MaterializeSubscriber.prototype._complete = function () {
							var destination = this.destination;
							destination.next(_Notification.Notification.createComplete());
							destination.complete();
						};

						return MaterializeSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../Notification': '../node_modules/rxjs/_esm5/internal/Notification.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/scan.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.scan = scan;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				function scan(accumulator, seed) {
					var hasSeed = false;

					if (arguments.length >= 2) {
						hasSeed = true;
					}

					return function scanOperatorFunction(source) {
						return source.lift(new ScanOperator(accumulator, seed, hasSeed));
					};
				}

				var ScanOperator =
					/*@__PURE__*/
					(function () {
						function ScanOperator(accumulator, seed, hasSeed) {
							if (hasSeed === void 0) {
								hasSeed = false;
							}

							this.accumulator = accumulator;
							this.seed = seed;
							this.hasSeed = hasSeed;
						}

						ScanOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed)
							);
						};

						return ScanOperator;
					})();

				var ScanSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(ScanSubscriber, _super);

						function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
							var _this = _super.call(this, destination) || this;

							_this.accumulator = accumulator;
							_this._seed = _seed;
							_this.hasSeed = hasSeed;
							_this.index = 0;
							return _this;
						}

						Object.defineProperty(ScanSubscriber.prototype, 'seed', {
							get: function () {
								return this._seed;
							},
							set: function (value) {
								this.hasSeed = true;
								this._seed = value;
							},
							enumerable: true,
							configurable: true
						});

						ScanSubscriber.prototype._next = function (value) {
							if (!this.hasSeed) {
								this.seed = value;
								this.destination.next(value);
							} else {
								return this._tryNext(value);
							}
						};

						ScanSubscriber.prototype._tryNext = function (value) {
							var index = this.index++;
							var result;

							try {
								result = this.accumulator(this.seed, value, index);
							} catch (err) {
								this.destination.error(err);
							}

							this.seed = result;
							this.destination.next(result);
						};

						return ScanSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/reduce.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.reduce = reduce;

				var _scan = require('./scan');

				var _takeLast = require('./takeLast');

				var _defaultIfEmpty = require('./defaultIfEmpty');

				var _pipe = require('../util/pipe');

				/** PURE_IMPORTS_START _scan,_takeLast,_defaultIfEmpty,_util_pipe PURE_IMPORTS_END */
				function reduce(accumulator, seed) {
					if (arguments.length >= 2) {
						return function reduceOperatorFunctionWithSeed(source) {
							return (0, _pipe.pipe)(
								(0, _scan.scan)(accumulator, seed),
								(0, _takeLast.takeLast)(1),
								(0, _defaultIfEmpty.defaultIfEmpty)(seed)
							)(source);
						};
					}

					return function reduceOperatorFunction(source) {
						return (0, _pipe.pipe)(
							(0, _scan.scan)(function (acc, value, index) {
								return accumulator(acc, value, index + 1);
							}),
							(0, _takeLast.takeLast)(1)
						)(source);
					};
				}
			},
			{
				'./scan': '../node_modules/rxjs/_esm5/internal/operators/scan.js',
				'./takeLast': '../node_modules/rxjs/_esm5/internal/operators/takeLast.js',
				'./defaultIfEmpty': '../node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js',
				'../util/pipe': '../node_modules/rxjs/_esm5/internal/util/pipe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/max.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.max = max;

				var _reduce = require('./reduce');

				/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */
				function max(comparer) {
					var max =
						typeof comparer === 'function'
							? function (x, y) {
									return comparer(x, y) > 0 ? x : y;
							  }
							: function (x, y) {
									return x > y ? x : y;
							  };
					return (0, _reduce.reduce)(max);
				}
			},
			{ './reduce': '../node_modules/rxjs/_esm5/internal/operators/reduce.js' }
		],
		'../node_modules/rxjs/_esm5/internal/operators/merge.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.merge = merge;

				var _merge = require('../observable/merge');

				/** PURE_IMPORTS_START _observable_merge PURE_IMPORTS_END */
				function merge() {
					var observables = [];

					for (var _i = 0; _i < arguments.length; _i++) {
						observables[_i] = arguments[_i];
					}

					return function (source) {
						return source.lift.call(_merge.merge.apply(void 0, [source].concat(observables)));
					};
				}
			},
			{ '../observable/merge': '../node_modules/rxjs/_esm5/internal/observable/merge.js' }
		],
		'../node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.mergeMapTo = mergeMapTo;

				var _mergeMap = require('./mergeMap');

				/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */
				function mergeMapTo(innerObservable, resultSelector, concurrent) {
					if (concurrent === void 0) {
						concurrent = Number.POSITIVE_INFINITY;
					}

					if (typeof resultSelector === 'function') {
						return (0, _mergeMap.mergeMap)(
							function () {
								return innerObservable;
							},
							resultSelector,
							concurrent
						);
					}

					if (typeof resultSelector === 'number') {
						concurrent = resultSelector;
					}

					return (0, _mergeMap.mergeMap)(function () {
						return innerObservable;
					}, concurrent);
				}
			},
			{ './mergeMap': '../node_modules/rxjs/_esm5/internal/operators/mergeMap.js' }
		],
		'../node_modules/rxjs/_esm5/internal/operators/mergeScan.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.mergeScan = mergeScan;
				exports.MergeScanSubscriber = exports.MergeScanOperator = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */
				function mergeScan(accumulator, seed, concurrent) {
					if (concurrent === void 0) {
						concurrent = Number.POSITIVE_INFINITY;
					}

					return function (source) {
						return source.lift(new MergeScanOperator(accumulator, seed, concurrent));
					};
				}

				var MergeScanOperator =
					/*@__PURE__*/
					(function () {
						function MergeScanOperator(accumulator, seed, concurrent) {
							this.accumulator = accumulator;
							this.seed = seed;
							this.concurrent = concurrent;
						}

						MergeScanOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent)
							);
						};

						return MergeScanOperator;
					})();

				exports.MergeScanOperator = MergeScanOperator;

				var MergeScanSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(MergeScanSubscriber, _super);

						function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
							var _this = _super.call(this, destination) || this;

							_this.accumulator = accumulator;
							_this.acc = acc;
							_this.concurrent = concurrent;
							_this.hasValue = false;
							_this.hasCompleted = false;
							_this.buffer = [];
							_this.active = 0;
							_this.index = 0;
							return _this;
						}

						MergeScanSubscriber.prototype._next = function (value) {
							if (this.active < this.concurrent) {
								var index = this.index++;
								var destination = this.destination;
								var ish = void 0;

								try {
									var accumulator = this.accumulator;
									ish = accumulator(this.acc, value, index);
								} catch (e) {
									return destination.error(e);
								}

								this.active++;

								this._innerSub(ish);
							} else {
								this.buffer.push(value);
							}
						};

						MergeScanSubscriber.prototype._innerSub = function (ish) {
							var innerSubscriber = new _innerSubscribe.SimpleInnerSubscriber(this);
							var destination = this.destination;
							destination.add(innerSubscriber);
							var innerSubscription = (0, _innerSubscribe.innerSubscribe)(ish, innerSubscriber);

							if (innerSubscription !== innerSubscriber) {
								destination.add(innerSubscription);
							}
						};

						MergeScanSubscriber.prototype._complete = function () {
							this.hasCompleted = true;

							if (this.active === 0 && this.buffer.length === 0) {
								if (this.hasValue === false) {
									this.destination.next(this.acc);
								}

								this.destination.complete();
							}

							this.unsubscribe();
						};

						MergeScanSubscriber.prototype.notifyNext = function (innerValue) {
							var destination = this.destination;
							this.acc = innerValue;
							this.hasValue = true;
							destination.next(innerValue);
						};

						MergeScanSubscriber.prototype.notifyComplete = function () {
							var buffer = this.buffer;
							this.active--;

							if (buffer.length > 0) {
								this._next(buffer.shift());
							} else if (this.active === 0 && this.hasCompleted) {
								if (this.hasValue === false) {
									this.destination.next(this.acc);
								}

								this.destination.complete();
							}
						};

						return MergeScanSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);

				exports.MergeScanSubscriber = MergeScanSubscriber;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/min.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.min = min;

				var _reduce = require('./reduce');

				/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */
				function min(comparer) {
					var min =
						typeof comparer === 'function'
							? function (x, y) {
									return comparer(x, y) < 0 ? x : y;
							  }
							: function (x, y) {
									return x < y ? x : y;
							  };
					return (0, _reduce.reduce)(min);
				}
			},
			{ './reduce': '../node_modules/rxjs/_esm5/internal/operators/reduce.js' }
		],
		'../node_modules/rxjs/_esm5/internal/operators/multicast.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.multicast = multicast;
				exports.MulticastOperator = void 0;

				var _ConnectableObservable = require('../observable/ConnectableObservable');

				/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */
				function multicast(subjectOrSubjectFactory, selector) {
					return function multicastOperatorFunction(source) {
						var subjectFactory;

						if (typeof subjectOrSubjectFactory === 'function') {
							subjectFactory = subjectOrSubjectFactory;
						} else {
							subjectFactory = function subjectFactory() {
								return subjectOrSubjectFactory;
							};
						}

						if (typeof selector === 'function') {
							return source.lift(new MulticastOperator(subjectFactory, selector));
						}

						var connectable = Object.create(
							source,
							_ConnectableObservable.connectableObservableDescriptor
						);
						connectable.source = source;
						connectable.subjectFactory = subjectFactory;
						return connectable;
					};
				}

				var MulticastOperator =
					/*@__PURE__*/
					(function () {
						function MulticastOperator(subjectFactory, selector) {
							this.subjectFactory = subjectFactory;
							this.selector = selector;
						}

						MulticastOperator.prototype.call = function (subscriber, source) {
							var selector = this.selector;
							var subject = this.subjectFactory();
							var subscription = selector(subject).subscribe(subscriber);
							subscription.add(source.subscribe(subject));
							return subscription;
						};

						return MulticastOperator;
					})();

				exports.MulticastOperator = MulticastOperator;
			},
			{
				'../observable/ConnectableObservable':
					'../node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/onErrorResumeNext.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.onErrorResumeNext = onErrorResumeNext;
				exports.onErrorResumeNextStatic = onErrorResumeNextStatic;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _from = require('../observable/from');

				var _isArray = require('../util/isArray');

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_observable_from,_util_isArray,_innerSubscribe PURE_IMPORTS_END */
				function onErrorResumeNext() {
					var nextSources = [];

					for (var _i = 0; _i < arguments.length; _i++) {
						nextSources[_i] = arguments[_i];
					}

					if (nextSources.length === 1 && (0, _isArray.isArray)(nextSources[0])) {
						nextSources = nextSources[0];
					}

					return function (source) {
						return source.lift(new OnErrorResumeNextOperator(nextSources));
					};
				}

				function onErrorResumeNextStatic() {
					var nextSources = [];

					for (var _i = 0; _i < arguments.length; _i++) {
						nextSources[_i] = arguments[_i];
					}

					var source = undefined;

					if (nextSources.length === 1 && (0, _isArray.isArray)(nextSources[0])) {
						nextSources = nextSources[0];
					}

					source = nextSources.shift();
					return (0, _from.from)(source).lift(new OnErrorResumeNextOperator(nextSources));
				}

				var OnErrorResumeNextOperator =
					/*@__PURE__*/
					(function () {
						function OnErrorResumeNextOperator(nextSources) {
							this.nextSources = nextSources;
						}

						OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new OnErrorResumeNextSubscriber(subscriber, this.nextSources)
							);
						};

						return OnErrorResumeNextOperator;
					})();

				var OnErrorResumeNextSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(OnErrorResumeNextSubscriber, _super);

						function OnErrorResumeNextSubscriber(destination, nextSources) {
							var _this = _super.call(this, destination) || this;

							_this.destination = destination;
							_this.nextSources = nextSources;
							return _this;
						}

						OnErrorResumeNextSubscriber.prototype.notifyError = function () {
							this.subscribeToNextSource();
						};

						OnErrorResumeNextSubscriber.prototype.notifyComplete = function () {
							this.subscribeToNextSource();
						};

						OnErrorResumeNextSubscriber.prototype._error = function (err) {
							this.subscribeToNextSource();
							this.unsubscribe();
						};

						OnErrorResumeNextSubscriber.prototype._complete = function () {
							this.subscribeToNextSource();
							this.unsubscribe();
						};

						OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
							var next = this.nextSources.shift();

							if (!!next) {
								var innerSubscriber = new _innerSubscribe.SimpleInnerSubscriber(this);
								var destination = this.destination;
								destination.add(innerSubscriber);
								var innerSubscription = (0, _innerSubscribe.innerSubscribe)(next, innerSubscriber);

								if (innerSubscription !== innerSubscriber) {
									destination.add(innerSubscription);
								}
							} else {
								this.destination.complete();
							}
						};

						return OnErrorResumeNextSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../observable/from': '../node_modules/rxjs/_esm5/internal/observable/from.js',
				'../util/isArray': '../node_modules/rxjs/_esm5/internal/util/isArray.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/pairwise.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.pairwise = pairwise;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				function pairwise() {
					return function (source) {
						return source.lift(new PairwiseOperator());
					};
				}

				var PairwiseOperator =
					/*@__PURE__*/
					(function () {
						function PairwiseOperator() {}

						PairwiseOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new PairwiseSubscriber(subscriber));
						};

						return PairwiseOperator;
					})();

				var PairwiseSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(PairwiseSubscriber, _super);

						function PairwiseSubscriber(destination) {
							var _this = _super.call(this, destination) || this;

							_this.hasPrev = false;
							return _this;
						}

						PairwiseSubscriber.prototype._next = function (value) {
							var pair;

							if (this.hasPrev) {
								pair = [this.prev, value];
							} else {
								this.hasPrev = true;
							}

							this.prev = value;

							if (pair) {
								this.destination.next(pair);
							}
						};

						return PairwiseSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/partition.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.partition = partition;

				var _not = require('../util/not');

				var _filter = require('./filter');

				/** PURE_IMPORTS_START _util_not,_filter PURE_IMPORTS_END */
				function partition(predicate, thisArg) {
					return function (source) {
						return [
							(0, _filter.filter)(predicate, thisArg)(source),
							(0, _filter.filter)((0, _not.not)(predicate, thisArg))(source)
						];
					};
				}
			},
			{
				'../util/not': '../node_modules/rxjs/_esm5/internal/util/not.js',
				'./filter': '../node_modules/rxjs/_esm5/internal/operators/filter.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/pluck.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.pluck = pluck;

				var _map = require('./map');

				/** PURE_IMPORTS_START _map PURE_IMPORTS_END */
				function pluck() {
					var properties = [];

					for (var _i = 0; _i < arguments.length; _i++) {
						properties[_i] = arguments[_i];
					}

					var length = properties.length;

					if (length === 0) {
						throw new Error('list of properties cannot be empty.');
					}

					return function (source) {
						return (0, _map.map)(plucker(properties, length))(source);
					};
				}

				function plucker(props, length) {
					var mapper = function (x) {
						var currentProp = x;

						for (var i = 0; i < length; i++) {
							var p = currentProp != null ? currentProp[props[i]] : undefined;

							if (p !== void 0) {
								currentProp = p;
							} else {
								return undefined;
							}
						}

						return currentProp;
					};

					return mapper;
				}
			},
			{ './map': '../node_modules/rxjs/_esm5/internal/operators/map.js' }
		],
		'../node_modules/rxjs/_esm5/internal/operators/publish.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.publish = publish;

				var _Subject = require('../Subject');

				var _multicast = require('./multicast');

				/** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */
				function publish(selector) {
					return selector
						? (0, _multicast.multicast)(function () {
								return new _Subject.Subject();
						  }, selector)
						: (0, _multicast.multicast)(new _Subject.Subject());
				}
			},
			{
				'../Subject': '../node_modules/rxjs/_esm5/internal/Subject.js',
				'./multicast': '../node_modules/rxjs/_esm5/internal/operators/multicast.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/publishBehavior.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.publishBehavior = publishBehavior;

				var _BehaviorSubject = require('../BehaviorSubject');

				var _multicast = require('./multicast');

				/** PURE_IMPORTS_START _BehaviorSubject,_multicast PURE_IMPORTS_END */
				function publishBehavior(value) {
					return function (source) {
						return (0, _multicast.multicast)(new _BehaviorSubject.BehaviorSubject(value))(source);
					};
				}
			},
			{
				'../BehaviorSubject': '../node_modules/rxjs/_esm5/internal/BehaviorSubject.js',
				'./multicast': '../node_modules/rxjs/_esm5/internal/operators/multicast.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/publishLast.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.publishLast = publishLast;

				var _AsyncSubject = require('../AsyncSubject');

				var _multicast = require('./multicast');

				/** PURE_IMPORTS_START _AsyncSubject,_multicast PURE_IMPORTS_END */
				function publishLast() {
					return function (source) {
						return (0, _multicast.multicast)(new _AsyncSubject.AsyncSubject())(source);
					};
				}
			},
			{
				'../AsyncSubject': '../node_modules/rxjs/_esm5/internal/AsyncSubject.js',
				'./multicast': '../node_modules/rxjs/_esm5/internal/operators/multicast.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/publishReplay.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.publishReplay = publishReplay;

				var _ReplaySubject = require('../ReplaySubject');

				var _multicast = require('./multicast');

				/** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */
				function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
					if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {
						scheduler = selectorOrScheduler;
					}

					var selector =
						typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;
					var subject = new _ReplaySubject.ReplaySubject(bufferSize, windowTime, scheduler);
					return function (source) {
						return (0, _multicast.multicast)(function () {
							return subject;
						}, selector)(source);
					};
				}
			},
			{
				'../ReplaySubject': '../node_modules/rxjs/_esm5/internal/ReplaySubject.js',
				'./multicast': '../node_modules/rxjs/_esm5/internal/operators/multicast.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/race.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.race = race;

				var _isArray = require('../util/isArray');

				var _race = require('../observable/race');

				/** PURE_IMPORTS_START _util_isArray,_observable_race PURE_IMPORTS_END */
				function race() {
					var observables = [];

					for (var _i = 0; _i < arguments.length; _i++) {
						observables[_i] = arguments[_i];
					}

					return function raceOperatorFunction(source) {
						if (observables.length === 1 && (0, _isArray.isArray)(observables[0])) {
							observables = observables[0];
						}

						return source.lift.call(_race.race.apply(void 0, [source].concat(observables)));
					};
				}
			},
			{
				'../util/isArray': '../node_modules/rxjs/_esm5/internal/util/isArray.js',
				'../observable/race': '../node_modules/rxjs/_esm5/internal/observable/race.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/repeat.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.repeat = repeat;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				var _empty = require('../observable/empty');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber,_observable_empty PURE_IMPORTS_END */
				function repeat(count) {
					if (count === void 0) {
						count = -1;
					}

					return function (source) {
						if (count === 0) {
							return (0, _empty.empty)();
						} else if (count < 0) {
							return source.lift(new RepeatOperator(-1, source));
						} else {
							return source.lift(new RepeatOperator(count - 1, source));
						}
					};
				}

				var RepeatOperator =
					/*@__PURE__*/
					(function () {
						function RepeatOperator(count, source) {
							this.count = count;
							this.source = source;
						}

						RepeatOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
						};

						return RepeatOperator;
					})();

				var RepeatSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(RepeatSubscriber, _super);

						function RepeatSubscriber(destination, count, source) {
							var _this = _super.call(this, destination) || this;

							_this.count = count;
							_this.source = source;
							return _this;
						}

						RepeatSubscriber.prototype.complete = function () {
							if (!this.isStopped) {
								var _a = this,
									source = _a.source,
									count = _a.count;

								if (count === 0) {
									return _super.prototype.complete.call(this);
								} else if (count > -1) {
									this.count = count - 1;
								}

								source.subscribe(this._unsubscribeAndRecycle());
							}
						};

						return RepeatSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../observable/empty': '../node_modules/rxjs/_esm5/internal/observable/empty.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/repeatWhen.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.repeatWhen = repeatWhen;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subject = require('../Subject');

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subject,_innerSubscribe PURE_IMPORTS_END */
				function repeatWhen(notifier) {
					return function (source) {
						return source.lift(new RepeatWhenOperator(notifier));
					};
				}

				var RepeatWhenOperator =
					/*@__PURE__*/
					(function () {
						function RepeatWhenOperator(notifier) {
							this.notifier = notifier;
						}

						RepeatWhenOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
						};

						return RepeatWhenOperator;
					})();

				var RepeatWhenSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(RepeatWhenSubscriber, _super);

						function RepeatWhenSubscriber(destination, notifier, source) {
							var _this = _super.call(this, destination) || this;

							_this.notifier = notifier;
							_this.source = source;
							_this.sourceIsBeingSubscribedTo = true;
							return _this;
						}

						RepeatWhenSubscriber.prototype.notifyNext = function () {
							this.sourceIsBeingSubscribedTo = true;
							this.source.subscribe(this);
						};

						RepeatWhenSubscriber.prototype.notifyComplete = function () {
							if (this.sourceIsBeingSubscribedTo === false) {
								return _super.prototype.complete.call(this);
							}
						};

						RepeatWhenSubscriber.prototype.complete = function () {
							this.sourceIsBeingSubscribedTo = false;

							if (!this.isStopped) {
								if (!this.retries) {
									this.subscribeToRetries();
								}

								if (!this.retriesSubscription || this.retriesSubscription.closed) {
									return _super.prototype.complete.call(this);
								}

								this._unsubscribeAndRecycle();

								this.notifications.next(undefined);
							}
						};

						RepeatWhenSubscriber.prototype._unsubscribe = function () {
							var _a = this,
								notifications = _a.notifications,
								retriesSubscription = _a.retriesSubscription;

							if (notifications) {
								notifications.unsubscribe();
								this.notifications = undefined;
							}

							if (retriesSubscription) {
								retriesSubscription.unsubscribe();
								this.retriesSubscription = undefined;
							}

							this.retries = undefined;
						};

						RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
							var _unsubscribe = this._unsubscribe;
							this._unsubscribe = null;

							_super.prototype._unsubscribeAndRecycle.call(this);

							this._unsubscribe = _unsubscribe;
							return this;
						};

						RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
							this.notifications = new _Subject.Subject();
							var retries;

							try {
								var notifier = this.notifier;
								retries = notifier(this.notifications);
							} catch (e) {
								return _super.prototype.complete.call(this);
							}

							this.retries = retries;
							this.retriesSubscription = (0, _innerSubscribe.innerSubscribe)(
								retries,
								new _innerSubscribe.SimpleInnerSubscriber(this)
							);
						};

						return RepeatWhenSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subject': '../node_modules/rxjs/_esm5/internal/Subject.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/retry.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.retry = retry;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				function retry(count) {
					if (count === void 0) {
						count = -1;
					}

					return function (source) {
						return source.lift(new RetryOperator(count, source));
					};
				}

				var RetryOperator =
					/*@__PURE__*/
					(function () {
						function RetryOperator(count, source) {
							this.count = count;
							this.source = source;
						}

						RetryOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
						};

						return RetryOperator;
					})();

				var RetrySubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(RetrySubscriber, _super);

						function RetrySubscriber(destination, count, source) {
							var _this = _super.call(this, destination) || this;

							_this.count = count;
							_this.source = source;
							return _this;
						}

						RetrySubscriber.prototype.error = function (err) {
							if (!this.isStopped) {
								var _a = this,
									source = _a.source,
									count = _a.count;

								if (count === 0) {
									return _super.prototype.error.call(this, err);
								} else if (count > -1) {
									this.count = count - 1;
								}

								source.subscribe(this._unsubscribeAndRecycle());
							}
						};

						return RetrySubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/retryWhen.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.retryWhen = retryWhen;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subject = require('../Subject');

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subject,_innerSubscribe PURE_IMPORTS_END */
				function retryWhen(notifier) {
					return function (source) {
						return source.lift(new RetryWhenOperator(notifier, source));
					};
				}

				var RetryWhenOperator =
					/*@__PURE__*/
					(function () {
						function RetryWhenOperator(notifier, source) {
							this.notifier = notifier;
							this.source = source;
						}

						RetryWhenOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new RetryWhenSubscriber(subscriber, this.notifier, this.source)
							);
						};

						return RetryWhenOperator;
					})();

				var RetryWhenSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(RetryWhenSubscriber, _super);

						function RetryWhenSubscriber(destination, notifier, source) {
							var _this = _super.call(this, destination) || this;

							_this.notifier = notifier;
							_this.source = source;
							return _this;
						}

						RetryWhenSubscriber.prototype.error = function (err) {
							if (!this.isStopped) {
								var errors = this.errors;
								var retries = this.retries;
								var retriesSubscription = this.retriesSubscription;

								if (!retries) {
									errors = new _Subject.Subject();

									try {
										var notifier = this.notifier;
										retries = notifier(errors);
									} catch (e) {
										return _super.prototype.error.call(this, e);
									}

									retriesSubscription = (0, _innerSubscribe.innerSubscribe)(
										retries,
										new _innerSubscribe.SimpleInnerSubscriber(this)
									);
								} else {
									this.errors = undefined;
									this.retriesSubscription = undefined;
								}

								this._unsubscribeAndRecycle();

								this.errors = errors;
								this.retries = retries;
								this.retriesSubscription = retriesSubscription;
								errors.next(err);
							}
						};

						RetryWhenSubscriber.prototype._unsubscribe = function () {
							var _a = this,
								errors = _a.errors,
								retriesSubscription = _a.retriesSubscription;

							if (errors) {
								errors.unsubscribe();
								this.errors = undefined;
							}

							if (retriesSubscription) {
								retriesSubscription.unsubscribe();
								this.retriesSubscription = undefined;
							}

							this.retries = undefined;
						};

						RetryWhenSubscriber.prototype.notifyNext = function () {
							var _unsubscribe = this._unsubscribe;
							this._unsubscribe = null;

							this._unsubscribeAndRecycle();

							this._unsubscribe = _unsubscribe;
							this.source.subscribe(this);
						};

						return RetryWhenSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subject': '../node_modules/rxjs/_esm5/internal/Subject.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/sample.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.sample = sample;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */
				function sample(notifier) {
					return function (source) {
						return source.lift(new SampleOperator(notifier));
					};
				}

				var SampleOperator =
					/*@__PURE__*/
					(function () {
						function SampleOperator(notifier) {
							this.notifier = notifier;
						}

						SampleOperator.prototype.call = function (subscriber, source) {
							var sampleSubscriber = new SampleSubscriber(subscriber);
							var subscription = source.subscribe(sampleSubscriber);
							subscription.add(
								(0, _innerSubscribe.innerSubscribe)(
									this.notifier,
									new _innerSubscribe.SimpleInnerSubscriber(sampleSubscriber)
								)
							);
							return subscription;
						};

						return SampleOperator;
					})();

				var SampleSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(SampleSubscriber, _super);

						function SampleSubscriber() {
							var _this = (_super !== null && _super.apply(this, arguments)) || this;

							_this.hasValue = false;
							return _this;
						}

						SampleSubscriber.prototype._next = function (value) {
							this.value = value;
							this.hasValue = true;
						};

						SampleSubscriber.prototype.notifyNext = function () {
							this.emitValue();
						};

						SampleSubscriber.prototype.notifyComplete = function () {
							this.emitValue();
						};

						SampleSubscriber.prototype.emitValue = function () {
							if (this.hasValue) {
								this.hasValue = false;
								this.destination.next(this.value);
							}
						};

						return SampleSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/sampleTime.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.sampleTime = sampleTime;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				var _async = require('../scheduler/async');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
				function sampleTime(period, scheduler) {
					if (scheduler === void 0) {
						scheduler = _async.async;
					}

					return function (source) {
						return source.lift(new SampleTimeOperator(period, scheduler));
					};
				}

				var SampleTimeOperator =
					/*@__PURE__*/
					(function () {
						function SampleTimeOperator(period, scheduler) {
							this.period = period;
							this.scheduler = scheduler;
						}

						SampleTimeOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new SampleTimeSubscriber(subscriber, this.period, this.scheduler)
							);
						};

						return SampleTimeOperator;
					})();

				var SampleTimeSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(SampleTimeSubscriber, _super);

						function SampleTimeSubscriber(destination, period, scheduler) {
							var _this = _super.call(this, destination) || this;

							_this.period = period;
							_this.scheduler = scheduler;
							_this.hasValue = false;

							_this.add(
								scheduler.schedule(dispatchNotification, period, {
									subscriber: _this,
									period: period
								})
							);

							return _this;
						}

						SampleTimeSubscriber.prototype._next = function (value) {
							this.lastValue = value;
							this.hasValue = true;
						};

						SampleTimeSubscriber.prototype.notifyNext = function () {
							if (this.hasValue) {
								this.hasValue = false;
								this.destination.next(this.lastValue);
							}
						};

						return SampleTimeSubscriber;
					})(_Subscriber.Subscriber);

				function dispatchNotification(state) {
					var subscriber = state.subscriber,
						period = state.period;
					subscriber.notifyNext();
					this.schedule(state, period);
				}
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../scheduler/async': '../node_modules/rxjs/_esm5/internal/scheduler/async.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/sequenceEqual.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.sequenceEqual = sequenceEqual;
				exports.SequenceEqualSubscriber = exports.SequenceEqualOperator = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				function sequenceEqual(compareTo, comparator) {
					return function (source) {
						return source.lift(new SequenceEqualOperator(compareTo, comparator));
					};
				}

				var SequenceEqualOperator =
					/*@__PURE__*/
					(function () {
						function SequenceEqualOperator(compareTo, comparator) {
							this.compareTo = compareTo;
							this.comparator = comparator;
						}

						SequenceEqualOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator)
							);
						};

						return SequenceEqualOperator;
					})();

				exports.SequenceEqualOperator = SequenceEqualOperator;

				var SequenceEqualSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(SequenceEqualSubscriber, _super);

						function SequenceEqualSubscriber(destination, compareTo, comparator) {
							var _this = _super.call(this, destination) || this;

							_this.compareTo = compareTo;
							_this.comparator = comparator;
							_this._a = [];
							_this._b = [];
							_this._oneComplete = false;

							_this.destination.add(
								compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this))
							);

							return _this;
						}

						SequenceEqualSubscriber.prototype._next = function (value) {
							if (this._oneComplete && this._b.length === 0) {
								this.emit(false);
							} else {
								this._a.push(value);

								this.checkValues();
							}
						};

						SequenceEqualSubscriber.prototype._complete = function () {
							if (this._oneComplete) {
								this.emit(this._a.length === 0 && this._b.length === 0);
							} else {
								this._oneComplete = true;
							}

							this.unsubscribe();
						};

						SequenceEqualSubscriber.prototype.checkValues = function () {
							var _c = this,
								_a = _c._a,
								_b = _c._b,
								comparator = _c.comparator;

							while (_a.length > 0 && _b.length > 0) {
								var a = _a.shift();

								var b = _b.shift();

								var areEqual = false;

								try {
									areEqual = comparator ? comparator(a, b) : a === b;
								} catch (e) {
									this.destination.error(e);
								}

								if (!areEqual) {
									this.emit(false);
								}
							}
						};

						SequenceEqualSubscriber.prototype.emit = function (value) {
							var destination = this.destination;
							destination.next(value);
							destination.complete();
						};

						SequenceEqualSubscriber.prototype.nextB = function (value) {
							if (this._oneComplete && this._a.length === 0) {
								this.emit(false);
							} else {
								this._b.push(value);

								this.checkValues();
							}
						};

						SequenceEqualSubscriber.prototype.completeB = function () {
							if (this._oneComplete) {
								this.emit(this._a.length === 0 && this._b.length === 0);
							} else {
								this._oneComplete = true;
							}
						};

						return SequenceEqualSubscriber;
					})(_Subscriber.Subscriber);

				exports.SequenceEqualSubscriber = SequenceEqualSubscriber;

				var SequenceEqualCompareToSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(SequenceEqualCompareToSubscriber, _super);

						function SequenceEqualCompareToSubscriber(destination, parent) {
							var _this = _super.call(this, destination) || this;

							_this.parent = parent;
							return _this;
						}

						SequenceEqualCompareToSubscriber.prototype._next = function (value) {
							this.parent.nextB(value);
						};

						SequenceEqualCompareToSubscriber.prototype._error = function (err) {
							this.parent.error(err);
							this.unsubscribe();
						};

						SequenceEqualCompareToSubscriber.prototype._complete = function () {
							this.parent.completeB();
							this.unsubscribe();
						};

						return SequenceEqualCompareToSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/share.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.share = share;

				var _multicast = require('./multicast');

				var _refCount = require('./refCount');

				var _Subject = require('../Subject');

				/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */
				function shareSubjectFactory() {
					return new _Subject.Subject();
				}

				function share() {
					return function (source) {
						return (0, _refCount.refCount)()(
							(0, _multicast.multicast)(shareSubjectFactory)(source)
						);
					};
				}
			},
			{
				'./multicast': '../node_modules/rxjs/_esm5/internal/operators/multicast.js',
				'./refCount': '../node_modules/rxjs/_esm5/internal/operators/refCount.js',
				'../Subject': '../node_modules/rxjs/_esm5/internal/Subject.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/shareReplay.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.shareReplay = shareReplay;

				var _ReplaySubject = require('../ReplaySubject');

				/** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */
				function shareReplay(configOrBufferSize, windowTime, scheduler) {
					var config;

					if (configOrBufferSize && typeof configOrBufferSize === 'object') {
						config = configOrBufferSize;
					} else {
						config = {
							bufferSize: configOrBufferSize,
							windowTime: windowTime,
							refCount: false,
							scheduler: scheduler
						};
					}

					return function (source) {
						return source.lift(shareReplayOperator(config));
					};
				}

				function shareReplayOperator(_a) {
					var _b = _a.bufferSize,
						bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b,
						_c = _a.windowTime,
						windowTime = _c === void 0 ? Number.POSITIVE_INFINITY : _c,
						useRefCount = _a.refCount,
						scheduler = _a.scheduler;
					var subject;
					var refCount = 0;
					var subscription;
					var hasError = false;
					var isComplete = false;
					return function shareReplayOperation(source) {
						refCount++;
						var innerSub;

						if (!subject || hasError) {
							hasError = false;
							subject = new _ReplaySubject.ReplaySubject(bufferSize, windowTime, scheduler);
							innerSub = subject.subscribe(this);
							subscription = source.subscribe({
								next: function (value) {
									subject.next(value);
								},
								error: function (err) {
									hasError = true;
									subject.error(err);
								},
								complete: function () {
									isComplete = true;
									subscription = undefined;
									subject.complete();
								}
							});

							if (isComplete) {
								subscription = undefined;
							}
						} else {
							innerSub = subject.subscribe(this);
						}

						this.add(function () {
							refCount--;
							innerSub.unsubscribe();
							innerSub = undefined;

							if (subscription && !isComplete && useRefCount && refCount === 0) {
								subscription.unsubscribe();
								subscription = undefined;
								subject = undefined;
							}
						});
					};
				}
			},
			{ '../ReplaySubject': '../node_modules/rxjs/_esm5/internal/ReplaySubject.js' }
		],
		'../node_modules/rxjs/_esm5/internal/operators/single.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.single = single;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				var _EmptyError = require('../util/EmptyError');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber,_util_EmptyError PURE_IMPORTS_END */
				function single(predicate) {
					return function (source) {
						return source.lift(new SingleOperator(predicate, source));
					};
				}

				var SingleOperator =
					/*@__PURE__*/
					(function () {
						function SingleOperator(predicate, source) {
							this.predicate = predicate;
							this.source = source;
						}

						SingleOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new SingleSubscriber(subscriber, this.predicate, this.source)
							);
						};

						return SingleOperator;
					})();

				var SingleSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(SingleSubscriber, _super);

						function SingleSubscriber(destination, predicate, source) {
							var _this = _super.call(this, destination) || this;

							_this.predicate = predicate;
							_this.source = source;
							_this.seenValue = false;
							_this.index = 0;
							return _this;
						}

						SingleSubscriber.prototype.applySingleValue = function (value) {
							if (this.seenValue) {
								this.destination.error('Sequence contains more than one element');
							} else {
								this.seenValue = true;
								this.singleValue = value;
							}
						};

						SingleSubscriber.prototype._next = function (value) {
							var index = this.index++;

							if (this.predicate) {
								this.tryNext(value, index);
							} else {
								this.applySingleValue(value);
							}
						};

						SingleSubscriber.prototype.tryNext = function (value, index) {
							try {
								if (this.predicate(value, index, this.source)) {
									this.applySingleValue(value);
								}
							} catch (err) {
								this.destination.error(err);
							}
						};

						SingleSubscriber.prototype._complete = function () {
							var destination = this.destination;

							if (this.index > 0) {
								destination.next(this.seenValue ? this.singleValue : undefined);
								destination.complete();
							} else {
								destination.error(new _EmptyError.EmptyError());
							}
						};

						return SingleSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../util/EmptyError': '../node_modules/rxjs/_esm5/internal/util/EmptyError.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/skip.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.skip = skip;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				function skip(count) {
					return function (source) {
						return source.lift(new SkipOperator(count));
					};
				}

				var SkipOperator =
					/*@__PURE__*/
					(function () {
						function SkipOperator(total) {
							this.total = total;
						}

						SkipOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new SkipSubscriber(subscriber, this.total));
						};

						return SkipOperator;
					})();

				var SkipSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(SkipSubscriber, _super);

						function SkipSubscriber(destination, total) {
							var _this = _super.call(this, destination) || this;

							_this.total = total;
							_this.count = 0;
							return _this;
						}

						SkipSubscriber.prototype._next = function (x) {
							if (++this.count > this.total) {
								this.destination.next(x);
							}
						};

						return SkipSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/skipLast.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.skipLast = skipLast;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				var _ArgumentOutOfRangeError = require('../util/ArgumentOutOfRangeError');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError PURE_IMPORTS_END */
				function skipLast(count) {
					return function (source) {
						return source.lift(new SkipLastOperator(count));
					};
				}

				var SkipLastOperator =
					/*@__PURE__*/
					(function () {
						function SkipLastOperator(_skipCount) {
							this._skipCount = _skipCount;

							if (this._skipCount < 0) {
								throw new _ArgumentOutOfRangeError.ArgumentOutOfRangeError();
							}
						}

						SkipLastOperator.prototype.call = function (subscriber, source) {
							if (this._skipCount === 0) {
								return source.subscribe(new _Subscriber.Subscriber(subscriber));
							} else {
								return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
							}
						};

						return SkipLastOperator;
					})();

				var SkipLastSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(SkipLastSubscriber, _super);

						function SkipLastSubscriber(destination, _skipCount) {
							var _this = _super.call(this, destination) || this;

							_this._skipCount = _skipCount;
							_this._count = 0;
							_this._ring = new Array(_skipCount);
							return _this;
						}

						SkipLastSubscriber.prototype._next = function (value) {
							var skipCount = this._skipCount;
							var count = this._count++;

							if (count < skipCount) {
								this._ring[count] = value;
							} else {
								var currentIndex = count % skipCount;
								var ring = this._ring;
								var oldValue = ring[currentIndex];
								ring[currentIndex] = value;
								this.destination.next(oldValue);
							}
						};

						return SkipLastSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../util/ArgumentOutOfRangeError':
					'../node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/skipUntil.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.skipUntil = skipUntil;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */
				function skipUntil(notifier) {
					return function (source) {
						return source.lift(new SkipUntilOperator(notifier));
					};
				}

				var SkipUntilOperator =
					/*@__PURE__*/
					(function () {
						function SkipUntilOperator(notifier) {
							this.notifier = notifier;
						}

						SkipUntilOperator.prototype.call = function (destination, source) {
							return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
						};

						return SkipUntilOperator;
					})();

				var SkipUntilSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(SkipUntilSubscriber, _super);

						function SkipUntilSubscriber(destination, notifier) {
							var _this = _super.call(this, destination) || this;

							_this.hasValue = false;
							var innerSubscriber = new _innerSubscribe.SimpleInnerSubscriber(_this);

							_this.add(innerSubscriber);

							_this.innerSubscription = innerSubscriber;
							var innerSubscription = (0, _innerSubscribe.innerSubscribe)(
								notifier,
								innerSubscriber
							);

							if (innerSubscription !== innerSubscriber) {
								_this.add(innerSubscription);

								_this.innerSubscription = innerSubscription;
							}

							return _this;
						}

						SkipUntilSubscriber.prototype._next = function (value) {
							if (this.hasValue) {
								_super.prototype._next.call(this, value);
							}
						};

						SkipUntilSubscriber.prototype.notifyNext = function () {
							this.hasValue = true;

							if (this.innerSubscription) {
								this.innerSubscription.unsubscribe();
							}
						};

						SkipUntilSubscriber.prototype.notifyComplete = function () {};

						return SkipUntilSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/skipWhile.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.skipWhile = skipWhile;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				function skipWhile(predicate) {
					return function (source) {
						return source.lift(new SkipWhileOperator(predicate));
					};
				}

				var SkipWhileOperator =
					/*@__PURE__*/
					(function () {
						function SkipWhileOperator(predicate) {
							this.predicate = predicate;
						}

						SkipWhileOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
						};

						return SkipWhileOperator;
					})();

				var SkipWhileSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(SkipWhileSubscriber, _super);

						function SkipWhileSubscriber(destination, predicate) {
							var _this = _super.call(this, destination) || this;

							_this.predicate = predicate;
							_this.skipping = true;
							_this.index = 0;
							return _this;
						}

						SkipWhileSubscriber.prototype._next = function (value) {
							var destination = this.destination;

							if (this.skipping) {
								this.tryCallPredicate(value);
							}

							if (!this.skipping) {
								destination.next(value);
							}
						};

						SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
							try {
								var result = this.predicate(value, this.index++);
								this.skipping = Boolean(result);
							} catch (err) {
								this.destination.error(err);
							}
						};

						return SkipWhileSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/startWith.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.startWith = startWith;

				var _concat = require('../observable/concat');

				var _isScheduler = require('../util/isScheduler');

				/** PURE_IMPORTS_START _observable_concat,_util_isScheduler PURE_IMPORTS_END */
				function startWith() {
					var array = [];

					for (var _i = 0; _i < arguments.length; _i++) {
						array[_i] = arguments[_i];
					}

					var scheduler = array[array.length - 1];

					if ((0, _isScheduler.isScheduler)(scheduler)) {
						array.pop();
						return function (source) {
							return (0, _concat.concat)(array, source, scheduler);
						};
					} else {
						return function (source) {
							return (0, _concat.concat)(array, source);
						};
					}
				}
			},
			{
				'../observable/concat': '../node_modules/rxjs/_esm5/internal/observable/concat.js',
				'../util/isScheduler': '../node_modules/rxjs/_esm5/internal/util/isScheduler.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.SubscribeOnObservable = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Observable = require('../Observable');

				var _asap = require('../scheduler/asap');

				var _isNumeric = require('../util/isNumeric');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */
				var SubscribeOnObservable =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(SubscribeOnObservable, _super);

						function SubscribeOnObservable(source, delayTime, scheduler) {
							if (delayTime === void 0) {
								delayTime = 0;
							}

							if (scheduler === void 0) {
								scheduler = _asap.asap;
							}

							var _this = _super.call(this) || this;

							_this.source = source;
							_this.delayTime = delayTime;
							_this.scheduler = scheduler;

							if (!(0, _isNumeric.isNumeric)(delayTime) || delayTime < 0) {
								_this.delayTime = 0;
							}

							if (!scheduler || typeof scheduler.schedule !== 'function') {
								_this.scheduler = _asap.asap;
							}

							return _this;
						}

						SubscribeOnObservable.create = function (source, delay, scheduler) {
							if (delay === void 0) {
								delay = 0;
							}

							if (scheduler === void 0) {
								scheduler = _asap.asap;
							}

							return new SubscribeOnObservable(source, delay, scheduler);
						};

						SubscribeOnObservable.dispatch = function (arg) {
							var source = arg.source,
								subscriber = arg.subscriber;
							return this.add(source.subscribe(subscriber));
						};

						SubscribeOnObservable.prototype._subscribe = function (subscriber) {
							var delay = this.delayTime;
							var source = this.source;
							var scheduler = this.scheduler;
							return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
								source: source,
								subscriber: subscriber
							});
						};

						return SubscribeOnObservable;
					})(_Observable.Observable);

				exports.SubscribeOnObservable = SubscribeOnObservable;
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Observable': '../node_modules/rxjs/_esm5/internal/Observable.js',
				'../scheduler/asap': '../node_modules/rxjs/_esm5/internal/scheduler/asap.js',
				'../util/isNumeric': '../node_modules/rxjs/_esm5/internal/util/isNumeric.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/subscribeOn.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.subscribeOn = subscribeOn;

				var _SubscribeOnObservable = require('../observable/SubscribeOnObservable');

				/** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */
				function subscribeOn(scheduler, delay) {
					if (delay === void 0) {
						delay = 0;
					}

					return function subscribeOnOperatorFunction(source) {
						return source.lift(new SubscribeOnOperator(scheduler, delay));
					};
				}

				var SubscribeOnOperator =
					/*@__PURE__*/
					(function () {
						function SubscribeOnOperator(scheduler, delay) {
							this.scheduler = scheduler;
							this.delay = delay;
						}

						SubscribeOnOperator.prototype.call = function (subscriber, source) {
							return new _SubscribeOnObservable.SubscribeOnObservable(
								source,
								this.delay,
								this.scheduler
							).subscribe(subscriber);
						};

						return SubscribeOnOperator;
					})();
			},
			{
				'../observable/SubscribeOnObservable':
					'../node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/switchMap.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.switchMap = switchMap;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _map = require('./map');

				var _from = require('../observable/from');

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */
				function switchMap(project, resultSelector) {
					if (typeof resultSelector === 'function') {
						return function (source) {
							return source.pipe(
								switchMap(function (a, i) {
									return (0, _from.from)(project(a, i)).pipe(
										(0, _map.map)(function (b, ii) {
											return resultSelector(a, b, i, ii);
										})
									);
								})
							);
						};
					}

					return function (source) {
						return source.lift(new SwitchMapOperator(project));
					};
				}

				var SwitchMapOperator =
					/*@__PURE__*/
					(function () {
						function SwitchMapOperator(project) {
							this.project = project;
						}

						SwitchMapOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
						};

						return SwitchMapOperator;
					})();

				var SwitchMapSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(SwitchMapSubscriber, _super);

						function SwitchMapSubscriber(destination, project) {
							var _this = _super.call(this, destination) || this;

							_this.project = project;
							_this.index = 0;
							return _this;
						}

						SwitchMapSubscriber.prototype._next = function (value) {
							var result;
							var index = this.index++;

							try {
								result = this.project(value, index);
							} catch (error) {
								this.destination.error(error);
								return;
							}

							this._innerSub(result);
						};

						SwitchMapSubscriber.prototype._innerSub = function (result) {
							var innerSubscription = this.innerSubscription;

							if (innerSubscription) {
								innerSubscription.unsubscribe();
							}

							var innerSubscriber = new _innerSubscribe.SimpleInnerSubscriber(this);
							var destination = this.destination;
							destination.add(innerSubscriber);
							this.innerSubscription = (0, _innerSubscribe.innerSubscribe)(result, innerSubscriber);

							if (this.innerSubscription !== innerSubscriber) {
								destination.add(this.innerSubscription);
							}
						};

						SwitchMapSubscriber.prototype._complete = function () {
							var innerSubscription = this.innerSubscription;

							if (!innerSubscription || innerSubscription.closed) {
								_super.prototype._complete.call(this);
							}

							this.unsubscribe();
						};

						SwitchMapSubscriber.prototype._unsubscribe = function () {
							this.innerSubscription = undefined;
						};

						SwitchMapSubscriber.prototype.notifyComplete = function () {
							this.innerSubscription = undefined;

							if (this.isStopped) {
								_super.prototype._complete.call(this);
							}
						};

						SwitchMapSubscriber.prototype.notifyNext = function (innerValue) {
							this.destination.next(innerValue);
						};

						return SwitchMapSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'./map': '../node_modules/rxjs/_esm5/internal/operators/map.js',
				'../observable/from': '../node_modules/rxjs/_esm5/internal/observable/from.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/switchAll.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.switchAll = switchAll;

				var _switchMap = require('./switchMap');

				var _identity = require('../util/identity');

				/** PURE_IMPORTS_START _switchMap,_util_identity PURE_IMPORTS_END */
				function switchAll() {
					return (0, _switchMap.switchMap)(_identity.identity);
				}
			},
			{
				'./switchMap': '../node_modules/rxjs/_esm5/internal/operators/switchMap.js',
				'../util/identity': '../node_modules/rxjs/_esm5/internal/util/identity.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/switchMapTo.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.switchMapTo = switchMapTo;

				var _switchMap = require('./switchMap');

				/** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */
				function switchMapTo(innerObservable, resultSelector) {
					return resultSelector
						? (0, _switchMap.switchMap)(function () {
								return innerObservable;
						  }, resultSelector)
						: (0, _switchMap.switchMap)(function () {
								return innerObservable;
						  });
				}
			},
			{ './switchMap': '../node_modules/rxjs/_esm5/internal/operators/switchMap.js' }
		],
		'../node_modules/rxjs/_esm5/internal/operators/takeUntil.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.takeUntil = takeUntil;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */
				function takeUntil(notifier) {
					return function (source) {
						return source.lift(new TakeUntilOperator(notifier));
					};
				}

				var TakeUntilOperator =
					/*@__PURE__*/
					(function () {
						function TakeUntilOperator(notifier) {
							this.notifier = notifier;
						}

						TakeUntilOperator.prototype.call = function (subscriber, source) {
							var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
							var notifierSubscription = (0, _innerSubscribe.innerSubscribe)(
								this.notifier,
								new _innerSubscribe.SimpleInnerSubscriber(takeUntilSubscriber)
							);

							if (notifierSubscription && !takeUntilSubscriber.seenValue) {
								takeUntilSubscriber.add(notifierSubscription);
								return source.subscribe(takeUntilSubscriber);
							}

							return takeUntilSubscriber;
						};

						return TakeUntilOperator;
					})();

				var TakeUntilSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(TakeUntilSubscriber, _super);

						function TakeUntilSubscriber(destination) {
							var _this = _super.call(this, destination) || this;

							_this.seenValue = false;
							return _this;
						}

						TakeUntilSubscriber.prototype.notifyNext = function () {
							this.seenValue = true;
							this.complete();
						};

						TakeUntilSubscriber.prototype.notifyComplete = function () {};

						return TakeUntilSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/takeWhile.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.takeWhile = takeWhile;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
				function takeWhile(predicate, inclusive) {
					if (inclusive === void 0) {
						inclusive = false;
					}

					return function (source) {
						return source.lift(new TakeWhileOperator(predicate, inclusive));
					};
				}

				var TakeWhileOperator =
					/*@__PURE__*/
					(function () {
						function TakeWhileOperator(predicate, inclusive) {
							this.predicate = predicate;
							this.inclusive = inclusive;
						}

						TakeWhileOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive)
							);
						};

						return TakeWhileOperator;
					})();

				var TakeWhileSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(TakeWhileSubscriber, _super);

						function TakeWhileSubscriber(destination, predicate, inclusive) {
							var _this = _super.call(this, destination) || this;

							_this.predicate = predicate;
							_this.inclusive = inclusive;
							_this.index = 0;
							return _this;
						}

						TakeWhileSubscriber.prototype._next = function (value) {
							var destination = this.destination;
							var result;

							try {
								result = this.predicate(value, this.index++);
							} catch (err) {
								destination.error(err);
								return;
							}

							this.nextOrComplete(value, result);
						};

						TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
							var destination = this.destination;

							if (Boolean(predicateResult)) {
								destination.next(value);
							} else {
								if (this.inclusive) {
									destination.next(value);
								}

								destination.complete();
							}
						};

						return TakeWhileSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/tap.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.tap = tap;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				var _noop = require('../util/noop');

				var _isFunction = require('../util/isFunction');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */
				function tap(nextOrObserver, error, complete) {
					return function tapOperatorFunction(source) {
						return source.lift(new DoOperator(nextOrObserver, error, complete));
					};
				}

				var DoOperator =
					/*@__PURE__*/
					(function () {
						function DoOperator(nextOrObserver, error, complete) {
							this.nextOrObserver = nextOrObserver;
							this.error = error;
							this.complete = complete;
						}

						DoOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete)
							);
						};

						return DoOperator;
					})();

				var TapSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(TapSubscriber, _super);

						function TapSubscriber(destination, observerOrNext, error, complete) {
							var _this = _super.call(this, destination) || this;

							_this._tapNext = _noop.noop;
							_this._tapError = _noop.noop;
							_this._tapComplete = _noop.noop;
							_this._tapError = error || _noop.noop;
							_this._tapComplete = complete || _noop.noop;

							if ((0, _isFunction.isFunction)(observerOrNext)) {
								_this._context = _this;
								_this._tapNext = observerOrNext;
							} else if (observerOrNext) {
								_this._context = observerOrNext;
								_this._tapNext = observerOrNext.next || _noop.noop;
								_this._tapError = observerOrNext.error || _noop.noop;
								_this._tapComplete = observerOrNext.complete || _noop.noop;
							}

							return _this;
						}

						TapSubscriber.prototype._next = function (value) {
							try {
								this._tapNext.call(this._context, value);
							} catch (err) {
								this.destination.error(err);
								return;
							}

							this.destination.next(value);
						};

						TapSubscriber.prototype._error = function (err) {
							try {
								this._tapError.call(this._context, err);
							} catch (err) {
								this.destination.error(err);
								return;
							}

							this.destination.error(err);
						};

						TapSubscriber.prototype._complete = function () {
							try {
								this._tapComplete.call(this._context);
							} catch (err) {
								this.destination.error(err);
								return;
							}

							return this.destination.complete();
						};

						return TapSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../util/noop': '../node_modules/rxjs/_esm5/internal/util/noop.js',
				'../util/isFunction': '../node_modules/rxjs/_esm5/internal/util/isFunction.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/throttle.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.throttle = throttle;
				exports.defaultThrottleConfig = void 0;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */
				var defaultThrottleConfig = {
					leading: true,
					trailing: false
				};
				exports.defaultThrottleConfig = defaultThrottleConfig;

				function throttle(durationSelector, config) {
					if (config === void 0) {
						config = defaultThrottleConfig;
					}

					return function (source) {
						return source.lift(
							new ThrottleOperator(durationSelector, !!config.leading, !!config.trailing)
						);
					};
				}

				var ThrottleOperator =
					/*@__PURE__*/
					(function () {
						function ThrottleOperator(durationSelector, leading, trailing) {
							this.durationSelector = durationSelector;
							this.leading = leading;
							this.trailing = trailing;
						}

						ThrottleOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new ThrottleSubscriber(
									subscriber,
									this.durationSelector,
									this.leading,
									this.trailing
								)
							);
						};

						return ThrottleOperator;
					})();

				var ThrottleSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(ThrottleSubscriber, _super);

						function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
							var _this = _super.call(this, destination) || this;

							_this.destination = destination;
							_this.durationSelector = durationSelector;
							_this._leading = _leading;
							_this._trailing = _trailing;
							_this._hasValue = false;
							return _this;
						}

						ThrottleSubscriber.prototype._next = function (value) {
							this._hasValue = true;
							this._sendValue = value;

							if (!this._throttled) {
								if (this._leading) {
									this.send();
								} else {
									this.throttle(value);
								}
							}
						};

						ThrottleSubscriber.prototype.send = function () {
							var _a = this,
								_hasValue = _a._hasValue,
								_sendValue = _a._sendValue;

							if (_hasValue) {
								this.destination.next(_sendValue);
								this.throttle(_sendValue);
							}

							this._hasValue = false;
							this._sendValue = undefined;
						};

						ThrottleSubscriber.prototype.throttle = function (value) {
							var duration = this.tryDurationSelector(value);

							if (!!duration) {
								this.add(
									(this._throttled = (0, _innerSubscribe.innerSubscribe)(
										duration,
										new _innerSubscribe.SimpleInnerSubscriber(this)
									))
								);
							}
						};

						ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
							try {
								return this.durationSelector(value);
							} catch (err) {
								this.destination.error(err);
								return null;
							}
						};

						ThrottleSubscriber.prototype.throttlingDone = function () {
							var _a = this,
								_throttled = _a._throttled,
								_trailing = _a._trailing;

							if (_throttled) {
								_throttled.unsubscribe();
							}

							this._throttled = undefined;

							if (_trailing) {
								this.send();
							}
						};

						ThrottleSubscriber.prototype.notifyNext = function () {
							this.throttlingDone();
						};

						ThrottleSubscriber.prototype.notifyComplete = function () {
							this.throttlingDone();
						};

						return ThrottleSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/throttleTime.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.throttleTime = throttleTime;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				var _async = require('../scheduler/async');

				var _throttle = require('./throttle');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */
				function throttleTime(duration, scheduler, config) {
					if (scheduler === void 0) {
						scheduler = _async.async;
					}

					if (config === void 0) {
						config = _throttle.defaultThrottleConfig;
					}

					return function (source) {
						return source.lift(
							new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)
						);
					};
				}

				var ThrottleTimeOperator =
					/*@__PURE__*/
					(function () {
						function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
							this.duration = duration;
							this.scheduler = scheduler;
							this.leading = leading;
							this.trailing = trailing;
						}

						ThrottleTimeOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new ThrottleTimeSubscriber(
									subscriber,
									this.duration,
									this.scheduler,
									this.leading,
									this.trailing
								)
							);
						};

						return ThrottleTimeOperator;
					})();

				var ThrottleTimeSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(ThrottleTimeSubscriber, _super);

						function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
							var _this = _super.call(this, destination) || this;

							_this.duration = duration;
							_this.scheduler = scheduler;
							_this.leading = leading;
							_this.trailing = trailing;
							_this._hasTrailingValue = false;
							_this._trailingValue = null;
							return _this;
						}

						ThrottleTimeSubscriber.prototype._next = function (value) {
							if (this.throttled) {
								if (this.trailing) {
									this._trailingValue = value;
									this._hasTrailingValue = true;
								}
							} else {
								this.add(
									(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, {
										subscriber: this
									}))
								);

								if (this.leading) {
									this.destination.next(value);
								} else if (this.trailing) {
									this._trailingValue = value;
									this._hasTrailingValue = true;
								}
							}
						};

						ThrottleTimeSubscriber.prototype._complete = function () {
							if (this._hasTrailingValue) {
								this.destination.next(this._trailingValue);
								this.destination.complete();
							} else {
								this.destination.complete();
							}
						};

						ThrottleTimeSubscriber.prototype.clearThrottle = function () {
							var throttled = this.throttled;

							if (throttled) {
								if (this.trailing && this._hasTrailingValue) {
									this.destination.next(this._trailingValue);
									this._trailingValue = null;
									this._hasTrailingValue = false;
								}

								throttled.unsubscribe();
								this.remove(throttled);
								this.throttled = null;
							}
						};

						return ThrottleTimeSubscriber;
					})(_Subscriber.Subscriber);

				function dispatchNext(arg) {
					var subscriber = arg.subscriber;
					subscriber.clearThrottle();
				}
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../scheduler/async': '../node_modules/rxjs/_esm5/internal/scheduler/async.js',
				'./throttle': '../node_modules/rxjs/_esm5/internal/operators/throttle.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/timeInterval.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.timeInterval = timeInterval;
				exports.TimeInterval = void 0;

				var _async = require('../scheduler/async');

				var _scan = require('./scan');

				var _defer = require('../observable/defer');

				var _map = require('./map');

				/** PURE_IMPORTS_START _scheduler_async,_scan,_observable_defer,_map PURE_IMPORTS_END */
				function timeInterval(scheduler) {
					if (scheduler === void 0) {
						scheduler = _async.async;
					}

					return function (source) {
						return (0, _defer.defer)(function () {
							return source.pipe(
								(0, _scan.scan)(
									function (_a, value) {
										var current = _a.current;
										return {
											value: value,
											current: scheduler.now(),
											last: current
										};
									},
									{
										current: scheduler.now(),
										value: undefined,
										last: undefined
									}
								),
								(0, _map.map)(function (_a) {
									var current = _a.current,
										last = _a.last,
										value = _a.value;
									return new TimeInterval(value, current - last);
								})
							);
						});
					};
				}

				var TimeInterval =
					/*@__PURE__*/
					(function () {
						function TimeInterval(value, interval) {
							this.value = value;
							this.interval = interval;
						}

						return TimeInterval;
					})();

				exports.TimeInterval = TimeInterval;
			},
			{
				'../scheduler/async': '../node_modules/rxjs/_esm5/internal/scheduler/async.js',
				'./scan': '../node_modules/rxjs/_esm5/internal/operators/scan.js',
				'../observable/defer': '../node_modules/rxjs/_esm5/internal/observable/defer.js',
				'./map': '../node_modules/rxjs/_esm5/internal/operators/map.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/timeoutWith.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.timeoutWith = timeoutWith;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _async = require('../scheduler/async');

				var _isDate = require('../util/isDate');

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_innerSubscribe PURE_IMPORTS_END */
				function timeoutWith(due, withObservable, scheduler) {
					if (scheduler === void 0) {
						scheduler = _async.async;
					}

					return function (source) {
						var absoluteTimeout = (0, _isDate.isDate)(due);
						var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
						return source.lift(
							new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler)
						);
					};
				}

				var TimeoutWithOperator =
					/*@__PURE__*/
					(function () {
						function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
							this.waitFor = waitFor;
							this.absoluteTimeout = absoluteTimeout;
							this.withObservable = withObservable;
							this.scheduler = scheduler;
						}

						TimeoutWithOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new TimeoutWithSubscriber(
									subscriber,
									this.absoluteTimeout,
									this.waitFor,
									this.withObservable,
									this.scheduler
								)
							);
						};

						return TimeoutWithOperator;
					})();

				var TimeoutWithSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(TimeoutWithSubscriber, _super);

						function TimeoutWithSubscriber(
							destination,
							absoluteTimeout,
							waitFor,
							withObservable,
							scheduler
						) {
							var _this = _super.call(this, destination) || this;

							_this.absoluteTimeout = absoluteTimeout;
							_this.waitFor = waitFor;
							_this.withObservable = withObservable;
							_this.scheduler = scheduler;

							_this.scheduleTimeout();

							return _this;
						}

						TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
							var withObservable = subscriber.withObservable;

							subscriber._unsubscribeAndRecycle();

							subscriber.add(
								(0, _innerSubscribe.innerSubscribe)(
									withObservable,
									new _innerSubscribe.SimpleInnerSubscriber(subscriber)
								)
							);
						};

						TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
							var action = this.action;

							if (action) {
								this.action = action.schedule(this, this.waitFor);
							} else {
								this.add(
									(this.action = this.scheduler.schedule(
										TimeoutWithSubscriber.dispatchTimeout,
										this.waitFor,
										this
									))
								);
							}
						};

						TimeoutWithSubscriber.prototype._next = function (value) {
							if (!this.absoluteTimeout) {
								this.scheduleTimeout();
							}

							_super.prototype._next.call(this, value);
						};

						TimeoutWithSubscriber.prototype._unsubscribe = function () {
							this.action = undefined;
							this.scheduler = null;
							this.withObservable = null;
						};

						return TimeoutWithSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../scheduler/async': '../node_modules/rxjs/_esm5/internal/scheduler/async.js',
				'../util/isDate': '../node_modules/rxjs/_esm5/internal/util/isDate.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/timeout.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.timeout = timeout;

				var _async = require('../scheduler/async');

				var _TimeoutError = require('../util/TimeoutError');

				var _timeoutWith = require('./timeoutWith');

				var _throwError = require('../observable/throwError');

				/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */
				function timeout(due, scheduler) {
					if (scheduler === void 0) {
						scheduler = _async.async;
					}

					return (0, _timeoutWith.timeoutWith)(
						due,
						(0, _throwError.throwError)(new _TimeoutError.TimeoutError()),
						scheduler
					);
				}
			},
			{
				'../scheduler/async': '../node_modules/rxjs/_esm5/internal/scheduler/async.js',
				'../util/TimeoutError': '../node_modules/rxjs/_esm5/internal/util/TimeoutError.js',
				'./timeoutWith': '../node_modules/rxjs/_esm5/internal/operators/timeoutWith.js',
				'../observable/throwError': '../node_modules/rxjs/_esm5/internal/observable/throwError.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/timestamp.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.timestamp = timestamp;
				exports.Timestamp = void 0;

				var _async = require('../scheduler/async');

				var _map = require('./map');

				/** PURE_IMPORTS_START _scheduler_async,_map PURE_IMPORTS_END */
				function timestamp(scheduler) {
					if (scheduler === void 0) {
						scheduler = _async.async;
					}

					return (0, _map.map)(function (value) {
						return new Timestamp(value, scheduler.now());
					});
				}

				var Timestamp =
					/*@__PURE__*/
					(function () {
						function Timestamp(value, timestamp) {
							this.value = value;
							this.timestamp = timestamp;
						}

						return Timestamp;
					})();

				exports.Timestamp = Timestamp;
			},
			{
				'../scheduler/async': '../node_modules/rxjs/_esm5/internal/scheduler/async.js',
				'./map': '../node_modules/rxjs/_esm5/internal/operators/map.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/toArray.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.toArray = toArray;

				var _reduce = require('./reduce');

				/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */
				function toArrayReducer(arr, item, index) {
					if (index === 0) {
						return [item];
					}

					arr.push(item);
					return arr;
				}

				function toArray() {
					return (0, _reduce.reduce)(toArrayReducer, []);
				}
			},
			{ './reduce': '../node_modules/rxjs/_esm5/internal/operators/reduce.js' }
		],
		'../node_modules/rxjs/_esm5/internal/operators/window.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.window = window;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subject = require('../Subject');

				var _innerSubscribe = require('../innerSubscribe');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subject,_innerSubscribe PURE_IMPORTS_END */
				function window(windowBoundaries) {
					return function windowOperatorFunction(source) {
						return source.lift(new WindowOperator(windowBoundaries));
					};
				}

				var WindowOperator =
					/*@__PURE__*/
					(function () {
						function WindowOperator(windowBoundaries) {
							this.windowBoundaries = windowBoundaries;
						}

						WindowOperator.prototype.call = function (subscriber, source) {
							var windowSubscriber = new WindowSubscriber(subscriber);
							var sourceSubscription = source.subscribe(windowSubscriber);

							if (!sourceSubscription.closed) {
								windowSubscriber.add(
									(0, _innerSubscribe.innerSubscribe)(
										this.windowBoundaries,
										new _innerSubscribe.SimpleInnerSubscriber(windowSubscriber)
									)
								);
							}

							return sourceSubscription;
						};

						return WindowOperator;
					})();

				var WindowSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(WindowSubscriber, _super);

						function WindowSubscriber(destination) {
							var _this = _super.call(this, destination) || this;

							_this.window = new _Subject.Subject();
							destination.next(_this.window);
							return _this;
						}

						WindowSubscriber.prototype.notifyNext = function () {
							this.openWindow();
						};

						WindowSubscriber.prototype.notifyError = function (error) {
							this._error(error);
						};

						WindowSubscriber.prototype.notifyComplete = function () {
							this._complete();
						};

						WindowSubscriber.prototype._next = function (value) {
							this.window.next(value);
						};

						WindowSubscriber.prototype._error = function (err) {
							this.window.error(err);
							this.destination.error(err);
						};

						WindowSubscriber.prototype._complete = function () {
							this.window.complete();
							this.destination.complete();
						};

						WindowSubscriber.prototype._unsubscribe = function () {
							this.window = null;
						};

						WindowSubscriber.prototype.openWindow = function () {
							var prevWindow = this.window;

							if (prevWindow) {
								prevWindow.complete();
							}

							var destination = this.destination;
							var newWindow = (this.window = new _Subject.Subject());
							destination.next(newWindow);
						};

						return WindowSubscriber;
					})(_innerSubscribe.SimpleOuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subject': '../node_modules/rxjs/_esm5/internal/Subject.js',
				'../innerSubscribe': '../node_modules/rxjs/_esm5/internal/innerSubscribe.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/windowCount.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.windowCount = windowCount;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subscriber = require('../Subscriber');

				var _Subject = require('../Subject');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subscriber,_Subject PURE_IMPORTS_END */
				function windowCount(windowSize, startWindowEvery) {
					if (startWindowEvery === void 0) {
						startWindowEvery = 0;
					}

					return function windowCountOperatorFunction(source) {
						return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
					};
				}

				var WindowCountOperator =
					/*@__PURE__*/
					(function () {
						function WindowCountOperator(windowSize, startWindowEvery) {
							this.windowSize = windowSize;
							this.startWindowEvery = startWindowEvery;
						}

						WindowCountOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery)
							);
						};

						return WindowCountOperator;
					})();

				var WindowCountSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(WindowCountSubscriber, _super);

						function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
							var _this = _super.call(this, destination) || this;

							_this.destination = destination;
							_this.windowSize = windowSize;
							_this.startWindowEvery = startWindowEvery;
							_this.windows = [new _Subject.Subject()];
							_this.count = 0;
							destination.next(_this.windows[0]);
							return _this;
						}

						WindowCountSubscriber.prototype._next = function (value) {
							var startWindowEvery =
								this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
							var destination = this.destination;
							var windowSize = this.windowSize;
							var windows = this.windows;
							var len = windows.length;

							for (var i = 0; i < len && !this.closed; i++) {
								windows[i].next(value);
							}

							var c = this.count - windowSize + 1;

							if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
								windows.shift().complete();
							}

							if (++this.count % startWindowEvery === 0 && !this.closed) {
								var window_1 = new _Subject.Subject();
								windows.push(window_1);
								destination.next(window_1);
							}
						};

						WindowCountSubscriber.prototype._error = function (err) {
							var windows = this.windows;

							if (windows) {
								while (windows.length > 0 && !this.closed) {
									windows.shift().error(err);
								}
							}

							this.destination.error(err);
						};

						WindowCountSubscriber.prototype._complete = function () {
							var windows = this.windows;

							if (windows) {
								while (windows.length > 0 && !this.closed) {
									windows.shift().complete();
								}
							}

							this.destination.complete();
						};

						WindowCountSubscriber.prototype._unsubscribe = function () {
							this.count = 0;
							this.windows = null;
						};

						return WindowCountSubscriber;
					})(_Subscriber.Subscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../Subject': '../node_modules/rxjs/_esm5/internal/Subject.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/windowTime.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.windowTime = windowTime;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subject = require('../Subject');

				var _async = require('../scheduler/async');

				var _Subscriber = require('../Subscriber');

				var _isNumeric = require('../util/isNumeric');

				var _isScheduler = require('../util/isScheduler');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
				function windowTime(windowTimeSpan) {
					var scheduler = _async.async;
					var windowCreationInterval = null;
					var maxWindowSize = Number.POSITIVE_INFINITY;

					if ((0, _isScheduler.isScheduler)(arguments[3])) {
						scheduler = arguments[3];
					}

					if ((0, _isScheduler.isScheduler)(arguments[2])) {
						scheduler = arguments[2];
					} else if ((0, _isNumeric.isNumeric)(arguments[2])) {
						maxWindowSize = Number(arguments[2]);
					}

					if ((0, _isScheduler.isScheduler)(arguments[1])) {
						scheduler = arguments[1];
					} else if ((0, _isNumeric.isNumeric)(arguments[1])) {
						windowCreationInterval = Number(arguments[1]);
					}

					return function windowTimeOperatorFunction(source) {
						return source.lift(
							new WindowTimeOperator(
								windowTimeSpan,
								windowCreationInterval,
								maxWindowSize,
								scheduler
							)
						);
					};
				}

				var WindowTimeOperator =
					/*@__PURE__*/
					(function () {
						function WindowTimeOperator(
							windowTimeSpan,
							windowCreationInterval,
							maxWindowSize,
							scheduler
						) {
							this.windowTimeSpan = windowTimeSpan;
							this.windowCreationInterval = windowCreationInterval;
							this.maxWindowSize = maxWindowSize;
							this.scheduler = scheduler;
						}

						WindowTimeOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new WindowTimeSubscriber(
									subscriber,
									this.windowTimeSpan,
									this.windowCreationInterval,
									this.maxWindowSize,
									this.scheduler
								)
							);
						};

						return WindowTimeOperator;
					})();

				var CountedSubject =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(CountedSubject, _super);

						function CountedSubject() {
							var _this = (_super !== null && _super.apply(this, arguments)) || this;

							_this._numberOfNextedValues = 0;
							return _this;
						}

						CountedSubject.prototype.next = function (value) {
							this._numberOfNextedValues++;

							_super.prototype.next.call(this, value);
						};

						Object.defineProperty(CountedSubject.prototype, 'numberOfNextedValues', {
							get: function () {
								return this._numberOfNextedValues;
							},
							enumerable: true,
							configurable: true
						});
						return CountedSubject;
					})(_Subject.Subject);

				var WindowTimeSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(WindowTimeSubscriber, _super);

						function WindowTimeSubscriber(
							destination,
							windowTimeSpan,
							windowCreationInterval,
							maxWindowSize,
							scheduler
						) {
							var _this = _super.call(this, destination) || this;

							_this.destination = destination;
							_this.windowTimeSpan = windowTimeSpan;
							_this.windowCreationInterval = windowCreationInterval;
							_this.maxWindowSize = maxWindowSize;
							_this.scheduler = scheduler;
							_this.windows = [];

							var window = _this.openWindow();

							if (windowCreationInterval !== null && windowCreationInterval >= 0) {
								var closeState = {
									subscriber: _this,
									window: window,
									context: null
								};
								var creationState = {
									windowTimeSpan: windowTimeSpan,
									windowCreationInterval: windowCreationInterval,
									subscriber: _this,
									scheduler: scheduler
								};

								_this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));

								_this.add(
									scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState)
								);
							} else {
								var timeSpanOnlyState = {
									subscriber: _this,
									window: window,
									windowTimeSpan: windowTimeSpan
								};

								_this.add(
									scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState)
								);
							}

							return _this;
						}

						WindowTimeSubscriber.prototype._next = function (value) {
							var windows = this.windows;
							var len = windows.length;

							for (var i = 0; i < len; i++) {
								var window_1 = windows[i];

								if (!window_1.closed) {
									window_1.next(value);

									if (window_1.numberOfNextedValues >= this.maxWindowSize) {
										this.closeWindow(window_1);
									}
								}
							}
						};

						WindowTimeSubscriber.prototype._error = function (err) {
							var windows = this.windows;

							while (windows.length > 0) {
								windows.shift().error(err);
							}

							this.destination.error(err);
						};

						WindowTimeSubscriber.prototype._complete = function () {
							var windows = this.windows;

							while (windows.length > 0) {
								var window_2 = windows.shift();

								if (!window_2.closed) {
									window_2.complete();
								}
							}

							this.destination.complete();
						};

						WindowTimeSubscriber.prototype.openWindow = function () {
							var window = new CountedSubject();
							this.windows.push(window);
							var destination = this.destination;
							destination.next(window);
							return window;
						};

						WindowTimeSubscriber.prototype.closeWindow = function (window) {
							window.complete();
							var windows = this.windows;
							windows.splice(windows.indexOf(window), 1);
						};

						return WindowTimeSubscriber;
					})(_Subscriber.Subscriber);

				function dispatchWindowTimeSpanOnly(state) {
					var subscriber = state.subscriber,
						windowTimeSpan = state.windowTimeSpan,
						window = state.window;

					if (window) {
						subscriber.closeWindow(window);
					}

					state.window = subscriber.openWindow();
					this.schedule(state, windowTimeSpan);
				}

				function dispatchWindowCreation(state) {
					var windowTimeSpan = state.windowTimeSpan,
						subscriber = state.subscriber,
						scheduler = state.scheduler,
						windowCreationInterval = state.windowCreationInterval;
					var window = subscriber.openWindow();
					var action = this;
					var context = {
						action: action,
						subscription: null
					};
					var timeSpanState = {
						subscriber: subscriber,
						window: window,
						context: context
					};
					context.subscription = scheduler.schedule(
						dispatchWindowClose,
						windowTimeSpan,
						timeSpanState
					);
					action.add(context.subscription);
					action.schedule(state, windowCreationInterval);
				}

				function dispatchWindowClose(state) {
					var subscriber = state.subscriber,
						window = state.window,
						context = state.context;

					if (context && context.action && context.subscription) {
						context.action.remove(context.subscription);
					}

					subscriber.closeWindow(window);
				}
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subject': '../node_modules/rxjs/_esm5/internal/Subject.js',
				'../scheduler/async': '../node_modules/rxjs/_esm5/internal/scheduler/async.js',
				'../Subscriber': '../node_modules/rxjs/_esm5/internal/Subscriber.js',
				'../util/isNumeric': '../node_modules/rxjs/_esm5/internal/util/isNumeric.js',
				'../util/isScheduler': '../node_modules/rxjs/_esm5/internal/util/isScheduler.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/windowToggle.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.windowToggle = windowToggle;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subject = require('../Subject');

				var _Subscription = require('../Subscription');

				var _OuterSubscriber = require('../OuterSubscriber');

				var _subscribeToResult = require('../util/subscribeToResult');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subject,_Subscription,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
				function windowToggle(openings, closingSelector) {
					return function (source) {
						return source.lift(new WindowToggleOperator(openings, closingSelector));
					};
				}

				var WindowToggleOperator =
					/*@__PURE__*/
					(function () {
						function WindowToggleOperator(openings, closingSelector) {
							this.openings = openings;
							this.closingSelector = closingSelector;
						}

						WindowToggleOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector)
							);
						};

						return WindowToggleOperator;
					})();

				var WindowToggleSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(WindowToggleSubscriber, _super);

						function WindowToggleSubscriber(destination, openings, closingSelector) {
							var _this = _super.call(this, destination) || this;

							_this.openings = openings;
							_this.closingSelector = closingSelector;
							_this.contexts = [];

							_this.add(
								(_this.openSubscription = (0, _subscribeToResult.subscribeToResult)(
									_this,
									openings,
									openings
								))
							);

							return _this;
						}

						WindowToggleSubscriber.prototype._next = function (value) {
							var contexts = this.contexts;

							if (contexts) {
								var len = contexts.length;

								for (var i = 0; i < len; i++) {
									contexts[i].window.next(value);
								}
							}
						};

						WindowToggleSubscriber.prototype._error = function (err) {
							var contexts = this.contexts;
							this.contexts = null;

							if (contexts) {
								var len = contexts.length;
								var index = -1;

								while (++index < len) {
									var context_1 = contexts[index];
									context_1.window.error(err);
									context_1.subscription.unsubscribe();
								}
							}

							_super.prototype._error.call(this, err);
						};

						WindowToggleSubscriber.prototype._complete = function () {
							var contexts = this.contexts;
							this.contexts = null;

							if (contexts) {
								var len = contexts.length;
								var index = -1;

								while (++index < len) {
									var context_2 = contexts[index];
									context_2.window.complete();
									context_2.subscription.unsubscribe();
								}
							}

							_super.prototype._complete.call(this);
						};

						WindowToggleSubscriber.prototype._unsubscribe = function () {
							var contexts = this.contexts;
							this.contexts = null;

							if (contexts) {
								var len = contexts.length;
								var index = -1;

								while (++index < len) {
									var context_3 = contexts[index];
									context_3.window.unsubscribe();
									context_3.subscription.unsubscribe();
								}
							}
						};

						WindowToggleSubscriber.prototype.notifyNext = function (
							outerValue,
							innerValue,
							outerIndex,
							innerIndex,
							innerSub
						) {
							if (outerValue === this.openings) {
								var closingNotifier = void 0;

								try {
									var closingSelector = this.closingSelector;
									closingNotifier = closingSelector(innerValue);
								} catch (e) {
									return this.error(e);
								}

								var window_1 = new _Subject.Subject();
								var subscription = new _Subscription.Subscription();
								var context_4 = {
									window: window_1,
									subscription: subscription
								};
								this.contexts.push(context_4);
								var innerSubscription = (0, _subscribeToResult.subscribeToResult)(
									this,
									closingNotifier,
									context_4
								);

								if (innerSubscription.closed) {
									this.closeWindow(this.contexts.length - 1);
								} else {
									innerSubscription.context = context_4;
									subscription.add(innerSubscription);
								}

								this.destination.next(window_1);
							} else {
								this.closeWindow(this.contexts.indexOf(outerValue));
							}
						};

						WindowToggleSubscriber.prototype.notifyError = function (err) {
							this.error(err);
						};

						WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
							if (inner !== this.openSubscription) {
								this.closeWindow(this.contexts.indexOf(inner.context));
							}
						};

						WindowToggleSubscriber.prototype.closeWindow = function (index) {
							if (index === -1) {
								return;
							}

							var contexts = this.contexts;
							var context = contexts[index];
							var window = context.window,
								subscription = context.subscription;
							contexts.splice(index, 1);
							window.complete();
							subscription.unsubscribe();
						};

						return WindowToggleSubscriber;
					})(_OuterSubscriber.OuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subject': '../node_modules/rxjs/_esm5/internal/Subject.js',
				'../Subscription': '../node_modules/rxjs/_esm5/internal/Subscription.js',
				'../OuterSubscriber': '../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
				'../util/subscribeToResult': '../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/windowWhen.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.windowWhen = windowWhen;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _Subject = require('../Subject');

				var _OuterSubscriber = require('../OuterSubscriber');

				var _subscribeToResult = require('../util/subscribeToResult');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
				function windowWhen(closingSelector) {
					return function windowWhenOperatorFunction(source) {
						return source.lift(new WindowOperator(closingSelector));
					};
				}

				var WindowOperator =
					/*@__PURE__*/
					(function () {
						function WindowOperator(closingSelector) {
							this.closingSelector = closingSelector;
						}

						WindowOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
						};

						return WindowOperator;
					})();

				var WindowSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(WindowSubscriber, _super);

						function WindowSubscriber(destination, closingSelector) {
							var _this = _super.call(this, destination) || this;

							_this.destination = destination;
							_this.closingSelector = closingSelector;

							_this.openWindow();

							return _this;
						}

						WindowSubscriber.prototype.notifyNext = function (
							_outerValue,
							_innerValue,
							_outerIndex,
							_innerIndex,
							innerSub
						) {
							this.openWindow(innerSub);
						};

						WindowSubscriber.prototype.notifyError = function (error) {
							this._error(error);
						};

						WindowSubscriber.prototype.notifyComplete = function (innerSub) {
							this.openWindow(innerSub);
						};

						WindowSubscriber.prototype._next = function (value) {
							this.window.next(value);
						};

						WindowSubscriber.prototype._error = function (err) {
							this.window.error(err);
							this.destination.error(err);
							this.unsubscribeClosingNotification();
						};

						WindowSubscriber.prototype._complete = function () {
							this.window.complete();
							this.destination.complete();
							this.unsubscribeClosingNotification();
						};

						WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
							if (this.closingNotification) {
								this.closingNotification.unsubscribe();
							}
						};

						WindowSubscriber.prototype.openWindow = function (innerSub) {
							if (innerSub === void 0) {
								innerSub = null;
							}

							if (innerSub) {
								this.remove(innerSub);
								innerSub.unsubscribe();
							}

							var prevWindow = this.window;

							if (prevWindow) {
								prevWindow.complete();
							}

							var window = (this.window = new _Subject.Subject());
							this.destination.next(window);
							var closingNotifier;

							try {
								var closingSelector = this.closingSelector;
								closingNotifier = closingSelector();
							} catch (e) {
								this.destination.error(e);
								this.window.error(e);
								return;
							}

							this.add(
								(this.closingNotification = (0, _subscribeToResult.subscribeToResult)(
									this,
									closingNotifier
								))
							);
						};

						return WindowSubscriber;
					})(_OuterSubscriber.OuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../Subject': '../node_modules/rxjs/_esm5/internal/Subject.js',
				'../OuterSubscriber': '../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
				'../util/subscribeToResult': '../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.withLatestFrom = withLatestFrom;

				var tslib_1 = _interopRequireWildcard(require('tslib'));

				var _OuterSubscriber = require('../OuterSubscriber');

				var _subscribeToResult = require('../util/subscribeToResult');

				function _getRequireWildcardCache() {
					if (typeof WeakMap !== 'function') return null;
					var cache = new WeakMap();
					_getRequireWildcardCache = function () {
						return cache;
					};
					return cache;
				}

				function _interopRequireWildcard(obj) {
					if (obj && obj.__esModule) {
						return obj;
					}
					var cache = _getRequireWildcardCache();
					if (cache && cache.has(obj)) {
						return cache.get(obj);
					}
					var newObj = {};
					if (obj != null) {
						var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
						for (var key in obj) {
							if (Object.prototype.hasOwnProperty.call(obj, key)) {
								var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
								if (desc && (desc.get || desc.set)) {
									Object.defineProperty(newObj, key, desc);
								} else {
									newObj[key] = obj[key];
								}
							}
						}
					}
					newObj.default = obj;
					if (cache) {
						cache.set(obj, newObj);
					}
					return newObj;
				}

				/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
				function withLatestFrom() {
					var args = [];

					for (var _i = 0; _i < arguments.length; _i++) {
						args[_i] = arguments[_i];
					}

					return function (source) {
						var project;

						if (typeof args[args.length - 1] === 'function') {
							project = args.pop();
						}

						var observables = args;
						return source.lift(new WithLatestFromOperator(observables, project));
					};
				}

				var WithLatestFromOperator =
					/*@__PURE__*/
					(function () {
						function WithLatestFromOperator(observables, project) {
							this.observables = observables;
							this.project = project;
						}

						WithLatestFromOperator.prototype.call = function (subscriber, source) {
							return source.subscribe(
								new WithLatestFromSubscriber(subscriber, this.observables, this.project)
							);
						};

						return WithLatestFromOperator;
					})();

				var WithLatestFromSubscriber =
					/*@__PURE__*/
					(function (_super) {
						tslib_1.__extends(WithLatestFromSubscriber, _super);

						function WithLatestFromSubscriber(destination, observables, project) {
							var _this = _super.call(this, destination) || this;

							_this.observables = observables;
							_this.project = project;
							_this.toRespond = [];
							var len = observables.length;
							_this.values = new Array(len);

							for (var i = 0; i < len; i++) {
								_this.toRespond.push(i);
							}

							for (var i = 0; i < len; i++) {
								var observable = observables[i];

								_this.add(
									(0, _subscribeToResult.subscribeToResult)(_this, observable, undefined, i)
								);
							}

							return _this;
						}

						WithLatestFromSubscriber.prototype.notifyNext = function (
							_outerValue,
							innerValue,
							outerIndex
						) {
							this.values[outerIndex] = innerValue;
							var toRespond = this.toRespond;

							if (toRespond.length > 0) {
								var found = toRespond.indexOf(outerIndex);

								if (found !== -1) {
									toRespond.splice(found, 1);
								}
							}
						};

						WithLatestFromSubscriber.prototype.notifyComplete = function () {};

						WithLatestFromSubscriber.prototype._next = function (value) {
							if (this.toRespond.length === 0) {
								var args = [value].concat(this.values);

								if (this.project) {
									this._tryProject(args);
								} else {
									this.destination.next(args);
								}
							}
						};

						WithLatestFromSubscriber.prototype._tryProject = function (args) {
							var result;

							try {
								result = this.project.apply(this, args);
							} catch (err) {
								this.destination.error(err);
								return;
							}

							this.destination.next(result);
						};

						return WithLatestFromSubscriber;
					})(_OuterSubscriber.OuterSubscriber);
			},
			{
				tslib: '../node_modules/tslib/tslib.es6.js',
				'../OuterSubscriber': '../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
				'../util/subscribeToResult': '../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js'
			}
		],
		'../node_modules/rxjs/_esm5/internal/operators/zip.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.zip = zip;

				var _zip = require('../observable/zip');

				/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */
				function zip() {
					var observables = [];

					for (var _i = 0; _i < arguments.length; _i++) {
						observables[_i] = arguments[_i];
					}

					return function zipOperatorFunction(source) {
						return source.lift.call(_zip.zip.apply(void 0, [source].concat(observables)));
					};
				}
			},
			{ '../observable/zip': '../node_modules/rxjs/_esm5/internal/observable/zip.js' }
		],
		'../node_modules/rxjs/_esm5/internal/operators/zipAll.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.zipAll = zipAll;

				var _zip = require('../observable/zip');

				/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */
				function zipAll(project) {
					return function (source) {
						return source.lift(new _zip.ZipOperator(project));
					};
				}
			},
			{ '../observable/zip': '../node_modules/rxjs/_esm5/internal/observable/zip.js' }
		],
		'../node_modules/rxjs/_esm5/operators/index.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				Object.defineProperty(exports, 'audit', {
					enumerable: true,
					get: function () {
						return _audit.audit;
					}
				});
				Object.defineProperty(exports, 'auditTime', {
					enumerable: true,
					get: function () {
						return _auditTime.auditTime;
					}
				});
				Object.defineProperty(exports, 'buffer', {
					enumerable: true,
					get: function () {
						return _buffer.buffer;
					}
				});
				Object.defineProperty(exports, 'bufferCount', {
					enumerable: true,
					get: function () {
						return _bufferCount.bufferCount;
					}
				});
				Object.defineProperty(exports, 'bufferTime', {
					enumerable: true,
					get: function () {
						return _bufferTime.bufferTime;
					}
				});
				Object.defineProperty(exports, 'bufferToggle', {
					enumerable: true,
					get: function () {
						return _bufferToggle.bufferToggle;
					}
				});
				Object.defineProperty(exports, 'bufferWhen', {
					enumerable: true,
					get: function () {
						return _bufferWhen.bufferWhen;
					}
				});
				Object.defineProperty(exports, 'catchError', {
					enumerable: true,
					get: function () {
						return _catchError.catchError;
					}
				});
				Object.defineProperty(exports, 'combineAll', {
					enumerable: true,
					get: function () {
						return _combineAll.combineAll;
					}
				});
				Object.defineProperty(exports, 'combineLatest', {
					enumerable: true,
					get: function () {
						return _combineLatest.combineLatest;
					}
				});
				Object.defineProperty(exports, 'concat', {
					enumerable: true,
					get: function () {
						return _concat.concat;
					}
				});
				Object.defineProperty(exports, 'concatAll', {
					enumerable: true,
					get: function () {
						return _concatAll.concatAll;
					}
				});
				Object.defineProperty(exports, 'concatMap', {
					enumerable: true,
					get: function () {
						return _concatMap.concatMap;
					}
				});
				Object.defineProperty(exports, 'concatMapTo', {
					enumerable: true,
					get: function () {
						return _concatMapTo.concatMapTo;
					}
				});
				Object.defineProperty(exports, 'count', {
					enumerable: true,
					get: function () {
						return _count.count;
					}
				});
				Object.defineProperty(exports, 'debounce', {
					enumerable: true,
					get: function () {
						return _debounce.debounce;
					}
				});
				Object.defineProperty(exports, 'debounceTime', {
					enumerable: true,
					get: function () {
						return _debounceTime.debounceTime;
					}
				});
				Object.defineProperty(exports, 'defaultIfEmpty', {
					enumerable: true,
					get: function () {
						return _defaultIfEmpty.defaultIfEmpty;
					}
				});
				Object.defineProperty(exports, 'delay', {
					enumerable: true,
					get: function () {
						return _delay.delay;
					}
				});
				Object.defineProperty(exports, 'delayWhen', {
					enumerable: true,
					get: function () {
						return _delayWhen.delayWhen;
					}
				});
				Object.defineProperty(exports, 'dematerialize', {
					enumerable: true,
					get: function () {
						return _dematerialize.dematerialize;
					}
				});
				Object.defineProperty(exports, 'distinct', {
					enumerable: true,
					get: function () {
						return _distinct.distinct;
					}
				});
				Object.defineProperty(exports, 'distinctUntilChanged', {
					enumerable: true,
					get: function () {
						return _distinctUntilChanged.distinctUntilChanged;
					}
				});
				Object.defineProperty(exports, 'distinctUntilKeyChanged', {
					enumerable: true,
					get: function () {
						return _distinctUntilKeyChanged.distinctUntilKeyChanged;
					}
				});
				Object.defineProperty(exports, 'elementAt', {
					enumerable: true,
					get: function () {
						return _elementAt.elementAt;
					}
				});
				Object.defineProperty(exports, 'endWith', {
					enumerable: true,
					get: function () {
						return _endWith.endWith;
					}
				});
				Object.defineProperty(exports, 'every', {
					enumerable: true,
					get: function () {
						return _every.every;
					}
				});
				Object.defineProperty(exports, 'exhaust', {
					enumerable: true,
					get: function () {
						return _exhaust.exhaust;
					}
				});
				Object.defineProperty(exports, 'exhaustMap', {
					enumerable: true,
					get: function () {
						return _exhaustMap.exhaustMap;
					}
				});
				Object.defineProperty(exports, 'expand', {
					enumerable: true,
					get: function () {
						return _expand.expand;
					}
				});
				Object.defineProperty(exports, 'filter', {
					enumerable: true,
					get: function () {
						return _filter.filter;
					}
				});
				Object.defineProperty(exports, 'finalize', {
					enumerable: true,
					get: function () {
						return _finalize.finalize;
					}
				});
				Object.defineProperty(exports, 'find', {
					enumerable: true,
					get: function () {
						return _find.find;
					}
				});
				Object.defineProperty(exports, 'findIndex', {
					enumerable: true,
					get: function () {
						return _findIndex.findIndex;
					}
				});
				Object.defineProperty(exports, 'first', {
					enumerable: true,
					get: function () {
						return _first.first;
					}
				});
				Object.defineProperty(exports, 'groupBy', {
					enumerable: true,
					get: function () {
						return _groupBy.groupBy;
					}
				});
				Object.defineProperty(exports, 'ignoreElements', {
					enumerable: true,
					get: function () {
						return _ignoreElements.ignoreElements;
					}
				});
				Object.defineProperty(exports, 'isEmpty', {
					enumerable: true,
					get: function () {
						return _isEmpty.isEmpty;
					}
				});
				Object.defineProperty(exports, 'last', {
					enumerable: true,
					get: function () {
						return _last.last;
					}
				});
				Object.defineProperty(exports, 'map', {
					enumerable: true,
					get: function () {
						return _map.map;
					}
				});
				Object.defineProperty(exports, 'mapTo', {
					enumerable: true,
					get: function () {
						return _mapTo.mapTo;
					}
				});
				Object.defineProperty(exports, 'materialize', {
					enumerable: true,
					get: function () {
						return _materialize.materialize;
					}
				});
				Object.defineProperty(exports, 'max', {
					enumerable: true,
					get: function () {
						return _max.max;
					}
				});
				Object.defineProperty(exports, 'merge', {
					enumerable: true,
					get: function () {
						return _merge.merge;
					}
				});
				Object.defineProperty(exports, 'mergeAll', {
					enumerable: true,
					get: function () {
						return _mergeAll.mergeAll;
					}
				});
				Object.defineProperty(exports, 'mergeMap', {
					enumerable: true,
					get: function () {
						return _mergeMap.mergeMap;
					}
				});
				Object.defineProperty(exports, 'flatMap', {
					enumerable: true,
					get: function () {
						return _mergeMap.flatMap;
					}
				});
				Object.defineProperty(exports, 'mergeMapTo', {
					enumerable: true,
					get: function () {
						return _mergeMapTo.mergeMapTo;
					}
				});
				Object.defineProperty(exports, 'mergeScan', {
					enumerable: true,
					get: function () {
						return _mergeScan.mergeScan;
					}
				});
				Object.defineProperty(exports, 'min', {
					enumerable: true,
					get: function () {
						return _min.min;
					}
				});
				Object.defineProperty(exports, 'multicast', {
					enumerable: true,
					get: function () {
						return _multicast.multicast;
					}
				});
				Object.defineProperty(exports, 'observeOn', {
					enumerable: true,
					get: function () {
						return _observeOn.observeOn;
					}
				});
				Object.defineProperty(exports, 'onErrorResumeNext', {
					enumerable: true,
					get: function () {
						return _onErrorResumeNext.onErrorResumeNext;
					}
				});
				Object.defineProperty(exports, 'pairwise', {
					enumerable: true,
					get: function () {
						return _pairwise.pairwise;
					}
				});
				Object.defineProperty(exports, 'partition', {
					enumerable: true,
					get: function () {
						return _partition.partition;
					}
				});
				Object.defineProperty(exports, 'pluck', {
					enumerable: true,
					get: function () {
						return _pluck.pluck;
					}
				});
				Object.defineProperty(exports, 'publish', {
					enumerable: true,
					get: function () {
						return _publish.publish;
					}
				});
				Object.defineProperty(exports, 'publishBehavior', {
					enumerable: true,
					get: function () {
						return _publishBehavior.publishBehavior;
					}
				});
				Object.defineProperty(exports, 'publishLast', {
					enumerable: true,
					get: function () {
						return _publishLast.publishLast;
					}
				});
				Object.defineProperty(exports, 'publishReplay', {
					enumerable: true,
					get: function () {
						return _publishReplay.publishReplay;
					}
				});
				Object.defineProperty(exports, 'race', {
					enumerable: true,
					get: function () {
						return _race.race;
					}
				});
				Object.defineProperty(exports, 'reduce', {
					enumerable: true,
					get: function () {
						return _reduce.reduce;
					}
				});
				Object.defineProperty(exports, 'repeat', {
					enumerable: true,
					get: function () {
						return _repeat.repeat;
					}
				});
				Object.defineProperty(exports, 'repeatWhen', {
					enumerable: true,
					get: function () {
						return _repeatWhen.repeatWhen;
					}
				});
				Object.defineProperty(exports, 'retry', {
					enumerable: true,
					get: function () {
						return _retry.retry;
					}
				});
				Object.defineProperty(exports, 'retryWhen', {
					enumerable: true,
					get: function () {
						return _retryWhen.retryWhen;
					}
				});
				Object.defineProperty(exports, 'refCount', {
					enumerable: true,
					get: function () {
						return _refCount.refCount;
					}
				});
				Object.defineProperty(exports, 'sample', {
					enumerable: true,
					get: function () {
						return _sample.sample;
					}
				});
				Object.defineProperty(exports, 'sampleTime', {
					enumerable: true,
					get: function () {
						return _sampleTime.sampleTime;
					}
				});
				Object.defineProperty(exports, 'scan', {
					enumerable: true,
					get: function () {
						return _scan.scan;
					}
				});
				Object.defineProperty(exports, 'sequenceEqual', {
					enumerable: true,
					get: function () {
						return _sequenceEqual.sequenceEqual;
					}
				});
				Object.defineProperty(exports, 'share', {
					enumerable: true,
					get: function () {
						return _share.share;
					}
				});
				Object.defineProperty(exports, 'shareReplay', {
					enumerable: true,
					get: function () {
						return _shareReplay.shareReplay;
					}
				});
				Object.defineProperty(exports, 'single', {
					enumerable: true,
					get: function () {
						return _single.single;
					}
				});
				Object.defineProperty(exports, 'skip', {
					enumerable: true,
					get: function () {
						return _skip.skip;
					}
				});
				Object.defineProperty(exports, 'skipLast', {
					enumerable: true,
					get: function () {
						return _skipLast.skipLast;
					}
				});
				Object.defineProperty(exports, 'skipUntil', {
					enumerable: true,
					get: function () {
						return _skipUntil.skipUntil;
					}
				});
				Object.defineProperty(exports, 'skipWhile', {
					enumerable: true,
					get: function () {
						return _skipWhile.skipWhile;
					}
				});
				Object.defineProperty(exports, 'startWith', {
					enumerable: true,
					get: function () {
						return _startWith.startWith;
					}
				});
				Object.defineProperty(exports, 'subscribeOn', {
					enumerable: true,
					get: function () {
						return _subscribeOn.subscribeOn;
					}
				});
				Object.defineProperty(exports, 'switchAll', {
					enumerable: true,
					get: function () {
						return _switchAll.switchAll;
					}
				});
				Object.defineProperty(exports, 'switchMap', {
					enumerable: true,
					get: function () {
						return _switchMap.switchMap;
					}
				});
				Object.defineProperty(exports, 'switchMapTo', {
					enumerable: true,
					get: function () {
						return _switchMapTo.switchMapTo;
					}
				});
				Object.defineProperty(exports, 'take', {
					enumerable: true,
					get: function () {
						return _take.take;
					}
				});
				Object.defineProperty(exports, 'takeLast', {
					enumerable: true,
					get: function () {
						return _takeLast.takeLast;
					}
				});
				Object.defineProperty(exports, 'takeUntil', {
					enumerable: true,
					get: function () {
						return _takeUntil.takeUntil;
					}
				});
				Object.defineProperty(exports, 'takeWhile', {
					enumerable: true,
					get: function () {
						return _takeWhile.takeWhile;
					}
				});
				Object.defineProperty(exports, 'tap', {
					enumerable: true,
					get: function () {
						return _tap.tap;
					}
				});
				Object.defineProperty(exports, 'throttle', {
					enumerable: true,
					get: function () {
						return _throttle.throttle;
					}
				});
				Object.defineProperty(exports, 'throttleTime', {
					enumerable: true,
					get: function () {
						return _throttleTime.throttleTime;
					}
				});
				Object.defineProperty(exports, 'throwIfEmpty', {
					enumerable: true,
					get: function () {
						return _throwIfEmpty.throwIfEmpty;
					}
				});
				Object.defineProperty(exports, 'timeInterval', {
					enumerable: true,
					get: function () {
						return _timeInterval.timeInterval;
					}
				});
				Object.defineProperty(exports, 'timeout', {
					enumerable: true,
					get: function () {
						return _timeout.timeout;
					}
				});
				Object.defineProperty(exports, 'timeoutWith', {
					enumerable: true,
					get: function () {
						return _timeoutWith.timeoutWith;
					}
				});
				Object.defineProperty(exports, 'timestamp', {
					enumerable: true,
					get: function () {
						return _timestamp.timestamp;
					}
				});
				Object.defineProperty(exports, 'toArray', {
					enumerable: true,
					get: function () {
						return _toArray.toArray;
					}
				});
				Object.defineProperty(exports, 'window', {
					enumerable: true,
					get: function () {
						return _window.window;
					}
				});
				Object.defineProperty(exports, 'windowCount', {
					enumerable: true,
					get: function () {
						return _windowCount.windowCount;
					}
				});
				Object.defineProperty(exports, 'windowTime', {
					enumerable: true,
					get: function () {
						return _windowTime.windowTime;
					}
				});
				Object.defineProperty(exports, 'windowToggle', {
					enumerable: true,
					get: function () {
						return _windowToggle.windowToggle;
					}
				});
				Object.defineProperty(exports, 'windowWhen', {
					enumerable: true,
					get: function () {
						return _windowWhen.windowWhen;
					}
				});
				Object.defineProperty(exports, 'withLatestFrom', {
					enumerable: true,
					get: function () {
						return _withLatestFrom.withLatestFrom;
					}
				});
				Object.defineProperty(exports, 'zip', {
					enumerable: true,
					get: function () {
						return _zip.zip;
					}
				});
				Object.defineProperty(exports, 'zipAll', {
					enumerable: true,
					get: function () {
						return _zipAll.zipAll;
					}
				});

				var _audit = require('../internal/operators/audit');

				var _auditTime = require('../internal/operators/auditTime');

				var _buffer = require('../internal/operators/buffer');

				var _bufferCount = require('../internal/operators/bufferCount');

				var _bufferTime = require('../internal/operators/bufferTime');

				var _bufferToggle = require('../internal/operators/bufferToggle');

				var _bufferWhen = require('../internal/operators/bufferWhen');

				var _catchError = require('../internal/operators/catchError');

				var _combineAll = require('../internal/operators/combineAll');

				var _combineLatest = require('../internal/operators/combineLatest');

				var _concat = require('../internal/operators/concat');

				var _concatAll = require('../internal/operators/concatAll');

				var _concatMap = require('../internal/operators/concatMap');

				var _concatMapTo = require('../internal/operators/concatMapTo');

				var _count = require('../internal/operators/count');

				var _debounce = require('../internal/operators/debounce');

				var _debounceTime = require('../internal/operators/debounceTime');

				var _defaultIfEmpty = require('../internal/operators/defaultIfEmpty');

				var _delay = require('../internal/operators/delay');

				var _delayWhen = require('../internal/operators/delayWhen');

				var _dematerialize = require('../internal/operators/dematerialize');

				var _distinct = require('../internal/operators/distinct');

				var _distinctUntilChanged = require('../internal/operators/distinctUntilChanged');

				var _distinctUntilKeyChanged = require('../internal/operators/distinctUntilKeyChanged');

				var _elementAt = require('../internal/operators/elementAt');

				var _endWith = require('../internal/operators/endWith');

				var _every = require('../internal/operators/every');

				var _exhaust = require('../internal/operators/exhaust');

				var _exhaustMap = require('../internal/operators/exhaustMap');

				var _expand = require('../internal/operators/expand');

				var _filter = require('../internal/operators/filter');

				var _finalize = require('../internal/operators/finalize');

				var _find = require('../internal/operators/find');

				var _findIndex = require('../internal/operators/findIndex');

				var _first = require('../internal/operators/first');

				var _groupBy = require('../internal/operators/groupBy');

				var _ignoreElements = require('../internal/operators/ignoreElements');

				var _isEmpty = require('../internal/operators/isEmpty');

				var _last = require('../internal/operators/last');

				var _map = require('../internal/operators/map');

				var _mapTo = require('../internal/operators/mapTo');

				var _materialize = require('../internal/operators/materialize');

				var _max = require('../internal/operators/max');

				var _merge = require('../internal/operators/merge');

				var _mergeAll = require('../internal/operators/mergeAll');

				var _mergeMap = require('../internal/operators/mergeMap');

				var _mergeMapTo = require('../internal/operators/mergeMapTo');

				var _mergeScan = require('../internal/operators/mergeScan');

				var _min = require('../internal/operators/min');

				var _multicast = require('../internal/operators/multicast');

				var _observeOn = require('../internal/operators/observeOn');

				var _onErrorResumeNext = require('../internal/operators/onErrorResumeNext');

				var _pairwise = require('../internal/operators/pairwise');

				var _partition = require('../internal/operators/partition');

				var _pluck = require('../internal/operators/pluck');

				var _publish = require('../internal/operators/publish');

				var _publishBehavior = require('../internal/operators/publishBehavior');

				var _publishLast = require('../internal/operators/publishLast');

				var _publishReplay = require('../internal/operators/publishReplay');

				var _race = require('../internal/operators/race');

				var _reduce = require('../internal/operators/reduce');

				var _repeat = require('../internal/operators/repeat');

				var _repeatWhen = require('../internal/operators/repeatWhen');

				var _retry = require('../internal/operators/retry');

				var _retryWhen = require('../internal/operators/retryWhen');

				var _refCount = require('../internal/operators/refCount');

				var _sample = require('../internal/operators/sample');

				var _sampleTime = require('../internal/operators/sampleTime');

				var _scan = require('../internal/operators/scan');

				var _sequenceEqual = require('../internal/operators/sequenceEqual');

				var _share = require('../internal/operators/share');

				var _shareReplay = require('../internal/operators/shareReplay');

				var _single = require('../internal/operators/single');

				var _skip = require('../internal/operators/skip');

				var _skipLast = require('../internal/operators/skipLast');

				var _skipUntil = require('../internal/operators/skipUntil');

				var _skipWhile = require('../internal/operators/skipWhile');

				var _startWith = require('../internal/operators/startWith');

				var _subscribeOn = require('../internal/operators/subscribeOn');

				var _switchAll = require('../internal/operators/switchAll');

				var _switchMap = require('../internal/operators/switchMap');

				var _switchMapTo = require('../internal/operators/switchMapTo');

				var _take = require('../internal/operators/take');

				var _takeLast = require('../internal/operators/takeLast');

				var _takeUntil = require('../internal/operators/takeUntil');

				var _takeWhile = require('../internal/operators/takeWhile');

				var _tap = require('../internal/operators/tap');

				var _throttle = require('../internal/operators/throttle');

				var _throttleTime = require('../internal/operators/throttleTime');

				var _throwIfEmpty = require('../internal/operators/throwIfEmpty');

				var _timeInterval = require('../internal/operators/timeInterval');

				var _timeout = require('../internal/operators/timeout');

				var _timeoutWith = require('../internal/operators/timeoutWith');

				var _timestamp = require('../internal/operators/timestamp');

				var _toArray = require('../internal/operators/toArray');

				var _window = require('../internal/operators/window');

				var _windowCount = require('../internal/operators/windowCount');

				var _windowTime = require('../internal/operators/windowTime');

				var _windowToggle = require('../internal/operators/windowToggle');

				var _windowWhen = require('../internal/operators/windowWhen');

				var _withLatestFrom = require('../internal/operators/withLatestFrom');

				var _zip = require('../internal/operators/zip');

				var _zipAll = require('../internal/operators/zipAll');
			},
			{
				'../internal/operators/audit': '../node_modules/rxjs/_esm5/internal/operators/audit.js',
				'../internal/operators/auditTime':
					'../node_modules/rxjs/_esm5/internal/operators/auditTime.js',
				'../internal/operators/buffer': '../node_modules/rxjs/_esm5/internal/operators/buffer.js',
				'../internal/operators/bufferCount':
					'../node_modules/rxjs/_esm5/internal/operators/bufferCount.js',
				'../internal/operators/bufferTime':
					'../node_modules/rxjs/_esm5/internal/operators/bufferTime.js',
				'../internal/operators/bufferToggle':
					'../node_modules/rxjs/_esm5/internal/operators/bufferToggle.js',
				'../internal/operators/bufferWhen':
					'../node_modules/rxjs/_esm5/internal/operators/bufferWhen.js',
				'../internal/operators/catchError':
					'../node_modules/rxjs/_esm5/internal/operators/catchError.js',
				'../internal/operators/combineAll':
					'../node_modules/rxjs/_esm5/internal/operators/combineAll.js',
				'../internal/operators/combineLatest':
					'../node_modules/rxjs/_esm5/internal/operators/combineLatest.js',
				'../internal/operators/concat': '../node_modules/rxjs/_esm5/internal/operators/concat.js',
				'../internal/operators/concatAll':
					'../node_modules/rxjs/_esm5/internal/operators/concatAll.js',
				'../internal/operators/concatMap':
					'../node_modules/rxjs/_esm5/internal/operators/concatMap.js',
				'../internal/operators/concatMapTo':
					'../node_modules/rxjs/_esm5/internal/operators/concatMapTo.js',
				'../internal/operators/count': '../node_modules/rxjs/_esm5/internal/operators/count.js',
				'../internal/operators/debounce':
					'../node_modules/rxjs/_esm5/internal/operators/debounce.js',
				'../internal/operators/debounceTime':
					'../node_modules/rxjs/_esm5/internal/operators/debounceTime.js',
				'../internal/operators/defaultIfEmpty':
					'../node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js',
				'../internal/operators/delay': '../node_modules/rxjs/_esm5/internal/operators/delay.js',
				'../internal/operators/delayWhen':
					'../node_modules/rxjs/_esm5/internal/operators/delayWhen.js',
				'../internal/operators/dematerialize':
					'../node_modules/rxjs/_esm5/internal/operators/dematerialize.js',
				'../internal/operators/distinct':
					'../node_modules/rxjs/_esm5/internal/operators/distinct.js',
				'../internal/operators/distinctUntilChanged':
					'../node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js',
				'../internal/operators/distinctUntilKeyChanged':
					'../node_modules/rxjs/_esm5/internal/operators/distinctUntilKeyChanged.js',
				'../internal/operators/elementAt':
					'../node_modules/rxjs/_esm5/internal/operators/elementAt.js',
				'../internal/operators/endWith': '../node_modules/rxjs/_esm5/internal/operators/endWith.js',
				'../internal/operators/every': '../node_modules/rxjs/_esm5/internal/operators/every.js',
				'../internal/operators/exhaust': '../node_modules/rxjs/_esm5/internal/operators/exhaust.js',
				'../internal/operators/exhaustMap':
					'../node_modules/rxjs/_esm5/internal/operators/exhaustMap.js',
				'../internal/operators/expand': '../node_modules/rxjs/_esm5/internal/operators/expand.js',
				'../internal/operators/filter': '../node_modules/rxjs/_esm5/internal/operators/filter.js',
				'../internal/operators/finalize':
					'../node_modules/rxjs/_esm5/internal/operators/finalize.js',
				'../internal/operators/find': '../node_modules/rxjs/_esm5/internal/operators/find.js',
				'../internal/operators/findIndex':
					'../node_modules/rxjs/_esm5/internal/operators/findIndex.js',
				'../internal/operators/first': '../node_modules/rxjs/_esm5/internal/operators/first.js',
				'../internal/operators/groupBy': '../node_modules/rxjs/_esm5/internal/operators/groupBy.js',
				'../internal/operators/ignoreElements':
					'../node_modules/rxjs/_esm5/internal/operators/ignoreElements.js',
				'../internal/operators/isEmpty': '../node_modules/rxjs/_esm5/internal/operators/isEmpty.js',
				'../internal/operators/last': '../node_modules/rxjs/_esm5/internal/operators/last.js',
				'../internal/operators/map': '../node_modules/rxjs/_esm5/internal/operators/map.js',
				'../internal/operators/mapTo': '../node_modules/rxjs/_esm5/internal/operators/mapTo.js',
				'../internal/operators/materialize':
					'../node_modules/rxjs/_esm5/internal/operators/materialize.js',
				'../internal/operators/max': '../node_modules/rxjs/_esm5/internal/operators/max.js',
				'../internal/operators/merge': '../node_modules/rxjs/_esm5/internal/operators/merge.js',
				'../internal/operators/mergeAll':
					'../node_modules/rxjs/_esm5/internal/operators/mergeAll.js',
				'../internal/operators/mergeMap':
					'../node_modules/rxjs/_esm5/internal/operators/mergeMap.js',
				'../internal/operators/mergeMapTo':
					'../node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js',
				'../internal/operators/mergeScan':
					'../node_modules/rxjs/_esm5/internal/operators/mergeScan.js',
				'../internal/operators/min': '../node_modules/rxjs/_esm5/internal/operators/min.js',
				'../internal/operators/multicast':
					'../node_modules/rxjs/_esm5/internal/operators/multicast.js',
				'../internal/operators/observeOn':
					'../node_modules/rxjs/_esm5/internal/operators/observeOn.js',
				'../internal/operators/onErrorResumeNext':
					'../node_modules/rxjs/_esm5/internal/operators/onErrorResumeNext.js',
				'../internal/operators/pairwise':
					'../node_modules/rxjs/_esm5/internal/operators/pairwise.js',
				'../internal/operators/partition':
					'../node_modules/rxjs/_esm5/internal/operators/partition.js',
				'../internal/operators/pluck': '../node_modules/rxjs/_esm5/internal/operators/pluck.js',
				'../internal/operators/publish': '../node_modules/rxjs/_esm5/internal/operators/publish.js',
				'../internal/operators/publishBehavior':
					'../node_modules/rxjs/_esm5/internal/operators/publishBehavior.js',
				'../internal/operators/publishLast':
					'../node_modules/rxjs/_esm5/internal/operators/publishLast.js',
				'../internal/operators/publishReplay':
					'../node_modules/rxjs/_esm5/internal/operators/publishReplay.js',
				'../internal/operators/race': '../node_modules/rxjs/_esm5/internal/operators/race.js',
				'../internal/operators/reduce': '../node_modules/rxjs/_esm5/internal/operators/reduce.js',
				'../internal/operators/repeat': '../node_modules/rxjs/_esm5/internal/operators/repeat.js',
				'../internal/operators/repeatWhen':
					'../node_modules/rxjs/_esm5/internal/operators/repeatWhen.js',
				'../internal/operators/retry': '../node_modules/rxjs/_esm5/internal/operators/retry.js',
				'../internal/operators/retryWhen':
					'../node_modules/rxjs/_esm5/internal/operators/retryWhen.js',
				'../internal/operators/refCount':
					'../node_modules/rxjs/_esm5/internal/operators/refCount.js',
				'../internal/operators/sample': '../node_modules/rxjs/_esm5/internal/operators/sample.js',
				'../internal/operators/sampleTime':
					'../node_modules/rxjs/_esm5/internal/operators/sampleTime.js',
				'../internal/operators/scan': '../node_modules/rxjs/_esm5/internal/operators/scan.js',
				'../internal/operators/sequenceEqual':
					'../node_modules/rxjs/_esm5/internal/operators/sequenceEqual.js',
				'../internal/operators/share': '../node_modules/rxjs/_esm5/internal/operators/share.js',
				'../internal/operators/shareReplay':
					'../node_modules/rxjs/_esm5/internal/operators/shareReplay.js',
				'../internal/operators/single': '../node_modules/rxjs/_esm5/internal/operators/single.js',
				'../internal/operators/skip': '../node_modules/rxjs/_esm5/internal/operators/skip.js',
				'../internal/operators/skipLast':
					'../node_modules/rxjs/_esm5/internal/operators/skipLast.js',
				'../internal/operators/skipUntil':
					'../node_modules/rxjs/_esm5/internal/operators/skipUntil.js',
				'../internal/operators/skipWhile':
					'../node_modules/rxjs/_esm5/internal/operators/skipWhile.js',
				'../internal/operators/startWith':
					'../node_modules/rxjs/_esm5/internal/operators/startWith.js',
				'../internal/operators/subscribeOn':
					'../node_modules/rxjs/_esm5/internal/operators/subscribeOn.js',
				'../internal/operators/switchAll':
					'../node_modules/rxjs/_esm5/internal/operators/switchAll.js',
				'../internal/operators/switchMap':
					'../node_modules/rxjs/_esm5/internal/operators/switchMap.js',
				'../internal/operators/switchMapTo':
					'../node_modules/rxjs/_esm5/internal/operators/switchMapTo.js',
				'../internal/operators/take': '../node_modules/rxjs/_esm5/internal/operators/take.js',
				'../internal/operators/takeLast':
					'../node_modules/rxjs/_esm5/internal/operators/takeLast.js',
				'../internal/operators/takeUntil':
					'../node_modules/rxjs/_esm5/internal/operators/takeUntil.js',
				'../internal/operators/takeWhile':
					'../node_modules/rxjs/_esm5/internal/operators/takeWhile.js',
				'../internal/operators/tap': '../node_modules/rxjs/_esm5/internal/operators/tap.js',
				'../internal/operators/throttle':
					'../node_modules/rxjs/_esm5/internal/operators/throttle.js',
				'../internal/operators/throttleTime':
					'../node_modules/rxjs/_esm5/internal/operators/throttleTime.js',
				'../internal/operators/throwIfEmpty':
					'../node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js',
				'../internal/operators/timeInterval':
					'../node_modules/rxjs/_esm5/internal/operators/timeInterval.js',
				'../internal/operators/timeout': '../node_modules/rxjs/_esm5/internal/operators/timeout.js',
				'../internal/operators/timeoutWith':
					'../node_modules/rxjs/_esm5/internal/operators/timeoutWith.js',
				'../internal/operators/timestamp':
					'../node_modules/rxjs/_esm5/internal/operators/timestamp.js',
				'../internal/operators/toArray': '../node_modules/rxjs/_esm5/internal/operators/toArray.js',
				'../internal/operators/window': '../node_modules/rxjs/_esm5/internal/operators/window.js',
				'../internal/operators/windowCount':
					'../node_modules/rxjs/_esm5/internal/operators/windowCount.js',
				'../internal/operators/windowTime':
					'../node_modules/rxjs/_esm5/internal/operators/windowTime.js',
				'../internal/operators/windowToggle':
					'../node_modules/rxjs/_esm5/internal/operators/windowToggle.js',
				'../internal/operators/windowWhen':
					'../node_modules/rxjs/_esm5/internal/operators/windowWhen.js',
				'../internal/operators/withLatestFrom':
					'../node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js',
				'../internal/operators/zip': '../node_modules/rxjs/_esm5/internal/operators/zip.js',
				'../internal/operators/zipAll': '../node_modules/rxjs/_esm5/internal/operators/zipAll.js'
			}
		],
		'../node_modules/fast-json-stable-stringify/index.js': [
			function (require, module, exports) {
				'use strict';

				module.exports = function (data, opts) {
					if (!opts) opts = {};
					if (typeof opts === 'function') opts = { cmp: opts };
					var cycles = typeof opts.cycles === 'boolean' ? opts.cycles : false;

					var cmp =
						opts.cmp &&
						(function (f) {
							return function (node) {
								return function (a, b) {
									var aobj = { key: a, value: node[a] };
									var bobj = { key: b, value: node[b] };
									return f(aobj, bobj);
								};
							};
						})(opts.cmp);

					var seen = [];
					return (function stringify(node) {
						if (node && node.toJSON && typeof node.toJSON === 'function') {
							node = node.toJSON();
						}

						if (node === undefined) return;
						if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
						if (typeof node !== 'object') return JSON.stringify(node);

						var i, out;
						if (Array.isArray(node)) {
							out = '[';
							for (i = 0; i < node.length; i++) {
								if (i) out += ',';
								out += stringify(node[i]) || 'null';
							}
							return out + ']';
						}

						if (node === null) return 'null';

						if (seen.indexOf(node) !== -1) {
							if (cycles) return JSON.stringify('__cycle__');
							throw new TypeError('Converting circular structure to JSON');
						}

						var seenIndex = seen.push(node) - 1;
						var keys = Object.keys(node).sort(cmp && cmp(node));
						out = '';
						for (i = 0; i < keys.length; i++) {
							var key = keys[i];
							var value = stringify(node[key]);

							if (!value) continue;
							if (out) out += ',';
							out += JSON.stringify(key) + ':' + value;
						}
						seen.splice(seenIndex, 1);
						return '{' + out + '}';
					})(data);
				};
			},
			{}
		],
		'../node_modules/safe-buffer/index.js': [
			function (require, module, exports) {
				/* eslint-disable node/no-deprecated-api */
				var buffer = require('buffer');
				var Buffer = buffer.Buffer;

				// alternative to using Object.keys for old browsers
				function copyProps(src, dst) {
					for (var key in src) {
						dst[key] = src[key];
					}
				}
				if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
					module.exports = buffer;
				} else {
					// Copy properties from require('buffer')
					copyProps(buffer, exports);
					exports.Buffer = SafeBuffer;
				}

				function SafeBuffer(arg, encodingOrOffset, length) {
					return Buffer(arg, encodingOrOffset, length);
				}

				SafeBuffer.prototype = Object.create(Buffer.prototype);

				// Copy static methods from Buffer
				copyProps(Buffer, SafeBuffer);

				SafeBuffer.from = function (arg, encodingOrOffset, length) {
					if (typeof arg === 'number') {
						throw new TypeError('Argument must not be a number');
					}
					return Buffer(arg, encodingOrOffset, length);
				};

				SafeBuffer.alloc = function (size, fill, encoding) {
					if (typeof size !== 'number') {
						throw new TypeError('Argument must be a number');
					}
					var buf = Buffer(size);
					if (fill !== undefined) {
						if (typeof encoding === 'string') {
							buf.fill(fill, encoding);
						} else {
							buf.fill(fill);
						}
					} else {
						buf.fill(0);
					}
					return buf;
				};

				SafeBuffer.allocUnsafe = function (size) {
					if (typeof size !== 'number') {
						throw new TypeError('Argument must be a number');
					}
					return Buffer(size);
				};

				SafeBuffer.allocUnsafeSlow = function (size) {
					if (typeof size !== 'number') {
						throw new TypeError('Argument must be a number');
					}
					return buffer.SlowBuffer(size);
				};
			},
			{ buffer: '../node_modules/node-libs-browser/node_modules/buffer/index.js' }
		],
		'../node_modules/readable-stream/writable-browser.js': [
			function (require, module, exports) {
				module.exports = require('./lib/_stream_writable.js');
			},
			{ './lib/_stream_writable.js': '../node_modules/readable-stream/lib/_stream_writable.js' }
		],
		'../node_modules/readable-stream/duplex-browser.js': [
			function (require, module, exports) {
				module.exports = require('./lib/_stream_duplex.js');
			},
			{ './lib/_stream_duplex.js': '../node_modules/readable-stream/lib/_stream_duplex.js' }
		],
		'../node_modules/readable-stream/transform.js': [
			function (require, module, exports) {
				module.exports = require('./readable').Transform;
			},
			{ './readable': '../node_modules/readable-stream/readable-browser.js' }
		],
		'../node_modules/readable-stream/passthrough.js': [
			function (require, module, exports) {
				module.exports = require('./readable').PassThrough;
			},
			{ './readable': '../node_modules/readable-stream/readable-browser.js' }
		],
		'../node_modules/stream-browserify/index.js': [
			function (require, module, exports) {
				// Copyright Joyent, Inc. and other Node contributors.
				//
				// Permission is hereby granted, free of charge, to any person obtaining a
				// copy of this software and associated documentation files (the
				// "Software"), to deal in the Software without restriction, including
				// without limitation the rights to use, copy, modify, merge, publish,
				// distribute, sublicense, and/or sell copies of the Software, and to permit
				// persons to whom the Software is furnished to do so, subject to the
				// following conditions:
				//
				// The above copyright notice and this permission notice shall be included
				// in all copies or substantial portions of the Software.
				//
				// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
				// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
				// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
				// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
				// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
				// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
				// USE OR OTHER DEALINGS IN THE SOFTWARE.

				module.exports = Stream;

				var EE = require('events').EventEmitter;
				var inherits = require('inherits');

				inherits(Stream, EE);
				Stream.Readable = require('readable-stream/readable.js');
				Stream.Writable = require('readable-stream/writable.js');
				Stream.Duplex = require('readable-stream/duplex.js');
				Stream.Transform = require('readable-stream/transform.js');
				Stream.PassThrough = require('readable-stream/passthrough.js');

				// Backwards-compat with node 0.4.x
				Stream.Stream = Stream;

				// old-style streams.  Note that the pipe method (the only relevant
				// part of this class) is overridden in the Readable class.

				function Stream() {
					EE.call(this);
				}

				Stream.prototype.pipe = function (dest, options) {
					var source = this;

					function ondata(chunk) {
						if (dest.writable) {
							if (false === dest.write(chunk) && source.pause) {
								source.pause();
							}
						}
					}

					source.on('data', ondata);

					function ondrain() {
						if (source.readable && source.resume) {
							source.resume();
						}
					}

					dest.on('drain', ondrain);

					// If the 'end' option is not supplied, dest.end() will be called when
					// source gets the 'end' or 'close' events.  Only dest.end() once.
					if (!dest._isStdio && (!options || options.end !== false)) {
						source.on('end', onend);
						source.on('close', onclose);
					}

					var didOnEnd = false;
					function onend() {
						if (didOnEnd) return;
						didOnEnd = true;

						dest.end();
					}

					function onclose() {
						if (didOnEnd) return;
						didOnEnd = true;

						if (typeof dest.destroy === 'function') dest.destroy();
					}

					// don't leave dangling pipes when there are errors.
					function onerror(er) {
						cleanup();
						if (EE.listenerCount(this, 'error') === 0) {
							throw er; // Unhandled stream error in pipe.
						}
					}

					source.on('error', onerror);
					dest.on('error', onerror);

					// remove all the event listeners that were added.
					function cleanup() {
						source.removeListener('data', ondata);
						dest.removeListener('drain', ondrain);

						source.removeListener('end', onend);
						source.removeListener('close', onclose);

						source.removeListener('error', onerror);
						dest.removeListener('error', onerror);

						source.removeListener('end', cleanup);
						source.removeListener('close', cleanup);

						dest.removeListener('close', cleanup);
					}

					source.on('end', cleanup);
					source.on('close', cleanup);

					dest.on('close', cleanup);

					dest.emit('pipe', source);

					// Allow for unix-like usage: A.pipe(B).pipe(C)
					return dest;
				};
			},
			{
				events: '../node_modules/events/events.js',
				inherits: '../node_modules/inherits/inherits_browser.js',
				'readable-stream/readable.js': '../node_modules/readable-stream/readable-browser.js',
				'readable-stream/writable.js': '../node_modules/readable-stream/writable-browser.js',
				'readable-stream/duplex.js': '../node_modules/readable-stream/duplex-browser.js',
				'readable-stream/transform.js': '../node_modules/readable-stream/transform.js',
				'readable-stream/passthrough.js': '../node_modules/readable-stream/passthrough.js'
			}
		],
		'../node_modules/hash-base/index.js': [
			function (require, module, exports) {
				'use strict';

				var Buffer = require('safe-buffer').Buffer;

				var Transform = require('stream').Transform;

				var inherits = require('inherits');

				function throwIfNotStringOrBuffer(val, prefix) {
					if (!Buffer.isBuffer(val) && typeof val !== 'string') {
						throw new TypeError(prefix + ' must be a string or a buffer');
					}
				}

				function HashBase(blockSize) {
					Transform.call(this);
					this._block = Buffer.allocUnsafe(blockSize);
					this._blockSize = blockSize;
					this._blockOffset = 0;
					this._length = [0, 0, 0, 0];
					this._finalized = false;
				}

				inherits(HashBase, Transform);

				HashBase.prototype._transform = function (chunk, encoding, callback) {
					var error = null;

					try {
						this.update(chunk, encoding);
					} catch (err) {
						error = err;
					}

					callback(error);
				};

				HashBase.prototype._flush = function (callback) {
					var error = null;

					try {
						this.push(this.digest());
					} catch (err) {
						error = err;
					}

					callback(error);
				};

				HashBase.prototype.update = function (data, encoding) {
					throwIfNotStringOrBuffer(data, 'Data');
					if (this._finalized) throw new Error('Digest already called');
					if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding); // consume data

					var block = this._block;
					var offset = 0;

					while (this._blockOffset + data.length - offset >= this._blockSize) {
						for (var i = this._blockOffset; i < this._blockSize; ) block[i++] = data[offset++];

						this._update();

						this._blockOffset = 0;
					}

					while (offset < data.length) block[this._blockOffset++] = data[offset++]; // update length

					for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
						this._length[j] += carry;
						carry = (this._length[j] / 0x0100000000) | 0;
						if (carry > 0) this._length[j] -= 0x0100000000 * carry;
					}

					return this;
				};

				HashBase.prototype._update = function () {
					throw new Error('_update is not implemented');
				};

				HashBase.prototype.digest = function (encoding) {
					if (this._finalized) throw new Error('Digest already called');
					this._finalized = true;

					var digest = this._digest();

					if (encoding !== undefined) digest = digest.toString(encoding); // reset state

					this._block.fill(0);

					this._blockOffset = 0;

					for (var i = 0; i < 4; ++i) this._length[i] = 0;

					return digest;
				};

				HashBase.prototype._digest = function () {
					throw new Error('_digest is not implemented');
				};

				module.exports = HashBase;
			},
			{
				'safe-buffer': '../node_modules/safe-buffer/index.js',
				stream: '../node_modules/stream-browserify/index.js',
				inherits: '../node_modules/inherits/inherits_browser.js'
			}
		],
		'../node_modules/md5.js/index.js': [
			function (require, module, exports) {
				'use strict';
				var inherits = require('inherits');
				var HashBase = require('hash-base');
				var Buffer = require('safe-buffer').Buffer;

				var ARRAY16 = new Array(16);

				function MD5() {
					HashBase.call(this, 64);

					// state
					this._a = 0x67452301;
					this._b = 0xefcdab89;
					this._c = 0x98badcfe;
					this._d = 0x10325476;
				}

				inherits(MD5, HashBase);

				MD5.prototype._update = function () {
					var M = ARRAY16;
					for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4);

					var a = this._a;
					var b = this._b;
					var c = this._c;
					var d = this._d;

					a = fnF(a, b, c, d, M[0], 0xd76aa478, 7);
					d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12);
					c = fnF(c, d, a, b, M[2], 0x242070db, 17);
					b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22);
					a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7);
					d = fnF(d, a, b, c, M[5], 0x4787c62a, 12);
					c = fnF(c, d, a, b, M[6], 0xa8304613, 17);
					b = fnF(b, c, d, a, M[7], 0xfd469501, 22);
					a = fnF(a, b, c, d, M[8], 0x698098d8, 7);
					d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12);
					c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17);
					b = fnF(b, c, d, a, M[11], 0x895cd7be, 22);
					a = fnF(a, b, c, d, M[12], 0x6b901122, 7);
					d = fnF(d, a, b, c, M[13], 0xfd987193, 12);
					c = fnF(c, d, a, b, M[14], 0xa679438e, 17);
					b = fnF(b, c, d, a, M[15], 0x49b40821, 22);

					a = fnG(a, b, c, d, M[1], 0xf61e2562, 5);
					d = fnG(d, a, b, c, M[6], 0xc040b340, 9);
					c = fnG(c, d, a, b, M[11], 0x265e5a51, 14);
					b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20);
					a = fnG(a, b, c, d, M[5], 0xd62f105d, 5);
					d = fnG(d, a, b, c, M[10], 0x02441453, 9);
					c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14);
					b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20);
					a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5);
					d = fnG(d, a, b, c, M[14], 0xc33707d6, 9);
					c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14);
					b = fnG(b, c, d, a, M[8], 0x455a14ed, 20);
					a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5);
					d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9);
					c = fnG(c, d, a, b, M[7], 0x676f02d9, 14);
					b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20);

					a = fnH(a, b, c, d, M[5], 0xfffa3942, 4);
					d = fnH(d, a, b, c, M[8], 0x8771f681, 11);
					c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16);
					b = fnH(b, c, d, a, M[14], 0xfde5380c, 23);
					a = fnH(a, b, c, d, M[1], 0xa4beea44, 4);
					d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11);
					c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16);
					b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23);
					a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4);
					d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11);
					c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16);
					b = fnH(b, c, d, a, M[6], 0x04881d05, 23);
					a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4);
					d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11);
					c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16);
					b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23);

					a = fnI(a, b, c, d, M[0], 0xf4292244, 6);
					d = fnI(d, a, b, c, M[7], 0x432aff97, 10);
					c = fnI(c, d, a, b, M[14], 0xab9423a7, 15);
					b = fnI(b, c, d, a, M[5], 0xfc93a039, 21);
					a = fnI(a, b, c, d, M[12], 0x655b59c3, 6);
					d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10);
					c = fnI(c, d, a, b, M[10], 0xffeff47d, 15);
					b = fnI(b, c, d, a, M[1], 0x85845dd1, 21);
					a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6);
					d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10);
					c = fnI(c, d, a, b, M[6], 0xa3014314, 15);
					b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21);
					a = fnI(a, b, c, d, M[4], 0xf7537e82, 6);
					d = fnI(d, a, b, c, M[11], 0xbd3af235, 10);
					c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15);
					b = fnI(b, c, d, a, M[9], 0xeb86d391, 21);

					this._a = (this._a + a) | 0;
					this._b = (this._b + b) | 0;
					this._c = (this._c + c) | 0;
					this._d = (this._d + d) | 0;
				};

				MD5.prototype._digest = function () {
					// create padding and handle blocks
					this._block[this._blockOffset++] = 0x80;
					if (this._blockOffset > 56) {
						this._block.fill(0, this._blockOffset, 64);
						this._update();
						this._blockOffset = 0;
					}

					this._block.fill(0, this._blockOffset, 56);
					this._block.writeUInt32LE(this._length[0], 56);
					this._block.writeUInt32LE(this._length[1], 60);
					this._update();

					// produce result
					var buffer = Buffer.allocUnsafe(16);
					buffer.writeInt32LE(this._a, 0);
					buffer.writeInt32LE(this._b, 4);
					buffer.writeInt32LE(this._c, 8);
					buffer.writeInt32LE(this._d, 12);
					return buffer;
				};

				function rotl(x, n) {
					return (x << n) | (x >>> (32 - n));
				}

				function fnF(a, b, c, d, m, k, s) {
					return (rotl((a + ((b & c) | (~b & d)) + m + k) | 0, s) + b) | 0;
				}

				function fnG(a, b, c, d, m, k, s) {
					return (rotl((a + ((b & d) | (c & ~d)) + m + k) | 0, s) + b) | 0;
				}

				function fnH(a, b, c, d, m, k, s) {
					return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0;
				}

				function fnI(a, b, c, d, m, k, s) {
					return (rotl((a + (c ^ (b | ~d)) + m + k) | 0, s) + b) | 0;
				}

				module.exports = MD5;
			},
			{
				inherits: '../node_modules/inherits/inherits_browser.js',
				'hash-base': '../node_modules/hash-base/index.js',
				'safe-buffer': '../node_modules/safe-buffer/index.js'
			}
		],
		'../node_modules/ripemd160/index.js': [
			function (require, module, exports) {
				'use strict';
				var Buffer = require('buffer').Buffer;
				var inherits = require('inherits');
				var HashBase = require('hash-base');

				var ARRAY16 = new Array(16);

				var zl = [
					0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9,
					5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8,
					12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
				];

				var zr = [
					5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15,
					8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3,
					11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9,
					11
				];

				var sl = [
					11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12,
					15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14,
					15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11,
					8, 5, 6
				];

				var sr = [
					8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7,
					12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8,
					11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15,
					13, 11, 11
				];

				var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e];
				var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000];

				function RIPEMD160() {
					HashBase.call(this, 64);

					// state
					this._a = 0x67452301;
					this._b = 0xefcdab89;
					this._c = 0x98badcfe;
					this._d = 0x10325476;
					this._e = 0xc3d2e1f0;
				}

				inherits(RIPEMD160, HashBase);

				RIPEMD160.prototype._update = function () {
					var words = ARRAY16;
					for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4);

					var al = this._a | 0;
					var bl = this._b | 0;
					var cl = this._c | 0;
					var dl = this._d | 0;
					var el = this._e | 0;

					var ar = this._a | 0;
					var br = this._b | 0;
					var cr = this._c | 0;
					var dr = this._d | 0;
					var er = this._e | 0;

					// computation
					for (var i = 0; i < 80; i += 1) {
						var tl;
						var tr;
						if (i < 16) {
							tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
							tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
						} else if (i < 32) {
							tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
							tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
						} else if (i < 48) {
							tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
							tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
						} else if (i < 64) {
							tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
							tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
						} else {
							// if (i<80) {
							tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
							tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
						}

						al = el;
						el = dl;
						dl = rotl(cl, 10);
						cl = bl;
						bl = tl;

						ar = er;
						er = dr;
						dr = rotl(cr, 10);
						cr = br;
						br = tr;
					}

					// update state
					var t = (this._b + cl + dr) | 0;
					this._b = (this._c + dl + er) | 0;
					this._c = (this._d + el + ar) | 0;
					this._d = (this._e + al + br) | 0;
					this._e = (this._a + bl + cr) | 0;
					this._a = t;
				};

				RIPEMD160.prototype._digest = function () {
					// create padding and handle blocks
					this._block[this._blockOffset++] = 0x80;
					if (this._blockOffset > 56) {
						this._block.fill(0, this._blockOffset, 64);
						this._update();
						this._blockOffset = 0;
					}

					this._block.fill(0, this._blockOffset, 56);
					this._block.writeUInt32LE(this._length[0], 56);
					this._block.writeUInt32LE(this._length[1], 60);
					this._update();

					// produce result
					var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20);
					buffer.writeInt32LE(this._a, 0);
					buffer.writeInt32LE(this._b, 4);
					buffer.writeInt32LE(this._c, 8);
					buffer.writeInt32LE(this._d, 12);
					buffer.writeInt32LE(this._e, 16);
					return buffer;
				};

				function rotl(x, n) {
					return (x << n) | (x >>> (32 - n));
				}

				function fn1(a, b, c, d, e, m, k, s) {
					return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0;
				}

				function fn2(a, b, c, d, e, m, k, s) {
					return (rotl((a + ((b & c) | (~b & d)) + m + k) | 0, s) + e) | 0;
				}

				function fn3(a, b, c, d, e, m, k, s) {
					return (rotl((a + ((b | ~c) ^ d) + m + k) | 0, s) + e) | 0;
				}

				function fn4(a, b, c, d, e, m, k, s) {
					return (rotl((a + ((b & d) | (c & ~d)) + m + k) | 0, s) + e) | 0;
				}

				function fn5(a, b, c, d, e, m, k, s) {
					return (rotl((a + (b ^ (c | ~d)) + m + k) | 0, s) + e) | 0;
				}

				module.exports = RIPEMD160;
			},
			{
				buffer: '../node_modules/node-libs-browser/node_modules/buffer/index.js',
				inherits: '../node_modules/inherits/inherits_browser.js',
				'hash-base': '../node_modules/hash-base/index.js'
			}
		],
		'../node_modules/sha.js/hash.js': [
			function (require, module, exports) {
				var Buffer = require('safe-buffer').Buffer;

				// prototype class for hash functions
				function Hash(blockSize, finalSize) {
					this._block = Buffer.alloc(blockSize);
					this._finalSize = finalSize;
					this._blockSize = blockSize;
					this._len = 0;
				}

				Hash.prototype.update = function (data, enc) {
					if (typeof data === 'string') {
						enc = enc || 'utf8';
						data = Buffer.from(data, enc);
					}

					var block = this._block;
					var blockSize = this._blockSize;
					var length = data.length;
					var accum = this._len;

					for (var offset = 0; offset < length; ) {
						var assigned = accum % blockSize;
						var remainder = Math.min(length - offset, blockSize - assigned);

						for (var i = 0; i < remainder; i++) {
							block[assigned + i] = data[offset + i];
						}

						accum += remainder;
						offset += remainder;

						if (accum % blockSize === 0) {
							this._update(block);
						}
					}

					this._len += length;
					return this;
				};

				Hash.prototype.digest = function (enc) {
					var rem = this._len % this._blockSize;

					this._block[rem] = 0x80;

					// zero (rem + 1) trailing bits, where (rem + 1) is the smallest
					// non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
					this._block.fill(0, rem + 1);

					if (rem >= this._finalSize) {
						this._update(this._block);
						this._block.fill(0);
					}

					var bits = this._len * 8;

					// uint32
					if (bits <= 0xffffffff) {
						this._block.writeUInt32BE(bits, this._blockSize - 4);

						// uint64
					} else {
						var lowBits = (bits & 0xffffffff) >>> 0;
						var highBits = (bits - lowBits) / 0x100000000;

						this._block.writeUInt32BE(highBits, this._blockSize - 8);
						this._block.writeUInt32BE(lowBits, this._blockSize - 4);
					}

					this._update(this._block);
					var hash = this._hash();

					return enc ? hash.toString(enc) : hash;
				};

				Hash.prototype._update = function () {
					throw new Error('_update must be implemented by subclass');
				};

				module.exports = Hash;
			},
			{ 'safe-buffer': '../node_modules/safe-buffer/index.js' }
		],
		'../node_modules/sha.js/sha.js': [
			function (require, module, exports) {
				/*
				 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
				 * in FIPS PUB 180-1
				 * This source code is derived from sha1.js of the same repository.
				 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
				 * operation was added.
				 */

				var inherits = require('inherits');
				var Hash = require('./hash');
				var Buffer = require('safe-buffer').Buffer;

				var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];

				var W = new Array(80);

				function Sha() {
					this.init();
					this._w = W;

					Hash.call(this, 64, 56);
				}

				inherits(Sha, Hash);

				Sha.prototype.init = function () {
					this._a = 0x67452301;
					this._b = 0xefcdab89;
					this._c = 0x98badcfe;
					this._d = 0x10325476;
					this._e = 0xc3d2e1f0;

					return this;
				};

				function rotl5(num) {
					return (num << 5) | (num >>> 27);
				}

				function rotl30(num) {
					return (num << 30) | (num >>> 2);
				}

				function ft(s, b, c, d) {
					if (s === 0) return (b & c) | (~b & d);
					if (s === 2) return (b & c) | (b & d) | (c & d);
					return b ^ c ^ d;
				}

				Sha.prototype._update = function (M) {
					var W = this._w;

					var a = this._a | 0;
					var b = this._b | 0;
					var c = this._c | 0;
					var d = this._d | 0;
					var e = this._e | 0;

					for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
					for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];

					for (var j = 0; j < 80; ++j) {
						var s = ~~(j / 20);
						var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0;

						e = d;
						d = c;
						c = rotl30(b);
						b = a;
						a = t;
					}

					this._a = (a + this._a) | 0;
					this._b = (b + this._b) | 0;
					this._c = (c + this._c) | 0;
					this._d = (d + this._d) | 0;
					this._e = (e + this._e) | 0;
				};

				Sha.prototype._hash = function () {
					var H = Buffer.allocUnsafe(20);

					H.writeInt32BE(this._a | 0, 0);
					H.writeInt32BE(this._b | 0, 4);
					H.writeInt32BE(this._c | 0, 8);
					H.writeInt32BE(this._d | 0, 12);
					H.writeInt32BE(this._e | 0, 16);

					return H;
				};

				module.exports = Sha;
			},
			{
				inherits: '../node_modules/inherits/inherits_browser.js',
				'./hash': '../node_modules/sha.js/hash.js',
				'safe-buffer': '../node_modules/safe-buffer/index.js'
			}
		],
		'../node_modules/sha.js/sha1.js': [
			function (require, module, exports) {
				/*
				 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
				 * in FIPS PUB 180-1
				 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
				 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
				 * Distributed under the BSD License
				 * See http://pajhome.org.uk/crypt/md5 for details.
				 */

				var inherits = require('inherits');
				var Hash = require('./hash');
				var Buffer = require('safe-buffer').Buffer;

				var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];

				var W = new Array(80);

				function Sha1() {
					this.init();
					this._w = W;

					Hash.call(this, 64, 56);
				}

				inherits(Sha1, Hash);

				Sha1.prototype.init = function () {
					this._a = 0x67452301;
					this._b = 0xefcdab89;
					this._c = 0x98badcfe;
					this._d = 0x10325476;
					this._e = 0xc3d2e1f0;

					return this;
				};

				function rotl1(num) {
					return (num << 1) | (num >>> 31);
				}

				function rotl5(num) {
					return (num << 5) | (num >>> 27);
				}

				function rotl30(num) {
					return (num << 30) | (num >>> 2);
				}

				function ft(s, b, c, d) {
					if (s === 0) return (b & c) | (~b & d);
					if (s === 2) return (b & c) | (b & d) | (c & d);
					return b ^ c ^ d;
				}

				Sha1.prototype._update = function (M) {
					var W = this._w;

					var a = this._a | 0;
					var b = this._b | 0;
					var c = this._c | 0;
					var d = this._d | 0;
					var e = this._e | 0;

					for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
					for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);

					for (var j = 0; j < 80; ++j) {
						var s = ~~(j / 20);
						var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0;

						e = d;
						d = c;
						c = rotl30(b);
						b = a;
						a = t;
					}

					this._a = (a + this._a) | 0;
					this._b = (b + this._b) | 0;
					this._c = (c + this._c) | 0;
					this._d = (d + this._d) | 0;
					this._e = (e + this._e) | 0;
				};

				Sha1.prototype._hash = function () {
					var H = Buffer.allocUnsafe(20);

					H.writeInt32BE(this._a | 0, 0);
					H.writeInt32BE(this._b | 0, 4);
					H.writeInt32BE(this._c | 0, 8);
					H.writeInt32BE(this._d | 0, 12);
					H.writeInt32BE(this._e | 0, 16);

					return H;
				};

				module.exports = Sha1;
			},
			{
				inherits: '../node_modules/inherits/inherits_browser.js',
				'./hash': '../node_modules/sha.js/hash.js',
				'safe-buffer': '../node_modules/safe-buffer/index.js'
			}
		],
		'../node_modules/sha.js/sha256.js': [
			function (require, module, exports) {
				/**
				 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
				 * in FIPS 180-2
				 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
				 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
				 *
				 */

				var inherits = require('inherits');
				var Hash = require('./hash');
				var Buffer = require('safe-buffer').Buffer;

				var K = [
					0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4,
					0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe,
					0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f,
					0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
					0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,
					0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
					0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116,
					0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
					0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7,
					0xc67178f2
				];

				var W = new Array(64);

				function Sha256() {
					this.init();

					this._w = W; // new Array(64)

					Hash.call(this, 64, 56);
				}

				inherits(Sha256, Hash);

				Sha256.prototype.init = function () {
					this._a = 0x6a09e667;
					this._b = 0xbb67ae85;
					this._c = 0x3c6ef372;
					this._d = 0xa54ff53a;
					this._e = 0x510e527f;
					this._f = 0x9b05688c;
					this._g = 0x1f83d9ab;
					this._h = 0x5be0cd19;

					return this;
				};

				function ch(x, y, z) {
					return z ^ (x & (y ^ z));
				}

				function maj(x, y, z) {
					return (x & y) | (z & (x | y));
				}

				function sigma0(x) {
					return ((x >>> 2) | (x << 30)) ^ ((x >>> 13) | (x << 19)) ^ ((x >>> 22) | (x << 10));
				}

				function sigma1(x) {
					return ((x >>> 6) | (x << 26)) ^ ((x >>> 11) | (x << 21)) ^ ((x >>> 25) | (x << 7));
				}

				function gamma0(x) {
					return ((x >>> 7) | (x << 25)) ^ ((x >>> 18) | (x << 14)) ^ (x >>> 3);
				}

				function gamma1(x) {
					return ((x >>> 17) | (x << 15)) ^ ((x >>> 19) | (x << 13)) ^ (x >>> 10);
				}

				Sha256.prototype._update = function (M) {
					var W = this._w;

					var a = this._a | 0;
					var b = this._b | 0;
					var c = this._c | 0;
					var d = this._d | 0;
					var e = this._e | 0;
					var f = this._f | 0;
					var g = this._g | 0;
					var h = this._h | 0;

					for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
					for (; i < 64; ++i)
						W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0;

					for (var j = 0; j < 64; ++j) {
						var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0;
						var T2 = (sigma0(a) + maj(a, b, c)) | 0;

						h = g;
						g = f;
						f = e;
						e = (d + T1) | 0;
						d = c;
						c = b;
						b = a;
						a = (T1 + T2) | 0;
					}

					this._a = (a + this._a) | 0;
					this._b = (b + this._b) | 0;
					this._c = (c + this._c) | 0;
					this._d = (d + this._d) | 0;
					this._e = (e + this._e) | 0;
					this._f = (f + this._f) | 0;
					this._g = (g + this._g) | 0;
					this._h = (h + this._h) | 0;
				};

				Sha256.prototype._hash = function () {
					var H = Buffer.allocUnsafe(32);

					H.writeInt32BE(this._a, 0);
					H.writeInt32BE(this._b, 4);
					H.writeInt32BE(this._c, 8);
					H.writeInt32BE(this._d, 12);
					H.writeInt32BE(this._e, 16);
					H.writeInt32BE(this._f, 20);
					H.writeInt32BE(this._g, 24);
					H.writeInt32BE(this._h, 28);

					return H;
				};

				module.exports = Sha256;
			},
			{
				inherits: '../node_modules/inherits/inherits_browser.js',
				'./hash': '../node_modules/sha.js/hash.js',
				'safe-buffer': '../node_modules/safe-buffer/index.js'
			}
		],
		'../node_modules/sha.js/sha224.js': [
			function (require, module, exports) {
				/**
				 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
				 * in FIPS 180-2
				 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
				 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
				 *
				 */

				var inherits = require('inherits');
				var Sha256 = require('./sha256');
				var Hash = require('./hash');
				var Buffer = require('safe-buffer').Buffer;

				var W = new Array(64);

				function Sha224() {
					this.init();

					this._w = W; // new Array(64)

					Hash.call(this, 64, 56);
				}

				inherits(Sha224, Sha256);

				Sha224.prototype.init = function () {
					this._a = 0xc1059ed8;
					this._b = 0x367cd507;
					this._c = 0x3070dd17;
					this._d = 0xf70e5939;
					this._e = 0xffc00b31;
					this._f = 0x68581511;
					this._g = 0x64f98fa7;
					this._h = 0xbefa4fa4;

					return this;
				};

				Sha224.prototype._hash = function () {
					var H = Buffer.allocUnsafe(28);

					H.writeInt32BE(this._a, 0);
					H.writeInt32BE(this._b, 4);
					H.writeInt32BE(this._c, 8);
					H.writeInt32BE(this._d, 12);
					H.writeInt32BE(this._e, 16);
					H.writeInt32BE(this._f, 20);
					H.writeInt32BE(this._g, 24);

					return H;
				};

				module.exports = Sha224;
			},
			{
				inherits: '../node_modules/inherits/inherits_browser.js',
				'./sha256': '../node_modules/sha.js/sha256.js',
				'./hash': '../node_modules/sha.js/hash.js',
				'safe-buffer': '../node_modules/safe-buffer/index.js'
			}
		],
		'../node_modules/sha.js/sha512.js': [
			function (require, module, exports) {
				var inherits = require('inherits');
				var Hash = require('./hash');
				var Buffer = require('safe-buffer').Buffer;

				var K = [
					0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5,
					0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b,
					0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be,
					0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
					0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786,
					0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275,
					0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152,
					0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
					0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967,
					0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed,
					0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e,
					0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
					0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624,
					0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8,
					0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3,
					0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
					0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208,
					0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915,
					0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6,
					0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
					0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b,
					0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6,
					0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
				];

				var W = new Array(160);

				function Sha512() {
					this.init();
					this._w = W;

					Hash.call(this, 128, 112);
				}

				inherits(Sha512, Hash);

				Sha512.prototype.init = function () {
					this._ah = 0x6a09e667;
					this._bh = 0xbb67ae85;
					this._ch = 0x3c6ef372;
					this._dh = 0xa54ff53a;
					this._eh = 0x510e527f;
					this._fh = 0x9b05688c;
					this._gh = 0x1f83d9ab;
					this._hh = 0x5be0cd19;

					this._al = 0xf3bcc908;
					this._bl = 0x84caa73b;
					this._cl = 0xfe94f82b;
					this._dl = 0x5f1d36f1;
					this._el = 0xade682d1;
					this._fl = 0x2b3e6c1f;
					this._gl = 0xfb41bd6b;
					this._hl = 0x137e2179;

					return this;
				};

				function Ch(x, y, z) {
					return z ^ (x & (y ^ z));
				}

				function maj(x, y, z) {
					return (x & y) | (z & (x | y));
				}

				function sigma0(x, xl) {
					return ((x >>> 28) | (xl << 4)) ^ ((xl >>> 2) | (x << 30)) ^ ((xl >>> 7) | (x << 25));
				}

				function sigma1(x, xl) {
					return ((x >>> 14) | (xl << 18)) ^ ((x >>> 18) | (xl << 14)) ^ ((xl >>> 9) | (x << 23));
				}

				function Gamma0(x, xl) {
					return ((x >>> 1) | (xl << 31)) ^ ((x >>> 8) | (xl << 24)) ^ (x >>> 7);
				}

				function Gamma0l(x, xl) {
					return ((x >>> 1) | (xl << 31)) ^ ((x >>> 8) | (xl << 24)) ^ ((x >>> 7) | (xl << 25));
				}

				function Gamma1(x, xl) {
					return ((x >>> 19) | (xl << 13)) ^ ((xl >>> 29) | (x << 3)) ^ (x >>> 6);
				}

				function Gamma1l(x, xl) {
					return ((x >>> 19) | (xl << 13)) ^ ((xl >>> 29) | (x << 3)) ^ ((x >>> 6) | (xl << 26));
				}

				function getCarry(a, b) {
					return a >>> 0 < b >>> 0 ? 1 : 0;
				}

				Sha512.prototype._update = function (M) {
					var W = this._w;

					var ah = this._ah | 0;
					var bh = this._bh | 0;
					var ch = this._ch | 0;
					var dh = this._dh | 0;
					var eh = this._eh | 0;
					var fh = this._fh | 0;
					var gh = this._gh | 0;
					var hh = this._hh | 0;

					var al = this._al | 0;
					var bl = this._bl | 0;
					var cl = this._cl | 0;
					var dl = this._dl | 0;
					var el = this._el | 0;
					var fl = this._fl | 0;
					var gl = this._gl | 0;
					var hl = this._hl | 0;

					for (var i = 0; i < 32; i += 2) {
						W[i] = M.readInt32BE(i * 4);
						W[i + 1] = M.readInt32BE(i * 4 + 4);
					}
					for (; i < 160; i += 2) {
						var xh = W[i - 15 * 2];
						var xl = W[i - 15 * 2 + 1];
						var gamma0 = Gamma0(xh, xl);
						var gamma0l = Gamma0l(xl, xh);

						xh = W[i - 2 * 2];
						xl = W[i - 2 * 2 + 1];
						var gamma1 = Gamma1(xh, xl);
						var gamma1l = Gamma1l(xl, xh);

						// W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
						var Wi7h = W[i - 7 * 2];
						var Wi7l = W[i - 7 * 2 + 1];

						var Wi16h = W[i - 16 * 2];
						var Wi16l = W[i - 16 * 2 + 1];

						var Wil = (gamma0l + Wi7l) | 0;
						var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0;
						Wil = (Wil + gamma1l) | 0;
						Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0;
						Wil = (Wil + Wi16l) | 0;
						Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0;

						W[i] = Wih;
						W[i + 1] = Wil;
					}

					for (var j = 0; j < 160; j += 2) {
						Wih = W[j];
						Wil = W[j + 1];

						var majh = maj(ah, bh, ch);
						var majl = maj(al, bl, cl);

						var sigma0h = sigma0(ah, al);
						var sigma0l = sigma0(al, ah);
						var sigma1h = sigma1(eh, el);
						var sigma1l = sigma1(el, eh);

						// t1 = h + sigma1 + ch + K[j] + W[j]
						var Kih = K[j];
						var Kil = K[j + 1];

						var chh = Ch(eh, fh, gh);
						var chl = Ch(el, fl, gl);

						var t1l = (hl + sigma1l) | 0;
						var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0;
						t1l = (t1l + chl) | 0;
						t1h = (t1h + chh + getCarry(t1l, chl)) | 0;
						t1l = (t1l + Kil) | 0;
						t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0;
						t1l = (t1l + Wil) | 0;
						t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0;

						// t2 = sigma0 + maj
						var t2l = (sigma0l + majl) | 0;
						var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0;

						hh = gh;
						hl = gl;
						gh = fh;
						gl = fl;
						fh = eh;
						fl = el;
						el = (dl + t1l) | 0;
						eh = (dh + t1h + getCarry(el, dl)) | 0;
						dh = ch;
						dl = cl;
						ch = bh;
						cl = bl;
						bh = ah;
						bl = al;
						al = (t1l + t2l) | 0;
						ah = (t1h + t2h + getCarry(al, t1l)) | 0;
					}

					this._al = (this._al + al) | 0;
					this._bl = (this._bl + bl) | 0;
					this._cl = (this._cl + cl) | 0;
					this._dl = (this._dl + dl) | 0;
					this._el = (this._el + el) | 0;
					this._fl = (this._fl + fl) | 0;
					this._gl = (this._gl + gl) | 0;
					this._hl = (this._hl + hl) | 0;

					this._ah = (this._ah + ah + getCarry(this._al, al)) | 0;
					this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0;
					this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0;
					this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0;
					this._eh = (this._eh + eh + getCarry(this._el, el)) | 0;
					this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0;
					this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0;
					this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0;
				};

				Sha512.prototype._hash = function () {
					var H = Buffer.allocUnsafe(64);

					function writeInt64BE(h, l, offset) {
						H.writeInt32BE(h, offset);
						H.writeInt32BE(l, offset + 4);
					}

					writeInt64BE(this._ah, this._al, 0);
					writeInt64BE(this._bh, this._bl, 8);
					writeInt64BE(this._ch, this._cl, 16);
					writeInt64BE(this._dh, this._dl, 24);
					writeInt64BE(this._eh, this._el, 32);
					writeInt64BE(this._fh, this._fl, 40);
					writeInt64BE(this._gh, this._gl, 48);
					writeInt64BE(this._hh, this._hl, 56);

					return H;
				};

				module.exports = Sha512;
			},
			{
				inherits: '../node_modules/inherits/inherits_browser.js',
				'./hash': '../node_modules/sha.js/hash.js',
				'safe-buffer': '../node_modules/safe-buffer/index.js'
			}
		],
		'../node_modules/sha.js/sha384.js': [
			function (require, module, exports) {
				var inherits = require('inherits');
				var SHA512 = require('./sha512');
				var Hash = require('./hash');
				var Buffer = require('safe-buffer').Buffer;

				var W = new Array(160);

				function Sha384() {
					this.init();
					this._w = W;

					Hash.call(this, 128, 112);
				}

				inherits(Sha384, SHA512);

				Sha384.prototype.init = function () {
					this._ah = 0xcbbb9d5d;
					this._bh = 0x629a292a;
					this._ch = 0x9159015a;
					this._dh = 0x152fecd8;
					this._eh = 0x67332667;
					this._fh = 0x8eb44a87;
					this._gh = 0xdb0c2e0d;
					this._hh = 0x47b5481d;

					this._al = 0xc1059ed8;
					this._bl = 0x367cd507;
					this._cl = 0x3070dd17;
					this._dl = 0xf70e5939;
					this._el = 0xffc00b31;
					this._fl = 0x68581511;
					this._gl = 0x64f98fa7;
					this._hl = 0xbefa4fa4;

					return this;
				};

				Sha384.prototype._hash = function () {
					var H = Buffer.allocUnsafe(48);

					function writeInt64BE(h, l, offset) {
						H.writeInt32BE(h, offset);
						H.writeInt32BE(l, offset + 4);
					}

					writeInt64BE(this._ah, this._al, 0);
					writeInt64BE(this._bh, this._bl, 8);
					writeInt64BE(this._ch, this._cl, 16);
					writeInt64BE(this._dh, this._dl, 24);
					writeInt64BE(this._eh, this._el, 32);
					writeInt64BE(this._fh, this._fl, 40);

					return H;
				};

				module.exports = Sha384;
			},
			{
				inherits: '../node_modules/inherits/inherits_browser.js',
				'./sha512': '../node_modules/sha.js/sha512.js',
				'./hash': '../node_modules/sha.js/hash.js',
				'safe-buffer': '../node_modules/safe-buffer/index.js'
			}
		],
		'../node_modules/sha.js/index.js': [
			function (require, module, exports) {
				var exports = (module.exports = function SHA(algorithm) {
					algorithm = algorithm.toLowerCase();

					var Algorithm = exports[algorithm];
					if (!Algorithm)
						throw new Error(algorithm + ' is not supported (we accept pull requests)');

					return new Algorithm();
				});

				exports.sha = require('./sha');
				exports.sha1 = require('./sha1');
				exports.sha224 = require('./sha224');
				exports.sha256 = require('./sha256');
				exports.sha384 = require('./sha384');
				exports.sha512 = require('./sha512');
			},
			{
				'./sha': '../node_modules/sha.js/sha.js',
				'./sha1': '../node_modules/sha.js/sha1.js',
				'./sha224': '../node_modules/sha.js/sha224.js',
				'./sha256': '../node_modules/sha.js/sha256.js',
				'./sha384': '../node_modules/sha.js/sha384.js',
				'./sha512': '../node_modules/sha.js/sha512.js'
			}
		],
		'../node_modules/cipher-base/index.js': [
			function (require, module, exports) {
				var Buffer = require('safe-buffer').Buffer;
				var Transform = require('stream').Transform;
				var StringDecoder = require('string_decoder').StringDecoder;
				var inherits = require('inherits');

				function CipherBase(hashMode) {
					Transform.call(this);
					this.hashMode = typeof hashMode === 'string';
					if (this.hashMode) {
						this[hashMode] = this._finalOrDigest;
					} else {
						this.final = this._finalOrDigest;
					}
					if (this._final) {
						this.__final = this._final;
						this._final = null;
					}
					this._decoder = null;
					this._encoding = null;
				}
				inherits(CipherBase, Transform);

				CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
					if (typeof data === 'string') {
						data = Buffer.from(data, inputEnc);
					}

					var outData = this._update(data);
					if (this.hashMode) return this;

					if (outputEnc) {
						outData = this._toString(outData, outputEnc);
					}

					return outData;
				};

				CipherBase.prototype.setAutoPadding = function () {};
				CipherBase.prototype.getAuthTag = function () {
					throw new Error('trying to get auth tag in unsupported state');
				};

				CipherBase.prototype.setAuthTag = function () {
					throw new Error('trying to set auth tag in unsupported state');
				};

				CipherBase.prototype.setAAD = function () {
					throw new Error('trying to set aad in unsupported state');
				};

				CipherBase.prototype._transform = function (data, _, next) {
					var err;
					try {
						if (this.hashMode) {
							this._update(data);
						} else {
							this.push(this._update(data));
						}
					} catch (e) {
						err = e;
					} finally {
						next(err);
					}
				};
				CipherBase.prototype._flush = function (done) {
					var err;
					try {
						this.push(this.__final());
					} catch (e) {
						err = e;
					}

					done(err);
				};
				CipherBase.prototype._finalOrDigest = function (outputEnc) {
					var outData = this.__final() || Buffer.alloc(0);
					if (outputEnc) {
						outData = this._toString(outData, outputEnc, true);
					}
					return outData;
				};

				CipherBase.prototype._toString = function (value, enc, fin) {
					if (!this._decoder) {
						this._decoder = new StringDecoder(enc);
						this._encoding = enc;
					}

					if (this._encoding !== enc) throw new Error("can't switch encodings");

					var out = this._decoder.write(value);
					if (fin) {
						out += this._decoder.end();
					}

					return out;
				};

				module.exports = CipherBase;
			},
			{
				'safe-buffer': '../node_modules/safe-buffer/index.js',
				stream: '../node_modules/stream-browserify/index.js',
				string_decoder: '../node_modules/string_decoder/lib/string_decoder.js',
				inherits: '../node_modules/inherits/inherits_browser.js'
			}
		],
		'../node_modules/create-hash/browser.js': [
			function (require, module, exports) {
				'use strict';
				var inherits = require('inherits');
				var MD5 = require('md5.js');
				var RIPEMD160 = require('ripemd160');
				var sha = require('sha.js');
				var Base = require('cipher-base');

				function Hash(hash) {
					Base.call(this, 'digest');

					this._hash = hash;
				}

				inherits(Hash, Base);

				Hash.prototype._update = function (data) {
					this._hash.update(data);
				};

				Hash.prototype._final = function () {
					return this._hash.digest();
				};

				module.exports = function createHash(alg) {
					alg = alg.toLowerCase();
					if (alg === 'md5') return new MD5();
					if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160();

					return new Hash(sha(alg));
				};
			},
			{
				inherits: '../node_modules/inherits/inherits_browser.js',
				'md5.js': '../node_modules/md5.js/index.js',
				ripemd160: '../node_modules/ripemd160/index.js',
				'sha.js': '../node_modules/sha.js/index.js',
				'cipher-base': '../node_modules/cipher-base/index.js'
			}
		],
		'../node_modules/base-x/src/index.js': [
			function (require, module, exports) {
				'use strict';
				// base-x encoding / decoding
				// Copyright (c) 2018 base-x contributors
				// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
				// Distributed under the MIT software license, see the accompanying
				// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
				// @ts-ignore
				var _Buffer = require('safe-buffer').Buffer;
				function base(ALPHABET) {
					if (ALPHABET.length >= 255) {
						throw new TypeError('Alphabet too long');
					}
					var BASE_MAP = new Uint8Array(256);
					for (var j = 0; j < BASE_MAP.length; j++) {
						BASE_MAP[j] = 255;
					}
					for (var i = 0; i < ALPHABET.length; i++) {
						var x = ALPHABET.charAt(i);
						var xc = x.charCodeAt(0);
						if (BASE_MAP[xc] !== 255) {
							throw new TypeError(x + ' is ambiguous');
						}
						BASE_MAP[xc] = i;
					}
					var BASE = ALPHABET.length;
					var LEADER = ALPHABET.charAt(0);
					var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
					var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
					function encode(source) {
						if (Array.isArray(source) || source instanceof Uint8Array) {
							source = _Buffer.from(source);
						}
						if (!_Buffer.isBuffer(source)) {
							throw new TypeError('Expected Buffer');
						}
						if (source.length === 0) {
							return '';
						}
						// Skip & count leading zeroes.
						var zeroes = 0;
						var length = 0;
						var pbegin = 0;
						var pend = source.length;
						while (pbegin !== pend && source[pbegin] === 0) {
							pbegin++;
							zeroes++;
						}
						// Allocate enough space in big-endian base58 representation.
						var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
						var b58 = new Uint8Array(size);
						// Process the bytes.
						while (pbegin !== pend) {
							var carry = source[pbegin];
							// Apply "b58 = b58 * 256 + ch".
							var i = 0;
							for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
								carry += (256 * b58[it1]) >>> 0;
								b58[it1] = carry % BASE >>> 0;
								carry = (carry / BASE) >>> 0;
							}
							if (carry !== 0) {
								throw new Error('Non-zero carry');
							}
							length = i;
							pbegin++;
						}
						// Skip leading zeroes in base58 result.
						var it2 = size - length;
						while (it2 !== size && b58[it2] === 0) {
							it2++;
						}
						// Translate the result into a string.
						var str = LEADER.repeat(zeroes);
						for (; it2 < size; ++it2) {
							str += ALPHABET.charAt(b58[it2]);
						}
						return str;
					}
					function decodeUnsafe(source) {
						if (typeof source !== 'string') {
							throw new TypeError('Expected String');
						}
						if (source.length === 0) {
							return _Buffer.alloc(0);
						}
						var psz = 0;
						// Skip leading spaces.
						if (source[psz] === ' ') {
							return;
						}
						// Skip and count leading '1's.
						var zeroes = 0;
						var length = 0;
						while (source[psz] === LEADER) {
							zeroes++;
							psz++;
						}
						// Allocate enough space in big-endian base256 representation.
						var size = ((source.length - psz) * FACTOR + 1) >>> 0; // log(58) / log(256), rounded up.
						var b256 = new Uint8Array(size);
						// Process the characters.
						while (source[psz]) {
							// Decode character
							var carry = BASE_MAP[source.charCodeAt(psz)];
							// Invalid character
							if (carry === 255) {
								return;
							}
							var i = 0;
							for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
								carry += (BASE * b256[it3]) >>> 0;
								b256[it3] = carry % 256 >>> 0;
								carry = (carry / 256) >>> 0;
							}
							if (carry !== 0) {
								throw new Error('Non-zero carry');
							}
							length = i;
							psz++;
						}
						// Skip trailing spaces.
						if (source[psz] === ' ') {
							return;
						}
						// Skip leading zeroes in b256.
						var it4 = size - length;
						while (it4 !== size && b256[it4] === 0) {
							it4++;
						}
						var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
						vch.fill(0x00, 0, zeroes);
						var j = zeroes;
						while (it4 !== size) {
							vch[j++] = b256[it4++];
						}
						return vch;
					}
					function decode(string) {
						var buffer = decodeUnsafe(string);
						if (buffer) {
							return buffer;
						}
						throw new Error('Non-base' + BASE + ' character');
					}
					return {
						encode: encode,
						decodeUnsafe: decodeUnsafe,
						decode: decode
					};
				}
				module.exports = base;
			},
			{ 'safe-buffer': '../node_modules/safe-buffer/index.js' }
		],
		'../node_modules/bs58/index.js': [
			function (require, module, exports) {
				var basex = require('base-x');
				var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

				module.exports = basex(ALPHABET);
			},
			{ 'base-x': '../node_modules/base-x/src/index.js' }
		],
		'../node_modules/bs58check/base.js': [
			function (require, module, exports) {
				'use strict';

				var base58 = require('bs58');
				var Buffer = require('safe-buffer').Buffer;

				module.exports = function (checksumFn) {
					// Encode a buffer as a base58-check encoded string
					function encode(payload) {
						var checksum = checksumFn(payload);

						return base58.encode(Buffer.concat([payload, checksum], payload.length + 4));
					}

					function decodeRaw(buffer) {
						var payload = buffer.slice(0, -4);
						var checksum = buffer.slice(-4);
						var newChecksum = checksumFn(payload);

						if (
							(checksum[0] ^ newChecksum[0]) |
							(checksum[1] ^ newChecksum[1]) |
							(checksum[2] ^ newChecksum[2]) |
							(checksum[3] ^ newChecksum[3])
						)
							return;

						return payload;
					}

					// Decode a base58-check encoded string to a buffer, no result if checksum is wrong
					function decodeUnsafe(string) {
						var buffer = base58.decodeUnsafe(string);
						if (!buffer) return;

						return decodeRaw(buffer);
					}

					function decode(string) {
						var buffer = base58.decode(string);
						var payload = decodeRaw(buffer, checksumFn);
						if (!payload) throw new Error('Invalid checksum');
						return payload;
					}

					return {
						encode: encode,
						decode: decode,
						decodeUnsafe: decodeUnsafe
					};
				};
			},
			{
				bs58: '../node_modules/bs58/index.js',
				'safe-buffer': '../node_modules/safe-buffer/index.js'
			}
		],
		'../node_modules/bs58check/index.js': [
			function (require, module, exports) {
				'use strict';

				var createHash = require('create-hash');
				var bs58checkBase = require('./base');

				// SHA256(SHA256(buffer))
				function sha256x2(buffer) {
					var tmp = createHash('sha256').update(buffer).digest();
					return createHash('sha256').update(tmp).digest();
				}

				module.exports = bs58checkBase(sha256x2);
			},
			{
				'create-hash': '../node_modules/create-hash/browser.js',
				'./base': '../node_modules/bs58check/base.js'
			}
		],
		'../node_modules/blakejs/util.js': [
			function (require, module, exports) {
				var Buffer = require('buffer').Buffer;
				const ERROR_MSG_INPUT = 'Input must be an string, Buffer or Uint8Array';

				// For convenience, let people hash a string, not just a Uint8Array
				function normalizeInput(input) {
					let ret;
					if (input instanceof Uint8Array) {
						ret = input;
					} else if (input instanceof Buffer) {
						ret = new Uint8Array(input);
					} else if (typeof input === 'string') {
						ret = new Uint8Array(Buffer.from(input, 'utf8'));
					} else {
						throw new Error(ERROR_MSG_INPUT);
					}
					return ret;
				}

				// Converts a Uint8Array to a hexadecimal string
				// For example, toHex([255, 0, 255]) returns "ff00ff"
				function toHex(bytes) {
					return Array.prototype.map
						.call(bytes, function (n) {
							return (n < 16 ? '0' : '') + n.toString(16);
						})
						.join('');
				}

				// Converts any value in [0...2^32-1] to an 8-character hex string
				function uint32ToHex(val) {
					return (0x100000000 + val).toString(16).substring(1);
				}

				// For debugging: prints out hash state in the same format as the RFC
				// sample computation exactly, so that you can diff
				function debugPrint(label, arr, size) {
					let msg = '\n' + label + ' = ';
					for (let i = 0; i < arr.length; i += 2) {
						if (size === 32) {
							msg += uint32ToHex(arr[i]).toUpperCase();
							msg += ' ';
							msg += uint32ToHex(arr[i + 1]).toUpperCase();
						} else if (size === 64) {
							msg += uint32ToHex(arr[i + 1]).toUpperCase();
							msg += uint32ToHex(arr[i]).toUpperCase();
						} else throw new Error('Invalid size ' + size);
						if (i % 6 === 4) {
							msg += '\n' + new Array(label.length + 4).join(' ');
						} else if (i < arr.length - 2) {
							msg += ' ';
						}
					}
					console.log(msg);
				}

				// For performance testing: generates N bytes of input, hashes M times
				// Measures and prints MB/second hash performance each time
				function testSpeed(hashFn, N, M) {
					let startMs = new Date().getTime();

					const input = new Uint8Array(N);
					for (let i = 0; i < N; i++) {
						input[i] = i % 256;
					}
					const genMs = new Date().getTime();
					console.log('Generated random input in ' + (genMs - startMs) + 'ms');
					startMs = genMs;

					for (let i = 0; i < M; i++) {
						const hashHex = hashFn(input);
						const hashMs = new Date().getTime();
						const ms = hashMs - startMs;
						startMs = hashMs;
						console.log('Hashed in ' + ms + 'ms: ' + hashHex.substring(0, 20) + '...');
						console.log(Math.round((N / (1 << 20) / (ms / 1000)) * 100) / 100 + ' MB PER SECOND');
					}
				}

				module.exports = {
					normalizeInput: normalizeInput,
					toHex: toHex,
					debugPrint: debugPrint,
					testSpeed: testSpeed
				};
			},
			{ buffer: '../node_modules/node-libs-browser/node_modules/buffer/index.js' }
		],
		'../node_modules/blakejs/blake2b.js': [
			function (require, module, exports) {
				// Blake2B in pure Javascript
				// Adapted from the reference implementation in RFC7693
				// Ported to Javascript by DC - https://github.com/dcposch

				const util = require('./util');

				// 64-bit unsigned addition
				// Sets v[a,a+1] += v[b,b+1]
				// v should be a Uint32Array
				function ADD64AA(v, a, b) {
					const o0 = v[a] + v[b];
					let o1 = v[a + 1] + v[b + 1];
					if (o0 >= 0x100000000) {
						o1++;
					}
					v[a] = o0;
					v[a + 1] = o1;
				}

				// 64-bit unsigned addition
				// Sets v[a,a+1] += b
				// b0 is the low 32 bits of b, b1 represents the high 32 bits
				function ADD64AC(v, a, b0, b1) {
					let o0 = v[a] + b0;
					if (b0 < 0) {
						o0 += 0x100000000;
					}
					let o1 = v[a + 1] + b1;
					if (o0 >= 0x100000000) {
						o1++;
					}
					v[a] = o0;
					v[a + 1] = o1;
				}

				// Little-endian byte access
				function B2B_GET32(arr, i) {
					return arr[i] ^ (arr[i + 1] << 8) ^ (arr[i + 2] << 16) ^ (arr[i + 3] << 24);
				}

				// G Mixing function
				// The ROTRs are inlined for speed
				function B2B_G(a, b, c, d, ix, iy) {
					const x0 = m[ix];
					const x1 = m[ix + 1];
					const y0 = m[iy];
					const y1 = m[iy + 1];

					ADD64AA(v, a, b); // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
					ADD64AC(v, a, x0, x1); // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits

					// v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
					let xor0 = v[d] ^ v[a];
					let xor1 = v[d + 1] ^ v[a + 1];
					v[d] = xor1;
					v[d + 1] = xor0;

					ADD64AA(v, c, d);

					// v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
					xor0 = v[b] ^ v[c];
					xor1 = v[b + 1] ^ v[c + 1];
					v[b] = (xor0 >>> 24) ^ (xor1 << 8);
					v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8);

					ADD64AA(v, a, b);
					ADD64AC(v, a, y0, y1);

					// v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
					xor0 = v[d] ^ v[a];
					xor1 = v[d + 1] ^ v[a + 1];
					v[d] = (xor0 >>> 16) ^ (xor1 << 16);
					v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16);

					ADD64AA(v, c, d);

					// v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
					xor0 = v[b] ^ v[c];
					xor1 = v[b + 1] ^ v[c + 1];
					v[b] = (xor1 >>> 31) ^ (xor0 << 1);
					v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1);
				}

				// Initialization Vector
				const BLAKE2B_IV32 = new Uint32Array([
					0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1,
					0xa54ff53a, 0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab,
					0x137e2179, 0x5be0cd19
				]);

				const SIGMA8 = [
					0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12,
					0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13,
					12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3,
					13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0,
					7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9,
					11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13,
					0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1,
					12, 0, 2, 11, 7, 5, 3
				];

				// These are offsets into a uint64 buffer.
				// Multiply them all by 2 to make them offsets into a uint32 buffer,
				// because this is Javascript and we don't have uint64s
				const SIGMA82 = new Uint8Array(
					SIGMA8.map(function (x) {
						return x * 2;
					})
				);

				// Compression function. 'last' flag indicates last block.
				// Note we're representing 16 uint64s as 32 uint32s
				const v = new Uint32Array(32);
				const m = new Uint32Array(32);
				function blake2bCompress(ctx, last) {
					let i = 0;

					// init work variables
					for (i = 0; i < 16; i++) {
						v[i] = ctx.h[i];
						v[i + 16] = BLAKE2B_IV32[i];
					}

					// low 64 bits of offset
					v[24] = v[24] ^ ctx.t;
					v[25] = v[25] ^ (ctx.t / 0x100000000);
					// high 64 bits not supported, offset may not be higher than 2**53-1

					// last block flag set ?
					if (last) {
						v[28] = ~v[28];
						v[29] = ~v[29];
					}

					// get little-endian words
					for (i = 0; i < 32; i++) {
						m[i] = B2B_GET32(ctx.b, 4 * i);
					}

					// twelve rounds of mixing
					// uncomment the DebugPrint calls to log the computation
					// and match the RFC sample documentation
					// util.debugPrint('          m[16]', m, 64)
					for (i = 0; i < 12; i++) {
						// util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)
						B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
						B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
						B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
						B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
						B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
						B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
						B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
						B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
					}
					// util.debugPrint('   (i=12) v[16]', v, 64)

					for (i = 0; i < 16; i++) {
						ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
					}
					// util.debugPrint('h[8]', ctx.h, 64)
				}

				// Creates a BLAKE2b hashing context
				// Requires an output length between 1 and 64 bytes
				// Takes an optional Uint8Array key
				function blake2bInit(outlen, key) {
					if (outlen === 0 || outlen > 64) {
						throw new Error('Illegal output length, expected 0 < length <= 64');
					}
					if (key && key.length > 64) {
						throw new Error('Illegal key, expected Uint8Array with 0 < length <= 64');
					}

					// state, 'param block'
					const ctx = {
						b: new Uint8Array(128),
						h: new Uint32Array(16),
						t: 0, // input count
						c: 0, // pointer within buffer
						outlen: outlen // output length in bytes
					};

					// initialize hash state
					for (let i = 0; i < 16; i++) {
						ctx.h[i] = BLAKE2B_IV32[i];
					}
					const keylen = key ? key.length : 0;
					ctx.h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen;

					// key the hash, if applicable
					if (key) {
						blake2bUpdate(ctx, key);
						// at the end
						ctx.c = 128;
					}

					return ctx;
				}

				// Updates a BLAKE2b streaming hash
				// Requires hash context and Uint8Array (byte array)
				function blake2bUpdate(ctx, input) {
					for (let i = 0; i < input.length; i++) {
						if (ctx.c === 128) {
							// buffer full ?
							ctx.t += ctx.c; // add counters
							blake2bCompress(ctx, false); // compress (not last)
							ctx.c = 0; // counter to zero
						}
						ctx.b[ctx.c++] = input[i];
					}
				}

				// Completes a BLAKE2b streaming hash
				// Returns a Uint8Array containing the message digest
				function blake2bFinal(ctx) {
					ctx.t += ctx.c; // mark last block offset

					while (ctx.c < 128) {
						// fill up with zeros
						ctx.b[ctx.c++] = 0;
					}
					blake2bCompress(ctx, true); // final block flag = 1

					// little endian convert and store
					const out = new Uint8Array(ctx.outlen);
					for (let i = 0; i < ctx.outlen; i++) {
						out[i] = ctx.h[i >> 2] >> (8 * (i & 3));
					}
					return out;
				}

				// Computes the BLAKE2B hash of a string or byte array, and returns a Uint8Array
				//
				// Returns a n-byte Uint8Array
				//
				// Parameters:
				// - input - the input bytes, as a string, Buffer or Uint8Array
				// - key - optional key Uint8Array, up to 64 bytes
				// - outlen - optional output length in bytes, default 64
				function blake2b(input, key, outlen) {
					// preprocess inputs
					outlen = outlen || 64;
					input = util.normalizeInput(input);

					// do the math
					const ctx = blake2bInit(outlen, key);
					blake2bUpdate(ctx, input);
					return blake2bFinal(ctx);
				}

				// Computes the BLAKE2B hash of a string or byte array
				//
				// Returns an n-byte hash in hex, all lowercase
				//
				// Parameters:
				// - input - the input bytes, as a string, Buffer, or Uint8Array
				// - key - optional key Uint8Array, up to 64 bytes
				// - outlen - optional output length in bytes, default 64
				function blake2bHex(input, key, outlen) {
					const output = blake2b(input, key, outlen);
					return util.toHex(output);
				}

				module.exports = {
					blake2b: blake2b,
					blake2bHex: blake2bHex,
					blake2bInit: blake2bInit,
					blake2bUpdate: blake2bUpdate,
					blake2bFinal: blake2bFinal
				};
			},
			{ './util': '../node_modules/blakejs/util.js' }
		],
		'../node_modules/blakejs/blake2s.js': [
			function (require, module, exports) {
				// BLAKE2s hash function in pure Javascript
				// Adapted from the reference implementation in RFC7693
				// Ported to Javascript by DC - https://github.com/dcposch

				const util = require('./util');

				// Little-endian byte access.
				// Expects a Uint8Array and an index
				// Returns the little-endian uint32 at v[i..i+3]
				function B2S_GET32(v, i) {
					return v[i] ^ (v[i + 1] << 8) ^ (v[i + 2] << 16) ^ (v[i + 3] << 24);
				}

				// Mixing function G.
				function B2S_G(a, b, c, d, x, y) {
					v[a] = v[a] + v[b] + x;
					v[d] = ROTR32(v[d] ^ v[a], 16);
					v[c] = v[c] + v[d];
					v[b] = ROTR32(v[b] ^ v[c], 12);
					v[a] = v[a] + v[b] + y;
					v[d] = ROTR32(v[d] ^ v[a], 8);
					v[c] = v[c] + v[d];
					v[b] = ROTR32(v[b] ^ v[c], 7);
				}

				// 32-bit right rotation
				// x should be a uint32
				// y must be between 1 and 31, inclusive
				function ROTR32(x, y) {
					return (x >>> y) ^ (x << (32 - y));
				}

				// Initialization Vector.
				const BLAKE2S_IV = new Uint32Array([
					0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab,
					0x5be0cd19
				]);

				const SIGMA = new Uint8Array([
					0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12,
					0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13,
					12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3,
					13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0,
					7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9,
					11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13,
					0
				]);

				// Compression function. "last" flag indicates last block
				const v = new Uint32Array(16);
				const m = new Uint32Array(16);
				function blake2sCompress(ctx, last) {
					let i = 0;
					for (i = 0; i < 8; i++) {
						// init work variables
						v[i] = ctx.h[i];
						v[i + 8] = BLAKE2S_IV[i];
					}

					v[12] ^= ctx.t; // low 32 bits of offset
					v[13] ^= ctx.t / 0x100000000; // high 32 bits
					if (last) {
						// last block flag set ?
						v[14] = ~v[14];
					}

					for (i = 0; i < 16; i++) {
						// get little-endian words
						m[i] = B2S_GET32(ctx.b, 4 * i);
					}

					// ten rounds of mixing
					// uncomment the DebugPrint calls to log the computation
					// and match the RFC sample documentation
					// util.debugPrint('          m[16]', m, 32)
					for (i = 0; i < 10; i++) {
						// util.debugPrint('   (i=' + i + ')  v[16]', v, 32)
						B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]]);
						B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]]);
						B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]]);
						B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]]);
						B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]]);
						B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]]);
						B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]]);
						B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]]);
					}
					// util.debugPrint('   (i=10) v[16]', v, 32)

					for (i = 0; i < 8; i++) {
						ctx.h[i] ^= v[i] ^ v[i + 8];
					}
					// util.debugPrint('h[8]', ctx.h, 32)
				}

				// Creates a BLAKE2s hashing context
				// Requires an output length between 1 and 32 bytes
				// Takes an optional Uint8Array key
				function blake2sInit(outlen, key) {
					if (!(outlen > 0 && outlen <= 32)) {
						throw new Error('Incorrect output length, should be in [1, 32]');
					}
					const keylen = key ? key.length : 0;
					if (key && !(keylen > 0 && keylen <= 32)) {
						throw new Error('Incorrect key length, should be in [1, 32]');
					}

					const ctx = {
						h: new Uint32Array(BLAKE2S_IV), // hash state
						b: new Uint8Array(64), // input block
						c: 0, // pointer within block
						t: 0, // input count
						outlen: outlen // output length in bytes
					};
					ctx.h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen;

					if (keylen > 0) {
						blake2sUpdate(ctx, key);
						ctx.c = 64; // at the end
					}

					return ctx;
				}

				// Updates a BLAKE2s streaming hash
				// Requires hash context and Uint8Array (byte array)
				function blake2sUpdate(ctx, input) {
					for (let i = 0; i < input.length; i++) {
						if (ctx.c === 64) {
							// buffer full ?
							ctx.t += ctx.c; // add counters
							blake2sCompress(ctx, false); // compress (not last)
							ctx.c = 0; // counter to zero
						}
						ctx.b[ctx.c++] = input[i];
					}
				}

				// Completes a BLAKE2s streaming hash
				// Returns a Uint8Array containing the message digest
				function blake2sFinal(ctx) {
					ctx.t += ctx.c; // mark last block offset
					while (ctx.c < 64) {
						// fill up with zeros
						ctx.b[ctx.c++] = 0;
					}
					blake2sCompress(ctx, true); // final block flag = 1

					// little endian convert and store
					const out = new Uint8Array(ctx.outlen);
					for (let i = 0; i < ctx.outlen; i++) {
						out[i] = (ctx.h[i >> 2] >> (8 * (i & 3))) & 0xff;
					}
					return out;
				}

				// Computes the BLAKE2S hash of a string or byte array, and returns a Uint8Array
				//
				// Returns a n-byte Uint8Array
				//
				// Parameters:
				// - input - the input bytes, as a string, Buffer, or Uint8Array
				// - key - optional key Uint8Array, up to 32 bytes
				// - outlen - optional output length in bytes, default 64
				function blake2s(input, key, outlen) {
					// preprocess inputs
					outlen = outlen || 32;
					input = util.normalizeInput(input);

					// do the math
					const ctx = blake2sInit(outlen, key);
					blake2sUpdate(ctx, input);
					return blake2sFinal(ctx);
				}

				// Computes the BLAKE2S hash of a string or byte array
				//
				// Returns an n-byte hash in hex, all lowercase
				//
				// Parameters:
				// - input - the input bytes, as a string, Buffer, or Uint8Array
				// - key - optional key Uint8Array, up to 32 bytes
				// - outlen - optional output length in bytes, default 64
				function blake2sHex(input, key, outlen) {
					const output = blake2s(input, key, outlen);
					return util.toHex(output);
				}

				module.exports = {
					blake2s: blake2s,
					blake2sHex: blake2sHex,
					blake2sInit: blake2sInit,
					blake2sUpdate: blake2sUpdate,
					blake2sFinal: blake2sFinal
				};
			},
			{ './util': '../node_modules/blakejs/util.js' }
		],
		'../node_modules/blakejs/index.js': [
			function (require, module, exports) {
				const b2b = require('./blake2b');
				const b2s = require('./blake2s');

				module.exports = {
					blake2b: b2b.blake2b,
					blake2bHex: b2b.blake2bHex,
					blake2bInit: b2b.blake2bInit,
					blake2bUpdate: b2b.blake2bUpdate,
					blake2bFinal: b2b.blake2bFinal,
					blake2s: b2s.blake2s,
					blake2sHex: b2s.blake2sHex,
					blake2sInit: b2s.blake2sInit,
					blake2sUpdate: b2s.blake2sUpdate,
					blake2sFinal: b2s.blake2sFinal
				};
			},
			{
				'./blake2b': '../node_modules/blakejs/blake2b.js',
				'./blake2s': '../node_modules/blakejs/blake2s.js'
			}
		],
		'../node_modules/@taquito/utils/dist/taquito-utils.es5.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.b58cencode = b58cencode;
				exports.b58decode = b58decode;
				exports.bytes2Char = bytes2Char;
				exports.char2Bytes = char2Bytes;
				exports.encodeExpr = encodeExpr;
				exports.encodeKey = encodeKey;
				exports.encodeKeyHash = encodeKeyHash;
				exports.encodeOpHash = encodeOpHash;
				exports.encodePubKey = encodePubKey;
				exports.isValidPrefix = isValidPrefix;
				exports.validateAddress = validateAddress;
				exports.validateChain = validateChain;
				exports.validateContractAddress = validateContractAddress;
				exports.validateKeyHash = validateKeyHash;
				exports.validatePublicKey = validatePublicKey;
				exports.validateSignature = validateSignature;
				exports.prefixLength =
					exports.prefix =
					exports.mic2arr =
					exports.mergebuf =
					exports.hex2buf =
					exports.buf2hex =
					exports.b58cdecode =
					exports.ValidationResult =
					exports.VERSION =
					exports.Prefix =
						void 0;

				var _buffer = require('buffer');

				var _a, _b;

				var Prefix;
				exports.Prefix = Prefix;

				(function (Prefix) {
					Prefix['TZ1'] = 'tz1';
					Prefix['TZ2'] = 'tz2';
					Prefix['TZ3'] = 'tz3';
					Prefix['KT'] = 'KT';
					Prefix['KT1'] = 'KT1';
					Prefix['EDSK2'] = 'edsk2';
					Prefix['SPSK'] = 'spsk';
					Prefix['P2SK'] = 'p2sk';
					Prefix['EDPK'] = 'edpk';
					Prefix['SPPK'] = 'sppk';
					Prefix['P2PK'] = 'p2pk';
					Prefix['EDESK'] = 'edesk';
					Prefix['SPESK'] = 'spesk';
					Prefix['P2ESK'] = 'p2esk';
					Prefix['EDSK'] = 'edsk';
					Prefix['EDSIG'] = 'edsig';
					Prefix['SPSIG'] = 'spsig';
					Prefix['P2SIG'] = 'p2sig';
					Prefix['SIG'] = 'sig';
					Prefix['NET'] = 'Net';
					Prefix['NCE'] = 'nce';
					Prefix['B'] = 'b';
					Prefix['O'] = 'o';
					Prefix['LO'] = 'Lo';
					Prefix['LLO'] = 'LLo';
					Prefix['P'] = 'P';
					Prefix['CO'] = 'Co';
					Prefix['ID'] = 'id';
					Prefix['EXPR'] = 'expr';
					Prefix['TZ'] = 'TZ';
				})(Prefix || (exports.Prefix = Prefix = {}));

				var prefix =
					((_a = {}),
					(_a[Prefix.TZ1] = new Uint8Array([6, 161, 159])),
					(_a[Prefix.TZ2] = new Uint8Array([6, 161, 161])),
					(_a[Prefix.TZ3] = new Uint8Array([6, 161, 164])),
					(_a[Prefix.KT] = new Uint8Array([2, 90, 121])),
					(_a[Prefix.KT1] = new Uint8Array([2, 90, 121])),
					(_a[Prefix.EDSK] = new Uint8Array([43, 246, 78, 7])),
					(_a[Prefix.EDSK2] = new Uint8Array([13, 15, 58, 7])),
					(_a[Prefix.SPSK] = new Uint8Array([17, 162, 224, 201])),
					(_a[Prefix.P2SK] = new Uint8Array([16, 81, 238, 189])),
					(_a[Prefix.EDPK] = new Uint8Array([13, 15, 37, 217])),
					(_a[Prefix.SPPK] = new Uint8Array([3, 254, 226, 86])),
					(_a[Prefix.P2PK] = new Uint8Array([3, 178, 139, 127])),
					(_a[Prefix.EDESK] = new Uint8Array([7, 90, 60, 179, 41])),
					(_a[Prefix.SPESK] = new Uint8Array([0x09, 0xed, 0xf1, 0xae, 0x96])),
					(_a[Prefix.P2ESK] = new Uint8Array([0x09, 0x30, 0x39, 0x73, 0xab])),
					(_a[Prefix.EDSIG] = new Uint8Array([9, 245, 205, 134, 18])),
					(_a[Prefix.SPSIG] = new Uint8Array([13, 115, 101, 19, 63])),
					(_a[Prefix.P2SIG] = new Uint8Array([54, 240, 44, 52])),
					(_a[Prefix.SIG] = new Uint8Array([4, 130, 43])),
					(_a[Prefix.NET] = new Uint8Array([87, 82, 0])),
					(_a[Prefix.NCE] = new Uint8Array([69, 220, 169])),
					(_a[Prefix.B] = new Uint8Array([1, 52])),
					(_a[Prefix.O] = new Uint8Array([5, 116])),
					(_a[Prefix.LO] = new Uint8Array([133, 233])),
					(_a[Prefix.LLO] = new Uint8Array([29, 159, 109])),
					(_a[Prefix.P] = new Uint8Array([2, 170])),
					(_a[Prefix.CO] = new Uint8Array([79, 179])),
					(_a[Prefix.ID] = new Uint8Array([153, 103])),
					(_a[Prefix.EXPR] = new Uint8Array([13, 44, 64, 27])), // Legacy prefix
					(_a[Prefix.TZ] = new Uint8Array([2, 90, 121])),
					_a);
				exports.prefix = prefix;
				var prefixLength =
					((_b = {}),
					(_b[Prefix.TZ1] = 20),
					(_b[Prefix.TZ2] = 20),
					(_b[Prefix.TZ3] = 20),
					(_b[Prefix.KT] = 20),
					(_b[Prefix.KT1] = 20),
					(_b[Prefix.EDPK] = 32),
					(_b[Prefix.SPPK] = 33),
					(_b[Prefix.P2PK] = 33),
					(_b[Prefix.EDSIG] = 64),
					(_b[Prefix.SPSIG] = 64),
					(_b[Prefix.P2SIG] = 64),
					(_b[Prefix.SIG] = 64),
					(_b[Prefix.NET] = 4),
					(_b[Prefix.B] = 32),
					(_b[Prefix.P] = 32),
					(_b[Prefix.O] = 32),
					_b);
				/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

				exports.prefixLength = prefixLength;

				function __read(o, n) {
					var m = typeof Symbol === 'function' && o[Symbol.iterator];
					if (!m) return o;
					var i = m.call(o),
						r,
						ar = [],
						e;

					try {
						while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
							ar.push(r.value);
						}
					} catch (error) {
						e = {
							error: error
						};
					} finally {
						try {
							if (r && !r.done && (m = i['return'])) m.call(i);
						} finally {
							if (e) throw e.error;
						}
					}

					return ar;
				}

				function __spreadArray(to, from) {
					for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {
						to[j] = from[i];
					}

					return to;
				}

				var bs58check$1 = require('bs58check');

				var ValidationResult;
				exports.ValidationResult = ValidationResult;

				(function (ValidationResult) {
					ValidationResult[(ValidationResult['NO_PREFIX_MATCHED'] = 0)] = 'NO_PREFIX_MATCHED';
					ValidationResult[(ValidationResult['INVALID_CHECKSUM'] = 1)] = 'INVALID_CHECKSUM';
					ValidationResult[(ValidationResult['INVALID_LENGTH'] = 2)] = 'INVALID_LENGTH';
					ValidationResult[(ValidationResult['VALID'] = 3)] = 'VALID';
				})(ValidationResult || (exports.ValidationResult = ValidationResult = {}));

				function isValidPrefix(value) {
					if (typeof value !== 'string') {
						return false;
					}

					return value in prefix;
				}
				/**
				 * @description This function is called by the validation functions ([[validateAddress]], [[validateChain]], [[validateContractAddress]], [[validateKeyHash]], [[validateSignature]], [[validatePublicKey]]).
				 * Verify if the value has the right prefix or return `NO_PREFIX_MATCHED`,
				 * decode the value using base58 and return `INVALID_CHECKSUM` if it fails,
				 * check if the length of the value matches the prefix type or return `INVALID_LENGTH`.
				 * If all checks pass, return `VALID`.
				 *
				 * @param value Value to validate
				 * @param prefixes prefix the value should have
				 */

				function validatePrefixedValue(value, prefixes) {
					var match = new RegExp('^(' + prefixes.join('|') + ')').exec(value);

					if (!match || match.length === 0) {
						return ValidationResult.NO_PREFIX_MATCHED;
					}

					var prefixKey = match[0];

					if (!isValidPrefix(prefixKey)) {
						return ValidationResult.NO_PREFIX_MATCHED;
					} // Remove annotation from contract address before doing the validation

					var contractAddress = /^(KT1\w{33})(\%(.*))?/.exec(value);

					if (contractAddress) {
						value = contractAddress[1];
					} // decodeUnsafe return undefined if decoding fail

					var decoded = bs58check$1.decodeUnsafe(value);

					if (!decoded) {
						return ValidationResult.INVALID_CHECKSUM;
					}

					decoded = decoded.slice(prefix[prefixKey].length);

					if (decoded.length !== prefixLength[prefixKey]) {
						return ValidationResult.INVALID_LENGTH;
					}

					return ValidationResult.VALID;
				}

				var implicitPrefix = [Prefix.TZ1, Prefix.TZ2, Prefix.TZ3];
				var contractPrefix = [Prefix.KT1];
				var signaturePrefix = [Prefix.EDSIG, Prefix.P2SIG, Prefix.SPSIG, Prefix.SIG];
				var pkPrefix = [Prefix.EDPK, Prefix.SPPK, Prefix.P2PK];
				/**
				 * @description Used to check if an address or a contract address is valid.
				 *
				 * @returns
				 * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).
				 *
				 * @example
				 * ```
				 * import { validateAddress } from '@taquito/utils';
				 * const pkh = 'tz1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'
				 * const validation = validateAddress(pkh)
				 * console.log(validation)
				 * // This example return 3 which correspond to VALID
				 * ```
				 */

				function validateAddress(value) {
					return validatePrefixedValue(
						value,
						__spreadArray(__spreadArray([], __read(implicitPrefix)), __read(contractPrefix))
					);
				}
				/**
				 * @description Used to check if a chain id is valid.
				 *
				 * @returns
				 * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).
				 *
				 * @example
				 * ```
				 * import { validateChain } from '@taquito/utils';
				 * const chainId = 'NetXdQprcVkpaWU'
				 * const validation = validateChain(chainId)
				 * console.log(validation)
				 * // This example return 3 which correspond to VALID
				 * ```
				 */

				function validateChain(value) {
					return validatePrefixedValue(value, [Prefix.NET]);
				}
				/**
				 * @description Used to check if a contract address is valid.
				 *
				 * @returns
				 * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).
				 *
				 * @example
				 * ```
				 * import { validateContractAddress } from '@taquito/utils';
				 * const contractAddress = 'KT1JVErLYTgtY8uGGZ4mso2npTSxqVLDRVbC'
				 * const validation = validateContractAddress(contractAddress)
				 * console.log(validation)
				 * // This example return 3 which correspond to VALID
				 * ```
				 */

				function validateContractAddress(value) {
					return validatePrefixedValue(value, contractPrefix);
				}
				/**
				 * @description Used to check if a key hash is valid.
				 *
				 * @returns
				 * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).
				 *
				 * @example
				 * ```
				 * import { validateKeyHash } from '@taquito/utils';
				 * const keyHashWithoutPrefix = '1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'
				 * const validation = validateKeyHash(keyHashWithoutPrefix)
				 * console.log(validation)
				 * // This example return 0 which correspond to NO_PREFIX_MATCHED
				 * ```
				 */

				function validateKeyHash(value) {
					return validatePrefixedValue(value, implicitPrefix);
				}
				/**
				 * @description Used to check if a signature is valid.
				 *
				 * @returns
				 * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).
				 *
				 * @example
				 * ```
				 * import { validateSignature } from '@taquito/utils';
				 * const signature = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'
				 * const validation = validateSignature(signature)
				 * console.log(validation)
				 * // This example return 3 which correspond to VALID
				 * ```
				 */

				function validateSignature(value) {
					return validatePrefixedValue(value, signaturePrefix);
				}
				/**
				 * @description Used to check if a signature is valid.
				 *
				 * @returns
				 * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).
				 *
				 * @example
				 * ```
				 * import { validatePublicKey } from '@taquito/utils';
				 * const publicKey = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'
				 * const validation = validatePublicKey(publicKey)
				 * console.log(validation)
				 * // This example return 3 which correspond to VALID
				 * ```
				 */

				function validatePublicKey(value) {
					return validatePrefixedValue(value, pkPrefix);
				} // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!

				/* tslint:disable */

				var VERSION = {
					commitHash: '68be71fd14ffd87bd0a0f91dab60d69c8665e88c',
					version: '10.2.0'
				};
				/* tslint:enable */

				/**
				 * @packageDocumentation
				 * @module @taquito/utils
				 */

				exports.VERSION = VERSION;

				var blake = require('blakejs');

				var bs58check = require('bs58check');
				/**
				 *
				 * @description Hash a string using the BLAKE2b algorithm, base58 encode the hash obtained and appends the prefix 'expr' to it
				 *
				 * @param value Value in hex
				 */

				function encodeExpr(value) {
					var blakeHash = blake.blake2b(hex2buf(value), null, 32);
					return b58cencode(blakeHash, prefix['expr']);
				}
				/**
				 *
				 * @description Return the operation hash of a signed operation
				 * @param value Value in hex of a signed operation
				 */

				function encodeOpHash(value) {
					var blakeHash = blake.blake2b(hex2buf(value), null, 32);
					return b58cencode(blakeHash, prefix.o);
				}
				/**
				 *
				 * @description Base58 encode a string or a Uint8Array and append a prefix to it
				 *
				 * @param value Value to base58 encode
				 * @param prefix prefix to append to the encoded string
				 */

				function b58cencode(value, prefix) {
					var payloadAr =
						typeof value === 'string' ? Uint8Array.from(_buffer.Buffer.from(value, 'hex')) : value;
					var n = new Uint8Array(prefix.length + payloadAr.length);
					n.set(prefix);
					n.set(payloadAr, prefix.length);
					return bs58check.encode(_buffer.Buffer.from(n.buffer));
				}
				/**
				 *
				 * @description Base58 decode a string and remove the prefix from it
				 *
				 * @param value Value to base58 decode
				 * @param prefix prefix to remove from the decoded string
				 */

				var b58cdecode = function (enc, prefixArg) {
					return bs58check.decode(enc).slice(prefixArg.length);
				};
				/**
				 *
				 * @description Base58 decode a string with predefined prefix
				 *
				 * @param value Value to base58 decode
				 */

				exports.b58cdecode = b58cdecode;

				function b58decode(payload) {
					var _a;

					var buf = bs58check.decode(payload);
					var prefixMap =
						((_a = {}),
						(_a[prefix.tz1.toString()] = '0000'),
						(_a[prefix.tz2.toString()] = '0001'),
						(_a[prefix.tz3.toString()] = '0002'),
						_a);
					var pref = prefixMap[new Uint8Array(buf.slice(0, 3)).toString()];

					if (pref) {
						// tz addresses
						var hex = buf2hex(buf.slice(3));
						return pref + hex;
					} else {
						// other (kt addresses)
						return '01' + buf2hex(buf.slice(3, 42)) + '00';
					}
				}
				/**
				 *
				 * @description Base58 encode a public key using predefined prefix
				 *
				 * @param value Public Key to base58 encode
				 */

				function encodePubKey(value) {
					if (value.substring(0, 2) === '00') {
						var pref = {
							'0000': prefix.tz1,
							'0001': prefix.tz2,
							'0002': prefix.tz3
						};
						return b58cencode(value.substring(4), pref[value.substring(0, 4)]);
					}

					return b58cencode(value.substring(2, 42), prefix.KT);
				}
				/**
				 *
				 * @description Base58 encode a key according to its prefix
				 *
				 * @param value Key to base58 encode
				 */

				function encodeKey(value) {
					if (value[0] === '0') {
						var pref = {
							'00': new Uint8Array([13, 15, 37, 217]),
							'01': new Uint8Array([3, 254, 226, 86]),
							'02': new Uint8Array([3, 178, 139, 127])
						};
						return b58cencode(value.substring(2), pref[value.substring(0, 2)]);
					}
				}
				/**
				 *
				 * @description Base58 encode a key hash according to its prefix
				 *
				 * @param value Key to base58 encode
				 */

				function encodeKeyHash(value) {
					if (value[0] === '0') {
						var pref = {
							'00': new Uint8Array([6, 161, 159]),
							'01': new Uint8Array([6, 161, 161]),
							'02': new Uint8Array([6, 161, 164])
						};
						return b58cencode(value.substring(2), pref[value.substring(0, 2)]);
					}
				}
				/**
				 *
				 * @description Convert an hex string to a Uint8Array
				 *
				 * @param hex Hex string to convert
				 */

				var hex2buf = function (hex) {
					return new Uint8Array(
						hex.match(/[\da-f]{2}/gi).map(function (h) {
							return parseInt(h, 16);
						})
					);
				};
				/**
				 *
				 * @description Merge 2 buffers together
				 *
				 * @param b1 First buffer
				 * @param b2 Second buffer
				 */

				exports.hex2buf = hex2buf;

				var mergebuf = function (b1, b2) {
					var r = new Uint8Array(b1.length + b2.length);
					r.set(b1);
					r.set(b2, b1.length);
					return r;
				};
				/**
				 *
				 * @description Flatten a michelson json representation to an array
				 *
				 * @param s michelson json
				 */

				exports.mergebuf = mergebuf;

				var mic2arr = function me2(s) {
					var ret = [];

					if (Object.prototype.hasOwnProperty.call(s, 'prim')) {
						if (s.prim === 'Pair') {
							ret.push(me2(s.args[0]));
							ret = ret.concat(me2(s.args[1]));
						} else if (s.prim === 'Elt') {
							ret = {
								key: me2(s.args[0]),
								val: me2(s.args[1])
							};
						} else if (s.prim === 'True') {
							ret = true;
						} else if (s.prim === 'False') {
							ret = false;
						}
					} else if (Array.isArray(s)) {
						var sc = s.length;

						for (var i = 0; i < sc; i++) {
							var n = me2(s[i]);

							if (typeof n.key !== 'undefined') {
								if (Array.isArray(ret)) {
									ret = {
										keys: [],
										vals: []
									};
								}

								ret.keys.push(n.key);
								ret.vals.push(n.val);
							} else {
								ret.push(n);
							}
						}
					} else if (Object.prototype.hasOwnProperty.call(s, 'string')) {
						ret = s.string;
					} else if (Object.prototype.hasOwnProperty.call(s, 'int')) {
						ret = parseInt(s.int, 10);
					} else {
						ret = s;
					}

					return ret;
				};
				/**
				 *
				 * @description Convert a buffer to an hex string
				 *
				 * @param buffer Buffer to convert
				 */

				exports.mic2arr = mic2arr;

				var buf2hex = function (buffer) {
					var byteArray = new Uint8Array(buffer);
					var hexParts = [];
					byteArray.forEach(function (byte) {
						var hex = byte.toString(16);
						var paddedHex = ('00' + hex).slice(-2);
						hexParts.push(paddedHex);
					});
					return hexParts.join('');
				};
				/**
				 *
				 * @description Convert a string to bytes
				 *
				 * @param str String to convert
				 */

				exports.buf2hex = buf2hex;

				function char2Bytes(str) {
					return _buffer.Buffer.from(str, 'utf8').toString('hex');
				}
				/**
				 *
				 * @description Convert bytes to a string
				 *
				 * @param str Bytes to convert
				 */

				function bytes2Char(hex) {
					return _buffer.Buffer.from(hex2buf(hex)).toString('utf8');
				}
			},
			{
				buffer: '../node_modules/node-libs-browser/node_modules/buffer/index.js',
				bs58check: '../node_modules/bs58check/index.js',
				blakejs: '../node_modules/blakejs/index.js'
			}
		],
		'../node_modules/@taquito/michelson-encoder/dist/taquito-michelson-encoder.es5.js': [
			function (require, module, exports) {
				var Buffer = require('buffer').Buffer;
				('use strict');

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.VERSION =
					exports.UnitValue =
					exports.SignatureValidationError =
					exports.SetValidationError =
					exports.Schema =
					exports.SaplingStateValue =
					exports.ParameterSchema =
					exports.NatValidationError =
					exports.MutezValidationError =
					exports.MichelsonMap =
					exports.MapValidationError =
					exports.MapTypecheckError =
					exports.ListValidationError =
					exports.KeyValidationError =
					exports.KeyHashValidationError =
					exports.IntValidationError =
					exports.EncodeTicketError =
					exports.ContractValidationError =
					exports.ChainIDValidationError =
					exports.BytesValidationError =
					exports.BigMapValidationError =
					exports.AddressValidationError =
						void 0;

				var _fastJsonStableStringify = _interopRequireDefault(
					require('fast-json-stable-stringify')
				);

				var _bignumber = _interopRequireDefault(require('bignumber.js'));

				var _utils = require('@taquito/utils');

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj };
				}

				function _typeof(obj) {
					if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
						_typeof = function (obj) {
							return typeof obj;
						};
					} else {
						_typeof = function (obj) {
							return obj &&
								typeof Symbol === 'function' &&
								obj.constructor === Symbol &&
								obj !== Symbol.prototype
								? 'symbol'
								: typeof obj;
						};
					}
					return _typeof(obj);
				}

				/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

				/* global Reflect, Promise */
				var extendStatics = function (d, b) {
					extendStatics =
						Object.setPrototypeOf ||
						({
							__proto__: []
						} instanceof Array &&
							function (d, b) {
								d.__proto__ = b;
							}) ||
						function (d, b) {
							for (var p in b) {
								if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
							}
						};

					return extendStatics(d, b);
				};

				function __extends(d, b) {
					if (typeof b !== 'function' && b !== null)
						throw new TypeError(
							'Class extends value ' + String(b) + ' is not a constructor or null'
						);
					extendStatics(d, b);

					function __() {
						this.constructor = d;
					}

					d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
				}

				var __assign = function () {
					__assign =
						Object.assign ||
						function __assign(t) {
							for (var s, i = 1, n = arguments.length; i < n; i++) {
								s = arguments[i];

								for (var p in s) {
									if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
								}
							}

							return t;
						};

					return __assign.apply(this, arguments);
				};

				function __generator(thisArg, body) {
					var _ = {
							label: 0,
							sent: function () {
								if (t[0] & 1) throw t[1];
								return t[1];
							},
							trys: [],
							ops: []
						},
						f,
						y,
						t,
						g;
					return (
						(g = {
							next: verb(0),
							throw: verb(1),
							return: verb(2)
						}),
						typeof Symbol === 'function' &&
							(g[Symbol.iterator] = function () {
								return this;
							}),
						g
					);

					function verb(n) {
						return function (v) {
							return step([n, v]);
						};
					}

					function step(op) {
						if (f) throw new TypeError('Generator is already executing.');

						while (_) {
							try {
								if (
									((f = 1),
									y &&
										(t =
											op[0] & 2
												? y['return']
												: op[0]
												? y['throw'] || ((t = y['return']) && t.call(y), 0)
												: y.next) &&
										!(t = t.call(y, op[1])).done)
								)
									return t;
								if (((y = 0), t)) op = [op[0] & 2, t.value];

								switch (op[0]) {
									case 0:
									case 1:
										t = op;
										break;

									case 4:
										_.label++;
										return {
											value: op[1],
											done: false
										};

									case 5:
										_.label++;
										y = op[1];
										op = [0];
										continue;

									case 7:
										op = _.ops.pop();

										_.trys.pop();

										continue;

									default:
										if (
											!((t = _.trys), (t = t.length > 0 && t[t.length - 1])) &&
											(op[0] === 6 || op[0] === 2)
										) {
											_ = 0;
											continue;
										}

										if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
											_.label = op[1];
											break;
										}

										if (op[0] === 6 && _.label < t[1]) {
											_.label = t[1];
											t = op;
											break;
										}

										if (t && _.label < t[2]) {
											_.label = t[2];

											_.ops.push(op);

											break;
										}

										if (t[2]) _.ops.pop();

										_.trys.pop();

										continue;
								}

								op = body.call(thisArg, _);
							} catch (e) {
								op = [6, e];
								y = 0;
							} finally {
								f = t = 0;
							}
						}

						if (op[0] & 5) throw op[1];
						return {
							value: op[0] ? op[1] : void 0,
							done: true
						};
					}
				}

				function __values(o) {
					var s = typeof Symbol === 'function' && Symbol.iterator,
						m = s && o[s],
						i = 0;
					if (m) return m.call(o);
					if (o && typeof o.length === 'number')
						return {
							next: function () {
								if (o && i >= o.length) o = void 0;
								return {
									value: o && o[i++],
									done: !o
								};
							}
						};
					throw new TypeError(s ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
				}

				function __read(o, n) {
					var m = typeof Symbol === 'function' && o[Symbol.iterator];
					if (!m) return o;
					var i = m.call(o),
						r,
						ar = [],
						e;

					try {
						while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
							ar.push(r.value);
						}
					} catch (error) {
						e = {
							error: error
						};
					} finally {
						try {
							if (r && !r.done && (m = i['return'])) m.call(i);
						} finally {
							if (e) throw e.error;
						}
					}

					return ar;
				}

				function __spreadArray(to, from) {
					for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {
						to[j] = from[i];
					}

					return to;
				}

				var _a$1; // Retrieve a unique symbol associated with the key from the environment
				// Used in order to identify all object that are of type MichelsonMap even if they come from different module

				var michelsonMapTypeSymbol = Symbol.for('taquito-michelson-map-type-symbol');

				var isMapType = function (value) {
					return 'args' in value && Array.isArray(value.args) && value.args.length === 2;
				};

				var MapTypecheckError =
					/** @class */
					(function () {
						function MapTypecheckError(value, type, errorType) {
							this.value = value;
							this.type = type;
							this.name = 'MapTypecheckError';
							this.message = errorType + ' not compliant with underlying michelson type';
						}

						return MapTypecheckError;
					})();
				/**
				 * @description Michelson Map is an abstraction over the michelson native map. It supports complex Pair as key
				 */

				exports.MapTypecheckError = MapTypecheckError;

				var MichelsonMap =
					/** @class */
					(function () {
						/**
						 * @param mapType If specified key and value will be type-checked before being added to the map
						 *
						 * @example new MichelsonMap({ prim: "map", args: [{prim: "string"}, {prim: "int"}]})
						 */
						function MichelsonMap(mapType) {
							this.valueMap = new Map();
							this.keyMap = new Map();
							this[_a$1] = true;

							if (mapType) {
								this.setType(mapType);
							}
						} // Used to check if an object is a michelson map.
						// Using instanceof was not working for project that had multiple instance of taquito dependencies
						// as the class constructor is different

						MichelsonMap.isMichelsonMap = function (obj) {
							return obj && obj[michelsonMapTypeSymbol] === true;
						};

						MichelsonMap.prototype.setType = function (mapType) {
							if (!isMapType(mapType)) {
								throw new Error('mapType is not a valid michelson map type');
							}

							this.keySchema = new Schema(mapType.args[0]);
							this.valueSchema = new Schema(mapType.args[1]);
						};

						MichelsonMap.prototype.removeType = function () {
							this.keySchema = undefined;
							this.valueSchema = undefined;
						};

						MichelsonMap.fromLiteral = function (obj, mapType) {
							var map = new MichelsonMap(mapType);
							Object.keys(obj).forEach(function (key) {
								map.set(key, obj[key]);
							});
							return map;
						};

						MichelsonMap.prototype.typecheckKey = function (key) {
							if (this.keySchema) {
								return this.keySchema.Typecheck(key);
							}

							return true;
						};

						MichelsonMap.prototype.typecheckValue = function (value) {
							if (this.valueSchema) {
								return this.valueSchema.Typecheck(value);
							}

							return true;
						};

						MichelsonMap.prototype.assertTypecheckValue = function (value) {
							if (!this.typecheckValue(value)) {
								throw new MapTypecheckError(value, this.valueSchema, 'value');
							}
						};

						MichelsonMap.prototype.assertTypecheckKey = function (key) {
							if (!this.typecheckKey(key)) {
								throw new MapTypecheckError(key, this.keySchema, 'key');
							}
						};

						MichelsonMap.prototype.serializeDeterministically = function (key) {
							return (0, _fastJsonStableStringify.default)(key);
						};

						MichelsonMap.prototype.keys = function () {
							var _b, _c, _d, key, e_1_1;

							var e_1, _e;

							return __generator(this, function (_f) {
								switch (_f.label) {
									case 0:
										_f.trys.push([0, 5, 6, 7]);

										(_b = __values(this.entries())), (_c = _b.next());
										_f.label = 1;

									case 1:
										if (!!_c.done) return [3 /*break*/, 4];
										(_d = __read(_c.value, 1)), (key = _d[0]);
										return [
											4,
											/*yield*/
											key
										];

									case 2:
										_f.sent();

										_f.label = 3;

									case 3:
										_c = _b.next();
										return [3 /*break*/, 1];

									case 4:
										return [3 /*break*/, 7];

									case 5:
										e_1_1 = _f.sent();
										e_1 = {
											error: e_1_1
										};
										return [3 /*break*/, 7];

									case 6:
										try {
											if (_c && !_c.done && (_e = _b.return)) _e.call(_b);
										} finally {
											if (e_1) throw e_1.error;
										}

										return [
											7
											/*endfinally*/
										];

									case 7:
										return [
											2
											/*return*/
										];
								}
							});
						};

						MichelsonMap.prototype.values = function () {
							var _b, _c, _d, value, e_2_1;

							var e_2, _e;

							return __generator(this, function (_f) {
								switch (_f.label) {
									case 0:
										_f.trys.push([0, 5, 6, 7]);

										(_b = __values(this.entries())), (_c = _b.next());
										_f.label = 1;

									case 1:
										if (!!_c.done) return [3 /*break*/, 4];
										(_d = __read(_c.value, 2)), (value = _d[1]);
										return [
											4,
											/*yield*/
											value
										];

									case 2:
										_f.sent();

										_f.label = 3;

									case 3:
										_c = _b.next();
										return [3 /*break*/, 1];

									case 4:
										return [3 /*break*/, 7];

									case 5:
										e_2_1 = _f.sent();
										e_2 = {
											error: e_2_1
										};
										return [3 /*break*/, 7];

									case 6:
										try {
											if (_c && !_c.done && (_e = _b.return)) _e.call(_b);
										} finally {
											if (e_2) throw e_2.error;
										}

										return [
											7
											/*endfinally*/
										];

									case 7:
										return [
											2
											/*return*/
										];
								}
							});
						};

						MichelsonMap.prototype.entries = function () {
							var _b, _c, key, e_3_1;

							var e_3, _d;

							return __generator(this, function (_e) {
								switch (_e.label) {
									case 0:
										_e.trys.push([0, 5, 6, 7]);

										(_b = __values(this.valueMap.keys())), (_c = _b.next());
										_e.label = 1;

									case 1:
										if (!!_c.done) return [3 /*break*/, 4];
										key = _c.value;
										return [
											4,
											/*yield*/
											[this.keyMap.get(key), this.valueMap.get(key)]
										];

									case 2:
										_e.sent();

										_e.label = 3;

									case 3:
										_c = _b.next();
										return [3 /*break*/, 1];

									case 4:
										return [3 /*break*/, 7];

									case 5:
										e_3_1 = _e.sent();
										e_3 = {
											error: e_3_1
										};
										return [3 /*break*/, 7];

									case 6:
										try {
											if (_c && !_c.done && (_d = _b.return)) _d.call(_b);
										} finally {
											if (e_3) throw e_3.error;
										}

										return [
											7
											/*endfinally*/
										];

									case 7:
										return [
											2
											/*return*/
										];
								}
							});
						};

						MichelsonMap.prototype.get = function (key) {
							this.assertTypecheckKey(key);
							var strKey = this.serializeDeterministically(key);
							return this.valueMap.get(strKey);
						};
						/**
						 *
						 * @description Set a key and a value in the MichelsonMap. If the key already exists, override the current value.
						 *
						 * @example map.set("myKey", "myValue") // Using a string as key
						 *
						 * @example map.set({0: "test", 1: "test1"}, "myValue") // Using a pair as key
						 *
						 * @warn The same key can be represented in multiple ways, depending on the type of the key. This duplicate key situation will cause a runtime error (duplicate key) when sending the map data to the Tezos RPC node.
						 *
						 * For example, consider a contract with a map whose key is of type boolean.  If you set the following values in MichelsonMap: map.set(false, "myValue") and map.set(null, "myValue").
						 *
						 * You will get two unique entries in the MichelsonMap. These values will both be evaluated as falsy by the MichelsonEncoder and ultimately rejected by the Tezos RPC.
						 */

						MichelsonMap.prototype.set = function (key, value) {
							this.assertTypecheckKey(key);
							this.assertTypecheckValue(value);
							var strKey = this.serializeDeterministically(key);
							this.keyMap.set(strKey, key);
							this.valueMap.set(strKey, value);
						};

						MichelsonMap.prototype.delete = function (key) {
							this.assertTypecheckKey(key);
							this.keyMap.delete(this.serializeDeterministically(key));
							this.valueMap.delete(this.serializeDeterministically(key));
						};

						MichelsonMap.prototype.has = function (key) {
							this.assertTypecheckKey(key);
							var strKey = this.serializeDeterministically(key);
							return this.keyMap.has(strKey) && this.valueMap.has(strKey);
						};

						MichelsonMap.prototype.clear = function () {
							this.keyMap.clear();
							this.valueMap.clear();
						};

						Object.defineProperty(MichelsonMap.prototype, 'size', {
							get: function () {
								return this.keyMap.size;
							},
							enumerable: false,
							configurable: true
						});

						MichelsonMap.prototype.forEach = function (cb) {
							var e_4, _b;

							try {
								for (var _c = __values(this.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
									var _e = __read(_d.value, 2),
										key = _e[0],
										value = _e[1];

									cb(value, key, this);
								}
							} catch (e_4_1) {
								e_4 = {
									error: e_4_1
								};
							} finally {
								try {
									if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
								} finally {
									if (e_4) throw e_4.error;
								}
							}
						};

						return MichelsonMap;
					})();

				exports.MichelsonMap = MichelsonMap;
				_a$1 = michelsonMapTypeSymbol;

				var TokenValidationError =
					/** @class */
					(function () {
						function TokenValidationError(value, token, baseMessage) {
							this.value = value;
							this.token = token;
							this.name = 'ValidationError';
							var annot = this.token.annot();
							var annotText = annot ? '[' + annot + '] ' : '';
							this.message = '' + annotText + baseMessage;
						}

						return TokenValidationError;
					})();

				var Token =
					/** @class */
					(function () {
						function Token(val, idx, fac) {
							this.val = val;
							this.idx = idx;
							this.fac = fac;
							this.createToken = this.fac;
						}

						Token.prototype.typeWithoutAnnotations = function () {
							var removeArgsRec = function (val) {
								if (val.args) {
									return {
										prim: val.prim,
										args: val.args.map(function (x) {
											return removeArgsRec(x);
										})
									};
								} else {
									return {
										prim: val.prim
									};
								}
							};

							return removeArgsRec(this.val);
						};

						Token.prototype.annot = function () {
							return (
								Array.isArray(this.val.annots) && this.val.annots.length > 0
									? this.val.annots[0]
									: String(this.idx)
							).replace(/(%|\:)(_Liq_entry_)?/, '');
						};

						Token.prototype.hasAnnotations = function () {
							return Array.isArray(this.val.annots) && this.val.annots.length;
						};

						Token.prototype.ExtractSignature = function () {
							return [[this.ExtractSchema()]];
						};

						return Token;
					})();

				var ComparableToken =
					/** @class */
					(function (_super) {
						__extends(ComparableToken, _super);

						function ComparableToken() {
							return (_super !== null && _super.apply(this, arguments)) || this;
						}

						ComparableToken.prototype.compare = function (o1, o2) {
							if (o1 === o2) {
								return 0;
							}

							return o1 < o2 ? -1 : 1;
						};

						return ComparableToken;
					})(Token);

				var BigMapValidationError =
					/** @class */
					(function (_super) {
						__extends(BigMapValidationError, _super);

						function BigMapValidationError(value, token, message) {
							var _this = _super.call(this, value, token, message) || this;

							_this.value = value;
							_this.token = token;
							_this.name = 'BigMapValidationError';
							return _this;
						}

						return BigMapValidationError;
					})(TokenValidationError);

				exports.BigMapValidationError = BigMapValidationError;

				var BigMapToken =
					/** @class */
					(function (_super) {
						__extends(BigMapToken, _super);

						function BigMapToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						Object.defineProperty(BigMapToken.prototype, 'ValueSchema', {
							get: function () {
								return this.createToken(this.val.args[1], 0);
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(BigMapToken.prototype, 'KeySchema', {
							get: function () {
								return this.createToken(this.val.args[0], 0);
							},
							enumerable: false,
							configurable: true
						});

						BigMapToken.prototype.ExtractSchema = function () {
							return {
								big_map: {
									key: this.KeySchema.ExtractSchema(),
									value: this.ValueSchema.ExtractSchema()
								}
							};
						};

						BigMapToken.prototype.isValid = function (value) {
							if (MichelsonMap.isMichelsonMap(value)) {
								return null;
							}

							return new BigMapValidationError(value, this, 'Value must be a MichelsonMap');
						};

						BigMapToken.prototype.Encode = function (args) {
							var _this = this;

							var val = args.pop();
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return Array.from(val.keys())
								.sort(function (a, b) {
									return _this.KeySchema.compare(a, b);
								})
								.map(function (key) {
									return {
										prim: 'Elt',
										args: [
											_this.KeySchema.EncodeObject(key),
											_this.ValueSchema.EncodeObject(val.get(key))
										]
									};
								});
						};

						BigMapToken.prototype.EncodeObject = function (args) {
							var _this = this;

							var val = args;
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return Array.from(val.keys())
								.sort(function (a, b) {
									return _this.KeySchema.compare(a, b);
								})
								.map(function (key) {
									return {
										prim: 'Elt',
										args: [
											_this.KeySchema.EncodeObject(key),
											_this.ValueSchema.EncodeObject(val.get(key))
										]
									};
								});
						};

						BigMapToken.prototype.Execute = function (val, semantic) {
							var _this = this;

							if (semantic && semantic[BigMapToken.prim]) {
								return semantic[BigMapToken.prim](val, this.val);
							}

							if (Array.isArray(val)) {
								// Athens is returning an empty array for big map in storage
								// Internal: In taquito v5 it is still used to decode big map diff (as if they were a regular map)
								var map_1 = new MichelsonMap(this.val);
								val.forEach(function (current) {
									map_1.set(
										_this.KeySchema.ToKey(current.args[0]),
										_this.ValueSchema.Execute(current.args[1])
									);
								});
								return map_1;
							} else if ('int' in val) {
								// Babylon is returning an int with the big map id in contract storage
								return val.int;
							} else {
								// Unknown case
								throw new Error(
									'Big map is expecting either an array (Athens) or an object with an int property (Babylon). Got ' +
										JSON.stringify(val)
								);
							}
						};

						BigMapToken.prim = 'big_map';
						return BigMapToken;
					})(Token);

				var OrToken =
					/** @class */
					(function (_super) {
						__extends(OrToken, _super);

						function OrToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						OrToken.prototype.Encode = function (args) {
							var label = args[args.length - 1];
							var leftToken = this.createToken(this.val.args[0], this.idx);
							var keyCount = 1;

							if (leftToken instanceof OrToken) {
								keyCount = Object.keys(leftToken.ExtractSchema()).length;
							}

							var rightToken = this.createToken(this.val.args[1], this.idx + keyCount);

							if (String(leftToken.annot()) === String(label) && !(leftToken instanceof OrToken)) {
								args.pop();
								return {
									prim: 'Left',
									args: [leftToken.Encode(args)]
								};
							} else if (
								String(rightToken.annot()) === String(label) &&
								!(rightToken instanceof OrToken)
							) {
								args.pop();
								return {
									prim: 'Right',
									args: [rightToken.Encode(args)]
								};
							} else {
								if (leftToken instanceof OrToken) {
									var val = leftToken.Encode(args);

									if (val) {
										return {
											prim: 'Left',
											args: [val]
										};
									}
								}

								if (rightToken instanceof OrToken) {
									var val = rightToken.Encode(args);

									if (val) {
										return {
											prim: 'Right',
											args: [val]
										};
									}
								}

								return null;
							}
						};

						OrToken.prototype.ExtractSignature = function () {
							var e_1, _a, e_2, _b;

							var leftToken = this.createToken(this.val.args[0], this.idx);
							var keyCount = 1;

							if (leftToken instanceof OrToken) {
								keyCount = Object.keys(leftToken.ExtractSchema()).length;
							}

							var rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
							var newSig = [];

							if (leftToken instanceof OrToken) {
								newSig.push.apply(newSig, __spreadArray([], __read(leftToken.ExtractSignature())));
							} else {
								try {
									for (
										var _c = __values(leftToken.ExtractSignature()), _d = _c.next();
										!_d.done;
										_d = _c.next()
									) {
										var sig = _d.value;
										newSig.push(__spreadArray([leftToken.annot()], __read(sig)));
									}
								} catch (e_1_1) {
									e_1 = {
										error: e_1_1
									};
								} finally {
									try {
										if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
									} finally {
										if (e_1) throw e_1.error;
									}
								}
							}

							if (rightToken instanceof OrToken) {
								newSig.push.apply(newSig, __spreadArray([], __read(rightToken.ExtractSignature())));
							} else {
								try {
									for (
										var _e = __values(rightToken.ExtractSignature()), _f = _e.next();
										!_f.done;
										_f = _e.next()
									) {
										var sig = _f.value;
										newSig.push(__spreadArray([rightToken.annot()], __read(sig)));
									}
								} catch (e_2_1) {
									e_2 = {
										error: e_2_1
									};
								} finally {
									try {
										if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
									} finally {
										if (e_2) throw e_2.error;
									}
								}
							}

							return newSig;
						};

						OrToken.prototype.EncodeObject = function (args) {
							var label = Object.keys(args)[0];
							var leftToken = this.createToken(this.val.args[0], this.idx);
							var keyCount = 1;

							if (leftToken instanceof OrToken) {
								keyCount = Object.keys(leftToken.ExtractSchema()).length;
							}

							var rightToken = this.createToken(this.val.args[1], this.idx + keyCount);

							if (String(leftToken.annot()) === String(label) && !(leftToken instanceof OrToken)) {
								return {
									prim: 'Left',
									args: [leftToken.EncodeObject(args[label])]
								};
							} else if (
								String(rightToken.annot()) === String(label) &&
								!(rightToken instanceof OrToken)
							) {
								return {
									prim: 'Right',
									args: [rightToken.EncodeObject(args[label])]
								};
							} else {
								if (leftToken instanceof OrToken) {
									var val = leftToken.EncodeObject(args);

									if (val) {
										return {
											prim: 'Left',
											args: [val]
										};
									}
								}

								if (rightToken instanceof OrToken) {
									var val = rightToken.EncodeObject(args);

									if (val) {
										return {
											prim: 'Right',
											args: [val]
										};
									}
								}

								return null;
							}
						};

						OrToken.prototype.Execute = function (val, semantics) {
							var _a, _b;

							var leftToken = this.createToken(this.val.args[0], this.idx);
							var keyCount = 1;

							if (leftToken instanceof OrToken) {
								keyCount = Object.keys(leftToken.ExtractSchema()).length;
							}

							var rightToken = this.createToken(this.val.args[1], this.idx + keyCount);

							if (val.prim === 'Right') {
								if (rightToken instanceof OrToken) {
									return rightToken.Execute(val.args[0], semantics);
								} else {
									return (
										(_a = {}),
										(_a[rightToken.annot()] = rightToken.Execute(val.args[0], semantics)),
										_a
									);
								}
							} else if (val.prim === 'Left') {
								if (leftToken instanceof OrToken) {
									return leftToken.Execute(val.args[0], semantics);
								}

								return (
									(_b = {}), (_b[leftToken.annot()] = leftToken.Execute(val.args[0], semantics)), _b
								);
							} else {
								throw new Error('Was expecting Left or Right prim but got: ' + val.prim);
							}
						};

						OrToken.prototype.traversal = function (getLeftValue, getRightValue, concat) {
							var _a, _b;

							var leftToken = this.createToken(this.val.args[0], this.idx);
							var keyCount = 1;
							var leftValue;

							if (leftToken instanceof OrToken && !leftToken.hasAnnotations()) {
								leftValue = getLeftValue(leftToken);
								keyCount = Object.keys(leftToken.ExtractSchema()).length;
							} else {
								leftValue = ((_a = {}), (_a[leftToken.annot()] = getLeftValue(leftToken)), _a);
							}

							var rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
							var rightValue;

							if (rightToken instanceof OrToken && !rightToken.hasAnnotations()) {
								rightValue = getRightValue(rightToken);
							} else {
								rightValue = ((_b = {}), (_b[rightToken.annot()] = getRightValue(rightToken)), _b);
							}

							var res = concat(leftValue, rightValue);
							return res;
						};

						OrToken.prototype.ExtractSchema = function () {
							return this.traversal(
								function (leftToken) {
									return leftToken.ExtractSchema();
								},
								function (rightToken) {
									return rightToken.ExtractSchema();
								},
								function (leftValue, rightValue) {
									return __assign(__assign({}, leftValue), rightValue);
								}
							);
						};

						OrToken.prototype.findToken = function (label) {
							var leftToken = this.createToken(this.val.args[0], this.idx);
							var keyCount = 1;

							if (leftToken instanceof OrToken) {
								keyCount = Object.keys(leftToken.ExtractSchema()).length;
							}

							var rightToken = this.createToken(this.val.args[1], this.idx + keyCount);

							if (
								String(leftToken.annot()) === String(label) &&
								!(leftToken instanceof OrToken) &&
								leftToken instanceof ComparableToken
							) {
								return leftToken;
							} else if (
								String(rightToken.annot()) === String(label) &&
								!(rightToken instanceof OrToken) &&
								rightToken instanceof ComparableToken
							) {
								return rightToken;
							} else {
								if (leftToken instanceof OrToken) {
									var tok = leftToken.findToken(label);

									if (tok) {
										return tok;
									}
								}

								if (rightToken instanceof OrToken) {
									var tok = rightToken.findToken(label);

									if (tok) {
										return tok;
									}
								}

								return null;
							}
						};

						OrToken.prototype.compare = function (val1, val2) {
							var labelVal1 = Object.keys(val1)[0];
							var labelVal2 = Object.keys(val2)[0];

							if (labelVal1 === labelVal2) {
								var token = this.findToken(labelVal1);

								if (token instanceof ComparableToken) {
									return token.compare(val1[labelVal1], val2[labelVal1]);
								}
							} else {
								var encoded1 = JSON.stringify(this.EncodeObject(val1));
								var encoded2 = JSON.stringify(this.EncodeObject(val2));
								return encoded1 < encoded2 ? -1 : 1;
							}
						};

						OrToken.prototype.ToKey = function (val) {
							return this.Execute(val);
						};

						OrToken.prototype.ToBigMapKey = function (val) {
							return {
								key: this.EncodeObject(val),
								type: this.typeWithoutAnnotations()
							};
						};

						OrToken.prim = 'or';
						return OrToken;
					})(ComparableToken); // collapse comb pair

				function collapse$1(val, prim) {
					if (prim === void 0) {
						prim = PairToken.prim;
					}

					if (Array.isArray(val)) {
						return collapse$1(
							{
								prim: prim,
								args: val
							},
							prim
						);
					}

					if (val.args === undefined) {
						throw new Error('Token has no arguments');
					}

					if (val.args.length > 2) {
						return [
							val.args[0],
							{
								prim: prim,
								args: val.args.slice(1)
							}
						];
					}

					return [val.args[0], val.args[1]];
				}

				var PairToken =
					/** @class */
					(function (_super) {
						__extends(PairToken, _super);

						function PairToken(val, idx, fac) {
							return (
								_super.call(
									this,
									Array.isArray(val)
										? {
												prim: PairToken.prim,
												args: val
										  }
										: val,
									idx,
									fac
								) || this
							);
						}

						PairToken.prototype.args = function () {
							// collapse comb pair
							return collapse$1(this.val);
						};

						PairToken.prototype.tokens = function () {
							var _this = this;

							var cnt = 0;
							return this.args().map(function (a) {
								var tok = _this.createToken(a, _this.idx + cnt);

								if (tok instanceof PairToken) {
									cnt += Object.keys(tok.ExtractSchema()).length;
								} else {
									cnt++;
								}

								return tok;
							});
						};

						PairToken.prototype.Encode = function (args) {
							return {
								prim: 'Pair',
								args: this.tokens().map(function (t) {
									return t.Encode(args);
								})
							};
						};

						PairToken.prototype.ExtractSignature = function () {
							var e_1, _a, e_2, _b;

							var args = this.args();
							var leftToken = this.createToken(args[0], this.idx);
							var keyCount = 1;

							if (leftToken instanceof OrToken) {
								keyCount = Object.keys(leftToken.ExtractSchema()).length;
							}

							var rightToken = this.createToken(args[1], this.idx + keyCount);
							var newSig = [];

							try {
								for (
									var _c = __values(leftToken.ExtractSignature()), _d = _c.next();
									!_d.done;
									_d = _c.next()
								) {
									var leftSig = _d.value;

									try {
										for (
											var _e = ((e_2 = void 0), __values(rightToken.ExtractSignature())),
												_f = _e.next();
											!_f.done;
											_f = _e.next()
										) {
											var rightSig = _f.value;
											newSig.push(
												__spreadArray(__spreadArray([], __read(leftSig)), __read(rightSig))
											);
										}
									} catch (e_2_1) {
										e_2 = {
											error: e_2_1
										};
									} finally {
										try {
											if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
										} finally {
											if (e_2) throw e_2.error;
										}
									}
								}
							} catch (e_1_1) {
								e_1 = {
									error: e_1_1
								};
							} finally {
								try {
									if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
								} finally {
									if (e_1) throw e_1.error;
								}
							}

							return newSig;
						};

						PairToken.prototype.ToBigMapKey = function (val) {
							return {
								key: this.EncodeObject(val),
								type: this.typeWithoutAnnotations()
							};
						};

						PairToken.prototype.ToKey = function (val) {
							return this.Execute(val);
						};

						PairToken.prototype.EncodeObject = function (args) {
							var _a = __read(this.tokens(), 2),
								leftToken = _a[0],
								rightToken = _a[1];

							var leftValue;

							if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {
								leftValue = args;
							} else {
								leftValue = args[leftToken.annot()];
							}

							var rightValue;

							if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {
								rightValue = args;
							} else {
								rightValue = args[rightToken.annot()];
							}

							return {
								prim: 'Pair',
								args: [leftToken.EncodeObject(leftValue), rightToken.EncodeObject(rightValue)]
							};
						};

						PairToken.prototype.traversal = function (getLeftValue, getRightValue) {
							var _a, _b;

							var args = this.args();
							var leftToken = this.createToken(args[0], this.idx);
							var keyCount = 1;
							var leftValue;

							if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {
								leftValue = getLeftValue(leftToken);
								keyCount = Object.keys(leftToken.ExtractSchema()).length;
							} else {
								leftValue = ((_a = {}), (_a[leftToken.annot()] = getLeftValue(leftToken)), _a);
							}

							var rightToken = this.createToken(args[1], this.idx + keyCount);
							var rightValue;

							if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {
								rightValue = getRightValue(rightToken);
							} else {
								rightValue = ((_b = {}), (_b[rightToken.annot()] = getRightValue(rightToken)), _b);
							}

							var res = __assign(__assign({}, leftValue), rightValue);

							return res;
						};

						PairToken.prototype.Execute = function (val, semantics) {
							var args = collapse$1(val, 'Pair');
							return this.traversal(
								function (leftToken) {
									return leftToken.Execute(args[0], semantics);
								},
								function (rightToken) {
									return rightToken.Execute(args[1], semantics);
								}
							);
						};

						PairToken.prototype.ExtractSchema = function () {
							return this.traversal(
								function (leftToken) {
									return leftToken.ExtractSchema();
								},
								function (rightToken) {
									return rightToken.ExtractSchema();
								}
							);
						};

						PairToken.prototype.compare = function (val1, val2) {
							var _a = __read(this.tokens(), 2),
								leftToken = _a[0],
								rightToken = _a[1];

							var getValue = function (token, args) {
								if (token instanceof PairToken && !token.hasAnnotations()) {
									return args;
								} else {
									return args[token.annot()];
								}
							};

							if (leftToken instanceof ComparableToken && rightToken instanceof ComparableToken) {
								var result = leftToken.compare(
									getValue(leftToken, val1),
									getValue(leftToken, val2)
								);

								if (result === 0) {
									return rightToken.compare(getValue(rightToken, val1), getValue(rightToken, val2));
								}

								return result;
							}

							throw new Error('Not a comparable pair');
						};

						PairToken.prim = 'pair';
						return PairToken;
					})(ComparableToken);

				var NatValidationError =
					/** @class */
					(function (_super) {
						__extends(NatValidationError, _super);

						function NatValidationError(value, token, message) {
							var _this = _super.call(this, value, token, message) || this;

							_this.value = value;
							_this.token = token;
							_this.name = 'NatValidationError';
							return _this;
						}

						return NatValidationError;
					})(TokenValidationError);

				exports.NatValidationError = NatValidationError;

				var NatToken =
					/** @class */
					(function (_super) {
						__extends(NatToken, _super);

						function NatToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						NatToken.prototype.Execute = function (val) {
							return new _bignumber.default(val[Object.keys(val)[0]]);
						};

						NatToken.prototype.Encode = function (args) {
							var val = args.pop();
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								int: new _bignumber.default(val).toFixed()
							};
						};

						NatToken.prototype.isValid = function (val) {
							var bigNumber = new _bignumber.default(val);

							if (bigNumber.isNaN()) {
								return new NatValidationError(val, this, 'Value is not a number: ' + val);
							} else if (bigNumber.isNegative()) {
								return new NatValidationError(val, this, 'Value cannot be negative: ' + val);
							} else {
								return null;
							}
						};

						NatToken.prototype.EncodeObject = function (val) {
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								int: new _bignumber.default(val).toFixed()
							};
						};

						NatToken.prototype.ExtractSchema = function () {
							return NatToken.prim;
						};

						NatToken.prototype.ToBigMapKey = function (val) {
							return {
								key: {
									int: String(val)
								},
								type: {
									prim: NatToken.prim
								}
							};
						};

						NatToken.prototype.ToKey = function (_a) {
							var int = _a.int;
							return int;
						};

						NatToken.prototype.compare = function (nat1, nat2) {
							var o1 = Number(nat1);
							var o2 = Number(nat2);

							if (o1 === o2) {
								return 0;
							}

							return o1 < o2 ? -1 : 1;
						};

						NatToken.prim = 'nat';
						return NatToken;
					})(ComparableToken);

				var StringToken =
					/** @class */
					(function (_super) {
						__extends(StringToken, _super);

						function StringToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						StringToken.prototype.Execute = function (val) {
							return val[Object.keys(val)[0]];
						};

						StringToken.prototype.ExtractSchema = function () {
							return StringToken.prim;
						};

						StringToken.prototype.Encode = function (args) {
							var val = args.pop();
							return {
								string: val
							};
						};

						StringToken.prototype.EncodeObject = function (val) {
							return {
								string: val
							};
						}; // tslint:disable-next-line: variable-name

						StringToken.prototype.ToKey = function (_a) {
							var string = _a.string;
							return string;
						};

						StringToken.prototype.ToBigMapKey = function (val) {
							return {
								key: {
									string: val
								},
								type: {
									prim: StringToken.prim
								}
							};
						};

						StringToken.prim = 'string';
						return StringToken;
					})(ComparableToken);

				var AddressValidationError =
					/** @class */
					(function (_super) {
						__extends(AddressValidationError, _super);

						function AddressValidationError(value, token, message) {
							var _this = _super.call(this, value, token, message) || this;

							_this.value = value;
							_this.token = token;
							_this.name = 'AddressValidationError';
							return _this;
						}

						return AddressValidationError;
					})(TokenValidationError);

				exports.AddressValidationError = AddressValidationError;

				var AddressToken =
					/** @class */
					(function (_super) {
						__extends(AddressToken, _super);

						function AddressToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						AddressToken.prototype.ToBigMapKey = function (val) {
							var decoded = (0, _utils.b58decode)(val);
							return {
								key: {
									bytes: decoded
								},
								type: {
									prim: 'bytes'
								}
							};
						};

						AddressToken.prototype.isValid = function (value) {
							if ((0, _utils.validateAddress)(value) !== _utils.ValidationResult.VALID) {
								return new AddressValidationError(value, this, 'Address is not valid: ' + value);
							}

							return null;
						};

						AddressToken.prototype.Encode = function (args) {
							var val = args.pop();
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								string: val
							};
						};

						AddressToken.prototype.EncodeObject = function (val) {
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								string: val
							};
						}; // tslint:disable-next-line: variable-name

						AddressToken.prototype.Execute = function (val) {
							if (val.string) {
								return val.string;
							}

							return (0, _utils.encodePubKey)(val.bytes);
						};

						AddressToken.prototype.ExtractSchema = function () {
							return AddressToken.prim;
						}; // tslint:disable-next-line: variable-name

						AddressToken.prototype.ToKey = function (_a) {
							var bytes = _a.bytes,
								string = _a.string;

							if (string) {
								return string;
							}

							return (0, _utils.encodePubKey)(bytes);
						};

						AddressToken.prototype.compare = function (address1, address2) {
							var isImplicit = function (address) {
								return address.startsWith('tz');
							};

							if (isImplicit(address1) && isImplicit(address2)) {
								return _super.prototype.compare.call(this, address1, address2);
							} else if (isImplicit(address1)) {
								return -1;
							} else if (isImplicit(address2)) {
								return 1;
							} else {
								return _super.prototype.compare.call(this, address1, address2);
							}
						};

						AddressToken.prim = 'address';
						return AddressToken;
					})(ComparableToken);

				var MapValidationError =
					/** @class */
					(function (_super) {
						__extends(MapValidationError, _super);

						function MapValidationError(value, token, message) {
							var _this = _super.call(this, value, token, message) || this;

							_this.value = value;
							_this.token = token;
							_this.name = 'MapValidationError';
							return _this;
						}

						return MapValidationError;
					})(TokenValidationError);

				exports.MapValidationError = MapValidationError;

				var MapToken =
					/** @class */
					(function (_super) {
						__extends(MapToken, _super);

						function MapToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						Object.defineProperty(MapToken.prototype, 'ValueSchema', {
							get: function () {
								return this.createToken(this.val.args[1], 0);
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(MapToken.prototype, 'KeySchema', {
							get: function () {
								return this.createToken(this.val.args[0], 0);
							},
							enumerable: false,
							configurable: true
						});

						MapToken.prototype.isValid = function (value) {
							if (MichelsonMap.isMichelsonMap(value)) {
								return null;
							}

							return new MapValidationError(value, this, 'Value must be a MichelsonMap');
						};

						MapToken.prototype.Execute = function (val, semantics) {
							var _this = this;

							var map = new MichelsonMap(this.val);
							val.forEach(function (current) {
								map.set(
									_this.KeySchema.ToKey(current.args[0]),
									_this.ValueSchema.Execute(current.args[1], semantics)
								);
							});
							return map;
						};

						MapToken.prototype.Encode = function (args) {
							var _this = this;

							var val = args.pop();
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return Array.from(val.keys())
								.sort(function (a, b) {
									return _this.KeySchema.compare(a, b);
								})
								.map(function (key) {
									return {
										prim: 'Elt',
										args: [
											_this.KeySchema.EncodeObject(key),
											_this.ValueSchema.EncodeObject(val.get(key))
										]
									};
								});
						};

						MapToken.prototype.EncodeObject = function (args) {
							var _this = this;

							var val = args;
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return Array.from(val.keys())
								.sort(function (a, b) {
									return _this.KeySchema.compare(a, b);
								})
								.map(function (key) {
									return {
										prim: 'Elt',
										args: [
											_this.KeySchema.EncodeObject(key),
											_this.ValueSchema.EncodeObject(val.get(key))
										]
									};
								});
						};

						MapToken.prototype.ExtractSchema = function () {
							return {
								map: {
									key: this.KeySchema.ExtractSchema(),
									value: this.ValueSchema.ExtractSchema()
								}
							};
						};

						MapToken.prim = 'map';
						return MapToken;
					})(Token);

				var BoolToken =
					/** @class */
					(function (_super) {
						__extends(BoolToken, _super);

						function BoolToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						BoolToken.prototype.Execute = function (val) {
							return String(val.prim).toLowerCase() === 'true' ? true : false;
						};

						BoolToken.prototype.Encode = function (args) {
							var val = args.pop();
							return {
								prim: val ? 'True' : 'False'
							};
						};

						BoolToken.prototype.EncodeObject = function (val) {
							return {
								prim: val ? 'True' : 'False'
							};
						};

						BoolToken.prototype.ExtractSchema = function () {
							return BoolToken.prim;
						};

						BoolToken.prototype.ToBigMapKey = function (val) {
							return {
								key: this.EncodeObject(val),
								type: {
									prim: BoolToken.prim
								}
							};
						};

						BoolToken.prototype.ToKey = function (val) {
							return this.EncodeObject(val);
						};

						BoolToken.prototype.compare = function (val1, val2) {
							if ((val1 && val2) || (!val1 && !val2)) {
								return 0;
							} else if (val1) {
								return 1;
							} else {
								return -1;
							}
						};

						BoolToken.prim = 'bool';
						return BoolToken;
					})(ComparableToken);

				var ContractValidationError =
					/** @class */
					(function (_super) {
						__extends(ContractValidationError, _super);

						function ContractValidationError(value, token, message) {
							var _this = _super.call(this, value, token, message) || this;

							_this.value = value;
							_this.token = token;
							_this.name = 'ContractValidationError';
							return _this;
						}

						return ContractValidationError;
					})(TokenValidationError);

				exports.ContractValidationError = ContractValidationError;

				var ContractToken =
					/** @class */
					(function (_super) {
						__extends(ContractToken, _super);

						function ContractToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						ContractToken.prototype.isValid = function (value) {
							// tz1,tz2 and tz3 seems to be valid contract values (for Unit contract)
							if ((0, _utils.validateAddress)(value) !== _utils.ValidationResult.VALID) {
								return new ContractValidationError(value, this, 'Contract address is not valid');
							}

							return null;
						};

						ContractToken.prototype.Execute = function (val) {
							if (val.string) {
								return val.string;
							}

							return (0, _utils.encodePubKey)(val.bytes);
						};

						ContractToken.prototype.Encode = function (args) {
							var val = args.pop();
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								string: val
							};
						};

						ContractToken.prototype.EncodeObject = function (val) {
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								string: val
							};
						};

						ContractToken.prototype.ExtractSchema = function () {
							return ContractToken.prim;
						};

						ContractToken.prim = 'contract';
						return ContractToken;
					})(Token);

				var ListValidationError =
					/** @class */
					(function (_super) {
						__extends(ListValidationError, _super);

						function ListValidationError(value, token, message) {
							var _this = _super.call(this, value, token, message) || this;

							_this.value = value;
							_this.token = token;
							_this.name = 'ListValidationError';
							return _this;
						}

						return ListValidationError;
					})(TokenValidationError);

				exports.ListValidationError = ListValidationError;

				var ListToken =
					/** @class */
					(function (_super) {
						__extends(ListToken, _super);

						function ListToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						ListToken.prototype.isValid = function (value) {
							if (Array.isArray(value)) {
								return null;
							}

							return new ListValidationError(value, this, 'Value must be an array');
						};

						ListToken.prototype.Encode = function (args) {
							var val = args.pop();
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							var schema = this.createToken(this.val.args[0], 0);
							return val.reduce(function (prev, current) {
								return __spreadArray(__spreadArray([], __read(prev)), [
									schema.EncodeObject(current)
								]);
							}, []);
						};

						ListToken.prototype.Execute = function (val, semantics) {
							var schema = this.createToken(this.val.args[0], 0);
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return val.reduce(function (prev, current) {
								return __spreadArray(__spreadArray([], __read(prev)), [
									schema.Execute(current, semantics)
								]);
							}, []);
						};

						ListToken.prototype.EncodeObject = function (args) {
							var schema = this.createToken(this.val.args[0], 0);
							var err = this.isValid(args);

							if (err) {
								throw err;
							}

							return args.reduce(function (prev, current) {
								return __spreadArray(__spreadArray([], __read(prev)), [
									schema.EncodeObject(current)
								]);
							}, []);
						};

						ListToken.prototype.ExtractSchema = function () {
							var _a;

							var valueSchema = this.createToken(this.val.args[0], this.idx);
							return (_a = {}), (_a[ListToken.prim] = valueSchema.ExtractSchema()), _a;
						};

						ListToken.prim = 'list';
						return ListToken;
					})(Token);

				var MutezValidationError =
					/** @class */
					(function (_super) {
						__extends(MutezValidationError, _super);

						function MutezValidationError(value, token, message) {
							var _this = _super.call(this, value, token, message) || this;

							_this.value = value;
							_this.token = token;
							_this.name = 'MutezValidationError';
							return _this;
						}

						return MutezValidationError;
					})(TokenValidationError);

				exports.MutezValidationError = MutezValidationError;

				var MutezToken =
					/** @class */
					(function (_super) {
						__extends(MutezToken, _super);

						function MutezToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						MutezToken.prototype.Execute = function (val) {
							return new _bignumber.default(val[Object.keys(val)[0]]);
						};

						MutezToken.prototype.ExtractSchema = function () {
							return MutezToken.prim;
						};

						MutezToken.prototype.isValid = function (val) {
							var bigNumber = new _bignumber.default(val);

							if (bigNumber.isNaN()) {
								return new MutezValidationError(val, this, 'Value is not a number: ' + val);
							} else {
								return null;
							}
						};

						MutezToken.prototype.Encode = function (args) {
							var val = args.pop();
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								int: String(val).toString()
							};
						};

						MutezToken.prototype.EncodeObject = function (val) {
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								int: String(val).toString()
							};
						};

						MutezToken.prototype.ToBigMapKey = function (val) {
							return {
								key: {
									int: String(val)
								},
								type: {
									prim: MutezToken.prim
								}
							};
						};

						MutezToken.prototype.ToKey = function (_a) {
							var int = _a.int;
							return int;
						};

						MutezToken.prototype.compare = function (mutez1, mutez2) {
							var o1 = Number(mutez1);
							var o2 = Number(mutez2);

							if (o1 === o2) {
								return 0;
							}

							return o1 < o2 ? -1 : 1;
						};

						MutezToken.prim = 'mutez';
						return MutezToken;
					})(ComparableToken);

				var BytesValidationError =
					/** @class */
					(function (_super) {
						__extends(BytesValidationError, _super);

						function BytesValidationError(value, token, message) {
							var _this = _super.call(this, value, token, message) || this;

							_this.value = value;
							_this.token = token;
							_this.name = 'BytesValidationError';
							return _this;
						}

						return BytesValidationError;
					})(TokenValidationError);

				exports.BytesValidationError = BytesValidationError;

				var BytesToken =
					/** @class */
					(function (_super) {
						__extends(BytesToken, _super);

						function BytesToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						BytesToken.prototype.ToBigMapKey = function (val) {
							return {
								key: {
									bytes: val
								},
								type: {
									prim: BytesToken.prim
								}
							};
						};

						BytesToken.prototype.isValid = function (val) {
							if (typeof val === 'string' && /^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
								return null;
							} else {
								return new BytesValidationError(val, this, 'Invalid bytes: ' + val);
							}
						};

						BytesToken.prototype.convertUint8ArrayToHexString = function (val) {
							return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;
						};

						BytesToken.prototype.Encode = function (args) {
							var val = args.pop();
							val = this.convertUint8ArrayToHexString(val);
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								bytes: String(val).toString()
							};
						};

						BytesToken.prototype.EncodeObject = function (val) {
							val = this.convertUint8ArrayToHexString(val);
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								bytes: String(val).toString()
							};
						};

						BytesToken.prototype.Execute = function (val) {
							return val.bytes;
						};

						BytesToken.prototype.ExtractSchema = function () {
							return BytesToken.prim;
						}; // tslint:disable-next-line: variable-name

						BytesToken.prototype.ToKey = function (_a) {
							var bytes = _a.bytes,
								string = _a.string;

							if (string) {
								return string;
							}

							return bytes;
						};

						BytesToken.prim = 'bytes';
						return BytesToken;
					})(ComparableToken);

				var OptionToken =
					/** @class */
					(function (_super) {
						__extends(OptionToken, _super);

						function OptionToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						OptionToken.prototype.subToken = function () {
							return this.createToken(this.val.args[0], this.idx);
						};

						OptionToken.prototype.annot = function () {
							return Array.isArray(this.val.annots)
								? _super.prototype.annot.call(this)
								: this.createToken(this.val.args[0], this.idx).annot();
						};

						OptionToken.prototype.Encode = function (args) {
							var value = args;

							if (value === undefined || value === null) {
								return {
									prim: 'None'
								};
							} else if (
								Array.isArray(value) &&
								(value[value.length - 1] === undefined || value[value.length - 1] === null)
							) {
								value.pop();
								return {
									prim: 'None'
								};
							}

							var schema = this.createToken(this.val.args[0], 0);
							return {
								prim: 'Some',
								args: [schema.Encode(args)]
							};
						};

						OptionToken.prototype.EncodeObject = function (args) {
							var schema = this.createToken(this.val.args[0], 0);
							var value = args;

							if (value === undefined || value === null) {
								return {
									prim: 'None'
								};
							}

							return {
								prim: 'Some',
								args: [schema.EncodeObject(value)]
							};
						};

						OptionToken.prototype.Execute = function (val, semantics) {
							if (val.prim === 'None') {
								return null;
							}

							var schema = this.createToken(this.val.args[0], 0);
							return schema.Execute(val.args[0], semantics);
						};

						OptionToken.prototype.ExtractSchema = function () {
							var schema = this.createToken(this.val.args[0], 0);
							return schema.ExtractSchema();
						};

						OptionToken.prototype.ExtractSignature = function () {
							var schema = this.createToken(this.val.args[0], 0);
							return __spreadArray(__spreadArray([], __read(schema.ExtractSignature())), [[]]);
						};

						Object.defineProperty(OptionToken.prototype, 'KeySchema', {
							get: function () {
								return this.createToken(this.val.args[0], 0);
							},
							enumerable: false,
							configurable: true
						});

						OptionToken.prototype.compare = function (val1, val2) {
							if (!val1) {
								return -1;
							} else if (!val2) {
								return 1;
							}

							return this.KeySchema.compare(val1, val2);
						};

						OptionToken.prototype.ToKey = function (val) {
							return this.Execute(val);
						};

						OptionToken.prototype.ToBigMapKey = function (val) {
							return {
								key: this.EncodeObject(val),
								type: this.typeWithoutAnnotations()
							};
						};

						OptionToken.prim = 'option';
						return OptionToken;
					})(ComparableToken);

				var TimestampToken =
					/** @class */
					(function (_super) {
						__extends(TimestampToken, _super);

						function TimestampToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						TimestampToken.prototype.Execute = function (val) {
							if (val.string) {
								return new Date(val.string).toISOString();
							} else if (val.int) {
								return new Date(Number(val.int) * 1000).toISOString();
							}
						};

						TimestampToken.prototype.Encode = function (args) {
							var val = args.pop();
							return {
								string: val
							};
						};

						TimestampToken.prototype.EncodeObject = function (val) {
							return {
								string: val
							};
						};

						TimestampToken.prototype.ExtractSchema = function () {
							return TimestampToken.prim;
						}; // tslint:disable-next-line: variable-name

						TimestampToken.prototype.ToKey = function (_a) {
							var string = _a.string;
							return string;
						};

						TimestampToken.prototype.ToBigMapKey = function (val) {
							return {
								key: {
									string: val
								},
								type: {
									prim: TimestampToken.prim
								}
							};
						};

						TimestampToken.prim = 'timestamp';
						return TimestampToken;
					})(ComparableToken);

				var IntValidationError =
					/** @class */
					(function (_super) {
						__extends(IntValidationError, _super);

						function IntValidationError(value, token, message) {
							var _this = _super.call(this, value, token, message) || this;

							_this.value = value;
							_this.token = token;
							_this.name = 'IntValidationError';
							return _this;
						}

						return IntValidationError;
					})(TokenValidationError);

				exports.IntValidationError = IntValidationError;

				var IntToken =
					/** @class */
					(function (_super) {
						__extends(IntToken, _super);

						function IntToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						IntToken.prototype.Execute = function (val) {
							return new _bignumber.default(val[Object.keys(val)[0]]);
						};

						IntToken.prototype.ExtractSchema = function () {
							return IntToken.prim;
						};

						IntToken.prototype.isValid = function (val) {
							var bigNumber = new _bignumber.default(val);

							if (bigNumber.isNaN()) {
								return new IntValidationError(val, this, 'Value is not a number: ' + val);
							} else {
								return null;
							}
						};

						IntToken.prototype.Encode = function (args) {
							var val = args.pop();
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								int: new _bignumber.default(val).toFixed()
							};
						};

						IntToken.prototype.EncodeObject = function (val) {
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								int: new _bignumber.default(val).toFixed()
							};
						};

						IntToken.prototype.ToBigMapKey = function (val) {
							return {
								key: {
									int: String(val)
								},
								type: {
									prim: IntToken.prim
								}
							};
						};

						IntToken.prototype.ToKey = function (_a) {
							var int = _a.int;
							return int;
						};

						IntToken.prototype.compare = function (int1, int2) {
							var o1 = Number(int1);
							var o2 = Number(int2);

							if (o1 === o2) {
								return 0;
							}

							return o1 < o2 ? -1 : 1;
						};

						IntToken.prim = 'int';
						return IntToken;
					})(ComparableToken);

				var UnitToken =
					/** @class */
					(function (_super) {
						__extends(UnitToken, _super);

						function UnitToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						UnitToken.prototype.Encode = function (args) {
							args.pop();
							return {
								prim: 'Unit'
							};
						};

						UnitToken.prototype.EncodeObject = function (_val) {
							return {
								prim: 'Unit'
							};
						};

						UnitToken.prototype.Execute = function (_val) {
							return UnitValue;
						};

						UnitToken.prototype.ExtractSchema = function () {
							return UnitToken.prim;
						};

						UnitToken.prototype.compare = function (_val1, _val2) {
							return 0;
						};

						UnitToken.prototype.ToKey = function (_val) {
							return UnitValue;
						};

						UnitToken.prototype.ToBigMapKey = function (_val) {
							return {
								key: {
									prim: 'Unit'
								},
								type: {
									prim: UnitToken.prim
								}
							};
						};

						UnitToken.prim = 'unit';
						return UnitToken;
					})(ComparableToken);

				var publicKeyPrefixLength = 4;

				var KeyValidationError =
					/** @class */
					(function (_super) {
						__extends(KeyValidationError, _super);

						function KeyValidationError(value, token, message) {
							var _this = _super.call(this, value, token, message) || this;

							_this.value = value;
							_this.token = token;
							_this.name = 'KeyValidationError';
							return _this;
						}

						return KeyValidationError;
					})(TokenValidationError);

				exports.KeyValidationError = KeyValidationError;

				var KeyToken =
					/** @class */
					(function (_super) {
						__extends(KeyToken, _super);

						function KeyToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						KeyToken.prototype.Execute = function (val) {
							if (val.string) {
								return val.string;
							}

							return (0, _utils.encodeKey)(val.bytes);
						};

						KeyToken.prototype.isValid = function (value) {
							if ((0, _utils.validatePublicKey)(value) !== _utils.ValidationResult.VALID) {
								return new KeyValidationError(value, this, 'Key is not valid');
							}

							return null;
						};

						KeyToken.prototype.Encode = function (args) {
							var val = args.pop();
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								string: val
							};
						};

						KeyToken.prototype.EncodeObject = function (val) {
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								string: val
							};
						};

						KeyToken.prototype.ExtractSchema = function () {
							return KeyToken.prim;
						};

						KeyToken.prototype.ToKey = function (val) {
							return this.Execute(val);
						};

						KeyToken.prototype.ToBigMapKey = function (val) {
							return {
								key: {
									string: val
								},
								type: {
									prim: KeyToken.prim
								}
							};
						};

						KeyToken.prototype.compare = function (key1, key2) {
							var keyPrefix1 = this.getPrefix(key1);
							var keyPrefix2 = this.getPrefix(key2);

							if (keyPrefix1 === _utils.Prefix.EDPK && keyPrefix2 !== _utils.Prefix.EDPK) {
								return -1;
							} else if (keyPrefix1 === _utils.Prefix.SPPK && keyPrefix2 !== _utils.Prefix.SPPK) {
								return keyPrefix2 === _utils.Prefix.EDPK ? 1 : -1;
							} else if (keyPrefix1 === _utils.Prefix.P2PK) {
								if (keyPrefix2 !== _utils.Prefix.P2PK) {
									return 1;
								}

								var keyBytes1 = this.getP256PublicKeyComparableBytes(key1);
								var keyBytes2 = this.getP256PublicKeyComparableBytes(key2);
								return Buffer.compare(keyBytes1, keyBytes2);
							}

							return _super.prototype.compare.call(this, key1, key2);
						};

						KeyToken.prototype.getPrefix = function (val) {
							return val.substring(0, publicKeyPrefixLength);
						};

						KeyToken.prototype.getP256PublicKeyComparableBytes = function (p2pk) {
							return (0, _utils.b58cdecode)(p2pk, _utils.prefix[_utils.Prefix.P2PK]).slice(1);
						};

						KeyToken.prim = 'key';
						return KeyToken;
					})(ComparableToken);

				var KeyHashValidationError =
					/** @class */
					(function (_super) {
						__extends(KeyHashValidationError, _super);

						function KeyHashValidationError(value, token, message) {
							var _this = _super.call(this, value, token, message) || this;

							_this.value = value;
							_this.token = token;
							_this.name = 'KeyHashValidationError';
							return _this;
						}

						return KeyHashValidationError;
					})(TokenValidationError);

				exports.KeyHashValidationError = KeyHashValidationError;

				var KeyHashToken =
					/** @class */
					(function (_super) {
						__extends(KeyHashToken, _super);

						function KeyHashToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						KeyHashToken.prototype.Execute = function (val) {
							if (val.string) {
								return val.string;
							}

							return (0, _utils.encodeKeyHash)(val.bytes);
						};

						KeyHashToken.prototype.isValid = function (value) {
							if ((0, _utils.validateKeyHash)(value) !== _utils.ValidationResult.VALID) {
								return new KeyHashValidationError(value, this, 'KeyHash is not valid: ' + value);
							}

							return null;
						};

						KeyHashToken.prototype.Encode = function (args) {
							var val = args.pop();
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								string: val
							};
						};

						KeyHashToken.prototype.EncodeObject = function (val) {
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								string: val
							};
						};

						KeyHashToken.prototype.ExtractSchema = function () {
							return KeyHashToken.prim;
						}; // tslint:disable-next-line: variable-name

						KeyHashToken.prototype.ToKey = function (_a) {
							var string = _a.string,
								bytes = _a.bytes;

							if (string) {
								return string;
							}

							return (0, _utils.encodeKeyHash)(bytes);
						};

						KeyHashToken.prototype.ToBigMapKey = function (val) {
							return {
								key: {
									string: val
								},
								type: {
									prim: KeyHashToken.prim
								}
							};
						};

						KeyHashToken.prim = 'key_hash';
						return KeyHashToken;
					})(ComparableToken);

				var SignatureValidationError =
					/** @class */
					(function (_super) {
						__extends(SignatureValidationError, _super);

						function SignatureValidationError(value, token, message) {
							var _this = _super.call(this, value, token, message) || this;

							_this.value = value;
							_this.token = token;
							_this.name = 'SignatureValidationError';
							return _this;
						}

						return SignatureValidationError;
					})(TokenValidationError);

				exports.SignatureValidationError = SignatureValidationError;

				var SignatureToken =
					/** @class */
					(function (_super) {
						__extends(SignatureToken, _super);

						function SignatureToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						SignatureToken.prototype.Execute = function (val) {
							return val.string;
						};

						SignatureToken.prototype.isValid = function (value) {
							if ((0, _utils.validateSignature)(value) !== _utils.ValidationResult.VALID) {
								return new SignatureValidationError(value, this, 'Signature is not valid');
							}

							return null;
						};

						SignatureToken.prototype.Encode = function (args) {
							var val = args.pop();
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								string: val
							};
						};

						SignatureToken.prototype.EncodeObject = function (val) {
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								string: val
							};
						};

						SignatureToken.prototype.ExtractSchema = function () {
							return SignatureToken.prim;
						};

						SignatureToken.prototype.ToKey = function (val) {
							return this.Execute(val);
						};

						SignatureToken.prototype.ToBigMapKey = function (val) {
							return {
								key: {
									string: val
								},
								type: {
									prim: SignatureToken.prim
								}
							};
						};

						SignatureToken.prim = 'signature';
						return SignatureToken;
					})(ComparableToken);

				var LambdaToken =
					/** @class */
					(function (_super) {
						__extends(LambdaToken, _super);

						function LambdaToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						LambdaToken.prototype.Execute = function (val) {
							if (val.string) {
								return val.string;
							} else {
								return val;
							}
						};

						LambdaToken.prototype.Encode = function (args) {
							var val = args.pop();
							return val;
						};

						LambdaToken.prototype.EncodeObject = function (val) {
							return val;
						};

						LambdaToken.prototype.ExtractSchema = function () {
							var _a;

							var leftToken = this.createToken(this.val.args[0], this.idx);
							var rightToken = this.createToken(this.val.args[1], this.idx + 1);
							return (
								(_a = {}),
								(_a[LambdaToken.prim] = {
									parameters: leftToken.ExtractSchema(),
									returns: rightToken.ExtractSchema()
								}),
								_a
							);
						};

						LambdaToken.prim = 'lambda';
						return LambdaToken;
					})(Token);

				var OperationToken =
					/** @class */
					(function (_super) {
						__extends(OperationToken, _super);

						function OperationToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						OperationToken.prototype.Execute = function (val) {
							return val.string;
						};

						OperationToken.prototype.Encode = function () {
							var args = [];

							for (var _i = 0; _i < arguments.length; _i++) {
								args[_i] = arguments[_i];
							}

							var val = args.pop();
							return {
								string: val
							};
						};

						OperationToken.prototype.EncodeObject = function (val) {
							return {
								string: val
							};
						};

						OperationToken.prototype.ExtractSchema = function () {
							return OperationToken.prim;
						};

						OperationToken.prim = 'operation';
						return OperationToken;
					})(Token);

				var SetValidationError =
					/** @class */
					(function (_super) {
						__extends(SetValidationError, _super);

						function SetValidationError(value, token, message) {
							var _this = _super.call(this, value, token, message) || this;

							_this.value = value;
							_this.token = token;
							_this.name = 'SetValidationError';
							return _this;
						}

						return SetValidationError;
					})(TokenValidationError);

				exports.SetValidationError = SetValidationError;

				var SetToken =
					/** @class */
					(function (_super) {
						__extends(SetToken, _super);

						function SetToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						Object.defineProperty(SetToken.prototype, 'KeySchema', {
							get: function () {
								return this.createToken(this.val.args[0], 0);
							},
							enumerable: false,
							configurable: true
						});

						SetToken.prototype.isValid = function (value) {
							if (Array.isArray(value)) {
								return null;
							}

							return new SetValidationError(value, this, 'Value must be an array');
						};

						SetToken.prototype.Encode = function (args) {
							var _this = this;

							var val = args.pop();
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return val
								.sort(function (a, b) {
									return _this.KeySchema.compare(a, b);
								})
								.reduce(function (prev, current) {
									return __spreadArray(__spreadArray([], __read(prev)), [
										_this.KeySchema.EncodeObject(current)
									]);
								}, []);
						};

						SetToken.prototype.Execute = function (val, semantics) {
							var _this = this;

							return val.reduce(function (prev, current) {
								return __spreadArray(__spreadArray([], __read(prev)), [
									_this.KeySchema.Execute(current, semantics)
								]);
							}, []);
						};

						SetToken.prototype.EncodeObject = function (args) {
							var _this = this;

							var err = this.isValid(args);

							if (err) {
								throw err;
							}

							return args
								.sort(function (a, b) {
									return _this.KeySchema.compare(a, b);
								})
								.reduce(function (prev, current) {
									return __spreadArray(__spreadArray([], __read(prev)), [
										_this.KeySchema.EncodeObject(current)
									]);
								}, []);
						};

						SetToken.prototype.ExtractSchema = function () {
							return SetToken.prim;
						};

						SetToken.prim = 'set';
						return SetToken;
					})(Token);

				var ChainIDValidationError =
					/** @class */
					(function (_super) {
						__extends(ChainIDValidationError, _super);

						function ChainIDValidationError(value, token, message) {
							var _this = _super.call(this, value, token, message) || this;

							_this.value = value;
							_this.token = token;
							_this.name = 'ChainIDValidationError';
							return _this;
						}

						return ChainIDValidationError;
					})(TokenValidationError);

				exports.ChainIDValidationError = ChainIDValidationError;

				var ChainIDToken =
					/** @class */
					(function (_super) {
						__extends(ChainIDToken, _super);

						function ChainIDToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						ChainIDToken.prototype.isValid = function (value) {
							if ((0, _utils.validateChain)(value) !== _utils.ValidationResult.VALID) {
								return new ChainIDValidationError(value, this, 'ChainID is not valid');
							}

							return null;
						};

						ChainIDToken.prototype.Execute = function (val) {
							return val[Object.keys(val)[0]];
						};

						ChainIDToken.prototype.ExtractSchema = function () {
							return ChainIDToken.prim;
						};

						ChainIDToken.prototype.Encode = function (args) {
							var val = args.pop();
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								string: val
							};
						};

						ChainIDToken.prototype.EncodeObject = function (val) {
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								string: val
							};
						}; // tslint:disable-next-line: variable-name

						ChainIDToken.prototype.ToKey = function (_a) {
							var string = _a.string;
							return string;
						};

						ChainIDToken.prototype.ToBigMapKey = function (val) {
							return {
								key: {
									string: val
								},
								type: {
									prim: ChainIDToken.prim
								}
							};
						};

						ChainIDToken.prim = 'chain_id';
						return ChainIDToken;
					})(ComparableToken);

				var EncodeTicketError =
					/** @class */
					(function () {
						function EncodeTicketError() {
							this.name = 'TicketEncodeError';
							this.message = 'Tickets cannot be sent to the blockchain; they are created on-chain';
						}

						return EncodeTicketError;
					})();

				exports.EncodeTicketError = EncodeTicketError;
				var ticketerType = {
					prim: 'contract'
				};
				var amountType = {
					prim: 'int'
				};

				var TicketToken =
					/** @class */
					(function (_super) {
						__extends(TicketToken, _super);

						function TicketToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						TicketToken.prototype.Encode = function (_args) {
							throw new EncodeTicketError();
						};

						TicketToken.prototype.EncodeObject = function (_args) {
							throw new EncodeTicketError();
						};

						TicketToken.prototype.Execute = function (val, semantics) {
							if (semantics && semantics[TicketToken.prim]) {
								return semantics[TicketToken.prim](val, this.val);
							}

							var ticketer = this.createToken(ticketerType, this.idx);
							var value = this.createToken(this.val.args[0], this.idx);
							var amount = this.createToken(amountType, this.idx);

							if (undefined == val.args[2] && undefined !== val.args[1].args) {
								return {
									ticketer: ticketer.Execute(val.args[0], semantics),
									value: value.Execute(val.args[1].args[0], semantics),
									amount: amount.Execute(val.args[1].args[1], semantics)
								};
							}

							return {
								ticketer: ticketer.Execute(val.args[0], semantics),
								value: value.Execute(val.args[1], semantics),
								amount: amount.Execute(val.args[2], semantics)
							};
						};

						TicketToken.prototype.ExtractSchema = function () {
							var valueSchema = this.createToken(this.val.args[0], this.idx);
							return {
								ticketer: ContractToken.prim,
								value: valueSchema.ExtractSchema(),
								amount: IntToken.prim
							};
						};

						TicketToken.prim = 'ticket';
						return TicketToken;
					})(Token);

				var NeverTokenError =
					/** @class */
					(function (_super) {
						__extends(NeverTokenError, _super);

						function NeverTokenError(value, token, message) {
							var _this = _super.call(this, value, token, message) || this;

							_this.value = value;
							_this.token = token;
							_this.name = 'NeverTokenError';
							return _this;
						}

						return NeverTokenError;
					})(TokenValidationError);

				var NeverToken =
					/** @class */
					(function (_super) {
						__extends(NeverToken, _super);

						function NeverToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						NeverToken.prototype.Encode = function (args) {
							var val = args.pop();
							throw new NeverTokenError(
								val,
								this,
								'Assigning a value to the type never is forbidden.'
							);
						};

						NeverToken.prototype.EncodeObject = function (val) {
							throw new NeverTokenError(
								val,
								this,
								'Assigning a value to the type never is forbidden.'
							);
						};

						NeverToken.prototype.Execute = function (val) {
							throw new NeverTokenError(val, this, 'There is no literal value for the type never.');
						};

						NeverToken.prototype.ExtractSchema = function () {
							return NeverToken.prim;
						};

						NeverToken.prim = 'never';
						return NeverToken;
					})(Token);

				var SaplingStateValidationError =
					/** @class */
					(function (_super) {
						__extends(SaplingStateValidationError, _super);

						function SaplingStateValidationError(value, token, message) {
							var _this = _super.call(this, value, token, message) || this;

							_this.value = value;
							_this.token = token;
							_this.name = 'SaplingStateValidationError';
							return _this;
						}

						return SaplingStateValidationError;
					})(TokenValidationError);

				var SaplingStateToken =
					/** @class */
					(function (_super) {
						__extends(SaplingStateToken, _super);

						function SaplingStateToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						SaplingStateToken.prototype.isValid = function (val) {
							return _typeof(val) === 'object' && Object.keys(val).length === 0;
						};

						SaplingStateToken.prototype.Execute = function (val, semantic) {
							if (semantic && semantic[SaplingStateToken.prim]) {
								return semantic[SaplingStateToken.prim](val, this.val);
							}

							if ('int' in val) {
								return val.int;
							} else {
								// Unknown case
								throw new Error(
									'Sapling state is expecting an object with an int property. Got ' +
										JSON.stringify(val)
								);
							}
						};

						SaplingStateToken.prototype.Encode = function (args) {
							var val = args.pop();

							if (this.isValid(val)) {
								return [];
							} else {
								throw new SaplingStateValidationError(
									val,
									this,
									'Invalid sapling_state. Received: ' + val + ' while expecting: {}'
								);
							}
						};

						SaplingStateToken.prototype.EncodeObject = function (val) {
							if (this.isValid(val)) {
								return [];
							} else {
								throw new SaplingStateValidationError(
									val,
									this,
									'Invalid sapling_state. Received: ' + val + ' while expecting: {}'
								);
							}
						};

						SaplingStateToken.prototype.ExtractSchema = function () {
							var _a;

							return (
								(_a = {}),
								(_a[SaplingStateToken.prim] = {
									'memo-size': Number(this.val.args[0]['int'])
								}),
								_a
							);
						};

						SaplingStateToken.prim = 'sapling_state';
						return SaplingStateToken;
					})(Token);

				var SaplingTransactionValidationError =
					/** @class */
					(function (_super) {
						__extends(SaplingTransactionValidationError, _super);

						function SaplingTransactionValidationError(value, token, message) {
							var _this = _super.call(this, value, token, message) || this;

							_this.value = value;
							_this.token = token;
							_this.name = 'SaplingTransactionValidationError';
							return _this;
						}

						return SaplingTransactionValidationError;
					})(TokenValidationError);

				var SaplingTransactionToken =
					/** @class */
					(function (_super) {
						__extends(SaplingTransactionToken, _super);

						function SaplingTransactionToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						SaplingTransactionToken.prototype.Execute = function (_val) {
							throw new Error('There is no literal value for the sapling_transaction type.');
						};

						SaplingTransactionToken.prototype.validateBytes = function (val) {
							var bytes = /^(0x|0X)?([0-9a-fA-F]*$)/.exec(val);

							if (bytes && bytes[2].length % 2 === 0) {
								return bytes[2];
							} else {
								throw new SaplingTransactionValidationError(val, this, 'Invalid bytes: ' + val);
							}
						};

						SaplingTransactionToken.prototype.convertUint8ArrayToHexString = function (val) {
							return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;
						};

						SaplingTransactionToken.prototype.Encode = function (args) {
							var val = args.pop();
							val = this.validateBytes(this.convertUint8ArrayToHexString(val));
							return {
								bytes: String(val).toString()
							};
						};

						SaplingTransactionToken.prototype.EncodeObject = function (val) {
							val = this.validateBytes(this.convertUint8ArrayToHexString(val));
							return {
								bytes: String(val).toString()
							};
						};

						SaplingTransactionToken.prototype.ExtractSchema = function () {
							var _a;

							return (
								(_a = {}),
								(_a[SaplingTransactionToken.prim] = {
									'memo-size': Number(this.val.args[0]['int'])
								}),
								_a
							);
						};

						SaplingTransactionToken.prim = 'sapling_transaction';
						return SaplingTransactionToken;
					})(Token);

				var Bls12381frValidationError =
					/** @class */
					(function (_super) {
						__extends(Bls12381frValidationError, _super);

						function Bls12381frValidationError(value, token, message) {
							var _this = _super.call(this, value, token, message) || this;

							_this.value = value;
							_this.token = token;
							_this.name = 'Bls12381frValidationError';
							return _this;
						}

						return Bls12381frValidationError;
					})(TokenValidationError);

				var Bls12381frToken =
					/** @class */
					(function (_super) {
						__extends(Bls12381frToken, _super);

						function Bls12381frToken(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						Bls12381frToken.prototype.isValid = function (val) {
							if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
								return null;
							} else {
								return new Bls12381frValidationError(val, this, 'Invalid bytes: ' + val);
							}
						};

						Bls12381frToken.prototype.convertUint8ArrayToHexString = function (val) {
							return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;
						};

						Bls12381frToken.prototype.Encode = function (args) {
							var val = args.pop();

							if (typeof val === 'number') {
								return {
									int: val.toString()
								};
							} else {
								val = this.convertUint8ArrayToHexString(val);
								var err = this.isValid(val);

								if (err) {
									throw err;
								}

								return {
									bytes: val
								};
							}
						};

						Bls12381frToken.prototype.EncodeObject = function (val) {
							if (typeof val === 'number') {
								return {
									int: val.toString()
								};
							} else {
								val = this.convertUint8ArrayToHexString(val);
								var err = this.isValid(val);

								if (err) {
									throw err;
								}

								return {
									bytes: val
								};
							}
						};

						Bls12381frToken.prototype.Execute = function (val) {
							return val.bytes;
						};

						Bls12381frToken.prototype.ExtractSchema = function () {
							return Bls12381frToken.prim;
						}; // An element of the BLS12-381 scalar field Fr
						// see https://tezos.gitlab.io/michelson-reference/#type-bls12_381_fr

						Bls12381frToken.prim = 'bls12_381_fr';
						return Bls12381frToken;
					})(Token);

				var Bls12381g1ValidationError =
					/** @class */
					(function (_super) {
						__extends(Bls12381g1ValidationError, _super);

						function Bls12381g1ValidationError(value, token, message) {
							var _this = _super.call(this, value, token, message) || this;

							_this.value = value;
							_this.token = token;
							_this.name = 'Bls12381g1ValidationError';
							return _this;
						}

						return Bls12381g1ValidationError;
					})(TokenValidationError);

				var Bls12381g1Token =
					/** @class */
					(function (_super) {
						__extends(Bls12381g1Token, _super);

						function Bls12381g1Token(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						Bls12381g1Token.prototype.isValid = function (val) {
							if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
								return null;
							} else {
								return new Bls12381g1ValidationError(val, this, 'Invalid bytes: ' + val);
							}
						};

						Bls12381g1Token.prototype.convertUint8ArrayToHexString = function (val) {
							return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;
						};

						Bls12381g1Token.prototype.Encode = function (args) {
							var val = args.pop();
							val = this.convertUint8ArrayToHexString(val);
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								bytes: val
							};
						};

						Bls12381g1Token.prototype.EncodeObject = function (val) {
							val = this.convertUint8ArrayToHexString(val);
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								bytes: val
							};
						};

						Bls12381g1Token.prototype.Execute = function (val) {
							return val.bytes;
						};

						Bls12381g1Token.prototype.ExtractSchema = function () {
							return Bls12381g1Token.prim;
						}; // A point on the BLS12-381 curve G1
						// See https://tezos.gitlab.io/michelson-reference/#type-bls12_381_g1

						Bls12381g1Token.prim = 'bls12_381_g1';
						return Bls12381g1Token;
					})(Token);

				var Bls12381g2ValidationError =
					/** @class */
					(function (_super) {
						__extends(Bls12381g2ValidationError, _super);

						function Bls12381g2ValidationError(value, token, message) {
							var _this = _super.call(this, value, token, message) || this;

							_this.value = value;
							_this.token = token;
							_this.name = 'Bls12381g2ValidationError';
							return _this;
						}

						return Bls12381g2ValidationError;
					})(TokenValidationError);

				var Bls12381g2Token =
					/** @class */
					(function (_super) {
						__extends(Bls12381g2Token, _super);

						function Bls12381g2Token(val, idx, fac) {
							var _this = _super.call(this, val, idx, fac) || this;

							_this.val = val;
							_this.idx = idx;
							_this.fac = fac;
							return _this;
						}

						Bls12381g2Token.prototype.isValid = function (val) {
							if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
								return null;
							} else {
								return new Bls12381g2ValidationError(val, this, 'Invalid bytes: ' + val);
							}
						};

						Bls12381g2Token.prototype.convertUint8ArrayToHexString = function (val) {
							return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;
						};

						Bls12381g2Token.prototype.Encode = function (args) {
							var val = args.pop();
							val = this.convertUint8ArrayToHexString(val);
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								bytes: val
							};
						};

						Bls12381g2Token.prototype.EncodeObject = function (val) {
							val = this.convertUint8ArrayToHexString(val);
							var err = this.isValid(val);

							if (err) {
								throw err;
							}

							return {
								bytes: val
							};
						};

						Bls12381g2Token.prototype.Execute = function (val) {
							return val.bytes;
						};

						Bls12381g2Token.prototype.ExtractSchema = function () {
							return Bls12381g2Token.prim;
						}; // A point on the BLS12-381 curve G2
						// See https://tezos.gitlab.io/michelson-reference/#type-bls12_381_g2

						Bls12381g2Token.prim = 'bls12_381_g2';
						return Bls12381g2Token;
					})(Token);

				var tokens = [
					PairToken,
					NatToken,
					StringToken,
					BigMapToken,
					AddressToken,
					MapToken,
					BoolToken,
					OrToken,
					ContractToken,
					ListToken,
					MutezToken,
					BytesToken,
					OptionToken,
					TimestampToken,
					IntToken,
					UnitToken,
					KeyToken,
					KeyHashToken,
					SignatureToken,
					LambdaToken,
					OperationToken,
					SetToken,
					ChainIDToken,
					TicketToken,
					NeverToken,
					SaplingStateToken,
					SaplingTransactionToken,
					Bls12381frToken,
					Bls12381g1Token,
					Bls12381g2Token
				];

				var InvalidTokenError =
					/** @class */
					(function () {
						function InvalidTokenError(message, data) {
							this.message = message;
							this.data = data;
							this.name = 'Invalid token error';
						}

						return InvalidTokenError;
					})();

				function createToken(val, idx) {
					if (Array.isArray(val)) {
						return new PairToken(val, idx, createToken);
					}

					var t = tokens.find(function (x) {
						return x.prim === val.prim;
					});

					if (!t) {
						throw new InvalidTokenError(
							'Malformed data expected a value with a valid prim property',
							val
						);
					}

					return new t(val, idx, createToken);
				}

				var _a;

				var schemaTypeSymbol = Symbol.for('taquito-schema-type-symbol'); // collapse comb pair

				function collapse(val, prim) {
					var _b, _c;

					if (prim === void 0) {
						prim = PairToken.prim;
					}

					if (Array.isArray(val)) {
						return collapse(
							{
								prim: prim,
								args: val
							},
							prim
						);
					}

					if (
						val.prim === prim &&
						((_b = val.args) === null || _b === void 0 ? void 0 : _b.length) > 2
					) {
						return __assign(__assign({}, val), {
							args: [
								val.args[0],
								{
									prim: prim,
									args: (_c = val.args) === null || _c === void 0 ? void 0 : _c.slice(1)
								}
							]
						});
					}

					return val;
				}

				function deepEqual(a, b) {
					var ac = collapse(a);
					var bc = collapse(b);
					return (
						ac.prim === bc.prim &&
						((ac.args === undefined && bc.args === undefined) ||
							(ac.args !== undefined &&
								bc.args !== undefined &&
								ac.args.length === bc.args.length &&
								ac.args.every(function (v, i) {
									var _b;

									return deepEqual(v, (_b = bc.args) === null || _b === void 0 ? void 0 : _b[i]);
								}))) &&
						((ac.annots === undefined && bc.annots === undefined) ||
							(ac.annots !== undefined &&
								bc.annots !== undefined &&
								ac.annots.length === bc.annots.length &&
								ac.annots.every(function (v, i) {
									var _b;

									return v === ((_b = bc.annots) === null || _b === void 0 ? void 0 : _b[i]);
								})))
					);
				}
				/**
				 * @warn Our current smart contract abstraction feature is currently in preview. It's API is not final, and it may not cover every use case (yet). We will greatly appreciate any feedback on this feature.
				 */

				var Schema =
					/** @class */
					(function () {
						function Schema(val) {
							this[_a] = true;
							this.root = createToken(val, 0);

							if (this.root instanceof BigMapToken) {
								this.bigMap = this.root;
							} else if (this.isExpressionExtended(val) && val.prim === 'pair') {
								var exp = val.args[0];

								if (this.isExpressionExtended(exp) && exp.prim === 'big_map') {
									this.bigMap = new BigMapToken(exp, 0, createToken);
								}
							}
						}

						Schema.isSchema = function (obj) {
							return obj && obj[schemaTypeSymbol] === true;
						};

						Schema.fromRPCResponse = function (val) {
							var storage =
								val &&
								val.script &&
								Array.isArray(val.script.code) &&
								val.script.code.find(function (x) {
									return x.prim === 'storage';
								});

							if (!storage || !Array.isArray(storage.args)) {
								throw new Error('Invalid rpc response passed as arguments');
							}

							return new Schema(storage.args[0]);
						};

						Schema.prototype.isExpressionExtended = function (val) {
							return 'prim' in val && Array.isArray(val.args);
						};

						Schema.prototype.removeTopLevelAnnotation = function (obj) {
							// PairToken and OrToken can have redundant top level annotation in their storage
							if (this.root instanceof PairToken || this.root instanceof OrToken) {
								if (
									this.root.hasAnnotations() &&
									_typeof(obj) === 'object' &&
									Object.keys(obj).length === 1
								) {
									return obj[Object.keys(obj)[0]];
								}
							}

							return obj;
						};

						Schema.prototype.Execute = function (val, semantics) {
							var storage = this.root.Execute(val, semantics);
							return this.removeTopLevelAnnotation(storage);
						};

						Schema.prototype.Typecheck = function (val) {
							if (this.root instanceof BigMapToken && Number.isInteger(Number(val))) {
								return true;
							}

							try {
								this.root.EncodeObject(val);
								return true;
							} catch (ex) {
								return false;
							}
						};

						Schema.prototype.ExecuteOnBigMapDiff = function (diff, semantics) {
							if (!this.bigMap) {
								throw new Error('No big map schema');
							}

							if (!Array.isArray(diff)) {
								throw new Error('Invalid big map diff. It must be an array');
							}

							var eltFormat = diff.map(function (_b) {
								var key = _b.key,
									value = _b.value;
								return {
									args: [key, value]
								};
							});
							return this.bigMap.Execute(eltFormat, semantics);
						};

						Schema.prototype.ExecuteOnBigMapValue = function (key, semantics) {
							if (!this.bigMap) {
								throw new Error('No big map schema');
							}

							return this.bigMap.ValueSchema.Execute(key, semantics);
						};

						Schema.prototype.EncodeBigMapKey = function (key) {
							if (!this.bigMap) {
								throw new Error('No big map schema');
							}

							try {
								return this.bigMap.KeySchema.ToBigMapKey(key);
							} catch (ex) {
								throw new Error('Unable to encode big map key: ' + ex);
							}
						};

						Schema.prototype.Encode = function (_value) {
							try {
								return this.root.EncodeObject(_value);
							} catch (ex) {
								if (ex instanceof TokenValidationError) {
									throw ex;
								}

								throw new Error('Unable to encode storage object. ' + ex);
							}
						};

						Schema.prototype.ExtractSchema = function () {
							return this.removeTopLevelAnnotation(this.root.ExtractSchema());
						};
						/**
						 * @deprecated
						 */

						Schema.prototype.ComputeState = function (tx, state) {
							var _b;

							var _this = this;

							if (!this.bigMap) {
								throw new Error('No big map schema');
							}

							var bigMap = tx.reduce(function (prev, current) {
								return __assign(
									__assign({}, prev),
									_this.ExecuteOnBigMapDiff(
										current.contents[0].metadata.operation_result.big_map_diff
									)
								);
							}, {});
							return __assign(
								__assign({}, this.Execute(state)),
								((_b = {}), (_b[this.bigMap.annot()] = bigMap), _b)
							);
						};
						/**
						 * @description Look up in top-level pairs of the storage to find a value matching the specified type
						 *
						 * @returns The first value found that match the type or `undefined` if no value is found
						 *
						 * @param storage storage to parse to find the value
						 * @param valueType type of value to look for
						 *
						 */

						Schema.prototype.FindFirstInTopLevelPair = function (storage, valueType) {
							return this.findValue(this.root['val'], storage, valueType);
						};

						Schema.prototype.findValue = function (schema, storage, valueToFind) {
							if (deepEqual(valueToFind, schema)) {
								return storage;
							}

							if (Array.isArray(schema) || schema['prim'] === 'pair') {
								var sch = collapse(schema);
								var str = collapse(storage, 'Pair');

								if (sch.args === undefined || str.args === undefined) {
									throw new Error('Tokens have no arguments'); // unlikely
								}

								return (
									this.findValue(sch.args[0], str.args[0], valueToFind) ||
									this.findValue(sch.args[1], str.args[1], valueToFind)
								);
							}
						};

						return Schema;
					})();

				exports.Schema = Schema;
				_a = schemaTypeSymbol;
				/**
				 * @warn Our current smart contract abstraction feature is currently in preview. It's API is not final, and it may not cover every use case (yet). We will greatly appreciate any feedback on this feature.
				 */

				var ParameterSchema =
					/** @class */
					(function () {
						function ParameterSchema(val) {
							this.root = createToken(val, 0);
						}

						ParameterSchema.fromRPCResponse = function (val) {
							var parameter =
								val &&
								val.script &&
								Array.isArray(val.script.code) &&
								val.script.code.find(function (x) {
									return x.prim === 'parameter';
								});

							if (!parameter || !Array.isArray(parameter.args)) {
								throw new Error('Invalid rpc response passed as arguments');
							}

							return new ParameterSchema(parameter.args[0]);
						};

						Object.defineProperty(ParameterSchema.prototype, 'isMultipleEntryPoint', {
							get: function () {
								return (
									this.root instanceof OrToken ||
									(this.root instanceof OptionToken && this.root.subToken() instanceof OrToken)
								);
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(ParameterSchema.prototype, 'hasAnnotation', {
							get: function () {
								if (this.isMultipleEntryPoint) {
									return Object.keys(this.ExtractSchema())[0] !== '0';
								} else {
									return true;
								}
							},
							enumerable: false,
							configurable: true
						});

						ParameterSchema.prototype.Execute = function (val, semantics) {
							return this.root.Execute(val, semantics);
						};

						ParameterSchema.prototype.Encode = function () {
							var args = [];

							for (var _i = 0; _i < arguments.length; _i++) {
								args[_i] = arguments[_i];
							}

							try {
								return this.root.Encode(args.reverse());
							} catch (ex) {
								if (ex instanceof TokenValidationError) {
									throw ex;
								}

								throw new Error('Unable to encode parameter. ' + ex);
							}
						};

						ParameterSchema.prototype.EncodeObject = function (_value) {
							try {
								return this.root.EncodeObject(_value);
							} catch (ex) {
								if (ex instanceof TokenValidationError) {
									throw ex;
								}

								throw new Error('Unable to encode parameter object. ' + ex);
							}
						};

						ParameterSchema.prototype.ExtractSchema = function () {
							return this.root.ExtractSchema();
						};

						ParameterSchema.prototype.ExtractSignatures = function () {
							return this.root.ExtractSignature();
						};

						return ParameterSchema;
					})(); // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!

				/* tslint:disable */

				exports.ParameterSchema = ParameterSchema;
				var VERSION = {
					commitHash: '68be71fd14ffd87bd0a0f91dab60d69c8665e88c',
					version: '10.2.0'
				};
				/* tslint:enable */

				/**
				 * @packageDocumentation
				 * @module @taquito/michelson-encoder
				 */

				exports.VERSION = VERSION;
				var UnitValue = Symbol();
				exports.UnitValue = UnitValue;
				var SaplingStateValue = {};
				exports.SaplingStateValue = SaplingStateValue;
			},
			{
				'fast-json-stable-stringify': '../node_modules/fast-json-stable-stringify/index.js',
				'bignumber.js': '../node_modules/bignumber.js/bignumber.js',
				'@taquito/utils': '../node_modules/@taquito/utils/dist/taquito-utils.es5.js',
				buffer: '../node_modules/node-libs-browser/node_modules/buffer/index.js'
			}
		],
		'../node_modules/@taquito/michel-codec/dist/taquito-michel-codec.es5.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.assertContractValid = assertContractValid;
				exports.assertDataListIfAny = assertDataListIfAny;
				exports.assertDataValid = assertDataValid;
				exports.assertMichelsonBigMapStorableType = assertMichelsonBigMapStorableType;
				exports.assertMichelsonComparableType = assertMichelsonComparableType;
				exports.assertMichelsonContract = assertMichelsonContract;
				exports.assertMichelsonData = assertMichelsonData;
				exports.assertMichelsonInstruction = assertMichelsonInstruction;
				exports.assertMichelsonPackableType = assertMichelsonPackableType;
				exports.assertMichelsonPassableType = assertMichelsonPassableType;
				exports.assertMichelsonPushableType = assertMichelsonPushableType;
				exports.assertMichelsonStorableType = assertMichelsonStorableType;
				exports.assertMichelsonType = assertMichelsonType;
				exports.assertTypeAnnotationsValid = assertTypeAnnotationsValid;
				exports.assertTypesEqual = assertTypesEqual;
				exports.contractEntryPoint = contractEntryPoint;
				exports.contractEntryPoints = contractEntryPoints;
				exports.contractSection = contractSection;
				exports.decodeAddressBytes = decodeAddressBytes;
				exports.decodePublicKeyBytes = decodePublicKeyBytes;
				exports.decodePublicKeyHashBytes = decodePublicKeyHashBytes;
				exports.emitMicheline = emitMicheline;
				exports.formatError = formatError;
				exports.formatStack = formatStack;
				exports.functionType = functionType;
				exports.isContractValid = isContractValid;
				exports.isDataValid = isDataValid;
				exports.isInstruction = isInstruction;
				exports.isMichelsonCode = isMichelsonCode;
				exports.isMichelsonData = isMichelsonData;
				exports.isMichelsonError = isMichelsonError;
				exports.isMichelsonScript = isMichelsonScript;
				exports.isMichelsonType = isMichelsonType;
				exports.isTypeAnnotationsValid = isTypeAnnotationsValid;
				exports.isTypeEqual = isTypeEqual;
				exports.packData = packData;
				exports.packDataBytes = packDataBytes;
				exports.traceDumpFunc = traceDumpFunc;
				exports.unpackData = unpackData;
				exports.unpackDataBytes = unpackDataBytes;
				exports.sourceReference =
					exports.refContract =
					exports.instructionIDs =
					exports.dummyContract =
					exports.VERSION =
					exports.Protocol =
					exports.Parser =
					exports.MichelsonValidationError =
					exports.MichelsonTypeError =
					exports.MichelsonInstructionError =
					exports.MichelsonError =
					exports.MichelineParseError =
					exports.MacroError =
					exports.JSONParseError =
					exports.DefaultProtocol =
					exports.Contract =
						void 0;

				function _typeof(obj) {
					if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
						_typeof = function (obj) {
							return typeof obj;
						};
					} else {
						_typeof = function (obj) {
							return obj &&
								typeof Symbol === 'function' &&
								obj.constructor === Symbol &&
								obj !== Symbol.prototype
								? 'symbol'
								: typeof obj;
						};
					}
					return _typeof(obj);
				}

				// Michelson abstract syntax tree types https://tezos.gitlab.io/whitedoc/michelson.html#concrete-syntax
				var sourceReference = Symbol('source_reference');
				/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

				/* global Reflect, Promise */

				exports.sourceReference = sourceReference;

				var extendStatics = function (d, b) {
					extendStatics =
						Object.setPrototypeOf ||
						({
							__proto__: []
						} instanceof Array &&
							function (d, b) {
								d.__proto__ = b;
							}) ||
						function (d, b) {
							for (var p in b) {
								if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
							}
						};

					return extendStatics(d, b);
				};

				function __extends(d, b) {
					if (typeof b !== 'function' && b !== null)
						throw new TypeError(
							'Class extends value ' + String(b) + ' is not a constructor or null'
						);
					extendStatics(d, b);

					function __() {
						this.constructor = d;
					}

					d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
				}

				var __assign = function () {
					__assign =
						Object.assign ||
						function __assign(t) {
							for (var s, i = 1, n = arguments.length; i < n; i++) {
								s = arguments[i];

								for (var p in s) {
									if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
								}
							}

							return t;
						};

					return __assign.apply(this, arguments);
				};

				function __rest(s, e) {
					var t = {};

					for (var p in s) {
						if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
					}

					if (s != null && typeof Object.getOwnPropertySymbols === 'function')
						for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
							if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
								t[p[i]] = s[p[i]];
						}
					return t;
				}

				function __generator(thisArg, body) {
					var _ = {
							label: 0,
							sent: function () {
								if (t[0] & 1) throw t[1];
								return t[1];
							},
							trys: [],
							ops: []
						},
						f,
						y,
						t,
						g;
					return (
						(g = {
							next: verb(0),
							throw: verb(1),
							return: verb(2)
						}),
						typeof Symbol === 'function' &&
							(g[Symbol.iterator] = function () {
								return this;
							}),
						g
					);

					function verb(n) {
						return function (v) {
							return step([n, v]);
						};
					}

					function step(op) {
						if (f) throw new TypeError('Generator is already executing.');

						while (_) {
							try {
								if (
									((f = 1),
									y &&
										(t =
											op[0] & 2
												? y['return']
												: op[0]
												? y['throw'] || ((t = y['return']) && t.call(y), 0)
												: y.next) &&
										!(t = t.call(y, op[1])).done)
								)
									return t;
								if (((y = 0), t)) op = [op[0] & 2, t.value];

								switch (op[0]) {
									case 0:
									case 1:
										t = op;
										break;

									case 4:
										_.label++;
										return {
											value: op[1],
											done: false
										};

									case 5:
										_.label++;
										y = op[1];
										op = [0];
										continue;

									case 7:
										op = _.ops.pop();

										_.trys.pop();

										continue;

									default:
										if (
											!((t = _.trys), (t = t.length > 0 && t[t.length - 1])) &&
											(op[0] === 6 || op[0] === 2)
										) {
											_ = 0;
											continue;
										}

										if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
											_.label = op[1];
											break;
										}

										if (op[0] === 6 && _.label < t[1]) {
											_.label = t[1];
											t = op;
											break;
										}

										if (t && _.label < t[2]) {
											_.label = t[2];

											_.ops.push(op);

											break;
										}

										if (t[2]) _.ops.pop();

										_.trys.pop();

										continue;
								}

								op = body.call(thisArg, _);
							} catch (e) {
								op = [6, e];
								y = 0;
							} finally {
								f = t = 0;
							}
						}

						if (op[0] & 5) throw op[1];
						return {
							value: op[0] ? op[1] : void 0,
							done: true
						};
					}
				}

				function __values(o) {
					var s = typeof Symbol === 'function' && Symbol.iterator,
						m = s && o[s],
						i = 0;
					if (m) return m.call(o);
					if (o && typeof o.length === 'number')
						return {
							next: function () {
								if (o && i >= o.length) o = void 0;
								return {
									value: o && o[i++],
									done: !o
								};
							}
						};
					throw new TypeError(s ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
				}

				function __read(o, n) {
					var m = typeof Symbol === 'function' && o[Symbol.iterator];
					if (!m) return o;
					var i = m.call(o),
						r,
						ar = [],
						e;

					try {
						while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
							ar.push(r.value);
						}
					} catch (error) {
						e = {
							error: error
						};
					} finally {
						try {
							if (r && !r.done && (m = i['return'])) m.call(i);
						} finally {
							if (e) throw e.error;
						}
					}

					return ar;
				}

				function __spreadArray(to, from) {
					for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {
						to[j] = from[i];
					}

					return to;
				}

				var ScanError =
					/** @class */
					(function (_super) {
						__extends(ScanError, _super);

						function ScanError(src, idx, message) {
							var _this = _super.call(this, message) || this;

							_this.src = src;
							_this.idx = idx;
							Object.setPrototypeOf(_this, ScanError.prototype);
							return _this;
						}

						return ScanError;
					})(Error);

				var Literal;

				(function (Literal) {
					Literal[(Literal['Comment'] = 0)] = 'Comment';
					Literal[(Literal['Number'] = 1)] = 'Number';
					Literal[(Literal['String'] = 2)] = 'String';
					Literal[(Literal['Bytes'] = 3)] = 'Bytes';
					Literal[(Literal['Ident'] = 4)] = 'Ident';
				})(Literal || (Literal = {}));

				var isSpace = new RegExp('\\s');
				var isIdentStart = new RegExp('[:@%_A-Za-z]');
				var isIdent = new RegExp('[@%_\\.A-Za-z0-9]');
				var isDigit = new RegExp('[0-9]');
				var isHex = new RegExp('[0-9a-fA-F]');

				function scan(src, scanComments) {
					var i, s, start, ii, esc;

					if (scanComments === void 0) {
						scanComments = false;
					}

					return __generator(this, function (_a) {
						switch (_a.label) {
							case 0:
								i = 0;
								_a.label = 1;

							case 1:
								if (!(i < src.length)) return [3 /*break*/, 19]; // Skip space

								while (i < src.length && isSpace.test(src[i])) {
									i++;
								}

								if (i === src.length) {
									return [
										2
										/*return*/
									];
								}

								s = src[i];
								start = i;
								if (!isIdentStart.test(s)) return [3 /*break*/, 3]; // Identifier

								i++;

								while (i < src.length && isIdent.test(src[i])) {
									i++;
								}

								return [
									4,
									/*yield*/
									{
										t: Literal.Ident,
										v: src.slice(start, i),
										first: start,
										last: i
									}
								];

							case 2:
								_a.sent();

								return [3 /*break*/, 18];

							case 3:
								if (!(src.length - i > 1 && src.substr(i, 2) === '0x')) return [3 /*break*/, 5]; // Bytes

								i += 2;

								while (i < src.length && isHex.test(src[i])) {
									i++;
								}

								if (((i - start) & 1) !== 0) {
									throw new ScanError(
										src,
										i,
										'Bytes literal length is expected to be power of two'
									);
								}

								return [
									4,
									/*yield*/
									{
										t: Literal.Bytes,
										v: src.slice(start, i),
										first: start,
										last: i
									}
								];

							case 4:
								_a.sent();

								return [3 /*break*/, 18];

							case 5:
								if (!(isDigit.test(s) || s === '-')) return [3 /*break*/, 7]; // Number

								if (s === '-') {
									i++;
								}

								ii = i;

								while (i < src.length && isDigit.test(src[i])) {
									i++;
								}

								if (ii === i) {
									throw new ScanError(src, i, 'Number literal is too short');
								}

								return [
									4,
									/*yield*/
									{
										t: Literal.Number,
										v: src.slice(start, i),
										first: start,
										last: i
									}
								];

							case 6:
								_a.sent();

								return [3 /*break*/, 18];

							case 7:
								if (!(s === '"')) return [3 /*break*/, 9]; // String

								i++;
								esc = false;

								for (; i < src.length && (esc || src[i] !== '"'); i++) {
									if (!esc && src[i] === '\\') {
										esc = true;
									} else {
										esc = false;
									}
								}

								if (i === src.length) {
									throw new ScanError(src, i, 'Unterminated string literal');
								}

								i++;
								return [
									4,
									/*yield*/
									{
										t: Literal.String,
										v: src.slice(start, i),
										first: start,
										last: i
									}
								];

							case 8:
								_a.sent();

								return [3 /*break*/, 18];

							case 9:
								if (!(s === '#')) return [3 /*break*/, 12]; // Comment

								i++;

								while (i < src.length && src[i] !== '\n') {
									i++;
								}

								if (!scanComments) return [3 /*break*/, 11];
								return [
									4,
									/*yield*/
									{
										t: Literal.Comment,
										v: src.slice(start, i),
										first: start,
										last: i
									}
								];

							case 10:
								_a.sent();

								_a.label = 11;

							case 11:
								return [3 /*break*/, 18];

							case 12:
								if (!(src.length - i > 1 && src.substr(i, 2) === '/*')) return [3 /*break*/, 15]; // C style comment

								i += 2;

								while (i < src.length && !(src.length - i > 1 && src.substr(i, 2) === '*/')) {
									i++;
								}

								if (i === src.length) {
									throw new ScanError(src, i, 'Unterminated C style comment');
								}

								i += 2;
								if (!scanComments) return [3 /*break*/, 14];
								return [
									4,
									/*yield*/
									{
										t: Literal.Comment,
										v: src.slice(start, i),
										first: start,
										last: i
									}
								];

							case 13:
								_a.sent();

								_a.label = 14;

							case 14:
								return [3 /*break*/, 18];

							case 15:
								if (!(s === '(' || s === ')' || s === '{' || s === '}' || s === ';'))
									return [3 /*break*/, 17];
								i++;
								return [
									4,
									/*yield*/
									{
										t: s,
										v: s,
										first: start,
										last: i
									}
								];

							case 16:
								_a.sent();

								return [3 /*break*/, 18];

							case 17:
								throw new ScanError(src, i, 'Invalid character at offset ' + i + ': `' + s + "'");

							case 18:
								return [3 /*break*/, 1];

							case 19:
								return [
									2
									/*return*/
								];
						}
					});
				} // Michelson types

				var refContract = Symbol('ref_contract');
				exports.refContract = refContract;
				var Protocol;
				exports.Protocol = Protocol;

				(function (Protocol) {
					Protocol['Pt24m4xi'] = 'Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd';
					Protocol['PsBABY5H'] = 'PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU';
					Protocol['PsBabyM1'] = 'PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS';
					Protocol['PsCARTHA'] = 'PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb';
					Protocol['PsDELPH1'] = 'PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo';
					Protocol['PtEdo2Zk'] = 'PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA';
					Protocol['PsFLorena'] = 'PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i';
					Protocol['PtGRANADs'] = 'PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV';
					Protocol['PtHangzH'] = 'PtHangzHogokSuiMHemCuowEavgYTP8J5qQ9fQS793MHYFpCY3r';
				})(Protocol || (exports.Protocol = Protocol = {}));

				var DefaultProtocol = Protocol.PsDELPH1;
				exports.DefaultProtocol = DefaultProtocol;

				var MacroError =
					/** @class */
					(function (_super) {
						__extends(MacroError, _super);

						function MacroError(prim, message) {
							var _this = _super.call(this, message) || this;

							_this.prim = prim;
							Object.setPrototypeOf(_this, MacroError.prototype);
							return _this;
						}

						return MacroError;
					})(Error);

				exports.MacroError = MacroError;

				function assertArgs$1(ex, n) {
					var _a, _b;

					if (
						(n === 0 && ex.args === undefined) ||
						((_a = ex.args) === null || _a === void 0 ? void 0 : _a.length) === n
					) {
						return true;
					}

					throw new MacroError(
						ex,
						'macro ' +
							ex.prim +
							' expects ' +
							n +
							' arguments, was given ' +
							((_b = ex.args) === null || _b === void 0 ? void 0 : _b.length)
					);
				}

				function assertNoAnnots(ex) {
					if (ex.annots === undefined) {
						return true;
					}

					throw new MacroError(ex, 'unexpected annotation on macro ' + ex.prim + ': ' + ex.annots);
				}

				function assertIntArg(ex, arg) {
					if ('int' in arg) {
						return true;
					}

					throw new MacroError(ex, 'macro ' + ex.prim + ' expects int argument');
				}

				function parsePairUnpairExpr(p, expr, annotations, agg) {
					var i = 0;
					var ai = 0;
					var ann = [null, null]; // Left expression

					var lexpr;

					if (i === expr.length) {
						throw new MacroError(p, 'unexpected end: ' + p.prim);
					}

					var c = expr[i++];

					switch (c) {
						case 'P':
							var _a = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg),
								r = _a.r,
								n = _a.n,
								an = _a.an;

							lexpr = r;
							i += n;
							ai += an;
							break;

						case 'A':
							if (ai !== annotations.length) {
								ann[0] = annotations[ai++];
							}

							break;

						default:
							throw new MacroError(p, p.prim + ': unexpected character: ' + c);
					} // Right expression

					var rexpr;

					if (i === expr.length) {
						throw new MacroError(p, 'unexpected end: ' + p.prim);
					}

					c = expr[i++];

					switch (c) {
						case 'P':
							var _b = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg),
								r = _b.r,
								n = _b.n,
								an = _b.an;

							rexpr = r.map(function (_a) {
								var _b = __read(_a, 2),
									v = _b[0],
									a = _b[1];

								return [v + 1, a];
							});
							i += n;
							ai += an;
							break;

						case 'I':
							if (ai !== annotations.length) {
								ann[1] = annotations[ai++];
							}

							break;

						default:
							throw new MacroError(p, p.prim + ': unexpected character: ' + c);
					}

					return {
						r: agg(lexpr, rexpr, [0, ann]),
						n: i,
						an: ai
					};
				}

				function parseSetMapCadr(p, expr, vann, term) {
					var c = expr[0];

					switch (c) {
						case 'A':
							return expr.length > 1
								? [
										{
											prim: 'DUP'
										},
										{
											prim: 'DIP',
											args: [
												[
													{
														prim: 'CAR',
														annots: ['@%%']
													},
													parseSetMapCadr(p, expr.slice(1), [], term)
												]
											]
										},
										{
											prim: 'CDR',
											annots: ['@%%']
										},
										{
											prim: 'SWAP'
										},
										{
											prim: 'PAIR',
											annots: __spreadArray(['%@', '%@'], __read(vann))
										}
								  ]
								: term.a;

						case 'D':
							return expr.length > 1
								? [
										{
											prim: 'DUP'
										},
										{
											prim: 'DIP',
											args: [
												[
													{
														prim: 'CDR',
														annots: ['@%%']
													},
													parseSetMapCadr(p, expr.slice(1), [], term)
												]
											]
										},
										{
											prim: 'CAR',
											annots: ['@%%']
										},
										{
											prim: 'PAIR',
											annots: __spreadArray(['%@', '%@'], __read(vann))
										}
								  ]
								: term.d;

						default:
							throw new MacroError(p, p.prim + ': unexpected character: ' + c);
					}
				}

				function trimLast(a, v) {
					var l = a.length;

					while (l > 0 && a[l - 1] === v) {
						l--;
					}

					return a.slice(0, l);
				}

				function filterAnnotations(a) {
					var e_1, _a;

					var fields = [];
					var rest = [];

					if (a !== undefined) {
						try {
							for (var a_1 = __values(a), a_1_1 = a_1.next(); !a_1_1.done; a_1_1 = a_1.next()) {
								var v = a_1_1.value;
								(v.length !== 0 && v[0] === '%' ? fields : rest).push(v);
							}
						} catch (e_1_1) {
							e_1 = {
								error: e_1_1
							};
						} finally {
							try {
								if (a_1_1 && !a_1_1.done && (_a = a_1.return)) _a.call(a_1);
							} finally {
								if (e_1) throw e_1.error;
							}
						}
					}

					return {
						fields: fields,
						rest: rest
					};
				}

				function mkPrim(_a) {
					var prim = _a.prim,
						annots = _a.annots,
						args = _a.args;
					return __assign(
						__assign(
							{
								prim: prim
							},
							annots && {
								annots: annots
							}
						),
						args && {
							args: args
						}
					);
				}

				var pairRe = /^P[PAI]{3,}R$/;
				var unpairRe = /^UNP[PAI]{2,}R$/;
				var cadrRe = /^C[AD]{2,}R$/;
				var setCadrRe = /^SET_C[AD]+R$/;
				var mapCadrRe = /^MAP_C[AD]+R$/;
				var diipRe = /^DI{2,}P$/;
				var duupRe = /^DU+P$/;

				function expandMacros(ex, opt) {
					var proto = (opt === null || opt === void 0 ? void 0 : opt.protocol) || DefaultProtocol;

					function mayRename(annots) {
						return annots !== undefined
							? [
									{
										prim: 'RENAME',
										annots: annots
									}
							  ]
							: [];
					}

					switch (ex.prim) {
						// Compare
						case 'CMPEQ':
						case 'CMPNEQ':
						case 'CMPLT':
						case 'CMPGT':
						case 'CMPLE':
						case 'CMPGE':
							if (assertArgs$1(ex, 0)) {
								return [
									{
										prim: 'COMPARE'
									},
									mkPrim({
										prim: ex.prim.slice(3),
										annots: ex.annots
									})
								];
							}

							break;

						case 'IFEQ':
						case 'IFNEQ':
						case 'IFLT':
						case 'IFGT':
						case 'IFLE':
						case 'IFGE':
							if (assertArgs$1(ex, 2)) {
								return [
									{
										prim: ex.prim.slice(2)
									},
									mkPrim({
										prim: 'IF',
										annots: ex.annots,
										args: ex.args
									})
								];
							}

							break;

						case 'IFCMPEQ':
						case 'IFCMPNEQ':
						case 'IFCMPLT':
						case 'IFCMPGT':
						case 'IFCMPLE':
						case 'IFCMPGE':
							if (assertArgs$1(ex, 2)) {
								return [
									{
										prim: 'COMPARE'
									},
									{
										prim: ex.prim.slice(5)
									},
									mkPrim({
										prim: 'IF',
										annots: ex.annots,
										args: ex.args
									})
								];
							}

							break;
						// Fail

						case 'FAIL':
							if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {
								return [
									{
										prim: 'UNIT'
									},
									{
										prim: 'FAILWITH'
									}
								];
							}

							break;
						// Assertion macros

						case 'ASSERT':
							if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {
								return [
									{
										prim: 'IF',
										args: [
											[],
											[
												[
													{
														prim: 'UNIT'
													},
													{
														prim: 'FAILWITH'
													}
												]
											]
										]
									}
								];
							}

							break;

						case 'ASSERT_EQ':
						case 'ASSERT_NEQ':
						case 'ASSERT_LT':
						case 'ASSERT_GT':
						case 'ASSERT_LE':
						case 'ASSERT_GE':
							if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {
								return [
									{
										prim: ex.prim.slice(7)
									},
									{
										prim: 'IF',
										args: [
											[],
											[
												[
													{
														prim: 'UNIT'
													},
													{
														prim: 'FAILWITH'
													}
												]
											]
										]
									}
								];
							}

							break;

						case 'ASSERT_CMPEQ':
						case 'ASSERT_CMPNEQ':
						case 'ASSERT_CMPLT':
						case 'ASSERT_CMPGT':
						case 'ASSERT_CMPLE':
						case 'ASSERT_CMPGE':
							if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {
								return [
									[
										{
											prim: 'COMPARE'
										},
										{
											prim: ex.prim.slice(10)
										}
									],
									{
										prim: 'IF',
										args: [
											[],
											[
												[
													{
														prim: 'UNIT'
													},
													{
														prim: 'FAILWITH'
													}
												]
											]
										]
									}
								];
							}

							break;

						case 'ASSERT_NONE':
							if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {
								return [
									{
										prim: 'IF_NONE',
										args: [
											[],
											[
												[
													{
														prim: 'UNIT'
													},
													{
														prim: 'FAILWITH'
													}
												]
											]
										]
									}
								];
							}

							break;

						case 'ASSERT_SOME':
							if (assertArgs$1(ex, 0)) {
								return [
									{
										prim: 'IF_NONE',
										args: [
											[
												[
													{
														prim: 'UNIT'
													},
													{
														prim: 'FAILWITH'
													}
												]
											],
											mayRename(ex.annots)
										]
									}
								];
							}

							break;

						case 'ASSERT_LEFT':
							if (assertArgs$1(ex, 0)) {
								return [
									{
										prim: 'IF_LEFT',
										args: [
											mayRename(ex.annots),
											[
												[
													{
														prim: 'UNIT'
													},
													{
														prim: 'FAILWITH'
													}
												]
											]
										]
									}
								];
							}

							break;

						case 'ASSERT_RIGHT':
							if (assertArgs$1(ex, 0)) {
								return [
									{
										prim: 'IF_LEFT',
										args: [
											[
												[
													{
														prim: 'UNIT'
													},
													{
														prim: 'FAILWITH'
													}
												]
											],
											mayRename(ex.annots)
										]
									}
								];
							}

							break;
						// Syntactic conveniences

						case 'IF_SOME':
							if (assertArgs$1(ex, 2)) {
								return [
									mkPrim({
										prim: 'IF_NONE',
										annots: ex.annots,
										args: [ex.args[1], ex.args[0]]
									})
								];
							}

							break;

						case 'IF_RIGHT':
							if (assertArgs$1(ex, 2)) {
								return [
									mkPrim({
										prim: 'IF_LEFT',
										annots: ex.annots,
										args: [ex.args[1], ex.args[0]]
									})
								];
							}

							break;
						// CAR/CDR n

						case 'CAR':
						case 'CDR':
							if (ex.args !== undefined) {
								if (assertArgs$1(ex, 1) && assertIntArg(ex, ex.args[0])) {
									var n = parseInt(ex.args[0].int, 10);
									return mkPrim({
										prim: 'GET',
										args: [
											{
												int: ex.prim === 'CAR' ? String(n * 2 + 1) : String(n * 2)
											}
										],
										annots: ex.annots
									});
								}
							} else {
								return ex;
							}
					} // More syntactic conveniences
					// PAPPAIIR macro

					if (pairRe.test(ex.prim)) {
						if (assertArgs$1(ex, 0)) {
							var _a = filterAnnotations(ex.annots),
								fields = _a.fields,
								rest_1 = _a.rest;

							var r_1 = parsePairUnpairExpr(ex, ex.prim.slice(1), fields, function (l, r, top) {
								return __spreadArray(
									__spreadArray(__spreadArray([], __read(l || [])), __read(r || [])),
									[top]
								);
							}).r;
							return r_1.map(function (_a, i) {
								var _b = __read(_a, 2),
									v = _b[0],
									a = _b[1];

								var ann = __spreadArray(
									__spreadArray(
										[],
										__read(
											trimLast(a, null).map(function (v) {
												return v === null ? '%' : v;
											})
										)
									),
									__read(v === 0 && i === r_1.length - 1 ? rest_1 : [])
								);

								var leaf = mkPrim({
									prim: 'PAIR',
									annots: ann.length !== 0 ? ann : undefined
								});
								return v === 0
									? leaf
									: {
											prim: 'DIP',
											args:
												v === 1
													? [[leaf]]
													: [
															{
																int: String(v)
															},
															[leaf]
													  ]
									  };
							});
						}
					} // UNPAPPAIIR macro

					if (unpairRe.test(ex.prim)) {
						if (
							proto === Protocol.PtEdo2Zk ||
							proto === Protocol.PsFLorena ||
							proto === Protocol.PtGRANADs ||
							proto === Protocol.PtHangzH
						) {
							if (ex.prim === 'UNPAIR') {
								return ex;
							}

							if (assertArgs$1(ex, 0)) {
								// 008_edo: annotations are deprecated
								var r = parsePairUnpairExpr(ex, ex.prim.slice(3), [], function (l, r, top) {
									return __spreadArray(__spreadArray([top], __read(r || [])), __read(l || []));
								}).r;
								return r.map(function (_a) {
									var _b = __read(_a, 1),
										v = _b[0];

									var leaf = mkPrim({
										prim: 'UNPAIR'
									});
									return v === 0
										? leaf
										: {
												prim: 'DIP',
												args:
													v === 1
														? [[leaf]]
														: [
																{
																	int: String(v)
																},
																[leaf]
														  ]
										  };
								});
							}
						} else if (assertArgs$1(ex, 0)) {
							var r = parsePairUnpairExpr(
								ex,
								ex.prim.slice(3),
								ex.annots || [],
								function (l, r, top) {
									return __spreadArray(__spreadArray([top], __read(r || [])), __read(l || []));
								}
							).r;
							return r.map(function (_a) {
								var _b = __read(_a, 2),
									v = _b[0],
									a = _b[1];

								var leaf = [
									{
										prim: 'DUP'
									},
									mkPrim({
										prim: 'CAR',
										annots: a[0] !== null ? [a[0]] : undefined
									}),
									{
										prim: 'DIP',
										args: [
											[
												mkPrim({
													prim: 'CDR',
													annots: a[1] !== null ? [a[1]] : undefined
												})
											]
										]
									}
								];
								return v === 0
									? leaf
									: {
											prim: 'DIP',
											args:
												v === 1
													? [[leaf]]
													: [
															{
																int: String(v)
															},
															[leaf]
													  ]
									  };
							});
						}
					} // C[AD]+R macro

					if (cadrRe.test(ex.prim)) {
						if (assertArgs$1(ex, 0)) {
							var ch_1 = __spreadArray([], __read(ex.prim.slice(1, ex.prim.length - 1)));

							return ch_1.map(function (c, i) {
								var ann = i === ch_1.length - 1 ? ex.annots : undefined;

								switch (c) {
									case 'A':
										return mkPrim({
											prim: 'CAR',
											annots: ann
										});

									case 'D':
										return mkPrim({
											prim: 'CDR',
											annots: ann
										});

									default:
										throw new MacroError(ex, 'unexpected character: ' + c);
								}
							});
						}
					} // SET_C[AD]+R macro

					if (setCadrRe.test(ex.prim)) {
						if (assertArgs$1(ex, 0)) {
							var _b = filterAnnotations(ex.annots),
								fields = _b.fields,
								rest = _b.rest;

							if (fields.length > 1) {
								throw new MacroError(
									ex,
									'unexpected annotation on macro ' + ex.prim + ': ' + fields
								);
							}

							var term =
								fields.length !== 0
									? {
											a: [
												{
													prim: 'DUP'
												},
												{
													prim: 'CAR',
													annots: fields
												},
												{
													prim: 'DROP'
												},
												{
													prim: 'CDR',
													annots: ['@%%']
												},
												{
													prim: 'SWAP'
												},
												{
													prim: 'PAIR',
													annots: [fields[0], '%@']
												}
											],
											d: [
												{
													prim: 'DUP'
												},
												{
													prim: 'CDR',
													annots: fields
												},
												{
													prim: 'DROP'
												},
												{
													prim: 'CAR',
													annots: ['@%%']
												},
												{
													prim: 'PAIR',
													annots: ['%@', fields[0]]
												}
											]
									  }
									: {
											a: [
												{
													prim: 'CDR',
													annots: ['@%%']
												},
												{
													prim: 'SWAP'
												},
												{
													prim: 'PAIR',
													annots: ['%', '%@']
												}
											],
											d: [
												{
													prim: 'CAR',
													annots: ['@%%']
												},
												{
													prim: 'PAIR',
													annots: ['%@', '%']
												}
											]
									  };
							return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), rest, term);
						}
					} // MAP_C[AD]+R macro

					if (mapCadrRe.test(ex.prim)) {
						if (assertArgs$1(ex, 1)) {
							var fields = filterAnnotations(ex.annots).fields;

							if (fields.length > 1) {
								throw new MacroError(
									ex,
									'unexpected annotation on macro ' + ex.prim + ': ' + fields
								);
							}

							var term = {
								a: [
									{
										prim: 'DUP'
									},
									{
										prim: 'CDR',
										annots: ['@%%']
									},
									{
										prim: 'DIP',
										args: [
											[
												mkPrim({
													prim: 'CAR',
													annots: fields.length !== 0 ? ['@' + fields[0].slice(1)] : undefined
												}),
												ex.args[0]
											]
										]
									},
									{
										prim: 'SWAP'
									},
									{
										prim: 'PAIR',
										annots: [fields.length !== 0 ? fields[0] : '%', '%@']
									}
								],
								d: [
									{
										prim: 'DUP'
									},
									mkPrim({
										prim: 'CDR',
										annots: fields.length !== 0 ? ['@' + fields[0].slice(1)] : undefined
									}),
									ex.args[0],
									{
										prim: 'SWAP'
									},
									{
										prim: 'CAR',
										annots: ['@%%']
									},
									{
										prim: 'PAIR',
										annots: ['%@', fields.length !== 0 ? fields[0] : '%']
									}
								]
							};
							return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), [], term);
						}
					} // Expand deprecated DI...IP to [DIP n]

					if (diipRe.test(ex.prim)) {
						if (assertArgs$1(ex, 1)) {
							var n = 0;

							while (ex.prim[1 + n] === 'I') {
								n++;
							}

							return mkPrim({
								prim: 'DIP',
								args: [
									{
										int: String(n)
									},
									ex.args[0]
								]
							});
						}
					} // Expand DU...UP and DUP n

					if (duupRe.test(ex.prim)) {
						var n = 0;

						while (ex.prim[1 + n] === 'U') {
							n++;
						}

						if (
							proto === Protocol.PtEdo2Zk ||
							proto === Protocol.PsFLorena ||
							proto === Protocol.PtGRANADs ||
							proto === Protocol.PtHangzH
						) {
							if (n === 1) {
								return ex;
							}

							if (assertArgs$1(ex, 0)) {
								return mkPrim({
									prim: 'DUP',
									args: [
										{
											int: String(n)
										}
									],
									annots: ex.annots
								});
							}
						} else {
							if (n === 1) {
								if (ex.args === undefined) {
									return ex; // skip
								}

								if (assertArgs$1(ex, 1) && assertIntArg(ex, ex.args[0])) {
									n = parseInt(ex.args[0].int, 10);
								}
							} else {
								assertArgs$1(ex, 0);
							}

							if (n === 1) {
								return [
									mkPrim({
										prim: 'DUP',
										annots: ex.annots
									})
								];
							} else if (n === 2) {
								return [
									{
										prim: 'DIP',
										args: [
											[
												mkPrim({
													prim: 'DUP',
													annots: ex.annots
												})
											]
										]
									},
									{
										prim: 'SWAP'
									}
								];
							} else {
								return [
									{
										prim: 'DIP',
										args: [
											{
												int: String(n - 1)
											},
											[
												mkPrim({
													prim: 'DUP',
													annots: ex.annots
												})
											]
										]
									},
									{
										prim: 'DIG',
										args: [
											{
												int: String(n)
											}
										]
									}
								];
							}
						}
					}

					return ex;
				}

				var MichelineParseError =
					/** @class */
					(function (_super) {
						__extends(MichelineParseError, _super);
						/**
						 * @param token A token caused the error
						 * @param message An error message
						 */

						function MichelineParseError(token, message) {
							var _this = _super.call(this, message) || this;

							_this.token = token;
							Object.setPrototypeOf(_this, MichelineParseError.prototype);
							return _this;
						}

						return MichelineParseError;
					})(Error);

				exports.MichelineParseError = MichelineParseError;

				var JSONParseError =
					/** @class */
					(function (_super) {
						__extends(JSONParseError, _super);
						/**
						 * @param node A node caused the error
						 * @param message An error message
						 */

						function JSONParseError(node, message) {
							var _this = _super.call(this, message) || this;

							_this.node = node;
							Object.setPrototypeOf(_this, JSONParseError.prototype);
							return _this;
						}

						return JSONParseError;
					})(Error);

				exports.JSONParseError = JSONParseError;
				var errEOF = new MichelineParseError(null, 'Unexpected EOF');

				function isAnnotation(tok) {
					return (
						tok.t === Literal.Ident && (tok.v[0] === '@' || tok.v[0] === '%' || tok.v[0] === ':')
					);
				}

				var intRe = new RegExp('^-?[0-9]+$');
				var bytesRe = new RegExp('^([0-9a-fA-F]{2})*$');
				/**
				 * Converts and validates Michelson expressions between JSON-based Michelson and Micheline
				 *
				 * Pretty Print a Michelson Smart Contract:
				 * ```
				 * const contract = await Tezos.contract.at("KT1Vsw3kh9638gqWoHTjvHCoHLPKvCbMVbCg");
				 * const p = new Parser();
				 *
				 * const michelsonCode = p.parseJSON(contract.script.code);
				 * const storage = p.parseJSON(contract.script.storage);
				 *
				 * console.log("Pretty print Michelson smart contract:");
				 * console.log(emitMicheline(michelsonCode, {indent:"    ", newline: "\n",}));
				 *
				 * console.log("Pretty print Storage:");
				 * console.log(emitMicheline(storage, {indent:"    ", newline: "\n",}));
				 * ```
				 *
				 * Encode a Michelson expression for inital storage of a smart contract
				 * ```
				 * const src = `(Pair (Pair { Elt 1
				 *                (Pair (Pair "tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" "tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx")
				 *                      0x0501000000026869) }
				 *          10000000)
				 *    (Pair 2 333))`;
				 *
				 * const p = new Parser();
				 *
				 * const exp = p.parseMichelineExpression(src);
				 * console.log(JSON.stringify(exp));
				 * ```
				 */

				var Parser =
					/** @class */
					(function () {
						function Parser(opt) {
							this.opt = opt;
						}

						Parser.prototype.expand = function (ex) {
							var _a, _b;

							if (
								((_a = this.opt) === null || _a === void 0 ? void 0 : _a.expandMacros) !== undefined
									? (_b = this.opt) === null || _b === void 0
										? void 0
										: _b.expandMacros
									: true
							) {
								var ret = expandMacros(ex, this.opt);

								if (ret !== ex) {
									ret[sourceReference] = __assign(
										__assign(
											{},
											ex[sourceReference] || {
												first: 0,
												last: 0
											}
										),
										{
											macro: ex
										}
									);
								}

								return ret;
							} else {
								return ex;
							}
						};

						Parser.prototype.parseListExpr = function (scanner, start) {
							var _a;

							var _b;

							var ref = {
								first: start.first,
								last: start.last
							};
							var expectBracket = start.t === '(';
							var tok;

							if (expectBracket) {
								tok = scanner.next();

								if (tok.done) {
									throw errEOF;
								}

								ref.last = tok.value.last;
							} else {
								tok = {
									value: start
								};
							}

							if (tok.value.t !== Literal.Ident) {
								throw new MichelineParseError(tok.value, 'not an identifier: ' + tok.value.v);
							}

							var ret =
								((_a = {
									prim: tok.value.v
								}),
								(_a[sourceReference] = ref),
								_a);

							for (;;) {
								var tok_1 = scanner.next();

								if (tok_1.done) {
									if (expectBracket) {
										throw errEOF;
									}

									break;
								} else if (tok_1.value.t === ')') {
									if (!expectBracket) {
										throw new MichelineParseError(tok_1.value, 'unexpected closing bracket');
									}

									ref.last = tok_1.value.last;
									break;
								} else if (isAnnotation(tok_1.value)) {
									ret.annots = ret.annots || [];
									ret.annots.push(tok_1.value.v);
									ref.last = tok_1.value.last;
								} else {
									ret.args = ret.args || [];
									var arg = this.parseExpr(scanner, tok_1.value);
									ref.last =
										((_b = arg[sourceReference]) === null || _b === void 0 ? void 0 : _b.last) ||
										ref.last;
									ret.args.push(arg);
								}
							}

							return this.expand(ret);
						};

						Parser.prototype.parseArgs = function (scanner, start) {
							var _a;

							var _b; // Identifier with arguments

							var ref = {
								first: start.first,
								last: start.last
							};
							var p =
								((_a = {
									prim: start.v
								}),
								(_a[sourceReference] = ref),
								_a);

							for (;;) {
								var t = scanner.next();

								if (t.done || t.value.t === '}' || t.value.t === ';') {
									return [p, t];
								}

								if (isAnnotation(t.value)) {
									ref.last = t.value.last;
									p.annots = p.annots || [];
									p.annots.push(t.value.v);
								} else {
									var arg = this.parseExpr(scanner, t.value);
									ref.last =
										((_b = arg[sourceReference]) === null || _b === void 0 ? void 0 : _b.last) ||
										ref.last;
									p.args = p.args || [];
									p.args.push(arg);
								}
							}
						};

						Parser.prototype.parseSequenceExpr = function (scanner, start) {
							var _a, _b;

							var ref = {
								first: start.first,
								last: start.last
							};
							var seq = [];
							seq[sourceReference] = ref;
							var expectBracket = start.t === '{';
							var tok =
								start.t === '{'
									? null
									: {
											value: start
									  };

							for (;;) {
								if (tok === null) {
									tok = scanner.next();

									if (!tok.done) {
										ref.last = tok.value.last;
									}
								}

								if (tok.done) {
									if (expectBracket) {
										throw errEOF;
									} else {
										return seq;
									}
								}

								if (tok.value.t === '}') {
									if (!expectBracket) {
										throw new MichelineParseError(tok.value, 'unexpected closing bracket');
									} else {
										return seq;
									}
								} else if (tok.value.t === Literal.Ident) {
									// Identifier with arguments
									var _c = __read(this.parseArgs(scanner, tok.value), 2),
										itm = _c[0],
										n = _c[1];

									ref.last =
										((_a = itm[sourceReference]) === null || _a === void 0 ? void 0 : _a.last) ||
										ref.last;
									seq.push(this.expand(itm));
									tok = n;
								} else {
									// Other
									var ex = this.parseExpr(scanner, tok.value);
									ref.last =
										((_b = ex[sourceReference]) === null || _b === void 0 ? void 0 : _b.last) ||
										ref.last;
									seq.push(ex);
									tok = null;
								}

								if (tok === null) {
									tok = scanner.next();

									if (!tok.done) {
										ref.last = tok.value.last;
									}
								}

								if (!tok.done && tok.value.t === ';') {
									tok = null;
								}
							}
						};

						Parser.prototype.parseExpr = function (scanner, tok) {
							var _a, _b, _c, _d;

							switch (tok.t) {
								case Literal.Ident:
									return this.expand(
										((_a = {
											prim: tok.v
										}),
										(_a[sourceReference] = {
											first: tok.first,
											last: tok.last
										}),
										_a)
									);

								case Literal.Number:
									return (
										(_b = {
											int: tok.v
										}),
										(_b[sourceReference] = {
											first: tok.first,
											last: tok.last
										}),
										_b
									);

								case Literal.String:
									return (
										(_c = {
											string: JSON.parse(tok.v)
										}),
										(_c[sourceReference] = {
											first: tok.first,
											last: tok.last
										}),
										_c
									);

								case Literal.Bytes:
									return (
										(_d = {
											bytes: tok.v.slice(2)
										}),
										(_d[sourceReference] = {
											first: tok.first,
											last: tok.last
										}),
										_d
									);

								case '{':
									return this.parseSequenceExpr(scanner, tok);

								default:
									return this.parseListExpr(scanner, tok);
							}
						};
						/**
						 * Parses a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.
						 * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`
						 */

						Parser.prototype.parseSequence = function (src) {
							// tslint:disable-next-line: strict-type-predicates
							if (typeof src !== 'string') {
								throw new TypeError('string type was expected, got ' + _typeof(src) + ' instead');
							}

							var scanner = scan(src);
							var tok = scanner.next();

							if (tok.done) {
								return null;
							}

							return this.parseSequenceExpr(scanner, tok.value);
						};
						/**
						 * Parse a Micheline sequence expression. Enclosing curly brackets may be omitted.
						 * @param src A Michelson list expression such as `(Pair {Elt "0" 0} 0)` or `Pair {Elt "0" 0} 0`
						 * @returns An AST node or null for empty document.
						 */

						Parser.prototype.parseList = function (src) {
							// tslint:disable-next-line: strict-type-predicates
							if (typeof src !== 'string') {
								throw new TypeError('string type was expected, got ' + _typeof(src) + ' instead');
							}

							var scanner = scan(src);
							var tok = scanner.next();

							if (tok.done) {
								return null;
							}

							return this.parseListExpr(scanner, tok.value);
						};
						/**
						 * Parse any Michelson expression
						 * @param src A Michelson expression such as `(Pair {Elt "0" 0} 0)` or `{parameter ...; storage int; code { DUP ; ...};}`
						 * @returns An AST node or null for empty document.
						 */

						Parser.prototype.parseMichelineExpression = function (src) {
							// tslint:disable-next-line: strict-type-predicates
							if (typeof src !== 'string') {
								throw new TypeError('string type was expected, got ' + _typeof(src) + ' instead');
							}

							var scanner = scan(src);
							var tok = scanner.next();

							if (tok.done) {
								return null;
							}

							return this.parseExpr(scanner, tok.value);
						};
						/**
						 * Parse a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.
						 * An alias for `parseSequence`
						 * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`
						 */

						Parser.prototype.parseScript = function (src) {
							return this.parseSequence(src);
						};
						/**
						 * Parse a Micheline sequence expression. Enclosing curly brackets may be omitted.
						 * An alias for `parseList`
						 * @param src A Michelson list expression such as `(Pair {Elt "0" 0} 0)` or `Pair {Elt "0" 0} 0`
						 * @returns An AST node or null for empty document.
						 */

						Parser.prototype.parseData = function (src) {
							return this.parseList(src);
						};
						/**
						 * Takes a JSON-encoded Michelson, validates it, strips away unneeded properties and optionally expands macros (See {@link ParserOptions}).
						 * @param src An object containing JSON-encoded Michelson, usually returned by `JSON.parse()`
						 */

						Parser.prototype.parseJSON = function (src) {
							var e_1, _a, e_2, _b, e_3, _c; // tslint:disable-next-line: strict-type-predicates

							if (_typeof(src) !== 'object') {
								throw new TypeError('object type was expected, got ' + _typeof(src) + ' instead');
							}

							if (Array.isArray(src)) {
								var ret = [];

								try {
									for (
										var src_1 = __values(src), src_1_1 = src_1.next();
										!src_1_1.done;
										src_1_1 = src_1.next()
									) {
										var n = src_1_1.value;

										if (n === null || _typeof(n) !== 'object') {
											throw new JSONParseError(n, 'unexpected sequence element: ' + n);
										}

										ret.push(this.parseJSON(n));
									}
								} catch (e_1_1) {
									e_1 = {
										error: e_1_1
									};
								} finally {
									try {
										if (src_1_1 && !src_1_1.done && (_a = src_1.return)) _a.call(src_1);
									} finally {
										if (e_1) throw e_1.error;
									}
								}

								return ret;
							} else if ('prim' in src) {
								var p = src;

								if (
									typeof p.prim === 'string' &&
									(p.annots === undefined || Array.isArray(p.annots)) &&
									(p.args === undefined || Array.isArray(p.args))
								) {
									var ret = {
										prim: p.prim
									};

									if (p.annots !== undefined) {
										try {
											for (var _d = __values(p.annots), _e = _d.next(); !_e.done; _e = _d.next()) {
												var a = _e.value;

												if (typeof a !== 'string') {
													throw new JSONParseError(a, 'string expected: ' + a);
												}
											}
										} catch (e_2_1) {
											e_2 = {
												error: e_2_1
											};
										} finally {
											try {
												if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
											} finally {
												if (e_2) throw e_2.error;
											}
										}

										ret.annots = p.annots;
									}

									if (p.args !== undefined) {
										ret.args = [];

										try {
											for (var _f = __values(p.args), _g = _f.next(); !_g.done; _g = _f.next()) {
												var a = _g.value;

												if (a === null || _typeof(a) !== 'object') {
													throw new JSONParseError(a, 'unexpected argument: ' + a);
												}

												ret.args.push(this.parseJSON(a));
											}
										} catch (e_3_1) {
											e_3 = {
												error: e_3_1
											};
										} finally {
											try {
												if (_g && !_g.done && (_c = _f.return)) _c.call(_f);
											} finally {
												if (e_3) throw e_3.error;
											}
										}
									}

									return this.expand(ret);
								}

								throw new JSONParseError(src, 'malformed prim expression: ' + src);
							} else if ('string' in src) {
								if (typeof src.string === 'string') {
									return {
										string: src.string
									};
								}

								throw new JSONParseError(src, 'malformed string literal: ' + src);
							} else if ('int' in src) {
								if (typeof src.int === 'string' && intRe.test(src.int)) {
									return {
										int: src.int
									};
								}

								throw new JSONParseError(src, 'malformed int literal: ' + src);
							} else if ('bytes' in src) {
								if (typeof src.bytes === 'string' && bytesRe.test(src.bytes)) {
									return {
										bytes: src.bytes
									};
								}

								throw new JSONParseError(src, 'malformed bytes literal: ' + src);
							} else {
								throw new JSONParseError(src, 'unexpected object: ' + src);
							}
						};

						return Parser;
					})();

				exports.Parser = Parser;

				var Formatter =
					/** @class */
					(function () {
						function Formatter(opt, lev) {
							if (lev === void 0) {
								lev = 0;
							}

							this.opt = opt;
							this.lev = lev;
						}

						Formatter.prototype.indent = function (n) {
							var _a;

							if (n === void 0) {
								n = 0;
							}

							var ret = '';

							if (((_a = this.opt) === null || _a === void 0 ? void 0 : _a.indent) !== undefined) {
								for (var i = this.lev + n; i > 0; i--) {
									ret += this.opt.indent;
								}
							}

							return ret;
						};

						Object.defineProperty(Formatter.prototype, 'lf', {
							get: function () {
								var _a;

								return ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.newline) || '';
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(Formatter.prototype, 'lfsp', {
							get: function () {
								var _a;

								return ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.newline) || ' ';
							},
							enumerable: false,
							configurable: true
						});

						Formatter.prototype.down = function (n) {
							return new Formatter(this.opt, this.lev + n);
						};

						return Formatter;
					})();

				function hasArgs(node) {
					return (
						'prim' in node &&
						((node.annots !== undefined && node.annots.length !== 0) ||
							(node.args !== undefined && node.args.length !== 0))
					);
				}

				function isMultiline(node) {
					var e_1, _a;

					if (node.args !== undefined) {
						try {
							for (var _b = __values(node.args), _c = _b.next(); !_c.done; _c = _b.next()) {
								var a = _c.value;

								if (Array.isArray(a) || hasArgs(a)) {
									return true;
								}
							}
						} catch (e_1_1) {
							e_1 = {
								error: e_1_1
							};
						} finally {
							try {
								if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
							} finally {
								if (e_1) throw e_1.error;
							}
						}
					}

					return false;
				}

				function emitExpr(node, f, foldMacros) {
					var e_2, _a, e_3, _b;

					var _c;

					var macro = (_c = node[sourceReference]) === null || _c === void 0 ? void 0 : _c.macro;

					if (foldMacros && macro) {
						return emitExpr(macro, f, foldMacros);
					}

					if (Array.isArray(node)) {
						return emitSeq(node, f, foldMacros);
					} else if ('string' in node) {
						return JSON.stringify(node.string);
					} else if ('int' in node) {
						return node.int;
					} else if ('bytes' in node) {
						return '0x' + node.bytes;
					} else {
						if (
							(node.annots === undefined || node.annots.length === 0) &&
							(node.args === undefined || node.args.length === 0)
						) {
							return node.prim;
						}

						var ret = '(' + node.prim;

						if (node.annots !== undefined) {
							try {
								for (var _d = __values(node.annots), _e = _d.next(); !_e.done; _e = _d.next()) {
									var a = _e.value;
									ret += ' ' + a;
								}
							} catch (e_2_1) {
								e_2 = {
									error: e_2_1
								};
							} finally {
								try {
									if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
								} finally {
									if (e_2) throw e_2.error;
								}
							}
						}

						if (node.args !== undefined) {
							var multiline = isMultiline(node);

							try {
								for (var _f = __values(node.args), _g = _f.next(); !_g.done; _g = _f.next()) {
									var a = _g.value;

									if (multiline) {
										ret += f.lfsp + f.indent(1) + emitExpr(a, f.down(1), foldMacros);
									} else {
										ret += ' ' + emitExpr(a, f, foldMacros);
									}
								}
							} catch (e_3_1) {
								e_3 = {
									error: e_3_1
								};
							} finally {
								try {
									if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
								} finally {
									if (e_3) throw e_3.error;
								}
							}
						}

						return ret + ')';
					}
				}

				function emitSeq(node, f, foldMacros) {
					var e_4, _a, e_5, _b, e_6, _c;

					var ret = '{' + f.lf;
					var i = node.length;

					try {
						for (
							var node_1 = __values(node), node_1_1 = node_1.next();
							!node_1_1.done;
							node_1_1 = node_1.next()
						) {
							var el = node_1_1.value;
							ret += f.indent(1);

							if ('prim' in el) {
								ret += el.prim;

								if (el.annots !== undefined) {
									try {
										for (
											var _d = ((e_5 = void 0), __values(el.annots)), _e = _d.next();
											!_e.done;
											_e = _d.next()
										) {
											var a = _e.value;
											ret += ' ' + a;
										}
									} catch (e_5_1) {
										e_5 = {
											error: e_5_1
										};
									} finally {
										try {
											if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
										} finally {
											if (e_5) throw e_5.error;
										}
									}
								}

								if (el.args !== undefined) {
									var multiline = isMultiline(el);

									try {
										for (
											var _f = ((e_6 = void 0), __values(el.args)), _g = _f.next();
											!_g.done;
											_g = _f.next()
										) {
											var a = _g.value;

											if (multiline) {
												ret += f.lfsp + f.indent(2) + emitExpr(a, f.down(2), foldMacros);
											} else {
												ret += ' ' + emitExpr(a, f, foldMacros);
											}
										}
									} catch (e_6_1) {
										e_6 = {
											error: e_6_1
										};
									} finally {
										try {
											if (_g && !_g.done && (_c = _f.return)) _c.call(_f);
										} finally {
											if (e_6) throw e_6.error;
										}
									}
								}
							} else {
								ret += emitExpr(el, f.down(1), foldMacros);
							}

							ret += i > 1 ? ';' + f.lfsp : f.lf;
							i--;
						}
					} catch (e_4_1) {
						e_4 = {
							error: e_4_1
						};
					} finally {
						try {
							if (node_1_1 && !node_1_1.done && (_a = node_1.return)) _a.call(node_1);
						} finally {
							if (e_4) throw e_4.error;
						}
					}

					return ret + f.indent() + '}';
				}
				/**
				 * Formats Micheline expression
				 * @param expr An AST node
				 * @param opt Options
				 */

				function emitMicheline(expr, opt, foldMacros) {
					if (foldMacros === void 0) {
						foldMacros = false;
					} // tslint:disable-next-line: strict-type-predicates

					if (_typeof(expr) !== 'object') {
						throw new TypeError('object type was expected, got ' + _typeof(expr) + ' instead');
					}

					return emitExpr(expr, new Formatter(opt), foldMacros);
				}

				var H = [
					0x6a09e667 | 0,
					0xbb67ae85 | 0,
					0x3c6ef372 | 0,
					0xa54ff53a | 0,
					0x510e527f | 0,
					0x9b05688c | 0,
					0x1f83d9ab | 0,
					0x5be0cd19 | 0
				];
				var K = [
					0x428a2f98 | 0,
					0x71374491 | 0,
					0xb5c0fbcf | 0,
					0xe9b5dba5 | 0,
					0x3956c25b | 0,
					0x59f111f1 | 0,
					0x923f82a4 | 0,
					0xab1c5ed5 | 0,
					0xd807aa98 | 0,
					0x12835b01 | 0,
					0x243185be | 0,
					0x550c7dc3 | 0,
					0x72be5d74 | 0,
					0x80deb1fe | 0,
					0x9bdc06a7 | 0,
					0xc19bf174 | 0,
					0xe49b69c1 | 0,
					0xefbe4786 | 0,
					0x0fc19dc6 | 0,
					0x240ca1cc | 0,
					0x2de92c6f | 0,
					0x4a7484aa | 0,
					0x5cb0a9dc | 0,
					0x76f988da | 0,
					0x983e5152 | 0,
					0xa831c66d | 0,
					0xb00327c8 | 0,
					0xbf597fc7 | 0,
					0xc6e00bf3 | 0,
					0xd5a79147 | 0,
					0x06ca6351 | 0,
					0x14292967 | 0,
					0x27b70a85 | 0,
					0x2e1b2138 | 0,
					0x4d2c6dfc | 0,
					0x53380d13 | 0,
					0x650a7354 | 0,
					0x766a0abb | 0,
					0x81c2c92e | 0,
					0x92722c85 | 0,
					0xa2bfe8a1 | 0,
					0xa81a664b | 0,
					0xc24b8b70 | 0,
					0xc76c51a3 | 0,
					0xd192e819 | 0,
					0xd6990624 | 0,
					0xf40e3585 | 0,
					0x106aa070 | 0,
					0x19a4c116 | 0,
					0x1e376c08 | 0,
					0x2748774c | 0,
					0x34b0bcb5 | 0,
					0x391c0cb3 | 0,
					0x4ed8aa4a | 0,
					0x5b9cca4f | 0,
					0x682e6ff3 | 0,
					0x748f82ee | 0,
					0x78a5636f | 0,
					0x84c87814 | 0,
					0x8cc70208 | 0,
					0x90befffa | 0,
					0xa4506ceb | 0,
					0xbef9a3f7 | 0,
					0xc67178f2 | 0
				]; // https://tools.ietf.org/html/rfc6234

				function sha256(msg) {
					var e_1, _a; // pad the message

					var r = (msg.length + 9) % 64;
					var pad = r === 0 ? 0 : 64 - r;

					if (msg.length > 268435455) {
						throw new Error('sha256: message length is too big: ' + msg.length);
					}

					var l = msg.length << 3;

					var buffer = __spreadArray(
						__spreadArray(
							__spreadArray(__spreadArray([], __read(msg)), [0x80]),
							__read(new Array(pad).fill(0))
						),
						[0, 0, 0, 0, (l >> 24) & 0xff, (l >> 16) & 0xff, (l >> 8) & 0xff, l & 0xff]
					);

					function ror(x, n) {
						return (x >>> n) | (x << (32 - n));
					}

					var h = __spreadArray([], __read(H));

					var w = new Array(64);
					var v = new Array(8);

					for (var offset = 0; offset < buffer.length; offset += 64) {
						var q = offset;
						var i = 0;

						while (i < 16) {
							w[i] =
								(buffer[q] << 24) | (buffer[q + 1] << 16) | (buffer[q + 2] << 8) | buffer[q + 3];
							q += 4;
							i++;
						}

						while (i < 64) {
							var s0 = ror(w[i - 15], 7) ^ ror(w[i - 15], 18) ^ (w[i - 15] >>> 3);
							var s1 = ror(w[i - 2], 17) ^ ror(w[i - 2], 19) ^ (w[i - 2] >>> 10);
							w[i] = ((s1 | 0) + w[i - 7] + s0 + w[i - 16]) | 0;
							i++;
						}

						for (var i_1 = 0; i_1 < 8; i_1++) {
							v[i_1] = h[i_1];
						}

						for (var i_2 = 0; i_2 < 64; i_2++) {
							var b0 = ror(v[0], 2) ^ ror(v[0], 13) ^ ror(v[0], 22);
							var b1 = ror(v[4], 6) ^ ror(v[4], 11) ^ ror(v[4], 25);
							var t1 = (v[7] + b1 + ((v[4] & v[5]) ^ (~v[4] & v[6])) + K[i_2] + w[i_2]) | 0;
							var t2 = (b0 + ((v[0] & v[1]) ^ (v[0] & v[2]) ^ (v[1] & v[2]))) | 0;
							v[7] = v[6];
							v[6] = v[5];
							v[5] = v[4];
							v[4] = (v[3] + t1) | 0;
							v[3] = v[2];
							v[2] = v[1];
							v[1] = v[0];
							v[0] = (t1 + t2) | 0;
						}

						for (var i_3 = 0; i_3 < 8; i_3++) {
							h[i_3] = (h[i_3] + v[i_3]) | 0;
						}
					}

					var digest = [];

					try {
						for (var h_1 = __values(h), h_1_1 = h_1.next(); !h_1_1.done; h_1_1 = h_1.next()) {
							var v_1 = h_1_1.value;
							digest.push((v_1 >> 24) & 0xff);
							digest.push((v_1 >> 16) & 0xff);
							digest.push((v_1 >> 8) & 0xff);
							digest.push(v_1 & 0xff);
						}
					} catch (e_1_1) {
						e_1 = {
							error: e_1_1
						};
					} finally {
						try {
							if (h_1_1 && !h_1_1.done && (_a = h_1.return)) _a.call(h_1);
						} finally {
							if (e_1) throw e_1.error;
						}
					}

					return digest;
				}

				var base58alphabetFwd = [
					0, 1, 2, 3, 4, 5, 6, 7, 8, -1, -1, -1, -1, -1, -1, -1, 9, 10, 11, 12, 13, 14, 15, 16, -1,
					17, 18, 19, 20, 21, -1, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, -1, -1, -1, -1, -1,
					-1, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, -1, 44, 45, 46, 47, 48, 49, 50, 51, 52,
					53, 54, 55, 56, 57
				];
				var base58alphabetBwd = [
					0, 1, 2, 3, 4, 5, 6, 7, 8, 16, 17, 18, 19, 20, 21, 22, 23, 25, 26, 27, 28, 29, 31, 32, 33,
					34, 35, 36, 37, 38, 39, 40, 41, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 61, 62,
					63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73
				];

				function byteAt(src, i) {
					var c = src.charCodeAt(i) - 49;

					if (c >= base58alphabetFwd.length || base58alphabetFwd[c] === -1) {
						throw new Error(
							'Base58 decoding error: unexpected character at position ' + i + ': ' + src[i]
						);
					}

					return base58alphabetFwd[c];
				}

				function decodeBase58(src) {
					var acc = [];
					var i = 0; // count and skip leading zeros

					while (i < src.length && byteAt(src, i) === 0) {
						i++;
					}

					var zeros = i;

					while (i < src.length) {
						var carry = byteAt(src, i++);
						/*
    for every symbol x
    acc = acc * 58 + x
    where acc is a little endian arbitrary length integer
    */

						var ii = 0;

						while (carry !== 0 || ii < acc.length) {
							var m = (acc[ii] || 0) * 58 + carry;
							acc[ii++] = m % 256;
							carry = Math.floor(m / 256);
						}
					}

					while (zeros-- > 0) {
						acc.push(0);
					}

					return acc.reverse();
				}

				function encodeBase58(src) {
					var acc = [];
					var i = 0; // count and skip leading zeros

					while (i < src.length && src[i] === 0) {
						i++;
					}

					var zeros = i;

					while (i < src.length) {
						var carry = src[i++];
						var ii = 0;

						while (carry !== 0 || ii < acc.length) {
							var m = (acc[ii] || 0) * 256 + carry;
							acc[ii++] = m % 58;
							carry = Math.floor(m / 58);
						}
					}

					while (zeros-- > 0) {
						acc.push(0);
					}

					acc.reverse();
					return String.fromCharCode.apply(
						String,
						__spreadArray(
							[],
							__read(
								acc.map(function (v) {
									return base58alphabetBwd[v] + 49;
								})
							)
						)
					);
				}

				function decodeBase58Check(src) {
					var buffer = decodeBase58(src);

					if (buffer.length < 4) {
						throw new Error('Base58Check decoding error: data is too short ' + buffer.length);
					}

					var data = buffer.slice(0, buffer.length - 4);
					var sum = buffer.slice(buffer.length - 4);
					var computed = sha256(sha256(data));

					if (
						sum[0] !== computed[0] ||
						sum[1] !== computed[1] ||
						sum[2] !== computed[2] ||
						sum[3] !== computed[3]
					) {
						throw new Error('Base58Check decoding error: invalid checksum');
					}

					return data;
				}

				function encodeBase58Check(src) {
					var sum = sha256(sha256(src));
					return encodeBase58(
						__spreadArray(__spreadArray([], __read(src)), __read(sum.slice(0, 4)))
					);
				}

				var MichelsonError =
					/** @class */
					(function (_super) {
						__extends(MichelsonError, _super);
						/**
						 * @param val Value of a AST node caused the error
						 * @param path Path to a node caused the error
						 * @param message An error message
						 */

						function MichelsonError(val, message) {
							var _this = _super.call(this, message) || this;

							_this.val = val;
							Object.setPrototypeOf(_this, MichelsonError.prototype);
							return _this;
						}

						return MichelsonError;
					})(Error);

				exports.MichelsonError = MichelsonError;

				function isMichelsonError(err) {
					return err instanceof MichelsonError;
				}

				var MichelsonTypeError =
					/** @class */
					(function (_super) {
						__extends(MichelsonTypeError, _super);
						/**
						 * @param val Value of a type node caused the error
						 * @param data Value of a data node caused the error
						 * @param message An error message
						 */

						function MichelsonTypeError(val, data, message) {
							var _this = _super.call(this, val, message) || this;

							if (data !== undefined) {
								_this.data = data;
							}

							Object.setPrototypeOf(_this, MichelsonTypeError.prototype);
							return _this;
						}

						return MichelsonTypeError;
					})(MichelsonError); // Ad hoc big integer parser

				exports.MichelsonTypeError = MichelsonTypeError;

				var LongInteger =
					/** @class */
					(function () {
						function LongInteger(arg) {
							this.neg = false;
							this.buf = [];

							if (arg === undefined) {
								return;
							}

							if (typeof arg === 'string') {
								for (var i = 0; i < arg.length; i++) {
									var c = arg.charCodeAt(i);

									if (i === 0 && c === 0x2d) {
										this.neg = true;
									} else {
										if (c < 0x30 || c > 0x39) {
											throw new Error('unexpected character in integer constant: ' + arg[i]);
										}

										this.append(c - 0x30);
									}
								}
							} else if (arg < 0) {
								this.neg = true;
								this.append(-arg);
							} else {
								this.append(arg);
							}
						}

						LongInteger.prototype.append = function (c) {
							var i = 0;

							while (c !== 0 || i < this.buf.length) {
								var m = (this.buf[i] || 0) * 10 + c;
								this.buf[i++] = m % 256;
								c = Math.floor(m / 256);
							}
						};

						LongInteger.prototype.cmp = function (arg) {
							if (this.neg !== arg.neg) {
								return (arg.neg ? 1 : 0) - (this.neg ? 1 : 0);
							} else {
								var ret = 0;

								if (this.buf.length !== arg.buf.length) {
									ret = this.buf.length < arg.buf.length ? -1 : 1;
								} else if (this.buf.length !== 0) {
									var i = arg.buf.length - 1;

									while (i >= 0 && this.buf[i] === arg.buf[i]) {
										i--;
									}

									ret = i < 0 ? 0 : this.buf[i] < arg.buf[i] ? -1 : 1;
								}

								return !this.neg ? ret : ret === 0 ? 0 : -ret;
							}
						};

						Object.defineProperty(LongInteger.prototype, 'sign', {
							get: function () {
								return this.buf.length === 0 ? 0 : this.neg ? -1 : 1;
							},
							enumerable: false,
							configurable: true
						});
						return LongInteger;
					})();

				function parseBytes(s) {
					var ret = [];

					for (var i = 0; i < s.length; i += 2) {
						var x = parseInt(s.slice(i, i + 2), 16);

						if (Number.isNaN(x)) {
							return null;
						}

						ret.push(x);
					}

					return ret;
				}

				function compareBytes(a, b) {
					if (a.length !== b.length) {
						return a.length < b.length ? -1 : 1;
					} else if (a.length !== 0) {
						var i = 0;

						while (i < a.length && a[i] === b[i]) {
							i++;
						}

						return i === a.length ? 0 : a[i] < b[i] ? -1 : 1;
					} else {
						return 0;
					}
				}

				function isDecimal(x) {
					try {
						// tslint:disable-next-line: no-unused-expression
						new LongInteger(x);
						return true;
					} catch (_a) {
						return false;
					}
				}

				function isNatural(x) {
					try {
						return new LongInteger(x).sign >= 0;
					} catch (_a) {
						return false;
					}
				}

				var annRe = /^(@%|@%%|%@|[@:%]([_0-9a-zA-Z][_0-9a-zA-Z\.%@]*)?)$/;

				function unpackAnnotations(p, opt) {
					var e_1, _a;

					if (Array.isArray(p)) {
						return {};
					}

					var field;
					var type;
					var vars;

					if (p.annots !== undefined) {
						try {
							for (var _b = __values(p.annots), _c = _b.next(); !_c.done; _c = _b.next()) {
								var v = _c.value;

								if (v.length !== 0) {
									if (
										!annRe.test(v) ||
										(!(opt === null || opt === void 0 ? void 0 : opt.specialVar) &&
											(v === '@%' || v === '@%%')) ||
										(!(opt === null || opt === void 0 ? void 0 : opt.specialFields) && v === '%@')
									) {
										throw new MichelsonError(p, p.prim + ': unexpected annotation: ' + v);
									}

									switch (v[0]) {
										case '%':
											if (
												(opt === null || opt === void 0 ? void 0 : opt.emptyFields) ||
												v.length > 1
											) {
												field = field || [];
												field.push(v);
											}

											break;

										case ':':
											if (v.length > 1) {
												type = type || [];
												type.push(v);
											}

											break;

										case '@':
											if (
												(opt === null || opt === void 0 ? void 0 : opt.emptyVar) ||
												v.length > 1
											) {
												vars = vars || [];
												vars.push(v);
											}

											break;
									}
								}
							}
						} catch (e_1_1) {
							e_1 = {
								error: e_1_1
							};
						} finally {
							try {
								if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
							} finally {
								if (e_1) throw e_1.error;
							}
						}
					}

					return {
						f: field,
						t: type,
						v: vars
					};
				}

				var tezosPrefix = {
					BlockHash: [32, [1, 52]],
					OperationHash: [32, [5, 116]],
					OperationListHash: [32, [133, 233]],
					OperationListListHash: [32, [29, 159, 109]],
					ProtocolHash: [32, [2, 170]],
					ContextHash: [32, [79, 199]],
					ED25519PublicKeyHash: [20, [6, 161, 159]],
					SECP256K1PublicKeyHash: [20, [6, 161, 161]],
					P256PublicKeyHash: [20, [6, 161, 164]],
					ContractHash: [20, [2, 90, 121]],
					CryptoboxPublicKeyHash: [16, [153, 103]],
					ED25519Seed: [32, [13, 15, 58, 7]],
					ED25519PublicKey: [32, [13, 15, 37, 217]],
					SECP256K1SecretKey: [32, [17, 162, 224, 201]],
					P256SecretKey: [32, [16, 81, 238, 189]],
					ED25519EncryptedSeed: [56, [7, 90, 60, 179, 41]],
					SECP256K1EncryptedSecretKey: [56, [9, 237, 241, 174, 150]],
					P256EncryptedSecretKey: [56, [9, 48, 57, 115, 171]],
					SECP256K1PublicKey: [33, [3, 254, 226, 86]],
					P256PublicKey: [33, [3, 178, 139, 127]],
					SECP256K1Scalar: [33, [38, 248, 136]],
					SECP256K1Element: [33, [5, 92, 0]],
					ED25519SecretKey: [64, [43, 246, 78, 7]],
					ED25519Signature: [64, [9, 245, 205, 134, 18]],
					SECP256K1Signature: [64, [13, 115, 101, 19, 63]],
					P256Signature: [64, [54, 240, 44, 52]],
					GenericSignature: [64, [4, 130, 43]],
					ChainID: [4, [87, 82, 0]]
				};

				function checkDecodeTezosID(id) {
					var e_2, _a;

					var types = [];

					for (var _i = 1; _i < arguments.length; _i++) {
						types[_i - 1] = arguments[_i];
					}

					var buf = decodeBase58Check(id);

					try {
						for (
							var types_1 = __values(types), types_1_1 = types_1.next();
							!types_1_1.done;
							types_1_1 = types_1.next()
						) {
							var t = types_1_1.value;

							var _b = __read(tezosPrefix[t], 2),
								plen = _b[0],
								p = _b[1];

							if (buf.length === plen + p.length) {
								var i = 0;

								while (i < p.length && buf[i] === p[i]) {
									i++;
								}

								if (i === p.length) {
									return [t, buf.slice(p.length)];
								}
							}
						}
					} catch (e_2_1) {
						e_2 = {
							error: e_2_1
						};
					} finally {
						try {
							if (types_1_1 && !types_1_1.done && (_a = types_1.return)) _a.call(types_1);
						} finally {
							if (e_2) throw e_2.error;
						}
					}

					return null;
				}

				function encodeTezosID(id, data) {
					var _a = __read(tezosPrefix[id], 2),
						plen = _a[0],
						p = _a[1];

					if (data.length !== plen) {
						throw new Error('incorrect data length for ' + id + ': ' + data.length);
					}

					return encodeBase58Check(__spreadArray(__spreadArray([], __read(p)), __read(data)));
				}

				function unpackComb(id, v) {
					var vv = v;
					var args = Array.isArray(vv) ? vv : vv.args;

					if (args.length === 2) {
						// it's a way to make a union of two interfaces not an interface with two independent properties of union types
						var ret =
							id === 'pair'
								? {
										prim: 'pair',
										args: args
								  }
								: {
										prim: 'Pair',
										args: args
								  };
						return ret;
					}

					return __assign(
						__assign(
							{},
							Array.isArray(vv)
								? {
										prim: id
								  }
								: vv
						),
						{
							args: [
								args[0],
								{
									prim: id,
									args: args.slice(1)
								}
							]
						}
					);
				}

				function isPairType(t) {
					return Array.isArray(t) || t.prim === 'pair';
				}

				function isPairData(d) {
					return Array.isArray(d) || ('prim' in d && d.prim === 'Pair');
				}

				var rfc3339Re =
					/^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])[T ]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|[+-]([01][0-9]|2[0-3]):([0-5][0-9]))$/;

				function parseDate(a) {
					if ('string' in a) {
						if (isNatural(a.string)) {
							return new Date(parseInt(a.string, 10));
						} else if (rfc3339Re.test(a.string)) {
							var x = new Date(a.string);

							if (!Number.isNaN(x.valueOf)) {
								return x;
							}
						}
					} else if (isNatural(a.int)) {
						return new Date(parseInt(a.int, 10));
					}

					return null;
				}

				function parseHex(s) {
					var res = [];

					for (var i = 0; i < s.length; i += 2) {
						var ss = s.slice(i, i + 2);
						var x = parseInt(ss, 16);

						if (Number.isNaN(x)) {
							throw new Error("can't parse hex byte: " + ss);
						}

						res.push(x);
					}

					return res;
				}

				function hexBytes(bytes) {
					return bytes
						.map(function (x) {
							return ((x >> 4) & 0xf).toString(16) + (x & 0xf).toString(16);
						})
						.join('');
				} // Michelson validator

				var noArgInstructionIDs = {
					ABS: true,
					ADD: true,
					ADDRESS: true,
					AMOUNT: true,
					AND: true,
					APPLY: true,
					BALANCE: true,
					BLAKE2B: true,
					CAR: true,
					CDR: true,
					CHAIN_ID: true,
					CHECK_SIGNATURE: true,
					COMPARE: true,
					CONCAT: true,
					CONS: true,
					EDIV: true,
					EQ: true,
					EXEC: true,
					FAILWITH: true,
					GE: true,
					GET_AND_UPDATE: true,
					GT: true,
					HASH_KEY: true,
					IMPLICIT_ACCOUNT: true,
					INT: true,
					ISNAT: true,
					JOIN_TICKETS: true,
					KECCAK: true,
					LE: true,
					LEVEL: true,
					LSL: true,
					LSR: true,
					LT: true,
					MEM: true,
					MUL: true,
					NEG: true,
					NEQ: true,
					NEVER: true,
					NOT: true,
					NOW: true,
					OR: true,
					PACK: true,
					PAIRING_CHECK: true,
					READ_TICKET: true,
					SAPLING_VERIFY_UPDATE: true,
					SELF: true,
					SELF_ADDRESS: true,
					SENDER: true,
					SET_DELEGATE: true,
					SHA256: true,
					SHA3: true,
					SHA512: true,
					SIZE: true,
					SLICE: true,
					SOME: true,
					SOURCE: true,
					SPLIT_TICKET: true,
					SUB: true,
					SWAP: true,
					TICKET: true,
					TOTAL_VOTING_POWER: true,
					TRANSFER_TOKENS: true,
					UNIT: true,
					VOTING_POWER: true,
					XOR: true,
					RENAME: true
				};
				var instructionIDs = Object.assign({}, noArgInstructionIDs, {
					CONTRACT: true,
					CREATE_CONTRACT: true,
					DIG: true,
					DIP: true,
					DROP: true,
					DUG: true,
					DUP: true,
					EMPTY_BIG_MAP: true,
					EMPTY_MAP: true,
					EMPTY_SET: true,
					GET: true,
					IF: true,
					IF_CONS: true,
					IF_LEFT: true,
					IF_NONE: true,
					ITER: true,
					LAMBDA: true,
					LEFT: true,
					LOOP: true,
					LOOP_LEFT: true,
					MAP: true,
					NIL: true,
					NONE: true,
					PAIR: true,
					PUSH: true,
					RIGHT: true,
					SAPLING_EMPTY_STATE: true,
					UNPACK: true,
					UNPAIR: true,
					UPDATE: true,
					CAST: true
				});
				exports.instructionIDs = instructionIDs;
				var simpleComparableTypeIDs = {
					unit: true,
					never: true,
					bool: true,
					int: true,
					nat: true,
					string: true,
					chain_id: true,
					bytes: true,
					mutez: true,
					key_hash: true,
					key: true,
					signature: true,
					timestamp: true,
					address: true
				};
				var typeIDs = Object.assign({}, simpleComparableTypeIDs, {
					or: true,
					pair: true,
					set: true,
					big_map: true,
					contract: true,
					lambda: true,
					list: true,
					map: true,
					operation: true,
					option: true,
					bls12_381_g1: true,
					bls12_381_g2: true,
					bls12_381_fr: true,
					sapling_transaction: true,
					sapling_state: true,
					ticket: true
				});

				var MichelsonValidationError =
					/** @class */
					(function (_super) {
						__extends(MichelsonValidationError, _super);
						/**
						 * @param val Value of a node caused the error
						 * @param message An error message
						 */

						function MichelsonValidationError(val, message) {
							var _this = _super.call(this, val, message) || this;

							_this.val = val;
							Object.setPrototypeOf(_this, MichelsonValidationError.prototype);
							return _this;
						}

						return MichelsonValidationError;
					})(MichelsonError);

				exports.MichelsonValidationError = MichelsonValidationError;

				function isPrim(ex) {
					return 'prim' in ex;
				}

				function isPrimOrSeq(ex) {
					return Array.isArray(ex) || 'prim' in ex;
				}

				function assertPrim(ex) {
					if (isPrim(ex)) {
						return true;
					}

					throw new MichelsonValidationError(ex, 'prim expression expected');
				}

				function assertSeq(ex) {
					if (Array.isArray(ex)) {
						return true;
					}

					throw new MichelsonValidationError(ex, 'sequence expression expected');
				}

				function assertPrimOrSeq(ex) {
					if (isPrimOrSeq(ex)) {
						return true;
					}

					throw new MichelsonValidationError(ex, 'prim or sequence expression expected');
				}

				function assertNatural(i) {
					if (i.int[0] === '-') {
						throw new MichelsonValidationError(i, 'natural number expected');
					}
				}

				function assertIntLiteral(ex) {
					if ('int' in ex) {
						return true;
					}

					throw new MichelsonValidationError(ex, 'int literal expected');
				}

				function assertArgs(ex, n) {
					var _a;

					if (
						(n === 0 && ex.args === undefined) ||
						((_a = ex.args) === null || _a === void 0 ? void 0 : _a.length) === n
					) {
						return true;
					}

					throw new MichelsonValidationError(ex, n + ' arguments expected');
				}
				/**
				 * Checks if the node is a valid Michelson code (sequence of instructions).
				 * This is a type guard function which either returns true of throws an exception.
				 * @param ex An AST node
				 */

				function assertMichelsonInstruction(ex) {
					var e_1, _a;

					var _b, _c;

					if (Array.isArray(ex)) {
						try {
							for (
								var ex_1 = __values(ex), ex_1_1 = ex_1.next();
								!ex_1_1.done;
								ex_1_1 = ex_1.next()
							) {
								var n = ex_1_1.value;

								if (!Array.isArray(n) && !isPrim(n)) {
									throw new MichelsonValidationError(ex, 'sequence or prim expected');
								}

								assertMichelsonInstruction(n);
							}
						} catch (e_1_1) {
							e_1 = {
								error: e_1_1
							};
						} finally {
							try {
								if (ex_1_1 && !ex_1_1.done && (_a = ex_1.return)) _a.call(ex_1);
							} finally {
								if (e_1) throw e_1.error;
							}
						}

						return true;
					}

					if (assertPrim(ex)) {
						if (Object.prototype.hasOwnProperty.call(noArgInstructionIDs, ex.prim)) {
							assertArgs(ex, 0);
							return true;
						}

						switch (ex.prim) {
							case 'DROP':
							case 'PAIR':
							case 'UNPAIR':
							case 'DUP':
							case 'UPDATE':
							case 'GET':
								if (ex.args !== undefined && assertArgs(ex, 1)) {
									/* istanbul ignore else */
									if (assertIntLiteral(ex.args[0])) {
										assertNatural(ex.args[0]);
									}
								}

								break;

							case 'DIG':
							case 'DUG':
							case 'SAPLING_EMPTY_STATE':
								/* istanbul ignore else */
								if (assertArgs(ex, 1)) {
									/* istanbul ignore else */
									if (assertIntLiteral(ex.args[0])) {
										assertNatural(ex.args[0]);
									}
								}

								break;

							case 'NONE':
							case 'LEFT':
							case 'RIGHT':
							case 'NIL':
							case 'CAST':
								/* istanbul ignore else */
								if (assertArgs(ex, 1)) {
									assertMichelsonType(ex.args[0]);
								}

								break;

							case 'UNPACK':
								/* istanbul ignore else */
								if (assertArgs(ex, 1)) {
									assertMichelsonPackableType(ex.args[0]);
								}

								break;

							case 'CONTRACT':
								/* istanbul ignore else */
								if (assertArgs(ex, 1)) {
									assertMichelsonPassableType(ex.args[0]);
								}

								break;

							case 'IF_NONE':
							case 'IF_LEFT':
							case 'IF_CONS':
							case 'IF':
								/* istanbul ignore else */
								if (assertArgs(ex, 2)) {
									/* istanbul ignore else */
									if (assertSeq(ex.args[0])) {
										assertMichelsonInstruction(ex.args[0]);
									}
									/* istanbul ignore else */

									if (assertSeq(ex.args[1])) {
										assertMichelsonInstruction(ex.args[1]);
									}
								}

								break;

							case 'MAP':
							case 'ITER':
							case 'LOOP':
							case 'LOOP_LEFT':
								/* istanbul ignore else */
								if (assertArgs(ex, 1)) {
									assertMichelsonInstruction(ex.args[0]);
								}

								break;

							case 'CREATE_CONTRACT':
								/* istanbul ignore else */
								if (assertArgs(ex, 1)) {
									assertMichelsonContract(ex.args[0]);
								}

								break;

							case 'DIP':
								if (((_b = ex.args) === null || _b === void 0 ? void 0 : _b.length) === 2) {
									/* istanbul ignore else */
									if (assertIntLiteral(ex.args[0])) {
										assertNatural(ex.args[0]);
									}
									/* istanbul ignore else */

									if (assertSeq(ex.args[1])) {
										assertMichelsonInstruction(ex.args[1]);
									}
								} else if (((_c = ex.args) === null || _c === void 0 ? void 0 : _c.length) === 1) {
									/* istanbul ignore else */
									if (assertSeq(ex.args[0])) {
										assertMichelsonInstruction(ex.args[0]);
									}
								} else {
									throw new MichelsonValidationError(ex, '1 or 2 arguments expected');
								}

								break;

							case 'PUSH':
								/* istanbul ignore else */
								if (assertArgs(ex, 2)) {
									assertMichelsonPushableType(ex.args[0]);
									assertMichelsonData(ex.args[1]);
								}

								break;

							case 'EMPTY_SET':
								/* istanbul ignore else */
								if (assertArgs(ex, 1)) {
									assertMichelsonComparableType(ex.args[0]);
								}

								break;

							case 'EMPTY_MAP':
								/* istanbul ignore else */
								if (assertArgs(ex, 2)) {
									assertMichelsonComparableType(ex.args[0]);
									assertMichelsonType(ex.args[1]);
								}

								break;

							case 'EMPTY_BIG_MAP':
								/* istanbul ignore else */
								if (assertArgs(ex, 2)) {
									assertMichelsonComparableType(ex.args[0]);
									assertMichelsonBigMapStorableType(ex.args[1]);
								}

								break;

							case 'LAMBDA':
								/* istanbul ignore else */
								if (assertArgs(ex, 3)) {
									assertMichelsonType(ex.args[0]);
									assertMichelsonType(ex.args[1]);
									/* istanbul ignore else */

									if (assertSeq(ex.args[2])) {
										assertMichelsonInstruction(ex.args[2]);
									}
								}

								break;

							default:
								throw new MichelsonValidationError(ex, 'instruction expected');
						}
					}

					return true;
				}

				function assertMichelsonComparableType(ex) {
					/* istanbul ignore else */
					if (assertPrimOrSeq(ex)) {
						if (
							Array.isArray(ex) ||
							ex.prim === 'pair' ||
							ex.prim === 'or' ||
							ex.prim === 'option'
						) {
							traverseType(ex, function (ex) {
								return assertMichelsonComparableType(ex);
							});
						} else if (!Object.prototype.hasOwnProperty.call(simpleComparableTypeIDs, ex.prim)) {
							throw new MichelsonValidationError(ex, ex.prim + ': type is not comparable');
						}
					}

					return true;
				}

				function assertMichelsonPackableType(ex) {
					/* istanbul ignore else */
					if (assertPrimOrSeq(ex)) {
						if (isPrim(ex)) {
							if (
								!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) ||
								ex.prim === 'big_map' ||
								ex.prim === 'operation' ||
								ex.prim === 'sapling_state' ||
								ex.prim === 'ticket'
							) {
								throw new MichelsonValidationError(
									ex,
									ex.prim + ": type can't be used inside PACK/UNPACK instructions"
								);
							}

							traverseType(ex, function (ex) {
								return assertMichelsonPackableType(ex);
							});
						}
					}

					return true;
				}

				function assertMichelsonPushableType(ex) {
					/* istanbul ignore else */
					if (assertPrimOrSeq(ex)) {
						if (isPrim(ex)) {
							if (
								!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) ||
								ex.prim === 'big_map' ||
								ex.prim === 'operation' ||
								ex.prim === 'sapling_state' ||
								ex.prim === 'ticket' ||
								ex.prim === 'contract'
							) {
								throw new MichelsonValidationError(ex, ex.prim + ": type can't be pushed");
							}

							traverseType(ex, function (ex) {
								return assertMichelsonPushableType(ex);
							});
						}
					}

					return true;
				}

				function assertMichelsonStorableType(ex) {
					/* istanbul ignore else */
					if (assertPrimOrSeq(ex)) {
						if (isPrim(ex)) {
							if (
								!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) ||
								ex.prim === 'operation' ||
								ex.prim === 'contract'
							) {
								throw new MichelsonValidationError(
									ex,
									ex.prim + ": type can't be used as part of a storage"
								);
							}

							traverseType(ex, function (ex) {
								return assertMichelsonStorableType(ex);
							});
						}
					}

					return true;
				}

				function assertMichelsonPassableType(ex) {
					/* istanbul ignore else */
					if (assertPrimOrSeq(ex)) {
						if (isPrim(ex)) {
							if (
								!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) ||
								ex.prim === 'operation'
							) {
								throw new MichelsonValidationError(
									ex,
									ex.prim + ": type can't be used as part of a parameter"
								);
							}

							traverseType(ex, function (ex) {
								return assertMichelsonPassableType(ex);
							});
						}
					}

					return true;
				}

				function assertMichelsonBigMapStorableType(ex) {
					/* istanbul ignore else */
					if (assertPrimOrSeq(ex)) {
						if (isPrim(ex)) {
							if (
								!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) ||
								ex.prim === 'big_map' ||
								ex.prim === 'operation' ||
								ex.prim === 'sapling_state'
							) {
								throw new MichelsonValidationError(
									ex,
									ex.prim + ": type can't be used inside a big_map"
								);
							}

							traverseType(ex, function (ex) {
								return assertMichelsonBigMapStorableType(ex);
							});
						}
					}

					return true;
				}
				/**
				 * Checks if the node is a valid Michelson type expression.
				 * This is a type guard function which either returns true of throws an exception.
				 * @param ex An AST node
				 */

				function assertMichelsonType(ex) {
					/* istanbul ignore else */
					if (assertPrimOrSeq(ex)) {
						if (isPrim(ex)) {
							if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim)) {
								throw new MichelsonValidationError(ex, 'type expected');
							}

							traverseType(ex, function (ex) {
								return assertMichelsonType(ex);
							});
						}
					}

					return true;
				}

				function traverseType(ex, cb) {
					if (Array.isArray(ex) || ex.prim === 'pair') {
						var args = Array.isArray(ex) ? ex : ex.args;

						if (args === undefined || args.length < 2) {
							throw new MichelsonValidationError(ex, 'at least 2 arguments expected');
						}

						args.forEach(function (a) {
							if (assertPrimOrSeq(a)) {
								cb(a);
							}
						});
						return true;
					}

					switch (ex.prim) {
						case 'option':
						case 'list':
							/* istanbul ignore else */
							if (assertArgs(ex, 1) && assertPrimOrSeq(ex.args[0])) {
								cb(ex.args[0]);
							}

							break;

						case 'contract':
							/* istanbul ignore else */
							if (assertArgs(ex, 1)) {
								assertMichelsonPassableType(ex.args[0]);
							}

							break;

						case 'or':
							/* istanbul ignore else */
							if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {
								cb(ex.args[0]);
								cb(ex.args[1]);
							}

							break;

						case 'lambda':
							/* istanbul ignore else */
							if (assertArgs(ex, 2)) {
								assertMichelsonType(ex.args[0]);
								assertMichelsonType(ex.args[1]);
							}

							break;

						case 'set':
							/* istanbul ignore else */
							if (assertArgs(ex, 1)) {
								assertMichelsonComparableType(ex.args[0]);
							}

							break;

						case 'map':
							/* istanbul ignore else */
							if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {
								assertMichelsonComparableType(ex.args[0]);
								cb(ex.args[1]);
							}

							break;

						case 'big_map':
							/* istanbul ignore else */
							if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {
								assertMichelsonComparableType(ex.args[0]);
								assertMichelsonBigMapStorableType(ex.args[1]);
								cb(ex.args[1]);
							}

							break;

						case 'ticket':
							/* istanbul ignore else */
							if (assertArgs(ex, 1) && assertPrimOrSeq(ex.args[0])) {
								assertMichelsonComparableType(ex.args[0]);
							}

							break;

						case 'sapling_state':
						case 'sapling_transaction':
							if (assertArgs(ex, 1)) {
								assertIntLiteral(ex.args[0]);
							}

							break;

						default:
							assertArgs(ex, 0);
					}

					return true;
				}
				/**
				 * Checks if the node is a valid Michelson data literal such as `(Pair {Elt "0" 0} 0)`.
				 * This is a type guard function which either returns true of throws an exception.
				 * @param ex An AST node
				 */

				function assertMichelsonData(ex) {
					var e_2, _a, e_3, _b;

					if ('int' in ex || 'string' in ex || 'bytes' in ex) {
						return true;
					}

					if (Array.isArray(ex)) {
						var mapElts = 0;

						try {
							for (
								var ex_2 = __values(ex), ex_2_1 = ex_2.next();
								!ex_2_1.done;
								ex_2_1 = ex_2.next()
							) {
								var n = ex_2_1.value;

								if (isPrim(n) && n.prim === 'Elt') {
									/* istanbul ignore else */
									if (assertArgs(n, 2)) {
										assertMichelsonData(n.args[0]);
										assertMichelsonData(n.args[1]);
									}

									mapElts++;
								} else {
									assertMichelsonData(n);
								}
							}
						} catch (e_2_1) {
							e_2 = {
								error: e_2_1
							};
						} finally {
							try {
								if (ex_2_1 && !ex_2_1.done && (_a = ex_2.return)) _a.call(ex_2);
							} finally {
								if (e_2) throw e_2.error;
							}
						}

						if (mapElts !== 0 && mapElts !== ex.length) {
							throw new MichelsonValidationError(
								ex,
								"data entries and map elements can't be intermixed"
							);
						}

						return true;
					}

					if (isPrim(ex)) {
						switch (ex.prim) {
							case 'Unit':
							case 'True':
							case 'False':
							case 'None':
								assertArgs(ex, 0);
								break;

							case 'Pair':
								/* istanbul ignore else */
								if (ex.args === undefined || ex.args.length < 2) {
									throw new MichelsonValidationError(ex, 'at least 2 arguments expected');
								}

								try {
									for (var _c = __values(ex.args), _d = _c.next(); !_d.done; _d = _c.next()) {
										var a = _d.value;
										assertMichelsonData(a);
									}
								} catch (e_3_1) {
									e_3 = {
										error: e_3_1
									};
								} finally {
									try {
										if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
									} finally {
										if (e_3) throw e_3.error;
									}
								}

								break;

							case 'Left':
							case 'Right':
							case 'Some':
								/* istanbul ignore else */
								if (assertArgs(ex, 1)) {
									assertMichelsonData(ex.args[0]);
								}

								break;

							default:
								if (Object.prototype.hasOwnProperty.call(instructionIDs, ex.prim)) {
									assertMichelsonInstruction(ex);
								} else {
									throw new MichelsonValidationError(ex, 'data entry or instruction expected');
								}
						}
					} else {
						throw new MichelsonValidationError(ex, 'data entry expected');
					}

					return true;
				}
				/**
				 * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.
				 * This is a type guard function which either returns true of throws an exception.
				 * @param ex An AST node
				 */

				function assertMichelsonContract(ex) {
					var e_4, _a;
					/* istanbul ignore else */

					if (assertSeq(ex)) {
						var ent = {};

						try {
							for (
								var ex_3 = __values(ex), ex_3_1 = ex_3.next();
								!ex_3_1.done;
								ex_3_1 = ex_3.next()
							) {
								var sec = ex_3_1.value;

								if (assertPrim(sec)) {
									if (sec.prim !== 'code' && sec.prim !== 'parameter' && sec.prim !== 'storage') {
										throw new MichelsonValidationError(
											ex,
											'unexpected contract section: ' + sec.prim
										);
									}

									if (sec.prim in ent) {
										throw new MichelsonValidationError(
											ex,
											'duplicate contract section: ' + sec.prim
										);
									}

									ent[sec.prim] = true;
									/* istanbul ignore else */

									if (assertArgs(sec, 1)) {
										switch (sec.prim) {
											case 'code':
												/* istanbul ignore else */
												if (assertSeq(sec.args[0])) {
													assertMichelsonInstruction(sec.args[0]);
												}

												break;

											case 'parameter':
												assertMichelsonPassableType(sec.args[0]);
												break;

											case 'storage':
												assertMichelsonStorableType(sec.args[0]);
										}
									}
								}
							}
						} catch (e_4_1) {
							e_4 = {
								error: e_4_1
							};
						} finally {
							try {
								if (ex_3_1 && !ex_3_1.done && (_a = ex_3.return)) _a.call(ex_3);
							} finally {
								if (e_4) throw e_4.error;
							}
						}
					}

					return true;
				}
				/**
				 * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.
				 * @param ex An AST node
				 */

				function isMichelsonScript(ex) {
					try {
						assertMichelsonContract(ex);
						return true;
					} catch (_a) {
						return false;
					}
				}
				/**
				 * Checks if the node is a valid Michelson data literal such as `(Pair {Elt "0" 0} 0)`.
				 * @param ex An AST node
				 */

				function isMichelsonData(ex) {
					try {
						assertMichelsonData(ex);
						return true;
					} catch (_a) {
						return false;
					}
				}
				/**
				 * Checks if the node is a valid Michelson code (sequence of instructions).
				 * @param ex An AST node
				 */

				function isMichelsonCode(ex) {
					try {
						assertMichelsonInstruction(ex);
						return true;
					} catch (_a) {
						return false;
					}
				}
				/**
				 * Checks if the node is a valid Michelson type expression.
				 * @param ex An AST node
				 */

				function isMichelsonType(ex) {
					try {
						assertMichelsonType(ex);
						return true;
					} catch (_a) {
						return false;
					}
				}

				function isInstruction(p) {
					return Object.prototype.hasOwnProperty.call(instructionIDs, p.prim);
				}

				function assertDataListIfAny(d) {
					var e_5, _a;

					if (!Array.isArray(d)) {
						return false;
					}

					try {
						for (var d_1 = __values(d), d_1_1 = d_1.next(); !d_1_1.done; d_1_1 = d_1.next()) {
							var v = d_1_1.value;

							if ('prim' in v) {
								if (isInstruction(v)) {
									throw new MichelsonError(
										d,
										'Instruction outside of a lambda: ' + JSON.stringify(d)
									);
								} else if (v.prim === 'Elt') {
									throw new MichelsonError(
										d,
										'Elt item outside of a map literal: ' + JSON.stringify(d)
									);
								}
							}
						}
					} catch (e_5_1) {
						e_5 = {
							error: e_5_1
						};
					} finally {
						try {
							if (d_1_1 && !d_1_1.done && (_a = d_1.return)) _a.call(d_1);
						} finally {
							if (e_5) throw e_5.error;
						}
					}

					return true;
				}

				var primitives = [
					'parameter',
					'storage',
					'code',
					'False',
					'Elt',
					'Left',
					'None',
					'Pair',
					'Right',
					'Some',
					'True',
					'Unit',
					'PACK',
					'UNPACK',
					'BLAKE2B',
					'SHA256',
					'SHA512',
					'ABS',
					'ADD',
					'AMOUNT',
					'AND',
					'BALANCE',
					'CAR',
					'CDR',
					'CHECK_SIGNATURE',
					'COMPARE',
					'CONCAT',
					'CONS',
					'CREATE_ACCOUNT',
					'CREATE_CONTRACT',
					'IMPLICIT_ACCOUNT',
					'DIP',
					'DROP',
					'DUP',
					'EDIV',
					'EMPTY_MAP',
					'EMPTY_SET',
					'EQ',
					'EXEC',
					'FAILWITH',
					'GE',
					'GET',
					'GT',
					'HASH_KEY',
					'IF',
					'IF_CONS',
					'IF_LEFT',
					'IF_NONE',
					'INT',
					'LAMBDA',
					'LE',
					'LEFT',
					'LOOP',
					'LSL',
					'LSR',
					'LT',
					'MAP',
					'MEM',
					'MUL',
					'NEG',
					'NEQ',
					'NIL',
					'NONE',
					'NOT',
					'NOW',
					'OR',
					'PAIR',
					'PUSH',
					'RIGHT',
					'SIZE',
					'SOME',
					'SOURCE',
					'SENDER',
					'SELF',
					'STEPS_TO_QUOTA',
					'SUB',
					'SWAP',
					'TRANSFER_TOKENS',
					'SET_DELEGATE',
					'UNIT',
					'UPDATE',
					'XOR',
					'ITER',
					'LOOP_LEFT',
					'ADDRESS',
					'CONTRACT',
					'ISNAT',
					'CAST',
					'RENAME',
					'bool',
					'contract',
					'int',
					'key',
					'key_hash',
					'lambda',
					'list',
					'map',
					'big_map',
					'nat',
					'option',
					'or',
					'pair',
					'set',
					'signature',
					'string',
					'bytes',
					'mutez',
					'timestamp',
					'unit',
					'operation',
					'address',
					'SLICE',
					'DIG',
					'DUG',
					'EMPTY_BIG_MAP',
					'APPLY',
					'chain_id',
					'CHAIN_ID',
					'LEVEL',
					'SELF_ADDRESS',
					'never',
					'NEVER',
					'UNPAIR',
					'VOTING_POWER',
					'TOTAL_VOTING_POWER',
					'KECCAK',
					'SHA3',
					'PAIRING_CHECK',
					'bls12_381_g1',
					'bls12_381_g2',
					'bls12_381_fr',
					'sapling_state',
					'sapling_transaction',
					'SAPLING_EMPTY_STATE',
					'SAPLING_VERIFY_UPDATE',
					'ticket',
					'TICKET',
					'READ_TICKET',
					'SPLIT_TICKET',
					'JOIN_TICKETS',
					'GET_AND_UPDATE'
				];
				var primTags = Object.assign.apply(
					Object,
					__spreadArray(
						[{}],
						__read(
							primitives.map(function (v, i) {
								var _a;

								return (_a = {}), (_a[v] = i), _a;
							})
						)
					)
				);
				var Tag;

				(function (Tag) {
					Tag[(Tag['Int'] = 0)] = 'Int';
					Tag[(Tag['String'] = 1)] = 'String';
					Tag[(Tag['Sequence'] = 2)] = 'Sequence';
					Tag[(Tag['Prim0'] = 3)] = 'Prim0';
					Tag[(Tag['Prim0Annot'] = 4)] = 'Prim0Annot';
					Tag[(Tag['Prim1'] = 5)] = 'Prim1';
					Tag[(Tag['Prim1Annot'] = 6)] = 'Prim1Annot';
					Tag[(Tag['Prim2'] = 7)] = 'Prim2';
					Tag[(Tag['Prim2Annot'] = 8)] = 'Prim2Annot';
					Tag[(Tag['Prim'] = 9)] = 'Prim';
					Tag[(Tag['Bytes'] = 10)] = 'Bytes';
				})(Tag || (Tag = {}));

				var Writer =
					/** @class */
					(function () {
						function Writer() {
							this.buffer = [];
						}

						Object.defineProperty(Writer.prototype, 'length', {
							get: function () {
								return this.buffer.length;
							},
							enumerable: false,
							configurable: true
						});

						Writer.prototype.writeBytes = function (val) {
							var _a;

							(_a = this.buffer).push.apply(
								_a,
								__spreadArray(
									[],
									__read(
										val.map(function (v) {
											return v & 0xff;
										})
									)
								)
							);
						};

						Writer.prototype.writeUint8 = function (val) {
							var v = val | 0;
							this.buffer.push(v & 0xff);
						};

						Writer.prototype.writeUint16 = function (val) {
							var v = val | 0;
							this.buffer.push((v >> 8) & 0xff);
							this.buffer.push(v & 0xff);
						};

						Writer.prototype.writeUint32 = function (val) {
							var v = val | 0;
							this.buffer.push((v >> 24) & 0xff);
							this.buffer.push((v >> 16) & 0xff);
							this.buffer.push((v >> 8) & 0xff);
							this.buffer.push(v & 0xff);
						};

						Writer.prototype.writeInt8 = function (val) {
							this.writeUint8(val);
						};

						Writer.prototype.writeInt16 = function (val) {
							this.writeUint16(val);
						};

						Writer.prototype.writeInt32 = function (val) {
							this.writeUint32(val);
						};

						return Writer;
					})();

				var boundsErr = new Error('bounds out of range');

				var Reader =
					/** @class */
					(function () {
						function Reader(buffer, idx, cap) {
							if (idx === void 0) {
								idx = 0;
							}

							if (cap === void 0) {
								cap = buffer.length;
							}

							this.buffer = buffer;
							this.idx = idx;
							this.cap = cap;
						}

						Object.defineProperty(Reader.prototype, 'length', {
							/** Remaining length */
							get: function () {
								return this.cap - this.idx;
							},
							enumerable: false,
							configurable: true
						});

						Reader.prototype.readBytes = function (len) {
							if (this.cap - this.idx < len) {
								throw boundsErr;
							}

							var ret = this.buffer.slice(this.idx, this.idx + len);
							this.idx += len;
							return ret;
						};

						Reader.prototype.reader = function (len) {
							if (this.cap - this.idx < len) {
								throw boundsErr;
							}

							var ret = new Reader(this.buffer, this.idx, this.idx + len);
							this.idx += len;
							return ret;
						};

						Reader.prototype.copy = function () {
							return new Reader(this.buffer, this.idx, this.cap);
						};

						Reader.prototype.readUint8 = function () {
							if (this.cap - this.idx < 1) {
								throw boundsErr;
							}

							return this.buffer[this.idx++] >>> 0;
						};

						Reader.prototype.readUint16 = function () {
							if (this.cap - this.idx < 2) {
								throw boundsErr;
							}

							var x0 = this.buffer[this.idx++];
							var x1 = this.buffer[this.idx++];
							return ((x0 << 8) | x1) >>> 0;
						};

						Reader.prototype.readUint32 = function () {
							if (this.cap - this.idx < 4) {
								throw boundsErr;
							}

							var x0 = this.buffer[this.idx++];
							var x1 = this.buffer[this.idx++];
							var x2 = this.buffer[this.idx++];
							var x3 = this.buffer[this.idx++];
							return ((x0 << 24) | (x1 << 16) | (x2 << 8) | x3) >>> 0;
						};

						Reader.prototype.readInt8 = function () {
							if (this.cap - this.idx < 1) {
								throw boundsErr;
							}

							var x = this.buffer[this.idx++];
							return (x << 24) >> 24;
						};

						Reader.prototype.readInt16 = function () {
							if (this.cap - this.idx < 2) {
								throw boundsErr;
							}

							var x0 = this.buffer[this.idx++];
							var x1 = this.buffer[this.idx++];
							return (((x0 << 8) | x1) << 16) >> 16;
						};

						Reader.prototype.readInt32 = function () {
							if (this.cap - this.idx < 4) {
								throw boundsErr;
							}

							var x0 = this.buffer[this.idx++];
							var x1 = this.buffer[this.idx++];
							var x2 = this.buffer[this.idx++];
							var x3 = this.buffer[this.idx++];
							return (x0 << 24) | (x1 << 16) | (x2 << 8) | x3;
						};

						return Reader;
					})();

				var ContractID;

				(function (ContractID) {
					ContractID[(ContractID['Implicit'] = 0)] = 'Implicit';
					ContractID[(ContractID['Originated'] = 1)] = 'Originated';
				})(ContractID || (ContractID = {}));

				var PublicKeyHashID;

				(function (PublicKeyHashID) {
					PublicKeyHashID[(PublicKeyHashID['ED25519'] = 0)] = 'ED25519';
					PublicKeyHashID[(PublicKeyHashID['SECP256K1'] = 1)] = 'SECP256K1';
					PublicKeyHashID[(PublicKeyHashID['P256'] = 2)] = 'P256';
				})(PublicKeyHashID || (PublicKeyHashID = {}));

				function readPublicKeyHash(rd) {
					var type;
					var tag = rd.readUint8();

					switch (tag) {
						case PublicKeyHashID.ED25519:
							type = 'ED25519PublicKeyHash';
							break;

						case PublicKeyHashID.SECP256K1:
							type = 'SECP256K1PublicKeyHash';
							break;

						case PublicKeyHashID.P256:
							type = 'P256PublicKeyHash';
							break;

						default:
							throw new Error('unknown public key hash tag: ' + tag);
					}

					return {
						type: type,
						hash: rd.readBytes(20)
					};
				}

				function readAddress(rd) {
					var address;
					var tag = rd.readUint8();

					switch (tag) {
						case ContractID.Implicit:
							address = readPublicKeyHash(rd);
							break;

						case ContractID.Originated:
							address = {
								type: 'ContractHash',
								hash: rd.readBytes(20)
							};
							rd.readBytes(1);
							break;

						default:
							throw new Error('unknown address tag: ' + tag);
					}

					if (rd.length !== 0) {
						// entry point
						var dec = new TextDecoder();
						address.entryPoint = dec.decode(new Uint8Array(rd.readBytes(rd.length)));
					}

					return address;
				}

				function writePublicKeyHash(a, w) {
					var tag;

					switch (a.type) {
						case 'ED25519PublicKeyHash':
							tag = PublicKeyHashID.ED25519;
							break;

						case 'SECP256K1PublicKeyHash':
							tag = PublicKeyHashID.SECP256K1;
							break;

						case 'P256PublicKeyHash':
							tag = PublicKeyHashID.P256;
							break;

						default:
							throw new Error('unexpected address type: ' + a.type);
					}

					w.writeUint8(tag);
					w.writeBytes(Array.from(a.hash));
				}

				function writeAddress(a, w) {
					if (a.type === 'ContractHash') {
						w.writeUint8(ContractID.Originated);
						w.writeBytes(Array.from(a.hash));
						w.writeUint8(0);
					} else {
						w.writeUint8(ContractID.Implicit);
						writePublicKeyHash(a, w);
					}

					if (a.entryPoint !== undefined && a.entryPoint !== '' && a.entryPoint !== 'default') {
						var enc = new TextEncoder();
						var bytes = enc.encode(a.entryPoint);
						w.writeBytes(Array.from(bytes));
					}
				}

				var PublicKeyID;

				(function (PublicKeyID) {
					PublicKeyID[(PublicKeyID['ED25519'] = 0)] = 'ED25519';
					PublicKeyID[(PublicKeyID['SECP256K1'] = 1)] = 'SECP256K1';
					PublicKeyID[(PublicKeyID['P256'] = 2)] = 'P256';
				})(PublicKeyID || (PublicKeyID = {}));

				function readPublicKey(rd) {
					var ln;
					var type;
					var tag = rd.readUint8();

					switch (tag) {
						case PublicKeyID.ED25519:
							type = 'ED25519PublicKey';
							ln = 32;
							break;

						case PublicKeyID.SECP256K1:
							type = 'SECP256K1PublicKey';
							ln = 33;
							break;

						case PublicKeyID.P256:
							type = 'P256PublicKey';
							ln = 33;
							break;

						default:
							throw new Error('unknown public key tag: ' + tag);
					}

					return {
						type: type,
						publicKey: rd.readBytes(ln)
					};
				}

				function writePublicKey(pk, w) {
					var tag;

					switch (pk.type) {
						case 'ED25519PublicKey':
							tag = PublicKeyID.ED25519;
							break;

						case 'SECP256K1PublicKey':
							tag = PublicKeyID.SECP256K1;
							break;

						case 'P256PublicKey':
							tag = PublicKeyID.P256;
							break;

						default:
							throw new Error('unexpected public key type: ' + pk.type);
					}

					w.writeUint8(tag);
					w.writeBytes(Array.from(pk.publicKey));
				}

				function writeExpr(expr, wr, tf) {
					var e_1, _a, e_2, _b, e_3, _c;

					var _d, _e;

					var _f = __read(tf(expr), 2),
						e = _f[0],
						args = _f[1];

					if (Array.isArray(e)) {
						var w = new Writer();

						try {
							for (var e_4 = __values(e), e_4_1 = e_4.next(); !e_4_1.done; e_4_1 = e_4.next()) {
								var v = e_4_1.value;
								var a = args.next();

								if (a.done) {
									throw new Error('REPORT ME: iterator is done');
								}

								writeExpr(v, w, a.value);
							}
						} catch (e_1_1) {
							e_1 = {
								error: e_1_1
							};
						} finally {
							try {
								if (e_4_1 && !e_4_1.done && (_a = e_4.return)) _a.call(e_4);
							} finally {
								if (e_1) throw e_1.error;
							}
						}

						wr.writeUint8(Tag.Sequence);
						wr.writeUint32(w.length);
						wr.writeBytes(w.buffer);
						return;
					}

					if ('string' in e) {
						var enc = new TextEncoder();
						var bytes = enc.encode(e.string);
						wr.writeUint8(Tag.String);
						wr.writeUint32(bytes.length);
						wr.writeBytes(Array.from(bytes));
						return;
					}

					if ('int' in e) {
						wr.writeUint8(Tag.Int);
						var val = BigInt(e.int);
						var sign = val < 0;

						if (sign) {
							val = -val;
						}

						var i = 0;

						do {
							var bits = i === 0 ? BigInt(6) : BigInt(7);
							var byte = val & ((BigInt(1) << bits) - BigInt(1));
							val >>= bits;

							if (val) {
								byte |= BigInt(0x80);
							}

							if (i === 0 && sign) {
								byte |= BigInt(0x40);
							}

							wr.writeUint8(Number(byte));
							i++;
						} while (val);

						return;
					}

					if ('bytes' in e) {
						var bytes = parseHex(e.bytes);
						wr.writeUint8(Tag.Bytes);
						wr.writeUint32(bytes.length);
						wr.writeBytes(bytes);
						return;
					}

					var prim = primTags[e.prim];

					if (prim === undefined) {
						throw new TypeError("Can't encode primary: " + e.prim);
					}

					var tag =
						(((_d = e.args) === null || _d === void 0 ? void 0 : _d.length) || 0) < 3
							? Tag.Prim0 +
							  (((_e = e.args) === null || _e === void 0 ? void 0 : _e.length) || 0) * 2 +
							  (e.annots === undefined || e.annots.length === 0 ? 0 : 1)
							: Tag.Prim;
					wr.writeUint8(tag);
					wr.writeUint8(prim);

					if (e.args !== undefined) {
						if (e.args.length < 3) {
							try {
								for (var _g = __values(e.args), _h = _g.next(); !_h.done; _h = _g.next()) {
									var v = _h.value;
									var a = args.next();

									if (a.done) {
										throw new Error('REPORT ME: iterator is done');
									}

									writeExpr(v, wr, a.value);
								}
							} catch (e_2_1) {
								e_2 = {
									error: e_2_1
								};
							} finally {
								try {
									if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
								} finally {
									if (e_2) throw e_2.error;
								}
							}
						} else {
							var w = new Writer();

							try {
								for (var _j = __values(e.args), _k = _j.next(); !_k.done; _k = _j.next()) {
									var v = _k.value;
									var a = args.next();

									if (a.done) {
										throw new Error('REPORT ME: iterator is done');
									}

									writeExpr(v, w, a.value);
								}
							} catch (e_3_1) {
								e_3 = {
									error: e_3_1
								};
							} finally {
								try {
									if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
								} finally {
									if (e_3) throw e_3.error;
								}
							}

							wr.writeUint32(w.length);
							wr.writeBytes(w.buffer);
						}
					}

					if (e.annots !== undefined && e.annots.length !== 0) {
						var enc = new TextEncoder();
						var bytes = enc.encode(e.annots.join(' '));
						wr.writeUint32(bytes.length);
						wr.writeBytes(Array.from(bytes));
					} else if (e.args !== undefined && e.args.length >= 3) {
						wr.writeUint32(0);
					}
				}

				function readExpr(rd, tf) {
					function passThrough() {
						return __generator(this, function (_a) {
							switch (_a.label) {
								case 0:
									return [
										4,
										/*yield*/
										readPassThrough
									];

								case 1:
									_a.sent();

									return [3 /*break*/, 0];

								case 2:
									return [
										2
										/*return*/
									];
							}
						});
					}

					var _a = __read(tf, 2),
						args = _a[0],
						tr = _a[1];

					var tag = rd.readUint8();

					switch (tag) {
						case Tag.Int: {
							var buf = [];
							var byte = void 0;

							do {
								byte = rd.readInt8();
								buf.push(byte);
							} while ((byte & 0x80) !== 0);

							var val = BigInt(0);
							var sign = false;

							for (var i = buf.length - 1; i >= 0; i--) {
								var bits = i === 0 ? BigInt(6) : BigInt(7);
								var byte_1 = BigInt(buf[i]);
								val <<= bits;
								val |= byte_1 & ((BigInt(1) << bits) - BigInt(1));

								if (i === 0) {
									sign = !!(byte_1 & BigInt(0x40));
								}
							}

							if (sign) {
								val = -val;
							}

							return tr({
								int: String(val)
							});
						}

						case Tag.String: {
							var length_1 = rd.readUint32();
							var bytes = rd.readBytes(length_1);
							var dec = new TextDecoder();
							return tr({
								string: dec.decode(new Uint8Array(bytes))
							});
						}

						case Tag.Bytes: {
							var length_2 = rd.readUint32();
							var bytes = rd.readBytes(length_2);
							var hex = hexBytes(Array.from(bytes));
							return tr({
								bytes: hex
							});
						}

						case Tag.Sequence: {
							var length_3 = rd.readUint32();
							var res = [];
							var savedrd = rd.copy(); // make two passes

							var it_1 = passThrough();

							for (var n = 0; n < 2; n++) {
								var r = savedrd.reader(length_3);
								res = [];

								while (r.length > 0) {
									var a = it_1.next();

									if (a.done) {
										throw new Error('REPORT ME: iterator is done');
									}

									res.push(readExpr(r, a.value));
								} // make a second pass with injected side effects

								it_1 = args(res);
								savedrd = rd;
							}

							return tr(res);
						}

						default: {
							if (tag > 9) {
								throw new Error('Unknown tag: ' + tag);
							}

							var p = rd.readUint8();

							if (p >= primitives.length) {
								throw new Error('Unknown primitive tag: ' + p);
							}

							var prim = primitives[p];
							var argn = (tag - 3) >> 1;
							var res = {
								prim: prim
							}; // make two passes

							var it_2 = passThrough();
							var savedrd = rd.copy();

							for (var n = 0; n < 2; n++) {
								res = {
									prim: prim
								};

								if (argn < 3) {
									for (var i = 0; i < argn; i++) {
										var a = it_2.next();

										if (a.done) {
											throw new Error('REPORT ME: iterator is done');
										}

										res.args = res.args || [];
										res.args.push(readExpr(savedrd, a.value));
									}
								} else {
									res.args = res.args || [];
									var length_4 = savedrd.readUint32();
									var r = savedrd.reader(length_4);

									while (r.length > 0) {
										var a = it_2.next();

										if (a.done) {
											throw new Error('REPORT ME: iterator is done');
										}

										res.args.push(readExpr(r, a.value));
									}
								} // make a second pass with injected side effects

								it_2 = args(res);
								savedrd = rd;
							}

							if (((tag - 3) & 1) === 1 || argn === 3) {
								// read annotations
								var length_5 = rd.readUint32();

								if (length_5 !== 0) {
									var bytes = rd.readBytes(length_5);
									var dec = new TextDecoder();
									res.annots = dec.decode(new Uint8Array(bytes)).split(' ');
								}
							}

							return tr(res);
						}
					}
				}

				var isOrData = function (e) {
					return 'prim' in e && (e.prim === 'Left' || e.prim === 'Right');
				};

				var isOptionData = function (e) {
					return 'prim' in e && (e.prim === 'Some' || e.prim === 'None');
				};

				var getWriteTransformFunc = function (t) {
					if (isPairType(t)) {
						return function (d) {
							if (!isPairData(d)) {
								throw new MichelsonTypeError(t, d, 'pair expected: ' + JSON.stringify(d));
							}

							assertDataListIfAny(d); // combs aren't used in pack format

							var tc = unpackComb('pair', t);
							var dc = unpackComb('Pair', d);
							return [
								dc,
								(function () {
									var _a, _b, a, e_5_1;

									var e_5, _c;

									return __generator(this, function (_d) {
										switch (_d.label) {
											case 0:
												_d.trys.push([0, 5, 6, 7]);

												(_a = __values(tc.args)), (_b = _a.next());
												_d.label = 1;

											case 1:
												if (!!_b.done) return [3 /*break*/, 4];
												a = _b.value;
												return [
													4,
													/*yield*/
													getWriteTransformFunc(a)
												];

											case 2:
												_d.sent();

												_d.label = 3;

											case 3:
												_b = _a.next();
												return [3 /*break*/, 1];

											case 4:
												return [3 /*break*/, 7];

											case 5:
												e_5_1 = _d.sent();
												e_5 = {
													error: e_5_1
												};
												return [3 /*break*/, 7];

											case 6:
												try {
													if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
												} finally {
													if (e_5) throw e_5.error;
												}

												return [
													7
													/*endfinally*/
												];

											case 7:
												return [
													2
													/*return*/
												];
										}
									});
								})()
							];
						};
					}

					switch (t.prim) {
						case 'or':
							return function (d) {
								if (!isOrData(d)) {
									throw new MichelsonTypeError(t, d, 'or expected: ' + JSON.stringify(d));
								}

								return [
									d,
									(function () {
										return __generator(this, function (_a) {
											switch (_a.label) {
												case 0:
													return [
														4,
														/*yield*/
														getWriteTransformFunc(t.args[d.prim === 'Left' ? 0 : 1])
													];

												case 1:
													_a.sent();

													return [
														2
														/*return*/
													];
											}
										});
									})()
								];
							};

						case 'option':
							return function (d) {
								if (!isOptionData(d)) {
									throw new MichelsonTypeError(t, d, 'option expected: ' + JSON.stringify(d));
								}

								return [
									d,
									(function () {
										var dd;
										return __generator(this, function (_a) {
											switch (_a.label) {
												case 0:
													dd = d;
													if (!(dd.prim === 'Some')) return [3 /*break*/, 2];
													return [
														4,
														/*yield*/
														getWriteTransformFunc(t.args[0])
													];

												case 1:
													_a.sent();

													_a.label = 2;

												case 2:
													return [
														2
														/*return*/
													];
											}
										});
									})()
								];
							};

						case 'list':
						case 'set':
							return function (d) {
								if (!Array.isArray(d)) {
									throw new MichelsonTypeError(t, d, t.prim + ' expected: ' + JSON.stringify(d));
								}

								return [
									d,
									(function () {
										var d_1, d_1_1, e_6_1;

										var e_6, _a;

										return __generator(this, function (_b) {
											switch (_b.label) {
												case 0:
													_b.trys.push([0, 5, 6, 7]);

													(d_1 = __values(d)), (d_1_1 = d_1.next());
													_b.label = 1;

												case 1:
													if (!!d_1_1.done) return [3 /*break*/, 4];
													return [
														4,
														/*yield*/
														getWriteTransformFunc(t.args[0])
													];

												case 2:
													_b.sent();

													_b.label = 3;

												case 3:
													d_1_1 = d_1.next();
													return [3 /*break*/, 1];

												case 4:
													return [3 /*break*/, 7];

												case 5:
													e_6_1 = _b.sent();
													e_6 = {
														error: e_6_1
													};
													return [3 /*break*/, 7];

												case 6:
													try {
														if (d_1_1 && !d_1_1.done && (_a = d_1.return)) _a.call(d_1);
													} finally {
														if (e_6) throw e_6.error;
													}

													return [
														7
														/*endfinally*/
													];

												case 7:
													return [
														2
														/*return*/
													];
											}
										});
									})()
								];
							};

						case 'map':
							return function (d) {
								if (!Array.isArray(d)) {
									throw new MichelsonTypeError(t, d, 'map expected: ' + JSON.stringify(d));
								}

								return [
									d,
									(function () {
										var d_2, d_2_1, e_7_1;

										var e_7, _a;

										return __generator(this, function (_b) {
											switch (_b.label) {
												case 0:
													_b.trys.push([0, 5, 6, 7]);

													(d_2 = __values(d)), (d_2_1 = d_2.next());
													_b.label = 1;

												case 1:
													if (!!d_2_1.done) return [3 /*break*/, 4];
													return [
														4,
														/*yield*/
														function (elt) {
															if (!('prim' in elt) || elt.prim !== 'Elt') {
																throw new MichelsonTypeError(
																	t,
																	elt,
																	'map element expected: ' + JSON.stringify(elt)
																);
															}

															return [
																elt,
																(function () {
																	var _a, _b, a, e_8_1;

																	var e_8, _c;

																	return __generator(this, function (_d) {
																		switch (_d.label) {
																			case 0:
																				_d.trys.push([0, 5, 6, 7]);

																				(_a = __values(t.args)), (_b = _a.next());
																				_d.label = 1;

																			case 1:
																				if (!!_b.done) return [3 /*break*/, 4];
																				a = _b.value;
																				return [
																					4,
																					/*yield*/
																					getWriteTransformFunc(a)
																				];

																			case 2:
																				_d.sent();

																				_d.label = 3;

																			case 3:
																				_b = _a.next();
																				return [3 /*break*/, 1];

																			case 4:
																				return [3 /*break*/, 7];

																			case 5:
																				e_8_1 = _d.sent();
																				e_8 = {
																					error: e_8_1
																				};
																				return [3 /*break*/, 7];

																			case 6:
																				try {
																					if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
																				} finally {
																					if (e_8) throw e_8.error;
																				}

																				return [
																					7
																					/*endfinally*/
																				];

																			case 7:
																				return [
																					2
																					/*return*/
																				];
																		}
																	});
																})()
															];
														}
													];

												case 2:
													_b.sent();

													_b.label = 3;

												case 3:
													d_2_1 = d_2.next();
													return [3 /*break*/, 1];

												case 4:
													return [3 /*break*/, 7];

												case 5:
													e_7_1 = _b.sent();
													e_7 = {
														error: e_7_1
													};
													return [3 /*break*/, 7];

												case 6:
													try {
														if (d_2_1 && !d_2_1.done && (_a = d_2.return)) _a.call(d_2);
													} finally {
														if (e_7) throw e_7.error;
													}

													return [
														7
														/*endfinally*/
													];

												case 7:
													return [
														2
														/*return*/
													];
											}
										});
									})()
								];
							};

						case 'chain_id':
							return function (d) {
								if (!('bytes' in d) && !('string' in d)) {
									throw new MichelsonTypeError(t, d, 'chain id expected: ' + JSON.stringify(d));
								}

								var bytes;

								if ('string' in d) {
									var id = checkDecodeTezosID(d.string, 'ChainID');

									if (id === null) {
										throw new MichelsonTypeError(t, d, 'chain id base58 expected: ' + d.string);
									}

									bytes = {
										bytes: hexBytes(id[1])
									};
								} else {
									bytes = d;
								}

								return [bytes, [][Symbol.iterator]()];
							};

						case 'signature':
							return function (d) {
								if (!('bytes' in d) && !('string' in d)) {
									throw new MichelsonTypeError(t, d, 'signature expected: ' + JSON.stringify(d));
								}

								var bytes;

								if ('string' in d) {
									var sig = checkDecodeTezosID(
										d.string,
										'ED25519Signature',
										'SECP256K1Signature',
										'P256Signature',
										'GenericSignature'
									);

									if (sig === null) {
										throw new MichelsonTypeError(t, d, 'signature base58 expected: ' + d.string);
									}

									bytes = {
										bytes: hexBytes(sig[1])
									};
								} else {
									bytes = d;
								}

								return [bytes, [][Symbol.iterator]()];
							};

						case 'key_hash':
							return function (d) {
								if (!('bytes' in d) && !('string' in d)) {
									throw new MichelsonTypeError(t, d, 'key hash expected: ' + JSON.stringify(d));
								}

								var bytes;

								if ('string' in d) {
									var pkh = checkDecodeTezosID(
										d.string,
										'ED25519PublicKeyHash',
										'SECP256K1PublicKeyHash',
										'P256PublicKeyHash'
									);

									if (pkh === null) {
										throw new MichelsonTypeError(t, d, 'key hash base58 expected: ' + d.string);
									}

									var w = new Writer();
									writePublicKeyHash(
										{
											type: pkh[0],
											hash: pkh[1]
										},
										w
									);
									bytes = {
										bytes: hexBytes(w.buffer)
									};
								} else {
									bytes = d;
								}

								return [bytes, [][Symbol.iterator]()];
							};

						case 'key':
							return function (d) {
								if (!('bytes' in d) && !('string' in d)) {
									throw new MichelsonTypeError(t, d, 'public key expected: ' + JSON.stringify(d));
								}

								var bytes;

								if ('string' in d) {
									var key = checkDecodeTezosID(
										d.string,
										'ED25519PublicKey',
										'SECP256K1PublicKey',
										'P256PublicKey'
									);

									if (key === null) {
										throw new MichelsonTypeError(t, d, 'public key base58 expected: ' + d.string);
									}

									var w = new Writer();
									writePublicKey(
										{
											type: key[0],
											publicKey: key[1]
										},
										w
									);
									bytes = {
										bytes: hexBytes(w.buffer)
									};
								} else {
									bytes = d;
								}

								return [bytes, [][Symbol.iterator]()];
							};

						case 'address':
							return function (d) {
								if (!('bytes' in d) && !('string' in d)) {
									throw new MichelsonTypeError(t, d, 'address expected: ' + JSON.stringify(d));
								}

								var bytes;

								if ('string' in d) {
									var s = d.string.split('%');
									var address = checkDecodeTezosID(
										s[0],
										'ED25519PublicKeyHash',
										'SECP256K1PublicKeyHash',
										'P256PublicKeyHash',
										'ContractHash'
									);

									if (address === null) {
										throw new MichelsonTypeError(t, d, 'address base58 expected: ' + d.string);
									}

									var w = new Writer();
									writeAddress(
										{
											type: address[0],
											hash: address[1],
											entryPoint: s.length > 1 ? s[1] : undefined
										},
										w
									);
									bytes = {
										bytes: hexBytes(w.buffer)
									};
								} else {
									bytes = d;
								}

								return [bytes, [][Symbol.iterator]()];
							};

						case 'timestamp':
							return function (d) {
								if (!('string' in d) && !('int' in d)) {
									throw new MichelsonTypeError(t, d, 'timestamp expected: ' + JSON.stringify(d));
								}

								var int;

								if ('string' in d) {
									var p = parseDate(d);

									if (p === null) {
										throw new MichelsonTypeError(t, d, "can't parse date: " + d.string);
									}

									int = {
										int: String(Math.floor(p.getTime() / 1000))
									};
								} else {
									int = d;
								}

								return [int, [][Symbol.iterator]()];
							};

						default:
							return writePassThrough;
					}
				};

				var isPushInstruction = function (e) {
					return 'prim' in e && e.prim === 'PUSH';
				};

				var writePassThrough = function (e) {
					if (isPushInstruction(e)) {
						assertMichelsonInstruction(e); // capture inlined type definition

						return [
							e,
							(function () {
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											return [
												4,
												/*yield*/
												writePassThrough
											];

										case 1:
											_a.sent();

											return [
												4,
												/*yield*/
												getWriteTransformFunc(e.args[0])
											];

										case 2:
											_a.sent();

											return [
												2
												/*return*/
											];
									}
								});
							})()
						];
					}

					return [
						e,
						(function () {
							return __generator(this, function (_a) {
								switch (_a.label) {
									case 0:
										return [
											4,
											/*yield*/
											writePassThrough
										];

									case 1:
										_a.sent();

										return [3 /*break*/, 0];

									case 2:
										return [
											2
											/*return*/
										];
								}
							});
						})()
					];
				};
				/**
				 * Serializes any value of packable type to its optimized binary representation
				 * identical to the one used by PACK and UNPACK Michelson instructions.
				 * Without a type definition (not recommended) the data will be encoded as a binary form of a generic Michelson expression.
				 * Type definition allows some types like `timestamp` and `address` and other base58 representable types to be encoded to
				 * corresponding optimized binary forms borrowed from the Tezos protocol
				 *
				 * ```typescript
				 * const data: MichelsonData = {
				 *     string: "KT1RvkwF4F7pz1gCoxkyZrG1RkrxQy3gmFTv%foo"
				 * };
				 *
				 * const typ: MichelsonType = {
				 *     prim: "address"
				 * };
				 *
				 * const packed = packData(data, typ);
				 *
				 * // 050a0000001901be41ee922ddd2cf33201e49d32da0afec571dce300666f6f
				 * ```
				 *
				 * Without a type definition the base58 encoded address will be treated as a string
				 * ```typescript
				 * const data: MichelsonData = {
				 *     string: "KT1RvkwF4F7pz1gCoxkyZrG1RkrxQy3gmFTv%foo"
				 * };
				 *
				 * const packed = packData(data);
				 *
				 * // 0501000000284b543152766b7746344637707a3167436f786b795a724731526b7278517933676d46547625666f6f
				 * ```
				 * @param d Data object
				 * @param t Optional type definition
				 * @returns Binary representation as numeric array
				 */

				function packData(d, t) {
					var w = new Writer();
					w.writeUint8(5);
					writeExpr(d, w, t !== undefined ? getWriteTransformFunc(t) : writePassThrough);
					return w.buffer;
				}
				/**
				 * Serializes any value of packable type to its optimized binary representation
				 * identical to the one used by PACK and UNPACK Michelson instructions.
				 * Same as {@link packData} but returns a `bytes` Michelson data literal instead of an array
				 *
				 * ```typescript
				 * const data: MichelsonData = {
				 *     string: "2019-09-26T10:59:51Z"
				 * };
				 *
				 * const typ: MichelsonType = {
				 *     prim: "timestamp"
				 * };
				 *
				 * const packed = packDataBytes(data, typ);
				 *
				 * // { bytes: "0500a7e8e4d80b" }
				 * ```
				 * @param d Data object
				 * @param t Optional type definition
				 * @returns Binary representation as a bytes literal
				 */

				function packDataBytes(d, t) {
					return {
						bytes: hexBytes(packData(d, t))
					};
				}

				var getReadTransformFuncs = function (t) {
					if (isPairType(t)) {
						var args_1 = Array.isArray(t) ? t : t.args;
						return [
							function (d) {
								if (!isPairData(d)) {
									throw new MichelsonTypeError(t, d, 'pair expected: ' + JSON.stringify(d));
								}

								return (function () {
									var args_2, args_2_1, a, e_9_1;

									var e_9, _a;

									return __generator(this, function (_b) {
										switch (_b.label) {
											case 0:
												_b.trys.push([0, 5, 6, 7]);

												(args_2 = __values(args_1)), (args_2_1 = args_2.next());
												_b.label = 1;

											case 1:
												if (!!args_2_1.done) return [3 /*break*/, 4];
												a = args_2_1.value;
												return [
													4,
													/*yield*/
													getReadTransformFuncs(a)
												];

											case 2:
												_b.sent();

												_b.label = 3;

											case 3:
												args_2_1 = args_2.next();
												return [3 /*break*/, 1];

											case 4:
												return [3 /*break*/, 7];

											case 5:
												e_9_1 = _b.sent();
												e_9 = {
													error: e_9_1
												};
												return [3 /*break*/, 7];

											case 6:
												try {
													if (args_2_1 && !args_2_1.done && (_a = args_2.return)) _a.call(args_2);
												} finally {
													if (e_9) throw e_9.error;
												}

												return [
													7
													/*endfinally*/
												];

											case 7:
												return [
													2
													/*return*/
												];
										}
									});
								})();
							},
							function (d) {
								return d;
							}
						];
					}

					switch (t.prim) {
						case 'or':
							return [
								function (d) {
									if (!isOrData(d)) {
										throw new MichelsonTypeError(t, d, 'or expected: ' + JSON.stringify(d));
									}

									return (function () {
										return __generator(this, function (_a) {
											switch (_a.label) {
												case 0:
													return [
														4,
														/*yield*/
														getReadTransformFuncs(t.args[d.prim === 'Left' ? 0 : 1])
													];

												case 1:
													_a.sent();

													return [
														2
														/*return*/
													];
											}
										});
									})();
								},
								function (d) {
									return d;
								}
							];

						case 'option':
							return [
								function (d) {
									if (!isOptionData(d)) {
										throw new MichelsonTypeError(t, d, 'option expected: ' + JSON.stringify(d));
									}

									return (function () {
										return __generator(this, function (_a) {
											switch (_a.label) {
												case 0:
													if (!(d.prim === 'Some')) return [3 /*break*/, 2];
													return [
														4,
														/*yield*/
														getReadTransformFuncs(t.args[0])
													];

												case 1:
													_a.sent();

													_a.label = 2;

												case 2:
													return [
														2
														/*return*/
													];
											}
										});
									})();
								},
								function (d) {
									return d;
								}
							];

						case 'list':
						case 'set':
							return [
								function (d) {
									if (!Array.isArray(d)) {
										throw new MichelsonTypeError(t, d, t.prim + ' expected: ' + JSON.stringify(d));
									}

									return (function () {
										return __generator(this, function (_a) {
											switch (_a.label) {
												case 0:
													return [
														4,
														/*yield*/
														getReadTransformFuncs(t.args[0])
													];

												case 1:
													_a.sent();

													return [3 /*break*/, 0];

												case 2:
													return [
														2
														/*return*/
													];
											}
										});
									})();
								},
								function (d) {
									return d;
								}
							];

						case 'map':
							return [
								function (d) {
									if (!Array.isArray(d)) {
										throw new MichelsonTypeError(t, d, 'map expected: ' + JSON.stringify(d));
									}

									return (function () {
										return __generator(this, function (_a) {
											switch (_a.label) {
												case 0:
													return [
														4,
														/*yield*/
														[
															function (elt) {
																if (!('prim' in elt) || elt.prim !== 'Elt') {
																	throw new MichelsonTypeError(
																		t,
																		elt,
																		'map element expected: ' + JSON.stringify(elt)
																	);
																}

																return (function () {
																	var _a, _b, a, e_10_1;

																	var e_10, _c;

																	return __generator(this, function (_d) {
																		switch (_d.label) {
																			case 0:
																				_d.trys.push([0, 5, 6, 7]);

																				(_a = __values(t.args)), (_b = _a.next());
																				_d.label = 1;

																			case 1:
																				if (!!_b.done) return [3 /*break*/, 4];
																				a = _b.value;
																				return [
																					4,
																					/*yield*/
																					getReadTransformFuncs(a)
																				];

																			case 2:
																				_d.sent();

																				_d.label = 3;

																			case 3:
																				_b = _a.next();
																				return [3 /*break*/, 1];

																			case 4:
																				return [3 /*break*/, 7];

																			case 5:
																				e_10_1 = _d.sent();
																				e_10 = {
																					error: e_10_1
																				};
																				return [3 /*break*/, 7];

																			case 6:
																				try {
																					if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
																				} finally {
																					if (e_10) throw e_10.error;
																				}

																				return [
																					7
																					/*endfinally*/
																				];

																			case 7:
																				return [
																					2
																					/*return*/
																				];
																		}
																	});
																})();
															},
															function (elt) {
																return elt;
															}
														]
													];

												case 1:
													_a.sent();

													return [3 /*break*/, 0];

												case 2:
													return [
														2
														/*return*/
													];
											}
										});
									})();
								},
								function (d) {
									return d;
								}
							];

						case 'chain_id':
							return [
								function () {
									return [][Symbol.iterator]();
								},
								function (d) {
									if (!('bytes' in d) && !('string' in d)) {
										throw new MichelsonTypeError(t, d, 'chain id expected: ' + JSON.stringify(d));
									}

									if ('string' in d) {
										return d;
									}

									var bytes = parseBytes(d.bytes);

									if (bytes === null) {
										throw new MichelsonTypeError(t, d, "can't parse bytes: " + d.bytes);
									}

									return {
										string: encodeTezosID('ChainID', bytes)
									};
								}
							];

						case 'signature':
							return [
								function () {
									return [][Symbol.iterator]();
								},
								function (d) {
									if (!('bytes' in d) && !('string' in d)) {
										throw new MichelsonTypeError(t, d, 'signature expected: ' + JSON.stringify(d));
									}

									if ('string' in d) {
										return d;
									}

									var bytes = parseBytes(d.bytes);

									if (bytes === null) {
										throw new MichelsonTypeError(t, d, "can't parse bytes: " + d.bytes);
									}

									return {
										string: encodeTezosID('GenericSignature', bytes)
									};
								}
							];

						case 'key_hash':
							return [
								function () {
									return [][Symbol.iterator]();
								},
								function (d) {
									if (!('bytes' in d) && !('string' in d)) {
										throw new MichelsonTypeError(t, d, 'key hash expected: ' + JSON.stringify(d));
									}

									if ('string' in d) {
										return d;
									}

									var bytes = parseBytes(d.bytes);

									if (bytes === null) {
										throw new MichelsonTypeError(t, d, "can't parse bytes: " + d.bytes);
									}

									var rd = new Reader(new Uint8Array(bytes));
									var addr = readPublicKeyHash(rd);
									return {
										string:
											encodeTezosID(addr.type, addr.hash) +
											(addr.entryPoint ? '%' + addr.entryPoint : '')
									};
								}
							];

						case 'key':
							return [
								function () {
									return [][Symbol.iterator]();
								},
								function (d) {
									if (!('bytes' in d) && !('string' in d)) {
										throw new MichelsonTypeError(t, d, 'public key expected: ' + JSON.stringify(d));
									}

									if ('string' in d) {
										return d;
									}

									var bytes = parseBytes(d.bytes);

									if (bytes === null) {
										throw new MichelsonTypeError(t, d, "can't parse bytes: " + d.bytes);
									}

									var rd = new Reader(new Uint8Array(bytes));
									var pk = readPublicKey(rd);
									return {
										string: encodeTezosID(pk.type, pk.publicKey)
									};
								}
							];

						case 'address':
							return [
								function () {
									return [][Symbol.iterator]();
								},
								function (d) {
									if (!('bytes' in d) && !('string' in d)) {
										throw new MichelsonTypeError(t, d, 'address expected: ' + JSON.stringify(d));
									}

									if ('string' in d) {
										return d;
									}

									var bytes = parseBytes(d.bytes);

									if (bytes === null) {
										throw new MichelsonTypeError(t, d, "can't parse bytes: " + d.bytes);
									}

									var rd = new Reader(new Uint8Array(bytes));
									var addr = readAddress(rd);
									return {
										string:
											encodeTezosID(addr.type, addr.hash) +
											(addr.entryPoint ? '%' + addr.entryPoint : '')
									};
								}
							];

						case 'timestamp':
							return [
								function () {
									return [][Symbol.iterator]();
								},
								function (d) {
									if (!('int' in d) && !('string' in d)) {
										throw new MichelsonTypeError(t, d, 'address expected: ' + JSON.stringify(d));
									}

									if ('string' in d) {
										return d;
									}

									var date = new Date(parseInt(d.int, 10) * 1000);
									return {
										string: date.toISOString().slice(0, 19) + 'Z'
									};
								}
							];

						default:
							return readPassThrough;
					}
				};

				var readPassThrough = [
					function (e) {
						if (isPushInstruction(e)) {
							assertMichelsonInstruction(e); // capture inlined type definition

							return (function () {
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											return [
												4,
												/*yield*/
												readPassThrough
											];

										case 1:
											_a.sent();

											return [
												4,
												/*yield*/
												getReadTransformFuncs(e.args[0])
											];

										case 2:
											_a.sent();

											return [
												2
												/*return*/
											];
									}
								});
							})();
						}

						return (function () {
							return __generator(this, function (_a) {
								switch (_a.label) {
									case 0:
										return [
											4,
											/*yield*/
											readPassThrough
										];

									case 1:
										_a.sent();

										return [3 /*break*/, 0];

									case 2:
										return [
											2
											/*return*/
										];
								}
							});
						})();
					},
					function (e) {
						return e;
					}
				];
				/**
				 * Deserialize a byte array into the corresponding Michelson value.
				 * Without a type definition (not recommended) the binary data will be treated as a binary form of a generic Michelson expression and returned as is.
				 * Type definition allows some types like `timestamp` and `address` and other types usually encoded in optimized binary forms to be transformed
				 * back to their string representations like base58 and ISO timestamps.
				 *
				 * ```typescript
				 * const src = [0x05, 0x00, 0xa7, 0xe8, 0xe4, 0xd8, 0x0b];
				 *
				 * const typ: MichelsonType = {
				 *     prim: "timestamp"
				 * };
				 *
				 * const data = unpackData(src, typ);
				 *
				 * // { string: "2019-09-26T10:59:51Z" }
				 * ```
				 *
				 * Same binary data without a type definition
				 * ```typescript
				 * const src = [0x05, 0x00, 0xa7, 0xe8, 0xe4, 0xd8, 0x0b];
				 *
				 * const data = unpackData(src);
				 *
				 * // { int: "1569495591" }
				 * ```
				 * @param src Byte array
				 * @param t Optional type definition
				 * @returns Deserialized data
				 */

				function unpackData(src, t) {
					var r = new Reader(src);

					if (r.readUint8() !== 5) {
						throw new Error('incorrect packed data magic number');
					}

					var ex = readExpr(r, t !== undefined ? getReadTransformFuncs(t) : readPassThrough);

					if (assertMichelsonData(ex)) {
						return ex;
					}

					throw new Error(); // never
				}
				/**
				 * Deserialize a byte array into the corresponding Michelson value.
				 * Same as {@link unpackData} but takes a `bytes` Michelson data literal instead of an array
				 *
				 * ```typescript
				 * const src = { bytes: "0500a7e8e4d80b" };
				 *
				 * const typ: MichelsonType = {
				 *     prim: "timestamp"
				 * };
				 *
				 * const data = unpackDataBytes(src, typ);
				 *
				 * // { string: "2019-09-26T10:59:51Z" }
				 * ```
				 * @param src Bytes object
				 * @param t Optional type definition
				 * @returns Deserialized data
				 */

				function unpackDataBytes(src, t) {
					var bytes = parseBytes(src.bytes);

					if (bytes === null) {
						throw new Error('can\'t parse bytes: "' + src.bytes + '"');
					}

					return unpackData(bytes, t);
				} // helper functions also used by validator

				function decodeAddressBytes(b) {
					var bytes = parseBytes(b.bytes);

					if (bytes === null) {
						throw new Error('can\'t parse bytes: "' + b.bytes + '"');
					}

					var rd = new Reader(new Uint8Array(bytes));
					return readAddress(rd);
				}

				function decodePublicKeyHashBytes(b) {
					var bytes = parseBytes(b.bytes);

					if (bytes === null) {
						throw new Error('can\'t parse bytes: "' + b.bytes + '"');
					}

					var rd = new Reader(new Uint8Array(bytes));
					return readPublicKeyHash(rd);
				}

				function decodePublicKeyBytes(b) {
					var bytes = parseBytes(b.bytes);

					if (bytes === null) {
						throw new Error('can\'t parse bytes: "' + b.bytes + '"');
					}

					var rd = new Reader(new Uint8Array(bytes));
					return readPublicKey(rd);
				}

				var MichelsonInstructionError =
					/** @class */
					(function (_super) {
						__extends(MichelsonInstructionError, _super);
						/**
						 * @param val Value of a type node caused the error
						 * @param stackState Current stack state
						 * @param message An error message
						 */

						function MichelsonInstructionError(val, stackState, message) {
							var _this = _super.call(this, val, message) || this;

							_this.stackState = stackState;
							Object.setPrototypeOf(_this, MichelsonInstructionError.prototype);
							return _this;
						}

						return MichelsonInstructionError;
					})(MichelsonError); // 'sequence as a pair' edo syntax helpers

				exports.MichelsonInstructionError = MichelsonInstructionError;

				function typeID(t) {
					return Array.isArray(t) ? 'pair' : t.prim;
				}

				function typeArgs(t) {
					return 'prim' in t ? t.args : t;
				}

				function assertScalarTypesEqual(a, b, field) {
					if (field === void 0) {
						field = false;
					}

					if (typeID(a) !== typeID(b)) {
						throw new MichelsonTypeError(
							a,
							undefined,
							'types mismatch: ' + typeID(a) + ' != ' + typeID(b)
						);
					}

					var ann = [unpackAnnotations(a), unpackAnnotations(b)];

					if (ann[0].t && ann[1].t && ann[0].t[0] !== ann[1].t[0]) {
						throw new MichelsonTypeError(
							a,
							undefined,
							typeID(a) + ': type names mismatch: ' + ann[0].t[0] + ' != ' + ann[1].t[0]
						);
					}

					if (field && ann[0].f && ann[1].f && ann[0].f[0] !== ann[1].f[0]) {
						throw new MichelsonTypeError(
							a,
							undefined,
							typeID(a) + ': field names mismatch: ' + ann[0].f[0] + ' != ' + ann[1].f
						);
					}

					if (isPairType(a)) {
						var aArgs = unpackComb('pair', a);
						var bArgs = unpackComb('pair', b);
						assertScalarTypesEqual(aArgs.args[0], bArgs.args[0], true);
						assertScalarTypesEqual(aArgs.args[1], bArgs.args[1], true);
						return;
					}

					switch (a.prim) {
						case 'option':
						case 'list':
						case 'contract':
						case 'set':
						case 'ticket':
							assertScalarTypesEqual(a.args[0], b.args[0]);
							break;

						case 'or':
							assertScalarTypesEqual(a.args[0], b.args[0], true);
							assertScalarTypesEqual(a.args[1], b.args[1], true);
							break;

						case 'lambda':
						case 'map':
						case 'big_map':
							assertScalarTypesEqual(a.args[0], b.args[0]);
							assertScalarTypesEqual(a.args[1], b.args[1]);
							break;

						case 'sapling_state':
						case 'sapling_transaction':
							if (parseInt(a.args[0].int, 10) !== parseInt(b.args[0].int, 10)) {
								throw new MichelsonTypeError(
									a,
									undefined,
									typeID(a) + ': type argument mismatch: ' + a.args[0].int + ' != ' + b.args[0].int
								);
							}
					}
				}

				function assertStacksEqual(a, b) {
					if (a.length !== b.length) {
						throw new MichelsonTypeError(
							a,
							undefined,
							'stack length mismatch: ' + a.length + ' != ' + b.length
						);
					}

					for (var i = 0; i < a.length; i++) {
						assertScalarTypesEqual(a[i], b[i]);
					}
				}

				function assertTypeAnnotationsValid(t, field) {
					var e_1, _a, e_2, _b;

					var _c, _d, _e;

					if (field === void 0) {
						field = false;
					}

					if (!Array.isArray(t)) {
						var ann = unpackAnnotations(t);

						if ((((_c = ann.t) === null || _c === void 0 ? void 0 : _c.length) || 0) > 1) {
							throw new MichelsonTypeError(
								t,
								undefined,
								t.prim + ': at most one type annotation allowed: ' + t.annots
							);
						}

						if (field) {
							if ((((_d = ann.f) === null || _d === void 0 ? void 0 : _d.length) || 0) > 1) {
								throw new MichelsonTypeError(
									t,
									undefined,
									t.prim + ': at most one field annotation allowed: ' + t.annots
								);
							}
						} else {
							if ((((_e = ann.f) === null || _e === void 0 ? void 0 : _e.length) || 0) > 0) {
								throw new MichelsonTypeError(
									t,
									undefined,
									t.prim + ": field annotations aren't allowed: " + t.annots
								);
							}
						}
					}

					if (isPairType(t)) {
						var args = typeArgs(t);

						try {
							for (
								var args_1 = __values(args), args_1_1 = args_1.next();
								!args_1_1.done;
								args_1_1 = args_1.next()
							) {
								var a = args_1_1.value;
								assertTypeAnnotationsValid(a, true);
							}
						} catch (e_1_1) {
							e_1 = {
								error: e_1_1
							};
						} finally {
							try {
								if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);
							} finally {
								if (e_1) throw e_1.error;
							}
						}

						return;
					}

					switch (t.prim) {
						case 'option':
						case 'list':
						case 'contract':
						case 'set':
							assertTypeAnnotationsValid(t.args[0]);
							break;

						case 'or':
							try {
								for (var _f = __values(t.args), _g = _f.next(); !_g.done; _g = _f.next()) {
									var a = _g.value;
									assertTypeAnnotationsValid(a, true);
								}
							} catch (e_2_1) {
								e_2 = {
									error: e_2_1
								};
							} finally {
								try {
									if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
								} finally {
									if (e_2) throw e_2.error;
								}
							}

							break;

						case 'lambda':
						case 'map':
						case 'big_map':
							assertTypeAnnotationsValid(t.args[0]);
							assertTypeAnnotationsValid(t.args[1]);
					}
				} // Data integrity check

				function compareMichelsonData(t, a, b) {
					if (isPairType(t)) {
						if (isPairData(a) && isPairData(b)) {
							assertDataListIfAny(a);
							assertDataListIfAny(b);
							var tComb = unpackComb('pair', t);
							var aComb = unpackComb('Pair', a);
							var bComb = unpackComb('Pair', b);
							var x = compareMichelsonData(tComb.args[0], aComb.args[0], bComb.args[0]);

							if (x !== 0) {
								return x;
							}

							return compareMichelsonData(tComb.args[0], aComb.args[1], bComb.args[1]);
						}
					} else {
						switch (t.prim) {
							case 'int':
							case 'nat':
							case 'mutez':
								if ('int' in a && 'int' in b) {
									return new LongInteger(a.int).cmp(new LongInteger(b.int));
								}

								break;

							case 'string':
								if ('string' in a && 'string' in b) {
									var x = a.string.localeCompare(b.string);
									return x < 0 ? -1 : x > 0 ? 1 : 0;
								}

								break;

							case 'bytes':
								if ('bytes' in a && 'bytes' in b) {
									var aa = parseBytes(a.bytes);
									var bb = parseBytes(b.bytes);

									if (aa !== null && bb !== null) {
										return compareBytes(aa, bb);
									}
								}

								break;

							case 'bool':
								if (
									'prim' in a &&
									'prim' in b &&
									(a.prim === 'True' || a.prim === 'False') &&
									(b.prim === 'True' || b.prim === 'False')
								) {
									return a.prim === b.prim ? 0 : a.prim === 'False' ? -1 : 1;
								}

								break;

							case 'key':
							case 'key_hash':
							case 'address':
							case 'signature':
							case 'chain_id':
								if (('string' in a || 'bytes' in a) && ('string' in b || 'bytes' in b)) {
									return compareBytes(
										'string' in a ? decodeBase58Check(a.string) : parseBytes(a.bytes) || [],
										'string' in b ? decodeBase58Check(b.string) : parseBytes(b.bytes) || []
									);
								}

								break;

							case 'timestamp':
								if (('string' in a || 'int' in a) && ('string' in b || 'int' in b)) {
									var aa = parseDate(a);
									var bb = parseDate(b);

									if (aa !== null && bb !== null) {
										var x = aa.valueOf() - bb.valueOf();
										return x < 0 ? -1 : x > 0 ? 1 : 0;
									}
								}

								break;

							case 'unit':
								if ('prim' in a && 'prim' in b && a.prim === 'Unit' && b.prim === 'Unit') {
									return 0;
								}
						}
					} // Unlikely, types are expected to be verified before the function call

					throw new MichelsonTypeError(
						t,
						undefined,
						typeID(t) + ': not comparable values: ' + JSON.stringify(a) + ', ' + JSON.stringify(b)
					);
				} // Simplified version of assertMichelsonInstruction() for previously validated data

				function isFunction(d) {
					var e_3, _a;

					if (!Array.isArray(d)) {
						return false;
					}

					try {
						for (var d_1 = __values(d), d_1_1 = d_1.next(); !d_1_1.done; d_1_1 = d_1.next()) {
							var v = d_1_1.value;

							if (!((Array.isArray(v) && isFunction(v)) || ('prim' in v && isInstruction(v)))) {
								return false;
							}
						}
					} catch (e_3_1) {
						e_3 = {
							error: e_3_1
						};
					} finally {
						try {
							if (d_1_1 && !d_1_1.done && (_a = d_1.return)) _a.call(d_1);
						} finally {
							if (e_3) throw e_3.error;
						}
					}

					return true;
				}

				function assertDataValidInternal(d, t, ctx) {
					var e_4, _a, e_5, _b;

					if (isPairType(t)) {
						if (isPairData(d)) {
							assertDataListIfAny(d);
							var dc = unpackComb('Pair', d);
							var tc = unpackComb('pair', t);
							assertDataValidInternal(dc.args[0], tc.args[0], ctx);
							assertDataValidInternal(dc.args[1], tc.args[1], ctx);
							return;
						}

						throw new MichelsonTypeError(t, d, 'pair expected: ' + JSON.stringify(d));
					}

					switch (t.prim) {
						// Atomic literals
						case 'int':
							if ('int' in d && isDecimal(d.int)) {
								return;
							}

							throw new MichelsonTypeError(t, d, 'integer value expected: ' + JSON.stringify(d));

						case 'nat':
						case 'mutez':
							if ('int' in d && isNatural(d.int)) {
								return;
							}

							throw new MichelsonTypeError(t, d, 'natural value expected: ' + JSON.stringify(d));

						case 'string':
							if ('string' in d) {
								return;
							}

							throw new MichelsonTypeError(t, d, 'string value expected: ' + JSON.stringify(d));

						case 'bytes':
						case 'bls12_381_g1':
						case 'bls12_381_g2':
							if ('bytes' in d && parseBytes(d.bytes) !== null) {
								return;
							}

							throw new MichelsonTypeError(t, d, 'bytes value expected: ' + JSON.stringify(d));

						case 'bool':
							if ('prim' in d && (d.prim === 'True' || d.prim === 'False')) {
								return;
							}

							throw new MichelsonTypeError(t, d, 'boolean value expected: ' + JSON.stringify(d));

						case 'key_hash':
							if (
								'string' in d &&
								checkDecodeTezosID(
									d.string,
									'ED25519PublicKeyHash',
									'SECP256K1PublicKeyHash',
									'P256PublicKeyHash'
								) !== null
							) {
								return;
							} else if ('bytes' in d) {
								try {
									decodePublicKeyHashBytes(d);
									return;
								} catch (err) {
									// ignore message
								}
							}

							throw new MichelsonTypeError(t, d, 'key hash expected: ' + JSON.stringify(d));

						case 'timestamp':
							if (('string' in d || 'int' in d) && parseDate(d) !== null) {
								return;
							}

							throw new MichelsonTypeError(t, d, 'timestamp expected: ' + JSON.stringify(d));

						case 'address':
							if ('string' in d) {
								var address = d.string;
								var ep = d.string.indexOf('%');

								if (ep >= 0) {
									// trim entry point
									address = d.string.slice(0, ep);
								}

								if (
									checkDecodeTezosID(
										address,
										'ED25519PublicKeyHash',
										'SECP256K1PublicKeyHash',
										'P256PublicKeyHash',
										'ContractHash'
									) !== null
								) {
									return;
								}
							} else if ('bytes' in d) {
								try {
									decodeAddressBytes(d);
									return;
								} catch (err) {
									// ignore message
								}
							}

							throw new MichelsonTypeError(t, d, 'address expected: ' + JSON.stringify(d));

						case 'key':
							if (
								'string' in d &&
								checkDecodeTezosID(
									d.string,
									'ED25519PublicKey',
									'SECP256K1PublicKey',
									'P256PublicKey'
								) !== null
							) {
								return;
							} else if ('bytes' in d) {
								try {
									decodePublicKeyBytes(d);
									return;
								} catch (err) {
									// ignore message
								}
							}

							throw new MichelsonTypeError(t, d, 'public key expected: ' + JSON.stringify(d));

						case 'unit':
							if ('prim' in d && d.prim === 'Unit') {
								return;
							}

							throw new MichelsonTypeError(t, d, 'unit value expected: ' + JSON.stringify(d));

						case 'signature':
							if (
								'bytes' in d ||
								('string' in d &&
									checkDecodeTezosID(
										d.string,
										'ED25519Signature',
										'SECP256K1Signature',
										'P256Signature',
										'GenericSignature'
									) !== null)
							) {
								return;
							}

							throw new MichelsonTypeError(t, d, 'signature expected: ' + JSON.stringify(d));

						case 'chain_id':
							if ('bytes' in d || 'string' in d) {
								var x = 'string' in d ? decodeBase58Check(d.string) : parseBytes(d.bytes);

								if (x !== null) {
									return;
								}
							}

							throw new MichelsonTypeError(t, d, 'chain id expected: ' + JSON.stringify(d));

						case 'operation':
							throw new MichelsonTypeError(
								t,
								d,
								"operation type can't be represented as a literal value"
							);

						case 'contract':
							throw new MichelsonTypeError(
								t,
								d,
								"contract type can't be represented as a literal value"
							);
						// Complex types

						case 'option':
							if ('prim' in d) {
								if (d.prim === 'None') {
									return;
								} else if (d.prim === 'Some') {
									assertDataValidInternal(d.args[0], t.args[0], ctx);
									return;
								}
							}

							throw new MichelsonTypeError(t, d, 'option expected: ' + JSON.stringify(d));

						case 'list':
						case 'set':
							if (assertDataListIfAny(d)) {
								var prev = void 0;

								try {
									for (var d_2 = __values(d), d_2_1 = d_2.next(); !d_2_1.done; d_2_1 = d_2.next()) {
										var v = d_2_1.value;
										assertDataValidInternal(v, t.args[0], ctx);

										if (t.prim === 'set') {
											if (prev === undefined) {
												prev = v;
											} else if (compareMichelsonData(t.args[0], prev, v) > 0) {
												throw new MichelsonTypeError(
													t,
													d,
													'set elements must be ordered: ' + JSON.stringify(d)
												);
											}
										}
									}
								} catch (e_4_1) {
									e_4 = {
										error: e_4_1
									};
								} finally {
									try {
										if (d_2_1 && !d_2_1.done && (_a = d_2.return)) _a.call(d_2);
									} finally {
										if (e_4) throw e_4.error;
									}
								}

								return;
							}

							throw new MichelsonTypeError(t, d, t.prim + ' expected: ' + JSON.stringify(d));

						case 'or':
							if ('prim' in d) {
								if (d.prim === 'Left') {
									assertDataValidInternal(d.args[0], t.args[0], ctx);
									return;
								} else if (d.prim === 'Right') {
									assertDataValidInternal(d.args[0], t.args[1], ctx);
									return;
								}
							}

							throw new MichelsonTypeError(t, d, 'union (or) expected: ' + JSON.stringify(d));

						case 'lambda':
							if (isFunction(d)) {
								var ret = functionTypeInternal(d, [t.args[0]], ctx);

								if ('failed' in ret) {
									throw new MichelsonTypeError(
										t,
										d,
										'function is failed with error type: ' + ret.failed
									);
								}

								if (ret.length !== 1) {
									throw new MichelsonTypeError(t, d, 'function must return a value');
								}

								assertScalarTypesEqual(t.args[1], ret[0]);
								return;
							}

							throw new MichelsonTypeError(t, d, 'function expected: ' + JSON.stringify(d));

						case 'map':
						case 'big_map':
							if (Array.isArray(d)) {
								var prev = void 0;

								try {
									for (var d_3 = __values(d), d_3_1 = d_3.next(); !d_3_1.done; d_3_1 = d_3.next()) {
										var v = d_3_1.value;

										if (!('prim' in v) || v.prim !== 'Elt') {
											throw new MichelsonTypeError(
												t,
												d,
												'map elements expected: ' + JSON.stringify(d)
											);
										}

										assertDataValidInternal(v.args[0], t.args[0], ctx);
										assertDataValidInternal(v.args[1], t.args[1], ctx);

										if (prev === undefined) {
											prev = v;
										} else if (compareMichelsonData(t.args[0], prev.args[0], v.args[0]) > 0) {
											throw new MichelsonTypeError(
												t,
												d,
												'map elements must be ordered: ' + JSON.stringify(d)
											);
										}
									}
								} catch (e_5_1) {
									e_5 = {
										error: e_5_1
									};
								} finally {
									try {
										if (d_3_1 && !d_3_1.done && (_b = d_3.return)) _b.call(d_3);
									} finally {
										if (e_5) throw e_5.error;
									}
								}

								return;
							}

							throw new MichelsonTypeError(t, d, t.prim + ' expected: ' + JSON.stringify(d));

						case 'bls12_381_fr':
							if (
								('int' in d && isDecimal(d.int)) ||
								('bytes' in d && parseBytes(d.bytes) !== null)
							) {
								return;
							}

							throw new MichelsonTypeError(
								t,
								d,
								'BLS12-381 element expected: ' + JSON.stringify(d)
							);

						case 'sapling_state':
							if (Array.isArray(d)) {
								return;
							}

							throw new MichelsonTypeError(t, d, 'sapling state expected: ' + JSON.stringify(d));

						case 'ticket':
							assertDataValidInternal(
								d,
								{
									prim: 'pair',
									args: [
										{
											prim: 'address'
										},
										t.args[0],
										{
											prim: 'nat'
										}
									]
								},
								ctx
							);
							return;

						default:
							throw new MichelsonTypeError(t, d, 'unexpected type: ' + typeID(t));
					}
				}

				function instructionListType(inst, stack, ctx) {
					var e_6, _a;

					var ret = stack;
					var s = stack;
					var i = 0;

					try {
						for (
							var inst_1 = __values(inst), inst_1_1 = inst_1.next();
							!inst_1_1.done;
							inst_1_1 = inst_1.next()
						) {
							var op = inst_1_1.value;
							var ft = functionTypeInternal(op, s, ctx);
							ret = ft;

							if ('failed' in ft) {
								break;
							}

							s = ft;
							i++;
						}
					} catch (e_6_1) {
						e_6 = {
							error: e_6_1
						};
					} finally {
						try {
							if (inst_1_1 && !inst_1_1.done && (_a = inst_1.return)) _a.call(inst_1);
						} finally {
							if (e_6) throw e_6.error;
						}
					}

					if ('failed' in ret && i !== inst.length - 1) {
						throw new MichelsonInstructionError(inst, ret, 'FAIL must appear in a tail position');
					}

					if ((ctx === null || ctx === void 0 ? void 0 : ctx.traceCallback) !== undefined) {
						var trace = {
							op: inst,
							in: stack,
							out: ret
						};
						ctx.traceCallback(trace);
					}

					return ret;
				}

				function functionTypeInternal(inst, stack, ctx) {
					var proto = (ctx === null || ctx === void 0 ? void 0 : ctx.protocol) || DefaultProtocol;

					if (Array.isArray(inst)) {
						return instructionListType(inst, stack, ctx);
					}

					var instruction = inst; // Make it const for type guarding
					// make sure the stack has enough number of arguments of specific types

					function args(n) {
						var e_7, _a;

						var typeIds = [];

						for (var _i = 1; _i < arguments.length; _i++) {
							typeIds[_i - 1] = arguments[_i];
						}

						if (stack.length < typeIds.length + n) {
							throw new MichelsonInstructionError(
								instruction,
								stack,
								instruction.prim + ': stack must have at least ' + typeIds.length + ' element(s)'
							);
						}

						var i = n;

						try {
							for (
								var typeIds_1 = __values(typeIds), typeIds_1_1 = typeIds_1.next();
								!typeIds_1_1.done;
								typeIds_1_1 = typeIds_1.next()
							) {
								var ids = typeIds_1_1.value;

								if (ids !== null && ids.length !== 0) {
									var ii = 0;

									while (ii < ids.length && ids[ii] !== typeID(stack[i])) {
										ii++;
									}

									if (ii === ids.length) {
										throw new MichelsonInstructionError(
											instruction,
											stack,
											instruction.prim +
												': stack type mismatch: [' +
												i +
												'] expected to be ' +
												ids +
												', got ' +
												typeID(stack[i]) +
												' instead'
										);
									}
								}

								i++;
							}
						} catch (e_7_1) {
							e_7 = {
								error: e_7_1
							};
						} finally {
							try {
								if (typeIds_1_1 && !typeIds_1_1.done && (_a = typeIds_1.return)) _a.call(typeIds_1);
							} finally {
								if (e_7) throw e_7.error;
							}
						}

						return stack.slice(n, typeIds.length + n);
					}

					function rethrow(fn) {
						return function () {
							var args = [];

							for (var _i = 0; _i < arguments.length; _i++) {
								args[_i] = arguments[_i];
							}

							try {
								return fn.apply(void 0, __spreadArray([], __read(args)));
							} catch (err) {
								if (err instanceof MichelsonError) {
									throw new MichelsonInstructionError(instruction, stack, err.message);
								} else {
									throw err;
								}
							}
						};
					}

					function rethrowTypeGuard(fn) {
						return function (arg) {
							try {
								return fn(arg);
							} catch (err) {
								if (err instanceof MichelsonError) {
									throw new MichelsonInstructionError(instruction, stack, err.message);
								} else {
									throw err;
								}
							}
						};
					}

					var argAnn = rethrow(unpackAnnotations);
					var ensureStacksEqual = rethrow(assertStacksEqual);
					var ensureTypesEqual = rethrow(assertScalarTypesEqual);
					var ensureComparableType = rethrowTypeGuard(assertMichelsonComparableType);
					var ensurePackableType = rethrowTypeGuard(assertMichelsonPackableType);
					var ensureStorableType = rethrowTypeGuard(assertMichelsonStorableType);
					var ensurePushableType = rethrowTypeGuard(assertMichelsonPushableType);
					var ensureBigMapStorableType = rethrowTypeGuard(assertMichelsonBigMapStorableType); // unpack instruction annotations and assert their maximum number

					function instructionAnn(num, opt) {
						var a = argAnn(
							instruction,
							__assign(__assign({}, opt), {
								emptyFields: num.f !== undefined && num.f > 1,
								emptyVar: num.v !== undefined && num.v > 1
							})
						);

						var assertNum = function (a, n, type) {
							if (a && a.length > (n || 0)) {
								throw new MichelsonInstructionError(
									instruction,
									stack,
									instruction.prim + ': at most ' + (n || 0) + ' ' + type + ' annotations allowed'
								);
							}
						};

						assertNum(a.f, num.f, 'field');
						assertNum(a.t, num.t, 'type');
						assertNum(a.v, num.v, 'variable');
						return a;
					} // also keeps annotation class if null is provided

					function annotate(tt, a) {
						var tx = tt;
						var t = Array.isArray(tx)
							? {
									prim: 'pair',
									args: tx
							  }
							: tx;
						var src = argAnn(t);
						var ann =
							a.v !== undefined || a.t !== undefined || a.f !== undefined
								? __spreadArray(
										__spreadArray(
											__spreadArray([], __read((a.v === null ? src.v : a.v) || [])),
											__read((a.t === null ? src.t : a.t) || [])
										),
										__read((a.f === null ? src.f : a.f) || [])
								  )
								: undefined;
						t.annots;

						var rest = __rest(t, ['annots']);

						return __assign(
							__assign({}, rest),
							ann &&
								ann.length !== 0 && {
									annots: ann
								}
						);
					} // shortcut to copy at most one variable annotation from the instruction to the type

					function annotateVar(t, def) {
						var ia = instructionAnn({
							v: 1
						});
						return annotate(t, {
							v: ia.v !== undefined ? ia.v : def !== undefined ? [def] : null,
							t: null
						});
					} // annotate CAR/CDR/UNPAIR/GET

					function annotateField(arg, field, insAnn, n, defField) {
						var _a, _b, _c, _d;

						var fieldAnn = (_a = argAnn(field).f) === null || _a === void 0 ? void 0 : _a[0]; // field's field annotation

						var insFieldAnn = (_b = insAnn.f) === null || _b === void 0 ? void 0 : _b[n];

						if (
							insFieldAnn !== undefined &&
							insFieldAnn !== '%' &&
							fieldAnn !== undefined &&
							insFieldAnn !== fieldAnn
						) {
							throw new MichelsonInstructionError(
								instruction,
								stack,
								instruction.prim +
									": field names doesn't match: " +
									insFieldAnn +
									' !== ' +
									fieldAnn
							);
						}

						var insVarAnn = (_c = insAnn.v) === null || _c === void 0 ? void 0 : _c[n]; // nth instruction's variable annotation

						var varAnn = (_d = argAnn(arg).v) === null || _d === void 0 ? void 0 : _d[0]; // instruction argument's variable annotation

						return annotate(field, {
							t: null,
							v: insVarAnn
								? insVarAnn === '@%'
									? fieldAnn
										? ['@' + fieldAnn.slice(1)]
										: undefined
									: insVarAnn === '@%%'
									? varAnn
										? ['@' + varAnn.slice(1) + '.' + (fieldAnn ? fieldAnn.slice(1) : defField)]
										: fieldAnn
										? ['@' + fieldAnn.slice(1)]
										: undefined
									: [insVarAnn]
								: null
						});
					} // comb helper functions

					function getN(src, n, i) {
						if (i === void 0) {
							i = n;
						}

						var p = unpackComb('pair', src);

						if (i === 1) {
							return [p.args[0]];
						} else if (i === 2) {
							return p.args;
						}

						var right = p.args[1];

						if (isPairType(right)) {
							return __spreadArray([p.args[0]], __read(getN(right, n, i - 1)));
						} else {
							throw new MichelsonInstructionError(
								instruction,
								stack,
								instruction.prim + ': at least ' + n + ' fields are expected'
							);
						}
					}

					function getNth(src, n, i) {
						if (i === void 0) {
							i = n;
						}

						if (i === 0) {
							return src;
						}

						var p = unpackComb('pair', src);

						if (i === 1) {
							return p.args[0];
						}

						var right = p.args[1];

						if (isPairType(right)) {
							return getNth(right, n, i - 2);
						} else if (i === 2) {
							return right;
						}

						throw new MichelsonInstructionError(
							instruction,
							stack,
							instruction.prim + ': at least ' + (n + 1) + ' fields are expected'
						);
					}

					function updateNth(src, x, n, i) {
						if (i === void 0) {
							i = n;
						}

						if (i === 0) {
							return x;
						}

						var p = unpackComb('pair', src);

						if (i === 1) {
							return __assign(__assign({}, p), {
								args: [x, p.args[1]]
							});
						}

						var right = p.args[1];

						if (isPairType(right)) {
							return __assign(__assign({}, p), {
								args: [p.args[0], updateNth(right, x, n, i - 2)]
							});
						} else if (i === 2) {
							return __assign(__assign({}, p), {
								args: [p.args[0], x]
							});
						}

						throw new MichelsonInstructionError(
							instruction,
							stack,
							instruction.prim + ': at least ' + (n + 1) + ' fields are expected'
						);
					}

					var varSuffix = function (a, suffix) {
						return ['@' + (a.v ? a.v[0].slice(1) + '.' : '') + suffix];
					};

					function branchType(br0, br1) {
						if ('failed' in br0 || 'failed' in br1) {
							// Might be useful for debugging
							if ('failed' in br0 && 'failed' in br1) {
								try {
									assertScalarTypesEqual(br0.failed, br1.failed);
									return br0;
								} catch (_a) {
									return {
										failed: {
											prim: 'or',
											args: [br0.failed, br1.failed]
										}
									};
								}
							} else {
								return 'failed' in br0 ? br1 : br0;
							}
						} else {
							ensureStacksEqual(br0, br1);
							return br0;
						}
					}

					var retStack = (function (instruction) {
						var _a, _b;

						var _c, _d, _e, _f, _g;

						switch (instruction.prim) {
							case 'DUP': {
								var n = instruction.args ? parseInt(instruction.args[0].int, 10) : 1;

								if (n === 0) {
									throw new MichelsonInstructionError(instruction, stack, 'DUP 0 is forbidden');
								}

								var s_1 = args(n - 1, null)[0];

								if (typeID(s_1) === 'ticket') {
									throw new MichelsonInstructionError(instruction, stack, "ticket can't be DUPed");
								}

								return __spreadArray([s_1], __read(stack));
							}

							case 'SWAP': {
								var s_2 = args(0, null, null);
								instructionAnn({});
								return __spreadArray([s_2[1], s_2[0]], __read(stack.slice(2)));
							}

							case 'SOME':
								return __spreadArray(
									[
										annotate(
											{
												prim: 'option',
												args: [args(0, null)[0]]
											},
											instructionAnn({
												t: 1,
												v: 1
											})
										)
									],
									__read(stack.slice(1))
								);

							case 'UNIT':
								return __spreadArray(
									[
										annotate(
											{
												prim: 'unit'
											},
											instructionAnn({
												v: 1,
												t: 1
											})
										)
									],
									__read(stack)
								);

							case 'PAIR': {
								var n = instruction.args ? parseInt(instruction.args[0].int, 10) : 2;

								if (n < 2) {
									throw new MichelsonInstructionError(
										instruction,
										stack,
										'PAIR ' + n + ' is forbidden'
									);
								}

								var s_3 = args.apply(void 0, __spreadArray([0], __read(new Array(n).fill(null))));
								var ia_1 = instructionAnn(
									{
										f: n,
										t: 1,
										v: 1
									},
									{
										specialFields: true
									}
								);

								var trim_1 = function (s) {
									var i = s.lastIndexOf('.');
									return s.slice(i > 0 ? i + 1 : 1);
								};

								var retArgs = s_3.map(function (v, i) {
									var _a;

									var va = argAnn(v);
									var f =
										ia_1.f && ia_1.f.length > i && ia_1.f[i] !== '%'
											? ia_1.f[i] === '%@'
												? va.v
													? [
															'%' +
																trim_1(
																	((_a = va.v) === null || _a === void 0 ? void 0 : _a[0]) || ''
																)
													  ]
													: undefined
												: [ia_1.f[i]]
											: undefined;
									return annotate(v, {
										v: null,
										t: null,
										f: f
									});
								});
								return __spreadArray(
									[
										annotate(
											{
												prim: 'pair',
												args: retArgs
											},
											{
												t: ia_1.t,
												v: ia_1.v
											}
										)
									],
									__read(stack.slice(n))
								);
							}

							case 'UNPAIR': {
								var n = instruction.args ? parseInt(instruction.args[0].int, 10) : 2;

								if (n < 2) {
									throw new MichelsonInstructionError(
										instruction,
										stack,
										'UNPAIR ' + n + ' is forbidden'
									);
								}

								var s_4 = args(0, ['pair'])[0];
								var ia_2 = instructionAnn(
									{
										f: 2,
										v: 2
									},
									{
										specialVar: true
									}
								);
								var fields = getN(s_4, n);
								return __spreadArray(
									__spreadArray(
										[],
										__read(
											fields.map(function (field, i) {
												return annotateField(s_4, field, ia_2, i, i === 0 ? 'car' : 'cdr');
											})
										)
									),
									__read(stack.slice(1))
								);
							}

							case 'CAR':
							case 'CDR': {
								var s_5 = unpackComb('pair', args(0, ['pair'])[0]);
								var field = s_5.args[instruction.prim === 'CAR' ? 0 : 1];
								var ia = instructionAnn(
									{
										f: 1,
										v: 1
									},
									{
										specialVar: true
									}
								);
								return __spreadArray(
									[annotateField(s_5, field, ia, 0, instruction.prim.toLocaleLowerCase())],
									__read(stack.slice(1))
								);
							}

							case 'CONS': {
								var s_6 = args(0, null, ['list']);
								ensureTypesEqual(s_6[0], s_6[1].args[0]);
								return __spreadArray(
									[
										annotateVar({
											prim: 'list',
											args: [s_6[1].args[0]]
										})
									],
									__read(stack.slice(2))
								);
							}

							case 'SIZE':
								args(0, ['string', 'list', 'set', 'map', 'bytes']);
								return __spreadArray(
									[
										annotateVar({
											prim: 'nat'
										})
									],
									__read(stack.slice(1))
								);

							case 'MEM': {
								var s_7 = args(0, null, ['set', 'map', 'big_map']);
								ensureComparableType(s_7[0]);
								ensureTypesEqual(s_7[0], s_7[1].args[0]);
								return __spreadArray(
									[
										annotateVar({
											prim: 'bool'
										})
									],
									__read(stack.slice(2))
								);
							}

							case 'GET':
								if (instruction.args) {
									// comb operation
									var n = parseInt(instruction.args[0].int, 10);
									var s_8 = args(0, ['pair'])[0];
									return __spreadArray([annotateVar(getNth(s_8, n))], __read(stack.slice(1)));
								} else {
									// map operation
									var s_9 = args(0, null, ['map', 'big_map']);
									ensureComparableType(s_9[0]);
									ensureTypesEqual(s_9[0], s_9[1].args[0]);
									return __spreadArray(
										[
											annotateVar({
												prim: 'option',
												args: [s_9[1].args[1]]
											})
										],
										__read(stack.slice(2))
									);
								}

							case 'UPDATE':
								if (instruction.args) {
									// comb operation
									var n = parseInt(instruction.args[0].int, 10);
									var s_10 = args(0, null, ['pair']);
									return __spreadArray(
										[annotateVar(updateNth(s_10[1], s_10[0], n))],
										__read(stack.slice(2))
									);
								} else {
									// map operation
									var s0 = args(0, null, ['bool', 'option']);
									ensureComparableType(s0[0]);

									if (s0[1].prim === 'bool') {
										var s1_1 = args(2, ['set']);
										ensureTypesEqual(s0[0], s1_1[0].args[0]);
										return __spreadArray(
											[
												annotateVar({
													prim: 'set',
													args: [
														annotate(s0[0], {
															t: null
														})
													]
												})
											],
											__read(stack.slice(3))
										);
									}

									var s1 = args(2, ['map', 'big_map']);
									ensureTypesEqual(s0[0], s1[0].args[0]);

									if (s1[0].prim === 'map') {
										return __spreadArray(
											[
												annotateVar({
													prim: 'map',
													args: [
														annotate(s0[0], {
															t: null
														}),
														annotate(s0[1].args[0], {
															t: null
														})
													]
												})
											],
											__read(stack.slice(3))
										);
									}

									ensureBigMapStorableType(s0[1].args[0]);
									return __spreadArray(
										[
											annotateVar({
												prim: 'big_map',
												args: [
													annotate(s0[0], {
														t: null
													}),
													annotate(s0[1].args[0], {
														t: null
													})
												]
											})
										],
										__read(stack.slice(3))
									);
								}

							case 'GET_AND_UPDATE': {
								var ia = instructionAnn({
									v: 2
								});
								var s_11 = args(0, null, ['option'], ['map', 'big_map']);
								ensureComparableType(s_11[0]);
								ensureTypesEqual(s_11[0], s_11[2].args[0]);
								ensureTypesEqual(s_11[1].args[0], s_11[2].args[1]);
								var va =
									(_c = ia.v) === null || _c === void 0
										? void 0
										: _c.map(function (v) {
												return v !== '@' ? [v] : undefined;
										  });

								if (s_11[2].prim === 'map') {
									return __spreadArray(
										[
											annotate(
												{
													prim: 'option',
													args: [s_11[2].args[1]]
												},
												{
													v: va === null || va === void 0 ? void 0 : va[0]
												}
											),
											annotate(
												{
													prim: 'map',
													args: [
														annotate(s_11[0], {
															t: null
														}),
														annotate(s_11[1].args[0], {
															t: null
														})
													]
												},
												{
													v: va === null || va === void 0 ? void 0 : va[1]
												}
											)
										],
										__read(stack.slice(3))
									);
								}

								ensureBigMapStorableType(s_11[1].args[0]);
								return __spreadArray(
									[
										annotate(
											{
												prim: 'option',
												args: [s_11[2].args[1]]
											},
											{
												v: va === null || va === void 0 ? void 0 : va[0]
											}
										),
										annotate(
											{
												prim: 'big_map',
												args: [
													annotate(s_11[0], {
														t: null
													}),
													annotate(s_11[1].args[0], {
														t: null
													})
												]
											},
											{
												v: va === null || va === void 0 ? void 0 : va[1]
											}
										)
									],
									__read(stack.slice(3))
								);
							}

							case 'EXEC': {
								var s_12 = args(0, null, ['lambda']);
								ensureTypesEqual(s_12[0], s_12[1].args[0]);
								return __spreadArray([annotateVar(s_12[1].args[1])], __read(stack.slice(2)));
							}

							case 'APPLY': {
								var s_13 = args(0, null, ['lambda']);
								ensureStorableType(s_13[0]);
								ensurePushableType(s_13[0]);

								if (!isPairType(s_13[1].args[0])) {
									throw new MichelsonInstructionError(
										instruction,
										stack,
										instruction.prim +
											": function's argument must be a pair: " +
											typeID(s_13[1].args[0])
									);
								}

								var pt = s_13[1].args[0];
								ensureTypesEqual(s_13[0], typeArgs(pt)[0]);
								return __spreadArray(
									[
										annotateVar({
											prim: 'lambda',
											args: [typeArgs(pt)[1], s_13[1].args[1]]
										})
									],
									__read(stack.slice(2))
								);
							}

							case 'FAILWITH': {
								var s_14 = args(0, null)[0];

								if (
									proto === Protocol.PtEdo2Zk ||
									proto === Protocol.PsFLorena ||
									proto === Protocol.PtGRANADs
								) {
									ensurePackableType(s_14);
								}

								return {
									failed: s_14
								};
							}

							case 'NEVER':
								args(0, ['never']);
								return {
									failed: {
										prim: 'never'
									}
								};

							case 'RENAME':
								return __spreadArray([annotateVar(args(0, null)[0])], __read(stack.slice(1)));

							case 'CONCAT': {
								var s0 = args(0, ['string', 'list', 'bytes']);

								if (s0[0].prim === 'list') {
									if (typeID(s0[0].args[0]) !== 'string' && typeID(s0[0].args[0]) !== 'bytes') {
										throw new MichelsonInstructionError(
											instruction,
											stack,
											instruction.prim +
												": can't concatenate list of " +
												typeID(s0[0].args[0]) +
												"'s"
										);
									}

									return __spreadArray([annotateVar(s0[0].args[0])], __read(stack.slice(1)));
								}

								var s1 = args(1, ['string', 'bytes']);

								if (s0[0].prim !== s1[0].prim) {
									throw new MichelsonInstructionError(
										instruction,
										stack,
										instruction.prim + ": can't concatenate " + s0[0].prim + ' with ' + s1[0].prim
									);
								}

								return __spreadArray([annotateVar(s1[0])], __read(stack.slice(2)));
							}

							case 'SLICE':
								return __spreadArray(
									[
										annotateVar(
											{
												prim: 'option',
												args: [args(0, ['nat'], ['nat'], ['string', 'bytes'])[2]]
											},
											'@slice'
										)
									],
									__read(stack.slice(3))
								);

							case 'PACK': {
								var s_15 = args(0, null)[0];
								ensurePackableType(s_15);
								return __spreadArray(
									[
										annotateVar(
											{
												prim: 'bytes'
											},
											'@packed'
										)
									],
									__read(stack.slice(1))
								);
							}

							case 'ADD': {
								var s_16 = args(
									0,
									[
										'nat',
										'int',
										'timestamp',
										'mutez',
										'bls12_381_g1',
										'bls12_381_g2',
										'bls12_381_fr'
									],
									[
										'nat',
										'int',
										'timestamp',
										'mutez',
										'bls12_381_g1',
										'bls12_381_g2',
										'bls12_381_fr'
									]
								);

								if (
									(s_16[0].prim === 'nat' && s_16[1].prim === 'int') ||
									(s_16[0].prim === 'int' && s_16[1].prim === 'nat')
								) {
									return __spreadArray(
										[
											annotateVar({
												prim: 'int'
											})
										],
										__read(stack.slice(2))
									);
								} else if (
									(s_16[0].prim === 'int' && s_16[1].prim === 'timestamp') ||
									(s_16[0].prim === 'timestamp' && s_16[1].prim === 'int')
								) {
									return __spreadArray(
										[
											annotateVar({
												prim: 'timestamp'
											})
										],
										__read(stack.slice(2))
									);
								} else if (
									(s_16[0].prim === 'int' ||
										s_16[0].prim === 'nat' ||
										s_16[0].prim === 'mutez' ||
										s_16[0].prim === 'bls12_381_g1' ||
										s_16[0].prim === 'bls12_381_g2' ||
										s_16[0].prim === 'bls12_381_fr') &&
									s_16[0].prim === s_16[1].prim
								) {
									return __spreadArray([annotateVar(s_16[0])], __read(stack.slice(2)));
								}

								throw new MichelsonInstructionError(
									instruction,
									stack,
									instruction.prim + ": can't add " + s_16[0].prim + ' to ' + s_16[1].prim
								);
							}

							case 'SUB': {
								var s_17 = args(
									0,
									['nat', 'int', 'timestamp', 'mutez'],
									['nat', 'int', 'timestamp', 'mutez']
								);

								if (
									((s_17[0].prim === 'nat' || s_17[0].prim === 'int') &&
										(s_17[1].prim === 'nat' || s_17[1].prim === 'int')) ||
									(s_17[0].prim === 'timestamp' && s_17[1].prim === 'timestamp')
								) {
									return __spreadArray(
										[
											annotateVar({
												prim: 'int'
											})
										],
										__read(stack.slice(2))
									);
								} else if (s_17[0].prim === 'timestamp' && s_17[1].prim === 'int') {
									return __spreadArray(
										[
											annotateVar({
												prim: 'timestamp'
											})
										],
										__read(stack.slice(2))
									);
								} else if (s_17[0].prim === 'mutez' && s_17[1].prim === 'mutez') {
									return __spreadArray(
										[
											annotateVar({
												prim: 'mutez'
											})
										],
										__read(stack.slice(2))
									);
								}

								throw new MichelsonInstructionError(
									instruction,
									stack,
									instruction.prim + ": can't subtract " + s_17[0].prim + ' from ' + s_17[1].prim
								);
							}

							case 'MUL': {
								var s_18 = args(
									0,
									['nat', 'int', 'mutez', 'bls12_381_g1', 'bls12_381_g2', 'bls12_381_fr'],
									['nat', 'int', 'mutez', 'bls12_381_g1', 'bls12_381_g2', 'bls12_381_fr']
								);

								if (
									(s_18[0].prim === 'nat' && s_18[1].prim === 'int') ||
									(s_18[0].prim === 'int' && s_18[1].prim === 'nat')
								) {
									return __spreadArray(
										[
											annotateVar({
												prim: 'int'
											})
										],
										__read(stack.slice(2))
									);
								} else if (
									(s_18[0].prim === 'nat' && s_18[1].prim === 'mutez') ||
									(s_18[0].prim === 'mutez' && s_18[1].prim === 'nat')
								) {
									return __spreadArray(
										[
											annotateVar({
												prim: 'mutez'
											})
										],
										__read(stack.slice(2))
									);
								} else if (
									((s_18[0].prim === 'bls12_381_g1' ||
										s_18[0].prim === 'bls12_381_g2' ||
										s_18[0].prim === 'bls12_381_fr') &&
										s_18[1].prim === 'bls12_381_fr') ||
									((s_18[0].prim === 'nat' || s_18[0].prim === 'int') &&
										s_18[0].prim === s_18[1].prim)
								) {
									return __spreadArray([annotateVar(s_18[0])], __read(stack.slice(2)));
								} else if (
									((s_18[0].prim === 'nat' || s_18[0].prim === 'int') &&
										s_18[1].prim === 'bls12_381_fr') ||
									((s_18[1].prim === 'nat' || s_18[1].prim === 'int') &&
										s_18[0].prim === 'bls12_381_fr')
								) {
									return __spreadArray(
										[
											annotateVar({
												prim: 'bls12_381_fr'
											})
										],
										__read(stack.slice(2))
									);
								}

								throw new MichelsonInstructionError(
									instruction,
									stack,
									instruction.prim + ": can't multiply " + s_18[0].prim + ' by ' + s_18[1].prim
								);
							}

							case 'EDIV': {
								var res = function (a, b) {
									return {
										prim: 'option',
										args: [
											{
												prim: 'pair',
												args: [
													{
														prim: a
													},
													{
														prim: b
													}
												]
											}
										]
									};
								};

								var s_19 = args(0, ['nat', 'int', 'mutez'], ['nat', 'int', 'mutez']);

								if (s_19[0].prim === 'nat' && s_19[1].prim === 'nat') {
									return __spreadArray([annotateVar(res('nat', 'nat'))], __read(stack.slice(2)));
								} else if (
									(s_19[0].prim === 'nat' || s_19[0].prim === 'int') &&
									(s_19[1].prim === 'nat' || s_19[1].prim === 'int')
								) {
									return __spreadArray([annotateVar(res('int', 'nat'))], __read(stack.slice(2)));
								} else if (s_19[0].prim === 'mutez' && s_19[1].prim === 'nat') {
									return __spreadArray(
										[annotateVar(res('mutez', 'mutez'))],
										__read(stack.slice(2))
									);
								} else if (s_19[0].prim === 'mutez' && s_19[1].prim === 'mutez') {
									return __spreadArray([annotateVar(res('nat', 'mutez'))], __read(stack.slice(2)));
								}

								throw new MichelsonInstructionError(
									instruction,
									stack,
									instruction.prim +
										": can't euclideally divide " +
										s_19[0].prim +
										' by ' +
										s_19[1].prim
								);
							}

							case 'ABS':
								args(0, ['int']);
								return __spreadArray(
									[
										annotateVar({
											prim: 'nat'
										})
									],
									__read(stack.slice(1))
								);

							case 'ISNAT':
								args(0, ['int']);
								return __spreadArray(
									[
										annotateVar({
											prim: 'option',
											args: [
												{
													prim: 'nat'
												}
											]
										})
									],
									__read(stack.slice(1))
								);

							case 'INT':
								args(0, ['nat', 'bls12_381_fr']);
								return __spreadArray(
									[
										annotateVar({
											prim: 'int'
										})
									],
									__read(stack.slice(1))
								);

							case 'NEG': {
								var s_20 = args(0, [
									'nat',
									'int',
									'bls12_381_g1',
									'bls12_381_g2',
									'bls12_381_fr'
								])[0];

								if (s_20.prim === 'nat' || s_20.prim === 'int') {
									return __spreadArray(
										[
											annotateVar({
												prim: 'int'
											})
										],
										__read(stack.slice(1))
									);
								}

								return __spreadArray([annotateVar(s_20)], __read(stack.slice(1)));
							}

							case 'LSL':
							case 'LSR':
								args(0, ['nat'], ['nat']);
								return __spreadArray(
									[
										annotateVar({
											prim: 'nat'
										})
									],
									__read(stack.slice(2))
								);

							case 'OR':
							case 'XOR': {
								var s_21 = args(0, ['nat', 'bool'], ['nat', 'bool']);

								if (s_21[0].prim !== s_21[1].prim) {
									throw new MichelsonInstructionError(
										instruction,
										stack,
										instruction.prim +
											': both arguments must be of the same type: ' +
											s_21[0].prim +
											', ' +
											s_21[1].prim
									);
								}

								return __spreadArray([annotateVar(s_21[1])], __read(stack.slice(2)));
							}

							case 'AND': {
								var s_22 = args(0, ['nat', 'bool', 'int'], ['nat', 'bool']);

								if (
									(s_22[0].prim !== 'int' || s_22[1].prim !== 'nat') &&
									s_22[0].prim !== s_22[1].prim
								) {
									throw new MichelsonInstructionError(
										instruction,
										stack,
										instruction.prim +
											': both arguments must be of the same type: ' +
											s_22[0].prim +
											', ' +
											s_22[1].prim
									);
								}

								return __spreadArray([annotateVar(s_22[1])], __read(stack.slice(2)));
							}

							case 'NOT': {
								var s_23 = args(0, ['nat', 'bool', 'int'])[0];

								if (s_23.prim === 'bool') {
									return __spreadArray(
										[
											annotateVar({
												prim: 'bool'
											})
										],
										__read(stack.slice(1))
									);
								}

								return __spreadArray(
									[
										annotateVar({
											prim: 'int'
										})
									],
									__read(stack.slice(1))
								);
							}

							case 'COMPARE': {
								var s_24 = args(0, null, null);
								ensureComparableType(s_24[0]);
								ensureComparableType(s_24[1]);
								return __spreadArray(
									[
										annotateVar({
											prim: 'int'
										})
									],
									__read(stack.slice(2))
								);
							}

							case 'EQ':
							case 'NEQ':
							case 'LT':
							case 'GT':
							case 'LE':
							case 'GE':
								args(0, ['int']);
								return __spreadArray(
									[
										annotateVar({
											prim: 'bool'
										})
									],
									__read(stack.slice(1))
								);

							case 'SELF': {
								if ((ctx === null || ctx === void 0 ? void 0 : ctx.contract) === undefined) {
									throw new MichelsonInstructionError(
										instruction,
										stack,
										instruction.prim + ': contract required'
									);
								}

								var ia = instructionAnn({
									f: 1,
									v: 1
								});
								var ep = contractEntryPoint(
									ctx.contract,
									(_d = ia.f) === null || _d === void 0 ? void 0 : _d[0]
								);

								if (ep === null) {
									throw new MichelsonInstructionError(
										instruction,
										stack,
										instruction.prim + ': contract has no entrypoint ' + ep
									);
								}

								return __spreadArray(
									[
										annotate(
											{
												prim: 'contract',
												args: [ep]
											},
											{
												v: ia.v ? ia.v : ['@self']
											}
										)
									],
									__read(stack)
								);
							}

							case 'TRANSFER_TOKENS': {
								var s_25 = args(0, null, ['mutez'], ['contract']);
								ensureTypesEqual(s_25[0], s_25[2].args[0]);
								return __spreadArray(
									[
										annotateVar({
											prim: 'operation'
										})
									],
									__read(stack.slice(3))
								);
							}

							case 'SET_DELEGATE': {
								var s_26 = args(0, ['option'])[0];

								if (typeID(s_26.args[0]) !== 'key_hash') {
									throw new MichelsonInstructionError(
										instruction,
										stack,
										instruction.prim + ': key hash expected: ' + typeID(s_26.args[0])
									);
								}

								return __spreadArray(
									[
										annotateVar({
											prim: 'operation'
										})
									],
									__read(stack.slice(1))
								);
							}

							case 'IMPLICIT_ACCOUNT':
								args(0, ['key_hash']);
								return __spreadArray(
									[
										annotateVar({
											prim: 'contract',
											args: [
												{
													prim: 'unit'
												}
											]
										})
									],
									__read(stack.slice(1))
								);

							case 'NOW':
								return __spreadArray(
									[
										annotateVar(
											{
												prim: 'timestamp'
											},
											'@now'
										)
									],
									__read(stack)
								);

							case 'AMOUNT':
								return __spreadArray(
									[
										annotateVar(
											{
												prim: 'mutez'
											},
											'@amount'
										)
									],
									__read(stack)
								);

							case 'BALANCE':
								return __spreadArray(
									[
										annotateVar(
											{
												prim: 'mutez'
											},
											'@balance'
										)
									],
									__read(stack)
								);

							case 'CHECK_SIGNATURE':
								args(0, ['key'], ['signature'], ['bytes']);
								return __spreadArray(
									[
										annotateVar({
											prim: 'bool'
										})
									],
									__read(stack.slice(3))
								);

							case 'BLAKE2B':
							case 'SHA256':
							case 'SHA512':
							case 'KECCAK':
							case 'SHA3':
								args(0, ['bytes']);
								return __spreadArray(
									[
										annotateVar({
											prim: 'bytes'
										})
									],
									__read(stack.slice(1))
								);

							case 'HASH_KEY':
								args(0, ['key']);
								return __spreadArray(
									[
										annotateVar({
											prim: 'key_hash'
										})
									],
									__read(stack.slice(1))
								);

							case 'SOURCE':
								return __spreadArray(
									[
										annotateVar(
											{
												prim: 'address'
											},
											'@source'
										)
									],
									__read(stack)
								);

							case 'SENDER':
								return __spreadArray(
									[
										annotateVar(
											{
												prim: 'address'
											},
											'@sender'
										)
									],
									__read(stack)
								);

							case 'ADDRESS': {
								var s_27 = args(0, ['contract'])[0];
								var ia = instructionAnn({
									v: 1
								});
								return __spreadArray(
									[
										annotate(
											((_a = {
												prim: 'address'
											}),
											(_a[refContract] = s_27),
											_a),
											{
												v: ia.v ? ia.v : varSuffix(argAnn(s_27), 'address')
											}
										)
									],
									__read(stack.slice(1))
								);
							}

							case 'SELF_ADDRESS': {
								var addr = {
									prim: 'address'
								};

								if ((ctx === null || ctx === void 0 ? void 0 : ctx.contract) !== undefined) {
									addr[refContract] = {
										prim: 'contract',
										args: [contractSection(ctx.contract, 'parameter').args[0]]
									};
								}

								return __spreadArray([annotateVar(addr, '@address')], __read(stack));
							}

							case 'CHAIN_ID':
								return __spreadArray(
									[
										annotateVar({
											prim: 'chain_id'
										})
									],
									__read(stack)
								);

							case 'DROP': {
								instructionAnn({});
								var n = instruction.args !== undefined ? parseInt(instruction.args[0].int, 10) : 1;
								args(n - 1, null);
								return stack.slice(n);
							}

							case 'DIG': {
								instructionAnn({});
								var n = parseInt(instruction.args[0].int, 10);
								return __spreadArray(
									__spreadArray([args(n, null)[0]], __read(stack.slice(0, n))),
									__read(stack.slice(n + 1))
								);
							}

							case 'DUG': {
								instructionAnn({});
								var n = parseInt(instruction.args[0].int, 10);
								return __spreadArray(
									__spreadArray(__spreadArray([], __read(stack.slice(1, n + 1))), [
										args(0, null)[0]
									]),
									__read(stack.slice(n + 1))
								);
							}

							case 'NONE':
								assertTypeAnnotationsValid(instruction.args[0]);
								return __spreadArray(
									[
										annotate(
											{
												prim: 'option',
												args: [instruction.args[0]]
											},
											instructionAnn({
												t: 1,
												v: 1
											})
										)
									],
									__read(stack)
								);

							case 'LEFT':
							case 'RIGHT': {
								var s_28 = args(0, null)[0];
								var ia = instructionAnn(
									{
										f: 2,
										t: 1,
										v: 1
									},
									{
										specialFields: true
									}
								);
								var va = argAnn(s_28);
								var children = [
									annotate(s_28, {
										t: null,
										v: null,
										f:
											ia.f && ia.f.length > 0 && ia.f[0] !== '%'
												? ia.f[0] === '%@'
													? va.v
														? ['%' + va.v[0].slice(1)]
														: undefined
													: ia.f
												: undefined
									}),
									annotate(instruction.args[0], {
										t: null,
										f: ia.f && ia.f.length > 1 && ia.f[1] !== '%' ? ia.f : undefined
									})
								];
								return __spreadArray(
									[
										annotate(
											{
												prim: 'or',
												args: instruction.prim === 'LEFT' ? children : [children[1], children[0]]
											},
											{
												t: ia.t,
												v: ia.v
											}
										)
									],
									__read(stack.slice(1))
								);
							}

							case 'NIL':
								assertTypeAnnotationsValid(instruction.args[0]);
								return __spreadArray(
									[
										annotate(
											{
												prim: 'list',
												args: [instruction.args[0]]
											},
											instructionAnn({
												t: 1,
												v: 1
											})
										)
									],
									__read(stack)
								);

							case 'UNPACK':
								args(0, ['bytes']);
								assertTypeAnnotationsValid(instruction.args[0]);
								return __spreadArray(
									[
										annotateVar(
											{
												prim: 'option',
												args: [instruction.args[0]]
											},
											'@unpacked'
										)
									],
									__read(stack.slice(1))
								);

							case 'CONTRACT': {
								var s_29 = args(0, ['address'])[0];
								assertTypeAnnotationsValid(instruction.args[0]);
								var ia = instructionAnn({
									v: 1,
									f: 1
								});
								var contract = s_29[refContract];

								if (contract !== undefined) {
									var ep = contractEntryPoint(
										contract,
										(_e = ia.f) === null || _e === void 0 ? void 0 : _e[0]
									);

									if (ep === null) {
										throw new MichelsonInstructionError(
											instruction,
											stack,
											instruction.prim + ': contract has no entrypoint ' + ep
										);
									}

									ensureTypesEqual(ep, instruction.args[0]);
								}

								return __spreadArray(
									[
										annotate(
											{
												prim: 'option',
												args: [
													{
														prim: 'contract',
														args: [instruction.args[0]]
													}
												]
											},
											{
												v: ia.v ? ia.v : varSuffix(argAnn(s_29), 'contract')
											}
										)
									],
									__read(stack.slice(1))
								);
							}

							case 'CAST':
								instructionAnn({});
								var s = args(0, null)[0];
								assertTypeAnnotationsValid(instruction.args[0]);
								ensureTypesEqual(instruction.args[0], s);
								return __spreadArray([instruction.args[0]], __read(stack.slice(1)));

							case 'IF_NONE': {
								instructionAnn({});
								var s_30 = args(0, ['option'])[0];
								var tail = stack.slice(1);
								var br0 = functionTypeInternal(instruction.args[0], tail, ctx);
								var br1 = functionTypeInternal(
									instruction.args[1],
									__spreadArray(
										[
											annotate(s_30.args[0], {
												t: null,
												v: varSuffix(argAnn(s_30), 'some')
											})
										],
										__read(tail)
									),
									ctx
								);
								return branchType(br0, br1);
							}

							case 'IF_LEFT': {
								instructionAnn({});
								var s_31 = args(0, ['or'])[0];
								var va = argAnn(s_31);
								var lefta = argAnn(s_31.args[0]);
								var righta = argAnn(s_31.args[1]);
								var tail = stack.slice(1);
								var br0 = functionTypeInternal(
									instruction.args[0],
									__spreadArray(
										[
											annotate(s_31.args[0], {
												t: null,
												v: varSuffix(va, lefta.f ? lefta.f[0].slice(1) : 'left')
											})
										],
										__read(tail)
									),
									ctx
								);
								var br1 = functionTypeInternal(
									instruction.args[1],
									__spreadArray(
										[
											annotate(s_31.args[1], {
												t: null,
												v: varSuffix(va, righta.f ? righta.f[0].slice(1) : 'right')
											})
										],
										__read(tail)
									),
									ctx
								);
								return branchType(br0, br1);
							}

							case 'IF_CONS': {
								instructionAnn({});
								var s_32 = args(0, ['list'])[0];
								var va = argAnn(s_32);
								var tail = stack.slice(1);
								var br0 = functionTypeInternal(
									instruction.args[0],
									__spreadArray(
										[
											annotate(s_32.args[0], {
												t: null,
												v: varSuffix(va, 'hd')
											}),
											annotate(s_32, {
												t: null,
												v: varSuffix(va, 'tl')
											})
										],
										__read(tail)
									),
									ctx
								);
								var br1 = functionTypeInternal(instruction.args[1], tail, ctx);
								return branchType(br0, br1);
							}

							case 'IF': {
								instructionAnn({});
								args(0, ['bool']);
								var tail = stack.slice(1);
								var br0 = functionTypeInternal(instruction.args[0], tail, ctx);
								var br1 = functionTypeInternal(instruction.args[1], tail, ctx);
								return branchType(br0, br1);
							}

							case 'MAP': {
								var s_33 = args(0, ['list', 'map'])[0];
								var tail = stack.slice(1);
								var elt =
									s_33.prim === 'map'
										? {
												prim: 'pair',
												args: s_33.args
										  }
										: s_33.args[0];
								var body = functionTypeInternal(
									instruction.args[0],
									__spreadArray(
										[
											annotate(elt, {
												t: null,
												v: varSuffix(argAnn(s_33), 'elt')
											})
										],
										__read(tail)
									),
									ctx
								);

								if ('failed' in body) {
									return body;
								}

								if (body.length < 1) {
									throw new MichelsonInstructionError(
										instruction,
										stack,
										instruction.prim + ': function must return a value'
									);
								}

								ensureStacksEqual(body.slice(1), tail);

								if (s_33.prim === 'list') {
									return __spreadArray(
										[
											annotateVar({
												prim: 'list',
												args: [body[0]]
											})
										],
										__read(tail)
									);
								}

								return __spreadArray(
									[
										annotateVar({
											prim: 'map',
											args: [s_33.args[0], body[0]]
										})
									],
									__read(tail)
								);
							}

							case 'ITER': {
								instructionAnn({});
								var s_34 = args(0, ['set', 'list', 'map'])[0];
								var tail = stack.slice(1);
								var elt =
									s_34.prim === 'map'
										? {
												prim: 'pair',
												args: s_34.args
										  }
										: s_34.args[0];
								var body = functionTypeInternal(
									instruction.args[0],
									__spreadArray(
										[
											annotate(elt, {
												t: null,
												v: varSuffix(argAnn(s_34), 'elt')
											})
										],
										__read(tail)
									),
									ctx
								);

								if ('failed' in body) {
									return body;
								}

								ensureStacksEqual(body, tail);
								return tail;
							}

							case 'LOOP': {
								instructionAnn({});
								args(0, ['bool']);
								var tail = stack.slice(1);
								var body = functionTypeInternal(instruction.args[0], tail, ctx);

								if ('failed' in body) {
									return body;
								}

								ensureStacksEqual(
									body,
									__spreadArray(
										[
											{
												prim: 'bool'
											}
										],
										__read(tail)
									)
								);
								return tail;
							}

							case 'LOOP_LEFT': {
								instructionAnn({});
								var s_35 = args(0, ['or'])[0];
								var tail = stack.slice(1);
								var body = functionTypeInternal(
									instruction.args[0],
									__spreadArray(
										[
											annotate(s_35.args[0], {
												t: null,
												v: varSuffix(argAnn(s_35), 'left')
											})
										],
										__read(tail)
									),
									ctx
								);

								if ('failed' in body) {
									return body;
								}

								ensureStacksEqual(body, __spreadArray([s_35], __read(tail)));
								return __spreadArray(
									[
										annotate(s_35.args[1], {
											t: null,
											v: instructionAnn({
												v: 1
											}).v
										})
									],
									__read(tail)
								);
							}

							case 'DIP': {
								instructionAnn({});
								var n = instruction.args.length === 2 ? parseInt(instruction.args[0].int, 10) : 1;
								args(n - 1, null);
								var head = stack.slice(0, n);
								var tail = stack.slice(n); // ternary operator is a type guard so use it instead of just `instruction.args.length - 1`

								var body =
									instruction.args.length === 2
										? functionTypeInternal(instruction.args[1], tail, ctx)
										: functionTypeInternal(instruction.args[0], tail, ctx);

								if ('failed' in body) {
									return body;
								}

								return __spreadArray(__spreadArray([], __read(head)), __read(body));
							}

							case 'CREATE_CONTRACT': {
								var ia = instructionAnn({
									v: 2
								});
								var s_36 = args(0, ['option'], ['mutez'], null);

								if (typeID(s_36[0].args[0]) !== 'key_hash') {
									throw new MichelsonInstructionError(
										instruction,
										stack,
										instruction.prim + ': key hash expected: ' + typeID(s_36[0].args[0])
									);
								}

								if (ensureStorableType(s_36[2])) {
									assertContractValid(instruction.args[0]);
									assertScalarTypesEqual(
										contractSection(instruction.args[0], 'storage').args[0],
										s_36[2]
									);
								}

								var va =
									(_f = ia.v) === null || _f === void 0
										? void 0
										: _f.map(function (v) {
												return v !== '@' ? [v] : undefined;
										  });
								return __spreadArray(
									[
										annotate(
											{
												prim: 'operation'
											},
											{
												v: va === null || va === void 0 ? void 0 : va[0]
											}
										),
										annotate(
											((_b = {
												prim: 'address'
											}),
											(_b[refContract] = {
												prim: 'contract',
												args: [contractSection(instruction.args[0], 'parameter').args[0]]
											}),
											_b),
											{
												v: va === null || va === void 0 ? void 0 : va[1]
											}
										)
									],
									__read(stack.slice(3))
								);
							}

							case 'PUSH':
								assertTypeAnnotationsValid(instruction.args[0]);
								assertDataValidInternal(
									instruction.args[1],
									instruction.args[0],
									__assign(__assign({}, ctx), {
										contract: undefined
									})
								);
								return __spreadArray([annotateVar(instruction.args[0])], __read(stack));

							case 'EMPTY_SET':
								assertTypeAnnotationsValid(instruction.args[0]);
								ensureComparableType(instruction.args[0]);
								return __spreadArray(
									[
										annotate(
											{
												prim: 'set',
												args: instruction.args
											},
											instructionAnn({
												t: 1,
												v: 1
											})
										)
									],
									__read(stack)
								);

							case 'EMPTY_MAP':
								assertTypeAnnotationsValid(instruction.args[0]);
								ensureComparableType(instruction.args[0]);
								assertTypeAnnotationsValid(instruction.args[1]);
								return __spreadArray(
									[
										annotate(
											{
												prim: 'map',
												args: instruction.args
											},
											instructionAnn({
												t: 1,
												v: 1
											})
										)
									],
									__read(stack)
								);

							case 'EMPTY_BIG_MAP':
								assertTypeAnnotationsValid(instruction.args[0]);
								ensureComparableType(instruction.args[0]);
								assertTypeAnnotationsValid(instruction.args[1]);
								ensureBigMapStorableType(instruction.args[0]);
								return __spreadArray(
									[
										annotate(
											{
												prim: 'big_map',
												args: instruction.args
											},
											instructionAnn({
												t: 1,
												v: 1
											})
										)
									],
									__read(stack)
								);

							case 'LAMBDA': {
								assertTypeAnnotationsValid(instruction.args[0]);
								assertTypeAnnotationsValid(instruction.args[1]);
								var body = functionTypeInternal(
									instruction.args[2],
									[instruction.args[0]],
									__assign(__assign({}, ctx), {
										contract: undefined
									})
								);

								if ('failed' in body) {
									return body;
								}

								if (body.length !== 1) {
									throw new MichelsonInstructionError(
										instruction,
										stack,
										instruction.prim + ': function must return a value'
									);
								}

								ensureTypesEqual(instruction.args[1], body[0]);
								return __spreadArray(
									[
										annotateVar({
											prim: 'lambda',
											args: [instruction.args[0], instruction.args[1]]
										})
									],
									__read(stack)
								);
							}

							case 'LEVEL':
								return __spreadArray(
									[
										annotateVar(
											{
												prim: 'nat'
											},
											'@level'
										)
									],
									__read(stack)
								);

							case 'TOTAL_VOTING_POWER':
								return __spreadArray(
									[
										annotateVar({
											prim: 'nat'
										})
									],
									__read(stack)
								);

							case 'VOTING_POWER':
								args(0, ['key_hash']);
								return __spreadArray(
									[
										annotateVar({
											prim: 'nat'
										})
									],
									__read(stack.slice(1))
								);

							case 'TICKET': {
								var s_37 = args(0, null, ['nat'])[0];
								ensureComparableType(s_37);
								return __spreadArray(
									[
										annotate(
											{
												prim: 'ticket',
												args: [s_37]
											},
											instructionAnn({
												t: 1,
												v: 1
											})
										)
									],
									__read(stack.slice(2))
								);
							}

							case 'JOIN_TICKETS': {
								var s_38 = unpackComb('pair', args(0, ['pair'])[0]);

								if (typeID(s_38.args[0]) !== 'ticket') {
									throw new MichelsonInstructionError(
										instruction,
										stack,
										instruction.prim + ': ticket expected: ' + typeID(s_38.args[0])
									);
								}

								ensureTypesEqual(s_38.args[0], s_38.args[1]);
								return __spreadArray(
									[
										annotateVar({
											prim: 'option',
											args: [
												annotate(s_38.args[0], {
													t: null
												})
											]
										})
									],
									__read(stack.slice(1))
								);
							}

							case 'SPLIT_TICKET': {
								var s_39 = args(0, ['ticket'], ['pair']);
								var p = unpackComb('pair', s_39[1]);

								if (typeID(p.args[0]) !== 'nat') {
									throw new MichelsonInstructionError(
										instruction,
										stack,
										instruction.prim + ': nat expected: ' + typeID(p.args[0])
									);
								}

								ensureTypesEqual(p.args[0], p.args[1]);
								return __spreadArray(
									[
										annotateVar({
											prim: 'option',
											args: [
												{
													prim: 'pair',
													args: [
														annotate(s_39[0], {
															t: null
														}),
														annotate(s_39[0], {
															t: null
														})
													]
												}
											]
										})
									],
									__read(stack.slice(2))
								);
							}

							case 'READ_TICKET': {
								var ia = instructionAnn({
									v: 2
								});
								var s_40 = args(0, ['ticket'])[0];
								var va =
									(_g = ia.v) === null || _g === void 0
										? void 0
										: _g.map(function (v) {
												return v !== '@' ? [v] : undefined;
										  });
								return __spreadArray(
									[
										annotate(
											{
												prim: 'pair',
												args: [
													{
														prim: 'address'
													},
													annotate(s_40.args[0], {
														t: null
													}),
													{
														prim: 'nat'
													}
												]
											},
											{
												v: va === null || va === void 0 ? void 0 : va[0]
											}
										),
										annotate(s_40, {
											v: va === null || va === void 0 ? void 0 : va[1],
											t: null
										})
									],
									__read(stack.slice(1))
								);
							}

							case 'PAIRING_CHECK': {
								var p = args(0, ['list'])[0].args[0];

								if (!isPairType(p)) {
									throw new MichelsonInstructionError(
										instruction,
										stack,
										instruction.prim + ': pair expected: ' + typeID(p)
									);
								}

								var c = unpackComb('pair', p);

								if (typeID(c.args[0]) !== 'bls12_381_g1') {
									throw new MichelsonInstructionError(
										instruction,
										stack,
										instruction.prim + ': bls12_381_g1 expected: ' + typeID(c.args[0])
									);
								}

								if (typeID(c.args[1]) !== 'bls12_381_g2') {
									throw new MichelsonInstructionError(
										instruction,
										stack,
										instruction.prim + ': bls12_381_g2 expected: ' + typeID(c.args[1])
									);
								}

								return __spreadArray(
									[
										annotateVar({
											prim: 'bool'
										})
									],
									__read(stack.slice(1))
								);
							}

							case 'SAPLING_EMPTY_STATE':
								return __spreadArray(
									[
										annotate(
											{
												prim: 'sapling_state',
												args: [instruction.args[0]]
											},
											instructionAnn({
												v: 1,
												t: 1
											})
										)
									],
									__read(stack)
								);

							case 'SAPLING_VERIFY_UPDATE': {
								var s_41 = args(0, ['sapling_transaction'], ['sapling_state']);

								if (parseInt(s_41[0].args[0].int, 10) !== parseInt(s_41[1].args[0].int, 10)) {
									throw new MichelsonInstructionError(
										instruction,
										stack,
										instruction.prim +
											': sapling memo size mismatch: ' +
											s_41[0].args[0].int +
											' != ' +
											s_41[1].args[0].int
									);
								}

								return __spreadArray(
									[
										annotateVar({
											prim: 'option',
											args: [
												{
													prim: 'pair',
													args: [
														{
															prim: 'int'
														},
														annotate(s_41[1], {
															t: null
														})
													]
												}
											]
										})
									],
									__read(stack.slice(2))
								);
							}

							default:
								throw new MichelsonError(
									instruction,
									'unexpected instruction: ' + instruction.prim
								);
						}
					})(instruction);

					if ((ctx === null || ctx === void 0 ? void 0 : ctx.traceCallback) !== undefined) {
						var trace = {
							op: instruction,
							in: stack,
							out: retStack
						};
						ctx.traceCallback(trace);
					}

					return retStack;
				}

				function contractSection(contract, section) {
					var e_8, _a;

					try {
						for (
							var contract_1 = __values(contract), contract_1_1 = contract_1.next();
							!contract_1_1.done;
							contract_1_1 = contract_1.next()
						) {
							var s = contract_1_1.value;

							if (s.prim === section) {
								return s;
							}
						}
					} catch (e_8_1) {
						e_8 = {
							error: e_8_1
						};
					} finally {
						try {
							if (contract_1_1 && !contract_1_1.done && (_a = contract_1.return))
								_a.call(contract_1);
						} finally {
							if (e_8) throw e_8.error;
						}
					}

					throw new MichelsonError(contract, 'missing contract section: ' + section);
				}

				function isContract(v) {
					var e_9, _a;

					if (Array.isArray(v)) {
						try {
							for (var v_1 = __values(v), v_1_1 = v_1.next(); !v_1_1.done; v_1_1 = v_1.next()) {
								var s = v_1_1.value;

								if (
									'prim' in s &&
									(s.prim === 'parameter' || s.prim === 'storage' || s.prim === 'code')
								) {
									return true;
								}
							}
						} catch (e_9_1) {
							e_9 = {
								error: e_9_1
							};
						} finally {
							try {
								if (v_1_1 && !v_1_1.done && (_a = v_1.return)) _a.call(v_1);
							} finally {
								if (e_9) throw e_9.error;
							}
						}
					}

					return false;
				}

				function contractEntryPoint(src, ep) {
					ep = ep || '%default';
					var entryPoint = contractEntryPoints(src).find(function (x) {
						return x[0] === ep;
					});

					if (entryPoint !== undefined) {
						return entryPoint[1];
					} else if (ep === '%default') {
						return isContract(src) ? contractSection(src, 'parameter').args[0] : src;
					}

					return null;
				}

				function isOrType(t) {
					return Array.isArray(t) || t.prim === 'or';
				}

				function contractEntryPoints(src) {
					if (isContract(src)) {
						var param = contractSection(src, 'parameter');
						var ch = contractEntryPoints(param.args[0]);
						var a = unpackAnnotations(param);
						return a.f ? __spreadArray([[a.f[0], param.args[0]]], __read(ch)) : ch;
					}

					if (isOrType(src)) {
						var args_2 = typeArgs(src);

						var getArg = function (n) {
							var a = unpackAnnotations(args_2[n]);

							if (typeID(args_2[n]) === 'or') {
								var ch = contractEntryPoints(args_2[n]);
								return a.f ? __spreadArray([[a.f[0], args_2[n]]], __read(ch)) : ch;
							}

							return a.f ? [[a.f[0], args_2[n]]] : [];
						};

						return __spreadArray(__spreadArray([], __read(getArg(0))), __read(getArg(1)));
					}

					return [];
				} // Contract validation

				function assertContractValid(contract, ctx) {
					var parameter = contractSection(contract, 'parameter').args[0];
					assertTypeAnnotationsValid(parameter, true);
					var storage = contractSection(contract, 'storage').args[0];
					assertTypeAnnotationsValid(storage);
					var arg = {
						prim: 'pair',
						args: [
							__assign(__assign({}, parameter), {
								annots: ['@parameter']
							}),
							__assign(__assign({}, storage), {
								annots: ['@storage']
							})
						]
					};
					var code = contractSection(contract, 'code').args[0];
					var ret = functionTypeInternal(
						code,
						[arg],
						__assign(__assign({}, ctx), {
							contract: contract
						})
					);

					if ('failed' in ret) {
						return ret;
					}

					var expected = {
						prim: 'pair',
						args: [
							{
								prim: 'list',
								args: [
									{
										prim: 'operation'
									}
								]
							},
							storage
						]
					};

					try {
						assertStacksEqual(ret, [expected]);
					} catch (err) {
						if (err instanceof MichelsonError) {
							throw new MichelsonInstructionError(code, ret, err.message);
						} else {
							throw err;
						}
					}

					return ret;
				} // Exported wrapper functions

				function assertDataValid(d, t, ctx) {
					assertTypeAnnotationsValid(t);
					assertDataValidInternal(d, t, ctx || null);
				}

				function functionType(inst, stack, ctx) {
					var e_10, _a, e_11, _b;

					try {
						for (
							var stack_1 = __values(stack), stack_1_1 = stack_1.next();
							!stack_1_1.done;
							stack_1_1 = stack_1.next()
						) {
							var t = stack_1_1.value;
							assertTypeAnnotationsValid(t);
						}
					} catch (e_10_1) {
						e_10 = {
							error: e_10_1
						};
					} finally {
						try {
							if (stack_1_1 && !stack_1_1.done && (_a = stack_1.return)) _a.call(stack_1);
						} finally {
							if (e_10) throw e_10.error;
						}
					}

					if ((ctx === null || ctx === void 0 ? void 0 : ctx.contract) !== undefined) {
						try {
							for (
								var _c = __values(['parameter', 'storage']), _d = _c.next();
								!_d.done;
								_d = _c.next()
							) {
								var typesec = _d.value;
								var sec = contractSection(ctx.contract, typesec).args[0];
								assertTypeAnnotationsValid(sec);
							}
						} catch (e_11_1) {
							e_11 = {
								error: e_11_1
							};
						} finally {
							try {
								if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
							} finally {
								if (e_11) throw e_11.error;
							}
						}
					}

					return functionTypeInternal(inst, stack, ctx || null);
				}

				function assertTypesEqual(a, b, field) {
					var e_12, _a, e_13, _b;

					if (field === void 0) {
						field = false;
					}

					if (Array.isArray(a)) {
						try {
							// type guards don't work for parametrized generic types
							for (var _c = __values(a), _d = _c.next(); !_d.done; _d = _c.next()) {
								var v = _d.value;
								assertTypeAnnotationsValid(v);
							}
						} catch (e_12_1) {
							e_12 = {
								error: e_12_1
							};
						} finally {
							try {
								if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
							} finally {
								if (e_12) throw e_12.error;
							}
						}

						try {
							for (var _e = __values(b), _f = _e.next(); !_f.done; _f = _e.next()) {
								var v = _f.value;
								assertTypeAnnotationsValid(v);
							}
						} catch (e_13_1) {
							e_13 = {
								error: e_13_1
							};
						} finally {
							try {
								if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
							} finally {
								if (e_13) throw e_13.error;
							}
						}
					} else {
						assertTypeAnnotationsValid(a);
						assertTypeAnnotationsValid(b);
					}

					assertScalarTypesEqual(a, b, field);
				}

				function isTypeAnnotationsValid(t, field) {
					if (field === void 0) {
						field = false;
					}

					try {
						assertTypeAnnotationsValid(t, field);
						return true;
					} catch (_a) {
						return false;
					}
				}

				function isContractValid(contract, ctx) {
					try {
						return assertContractValid(contract, ctx);
					} catch (_a) {
						return null;
					}
				}

				function isDataValid(d, t, ctx) {
					try {
						assertDataValid(d, t, ctx);
						return true;
					} catch (_a) {
						return false;
					}
				}

				function isTypeEqual(a, b, field) {
					if (field === void 0) {
						field = false;
					}

					try {
						assertTypesEqual(a, b, field);
						return true;
					} catch (_a) {
						return false;
					}
				}

				var Contract =
					/** @class */
					(function () {
						function Contract(contract, opt) {
							this.contract = contract;
							this.ctx = __assign(
								{
									contract: contract
								},
								opt
							);
							this.output = assertContractValid(contract, this.ctx);
						}

						Contract.parse = function (src, opt) {
							var p = new Parser(opt);
							var expr = typeof src === 'string' ? p.parseScript(src) : p.parseJSON(src);

							if (expr === null) {
								throw new Error('empty contract');
							}

							if (assertMichelsonContract(expr)) {
								return new Contract(expr, opt);
							}
						};

						Contract.parseTypeExpression = function (src, opt) {
							var p = new Parser(opt);
							var expr = typeof src === 'string' ? p.parseScript(src) : p.parseJSON(src);

							if (expr === null) {
								throw new Error('empty type expression');
							}

							if (assertMichelsonType(expr) && assertTypeAnnotationsValid(expr)) {
								return expr;
							}

							throw undefined;
						};

						Contract.parseDataExpression = function (src, opt) {
							var p = new Parser(opt);
							var expr = typeof src === 'string' ? p.parseScript(src) : p.parseJSON(src);

							if (expr === null) {
								throw new Error('empty data expression');
							}

							if (assertMichelsonData(expr)) {
								return expr;
							}

							throw undefined;
						};

						Contract.prototype.section = function (section) {
							return contractSection(this.contract, section);
						};

						Contract.prototype.entryPoints = function () {
							return contractEntryPoints(this.contract);
						};

						Contract.prototype.entryPoint = function (ep) {
							return contractEntryPoint(this.contract, ep);
						};

						Contract.prototype.assertDataValid = function (d, t) {
							assertDataValid(d, t, this.ctx);
						};

						Contract.prototype.isDataValid = function (d, t) {
							return isDataValid(d, t, this.ctx);
						};

						Contract.prototype.assertParameterValid = function (ep, d) {
							var t = this.entryPoint(ep || undefined);

							if (t === null) {
								throw new Error('contract has no entrypoint named ' + ep);
							}

							this.assertDataValid(d, t);
						};

						Contract.prototype.isParameterValid = function (ep, d) {
							try {
								this.assertParameterValid(ep, d);
								return true;
							} catch (_a) {
								return false;
							}
						};

						Contract.prototype.functionType = function (inst, stack) {
							return functionType(inst, stack, this.ctx);
						};

						return Contract;
					})();

				exports.Contract = Contract;
				var dummyContract = new Contract([
					{
						prim: 'parameter',
						args: [
							{
								prim: 'unit'
							}
						]
					},
					{
						prim: 'storage',
						args: [
							{
								prim: 'unit'
							}
						]
					},
					{
						prim: 'code',
						args: [
							[
								{
									prim: 'CAR'
								},
								{
									prim: 'NIL',
									args: [
										{
											prim: 'operation'
										}
									]
								},
								{
									prim: 'PAIR'
								}
							]
						]
					}
				]);
				exports.dummyContract = dummyContract;

				function formatStack(s) {
					if ('failed' in s) {
						return '[FAILED: ' + emitMicheline(s.failed) + ']';
					}

					return s
						.map(function (v, i) {
							var ann = unpackAnnotations(v);
							return '[' + i + (ann.v ? '/' + ann.v[0] : '') + ']: ' + emitMicheline(v);
						})
						.join('\n');
				}

				function traceDumpFunc(blocks, cb) {
					return function (v) {
						var _a;

						if (Array.isArray(v) && !blocks) {
							return;
						}

						var macro = (_a = v.op[sourceReference]) === null || _a === void 0 ? void 0 : _a.macro;
						var msg =
							(macro ? 'Macro' : 'Op') +
							': ' +
							(macro ? emitMicheline(macro, undefined, true) + ' / ' : '') +
							emitMicheline(v.op) +
							'\nInput:\n' +
							formatStack(v.in) +
							'\nOutput:\n' +
							formatStack(v.out) +
							'\n';
						cb(msg);
					};
				}

				function formatError(err) {
					var _a;

					if (err instanceof MichelsonInstructionError) {
						var macro =
							(_a = err.val[sourceReference]) === null || _a === void 0 ? void 0 : _a.macro;
						return (
							(macro ? 'Macro' : 'Op') +
							': ' +
							(macro ? emitMicheline(macro, undefined, true) + ' / ' : '') +
							emitMicheline(err.val) +
							'\nStack:\n' +
							formatStack(err.stackState) +
							'\n'
						);
					} else if (err instanceof MichelsonTypeError) {
						var type = Array.isArray(err.val)
							? '[' +
							  err.val
									.map(function (v, i) {
										return '[' + i + ']: ' + emitMicheline(v);
									})
									.join('; ') +
							  ']'
							: emitMicheline(err.val);
						return (
							'Type: ' +
							type +
							'\n' +
							(err.data ? 'Data: ' + emitMicheline(err.data) + '\n' : '') +
							'\n'
						);
					} else {
						return 'Value: ' + emitMicheline(err.val);
					}
				} // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!

				/* tslint:disable */

				var VERSION = {
					commitHash: '68be71fd14ffd87bd0a0f91dab60d69c8665e88c',
					version: '10.2.0'
				};
				/* tslint:enable */

				exports.VERSION = VERSION;
			},
			{}
		],
		'../node_modules/@taquito/taquito/dist/taquito.es5.js': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.compose = compose;
				Object.defineProperty(exports, 'OpKind', {
					enumerable: true,
					get: function () {
						return _rpc2.OpKind;
					}
				});
				Object.defineProperty(exports, 'MichelsonMap', {
					enumerable: true,
					get: function () {
						return _michelsonEncoder.MichelsonMap;
					}
				});
				Object.defineProperty(exports, 'UnitValue', {
					enumerable: true,
					get: function () {
						return _michelsonEncoder.UnitValue;
					}
				});
				exports.protocols =
					exports.defaultConfigStreamer =
					exports.defaultConfigConfirmation =
					exports.createTransferOperation =
					exports.createSetDelegateOperation =
					exports.createRevealOperation =
					exports.createRegisterDelegateOperation =
					exports.createOriginationOperation =
					exports.WalletOperationBatch =
					exports.WalletOperation =
					exports.Wallet =
					exports.VIEW_LAMBDA =
					exports.UndefinedLambdaContractError =
					exports.TransactionWalletOperation =
					exports.TransactionOperation =
					exports.TezosToolkit =
					exports.TezosPreapplyFailureError =
					exports.TezosOperationError =
					exports.RpcPacker =
					exports.RpcForger =
					exports.Protocols =
					exports.PollingSubscribeProvider =
					exports.OriginationWalletOperation =
					exports.OriginationOperation =
					exports.OperationBatch =
					exports.Operation =
					exports.NoopParser =
					exports.MissedBlockDuringConfirmationError =
					exports.MichelCodecParser =
					exports.MichelCodecPacker =
					exports.MANAGER_LAMBDA =
					exports.LegacyWalletProvider =
					exports.InvalidParameterError =
					exports.InvalidInitParameter =
					exports.InvalidDelegationSource =
					exports.InvalidCodeParameter =
					exports.DelegationWalletOperation =
					exports.DelegateOperation =
					exports.DefaultLambdaAddresses =
					exports.DEFAULT_STORAGE_LIMIT =
					exports.DEFAULT_SMART_CONTRACT_METHOD_NAME =
					exports.DEFAULT_GAS_LIMIT =
					exports.DEFAULT_FEE =
					exports.ContractView =
					exports.ContractMethodObject =
					exports.ContractMethod =
					exports.ContractAbstraction =
					exports.Context =
					exports.CompositeForger =
					exports.ChainIds =
					exports.BigMapAbstraction =
					exports.BatchOperation =
						void 0;

				var _rpc2 = require('@taquito/rpc');

				var _rxjs = require('rxjs');

				var _operators = require('rxjs/operators');

				var _michelsonEncoder = require('@taquito/michelson-encoder');

				var _bignumber = _interopRequireDefault(require('bignumber.js'));

				var _httpUtils = require('@taquito/http-utils');

				var _utils = require('@taquito/utils');

				var _michelCodec = require('@taquito/michel-codec');

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj };
				}

				function _typeof(obj) {
					if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
						_typeof = function (obj) {
							return typeof obj;
						};
					} else {
						_typeof = function (obj) {
							return obj &&
								typeof Symbol === 'function' &&
								obj.constructor === Symbol &&
								obj !== Symbol.prototype
								? 'symbol'
								: typeof obj;
						};
					}
					return _typeof(obj);
				}

				/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

				/* global Reflect, Promise */
				var extendStatics = function (d, b) {
					extendStatics =
						Object.setPrototypeOf ||
						({
							__proto__: []
						} instanceof Array &&
							function (d, b) {
								d.__proto__ = b;
							}) ||
						function (d, b) {
							for (var p in b) {
								if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
							}
						};

					return extendStatics(d, b);
				};

				function __extends(d, b) {
					if (typeof b !== 'function' && b !== null)
						throw new TypeError(
							'Class extends value ' + String(b) + ' is not a constructor or null'
						);
					extendStatics(d, b);

					function __() {
						this.constructor = d;
					}

					d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
				}

				var __assign = function () {
					__assign =
						Object.assign ||
						function __assign(t) {
							for (var s, i = 1, n = arguments.length; i < n; i++) {
								s = arguments[i];

								for (var p in s) {
									if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
								}
							}

							return t;
						};

					return __assign.apply(this, arguments);
				};

				function __rest(s, e) {
					var t = {};

					for (var p in s) {
						if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
					}

					if (s != null && typeof Object.getOwnPropertySymbols === 'function')
						for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
							if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
								t[p[i]] = s[p[i]];
						}
					return t;
				}

				function __awaiter(thisArg, _arguments, P, generator) {
					function adopt(value) {
						return value instanceof P
							? value
							: new P(function (resolve) {
									resolve(value);
							  });
					}

					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) {
							try {
								step(generator.next(value));
							} catch (e) {
								reject(e);
							}
						}

						function rejected(value) {
							try {
								step(generator['throw'](value));
							} catch (e) {
								reject(e);
							}
						}

						function step(result) {
							result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
						}

						step((generator = generator.apply(thisArg, _arguments || [])).next());
					});
				}

				function __generator(thisArg, body) {
					var _ = {
							label: 0,
							sent: function () {
								if (t[0] & 1) throw t[1];
								return t[1];
							},
							trys: [],
							ops: []
						},
						f,
						y,
						t,
						g;
					return (
						(g = {
							next: verb(0),
							throw: verb(1),
							return: verb(2)
						}),
						typeof Symbol === 'function' &&
							(g[Symbol.iterator] = function () {
								return this;
							}),
						g
					);

					function verb(n) {
						return function (v) {
							return step([n, v]);
						};
					}

					function step(op) {
						if (f) throw new TypeError('Generator is already executing.');

						while (_) {
							try {
								if (
									((f = 1),
									y &&
										(t =
											op[0] & 2
												? y['return']
												: op[0]
												? y['throw'] || ((t = y['return']) && t.call(y), 0)
												: y.next) &&
										!(t = t.call(y, op[1])).done)
								)
									return t;
								if (((y = 0), t)) op = [op[0] & 2, t.value];

								switch (op[0]) {
									case 0:
									case 1:
										t = op;
										break;

									case 4:
										_.label++;
										return {
											value: op[1],
											done: false
										};

									case 5:
										_.label++;
										y = op[1];
										op = [0];
										continue;

									case 7:
										op = _.ops.pop();

										_.trys.pop();

										continue;

									default:
										if (
											!((t = _.trys), (t = t.length > 0 && t[t.length - 1])) &&
											(op[0] === 6 || op[0] === 2)
										) {
											_ = 0;
											continue;
										}

										if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
											_.label = op[1];
											break;
										}

										if (op[0] === 6 && _.label < t[1]) {
											_.label = t[1];
											t = op;
											break;
										}

										if (t && _.label < t[2]) {
											_.label = t[2];

											_.ops.push(op);

											break;
										}

										if (t[2]) _.ops.pop();

										_.trys.pop();

										continue;
								}

								op = body.call(thisArg, _);
							} catch (e) {
								op = [6, e];
								y = 0;
							} finally {
								f = t = 0;
							}
						}

						if (op[0] & 5) throw op[1];
						return {
							value: op[0] ? op[1] : void 0,
							done: true
						};
					}
				}

				function __values(o) {
					var s = typeof Symbol === 'function' && Symbol.iterator,
						m = s && o[s],
						i = 0;
					if (m) return m.call(o);
					if (o && typeof o.length === 'number')
						return {
							next: function () {
								if (o && i >= o.length) o = void 0;
								return {
									value: o && o[i++],
									done: !o
								};
							}
						};
					throw new TypeError(s ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
				}

				function __read(o, n) {
					var m = typeof Symbol === 'function' && o[Symbol.iterator];
					if (!m) return o;
					var i = m.call(o),
						r,
						ar = [],
						e;

					try {
						while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
							ar.push(r.value);
						}
					} catch (error) {
						e = {
							error: error
						};
					} finally {
						try {
							if (r && !r.done && (m = i['return'])) m.call(i);
						} finally {
							if (e) throw e.error;
						}
					}

					return ar;
				}

				function __spreadArray(to, from) {
					for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {
						to[j] = from[i];
					}

					return to;
				}

				var RpcForger =
					/** @class */
					(function () {
						function RpcForger(context) {
							this.context = context;
						}

						RpcForger.prototype.forge = function (_a) {
							var branch = _a.branch,
								contents = _a.contents;
							return this.context.rpc.forgeOperations({
								branch: branch,
								contents: contents
							});
						};

						return RpcForger;
					})();

				exports.RpcForger = RpcForger;

				var RpcInjector =
					/** @class */
					(function () {
						function RpcInjector(context) {
							this.context = context;
						}

						RpcInjector.prototype.inject = function (signedOperationBytes) {
							return this.context.rpc.injectOperation(signedOperationBytes);
						};

						return RpcInjector;
					})();

				var UnconfiguredSignerError =
					/** @class */
					(function () {
						function UnconfiguredSignerError() {
							this.name = 'UnconfiguredSignerError';
							this.message =
								'No signer has been configured. Please configure one by calling setProvider({signer}) on your TezosToolkit instance.';
						}

						return UnconfiguredSignerError;
					})();
				/**
				 * @description Default signer implementation which does nothing and produce invalid signature
				 */

				var NoopSigner =
					/** @class */
					(function () {
						function NoopSigner() {}

						NoopSigner.prototype.publicKey = function () {
							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_a) {
									throw new UnconfiguredSignerError();
								});
							});
						};

						NoopSigner.prototype.publicKeyHash = function () {
							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_a) {
									throw new UnconfiguredSignerError();
								});
							});
						};

						NoopSigner.prototype.secretKey = function () {
							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_a) {
									throw new UnconfiguredSignerError();
								});
							});
						};

						NoopSigner.prototype.sign = function (_bytes, _watermark) {
							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_a) {
									throw new UnconfiguredSignerError();
								});
							});
						};

						return NoopSigner;
					})();

				var DEFAULT_GAS_LIMIT;
				exports.DEFAULT_GAS_LIMIT = DEFAULT_GAS_LIMIT;

				(function (DEFAULT_GAS_LIMIT) {
					DEFAULT_GAS_LIMIT[(DEFAULT_GAS_LIMIT['DELEGATION'] = 10600)] = 'DELEGATION';
					DEFAULT_GAS_LIMIT[(DEFAULT_GAS_LIMIT['ORIGINATION'] = 10600)] = 'ORIGINATION';
					DEFAULT_GAS_LIMIT[(DEFAULT_GAS_LIMIT['TRANSFER'] = 10600)] = 'TRANSFER';
					DEFAULT_GAS_LIMIT[(DEFAULT_GAS_LIMIT['REVEAL'] = 1100)] = 'REVEAL';
				})(DEFAULT_GAS_LIMIT || (exports.DEFAULT_GAS_LIMIT = DEFAULT_GAS_LIMIT = {}));

				var DEFAULT_FEE;
				exports.DEFAULT_FEE = DEFAULT_FEE;

				(function (DEFAULT_FEE) {
					DEFAULT_FEE[(DEFAULT_FEE['DELEGATION'] = 1257)] = 'DELEGATION';
					DEFAULT_FEE[(DEFAULT_FEE['ORIGINATION'] = 10000)] = 'ORIGINATION';
					DEFAULT_FEE[(DEFAULT_FEE['TRANSFER'] = 10000)] = 'TRANSFER';
					DEFAULT_FEE[(DEFAULT_FEE['REVEAL'] = 374)] = 'REVEAL';
				})(DEFAULT_FEE || (exports.DEFAULT_FEE = DEFAULT_FEE = {}));

				var DEFAULT_STORAGE_LIMIT;
				exports.DEFAULT_STORAGE_LIMIT = DEFAULT_STORAGE_LIMIT;

				(function (DEFAULT_STORAGE_LIMIT) {
					DEFAULT_STORAGE_LIMIT[(DEFAULT_STORAGE_LIMIT['DELEGATION'] = 0)] = 'DELEGATION';
					DEFAULT_STORAGE_LIMIT[(DEFAULT_STORAGE_LIMIT['ORIGINATION'] = 257)] = 'ORIGINATION';
					DEFAULT_STORAGE_LIMIT[(DEFAULT_STORAGE_LIMIT['TRANSFER'] = 257)] = 'TRANSFER';
					DEFAULT_STORAGE_LIMIT[(DEFAULT_STORAGE_LIMIT['REVEAL'] = 0)] = 'REVEAL';
				})(DEFAULT_STORAGE_LIMIT || (exports.DEFAULT_STORAGE_LIMIT = DEFAULT_STORAGE_LIMIT = {}));

				var Protocols;
				exports.Protocols = Protocols;

				(function (Protocols) {
					Protocols['Pt24m4xi'] = 'Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd';
					Protocols['PsBABY5H'] = 'PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU';
					Protocols['PsBabyM1'] = 'PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS';
					Protocols['PsCARTHA'] = 'PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb';
					Protocols['PsDELPH1'] = 'PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo';
					Protocols['PtEdo2Zk'] = 'PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA';
					Protocols['PsFLorena'] = 'PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i';
					Protocols['PtGRANADs'] = 'PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV';
					Protocols['PtHangzH'] = 'PtHangzHogokSuiMHemCuowEavgYTP8J5qQ9fQS793MHYFpCY3r';
				})(Protocols || (exports.Protocols = Protocols = {}));

				var protocols = {
					'004': [Protocols.Pt24m4xi],
					'005': [Protocols.PsBABY5H, Protocols.PsBabyM1],
					'006': [Protocols.PsCARTHA],
					'007': [Protocols.PsDELPH1],
					'008': [Protocols.PtEdo2Zk],
					'009': [Protocols.PsFLorena],
					'010': [Protocols.PtGRANADs],
					'011': [Protocols.PtHangzH]
				};
				exports.protocols = protocols;
				var DefaultLambdaAddresses;
				exports.DefaultLambdaAddresses = DefaultLambdaAddresses;

				(function (DefaultLambdaAddresses) {
					DefaultLambdaAddresses['MAINNET'] = 'KT1CPuTzwC7h7uLXd5WQmpMFso1HxrLBUtpE';
					DefaultLambdaAddresses['CARTHAGENET'] = 'KT1VAy1o1FGiXYfD3YT7x7k5eF5HSHhmc1u6';
					DefaultLambdaAddresses['DELPHINET'] = 'KT19abMFs3haqyKYwqdLjK9GbtofryZLvpiK';
					DefaultLambdaAddresses['EDONET'] = 'KT1A64nVZDccAHGAsf1ZyVajXZcbiwjV3SnN';
					DefaultLambdaAddresses['FLORENCENET'] = 'KT1KCe3YqGnudsiCWb5twbe2DH5T3EMdLpSE';
					DefaultLambdaAddresses['GRANADANET'] = 'KT1BCun2vsA4GBQvsKAuGD5x873MfW2jsN9z';
					DefaultLambdaAddresses['HANGZHOUNET'] = 'KT1UHUE6ZxjMuFPnPqgDSt13A6zFAAWDReso';
				})(
					DefaultLambdaAddresses || (exports.DefaultLambdaAddresses = DefaultLambdaAddresses = {})
				);

				var ChainIds;
				exports.ChainIds = ChainIds;

				(function (ChainIds) {
					ChainIds['MAINNET'] = 'NetXdQprcVkpaWU';
					ChainIds['CARTHAGENET'] = 'NetXjD3HPJJjmcd';
					ChainIds['DELPHINET'] = 'NetXm8tYqnMWky1';
					ChainIds['EDONET'] = 'NetXSgo1ZT2DRUG';
					ChainIds['FLORENCENET'] = 'NetXxkAx4woPLyu';
					ChainIds['GRANADANET'] = 'NetXz969SFaFn8k';
					ChainIds['HANGZHOUNET'] = 'NetXuXoGoLxNK6o';
				})(ChainIds || (exports.ChainIds = ChainIds = {}));

				var TZ_DECIMALS = 6;
				var MTZ_DECIMALS = 3;

				function getDecimal(format) {
					switch (format) {
						case 'tz':
							return TZ_DECIMALS;

						case 'mtz':
							return MTZ_DECIMALS;

						case 'mutez':
						default:
							return 0;
					}
				}

				function format(from, to, amount) {
					if (from === void 0) {
						from = 'mutez';
					}

					if (to === void 0) {
						to = 'mutez';
					}

					var bigNum = new _bignumber.default(amount);

					if (bigNum.isNaN()) {
						return amount;
					}

					return bigNum
						.multipliedBy(Math.pow(10, getDecimal(from)))
						.dividedBy(Math.pow(10, getDecimal(to)));
				}

				var InvalidParameterError =
					/** @class */
					(function () {
						function InvalidParameterError(smartContractMethodName, sigs, args) {
							this.smartContractMethodName = smartContractMethodName;
							this.sigs = sigs;
							this.args = args;
							this.name = 'Invalid parameters error';
							this.message =
								smartContractMethodName +
								' Received ' +
								args.length +
								' arguments while expecting one of the following signatures (' +
								JSON.stringify(sigs) +
								')';
						}

						return InvalidParameterError;
					})();

				exports.InvalidParameterError = InvalidParameterError;

				var UndefinedLambdaContractError =
					/** @class */
					(function () {
						function UndefinedLambdaContractError() {
							this.name = 'Undefined LambdaContract error';
							this.message =
								'This might happen if you are using a sandbox. Please provide the address of a lambda contract as a parameter of the read method.';
						}

						return UndefinedLambdaContractError;
					})();

				exports.UndefinedLambdaContractError = UndefinedLambdaContractError;

				var InvalidDelegationSource =
					/** @class */
					(function () {
						function InvalidDelegationSource(source) {
							this.source = source;
							this.name = 'Invalid delegation source error';
							this.message =
								'Since Babylon delegation source can no longer be a contract address ' +
								source +
								'. Please use the smart contract abstraction to set your delegate.';
						}

						return InvalidDelegationSource;
					})();

				exports.InvalidDelegationSource = InvalidDelegationSource;

				var InvalidCodeParameter =
					/** @class */
					(function () {
						function InvalidCodeParameter(message, data) {
							this.message = message;
							this.data = data;
							this.name = 'InvalidCodeParameter';
						}

						return InvalidCodeParameter;
					})();

				exports.InvalidCodeParameter = InvalidCodeParameter;

				var InvalidInitParameter =
					/** @class */
					(function () {
						function InvalidInitParameter(message, data) {
							this.message = message;
							this.data = data;
							this.name = 'InvalidInitParameter';
						}

						return InvalidInitParameter;
					})();

				exports.InvalidInitParameter = InvalidInitParameter;

				var createOriginationOperation = function (_a) {
					var code = _a.code,
						init = _a.init,
						_b = _a.balance,
						balance = _b === void 0 ? '0' : _b,
						delegate = _a.delegate,
						storage = _a.storage,
						_c = _a.fee,
						fee = _c === void 0 ? DEFAULT_FEE.ORIGINATION : _c,
						_d = _a.gasLimit,
						gasLimit = _d === void 0 ? DEFAULT_GAS_LIMIT.ORIGINATION : _d,
						_e = _a.storageLimit,
						storageLimit = _e === void 0 ? DEFAULT_STORAGE_LIMIT.ORIGINATION : _e,
						_f = _a.mutez,
						mutez = _f === void 0 ? false : _f;
					return __awaiter(void 0, void 0, void 0, function () {
						var contractStorage, storageType, schema, script, operation;
						return __generator(this, function (_g) {
							// tslint:disable-next-line: strict-type-predicates
							if (storage !== undefined && init !== undefined) {
								throw new Error(
									'Storage and Init cannot be set a the same time. Please either use storage or init but not both.'
								);
							}

							if (!Array.isArray(code)) {
								throw new InvalidCodeParameter(
									'Wrong code parameter type, expected an array',
									code
								);
							}

							if (storage !== undefined) {
								storageType = code.find(function (p) {
									return 'prim' in p && p.prim === 'storage';
								});

								if (
									(storageType === null || storageType === void 0 ? void 0 : storageType.args) ===
									undefined
								) {
									throw new InvalidCodeParameter(
										'The storage section is missing from the script',
										code
									);
								}

								schema = new _michelsonEncoder.Schema(storageType.args[0]);
								contractStorage = schema.Encode(storage);
							} else if (init !== undefined && _typeof(init) === 'object') {
								contractStorage = init;
							} else {
								throw new InvalidInitParameter(
									'Wrong init parameter type, expected JSON Michelson',
									init
								);
							}

							script = {
								code: code,
								storage: contractStorage
							};
							operation = {
								kind: _rpc2.OpKind.ORIGINATION,
								fee: fee,
								gas_limit: gasLimit,
								storage_limit: storageLimit,
								balance: mutez ? balance.toString() : format('tz', 'mutez', balance).toString(),
								script: script
							};

							if (delegate) {
								operation.delegate = delegate;
							}

							return [
								2,
								/*return*/
								operation
							];
						});
					});
				};

				exports.createOriginationOperation = createOriginationOperation;

				var createTransferOperation = function (_a) {
					var to = _a.to,
						amount = _a.amount,
						parameter = _a.parameter,
						_b = _a.fee,
						fee = _b === void 0 ? DEFAULT_FEE.TRANSFER : _b,
						_c = _a.gasLimit,
						gasLimit = _c === void 0 ? DEFAULT_GAS_LIMIT.TRANSFER : _c,
						_d = _a.storageLimit,
						storageLimit = _d === void 0 ? DEFAULT_STORAGE_LIMIT.TRANSFER : _d,
						_e = _a.mutez,
						mutez = _e === void 0 ? false : _e;
					return __awaiter(void 0, void 0, void 0, function () {
						var operation;
						return __generator(this, function (_f) {
							operation = {
								kind: _rpc2.OpKind.TRANSACTION,
								fee: fee,
								gas_limit: gasLimit,
								storage_limit: storageLimit,
								amount: mutez ? amount.toString() : format('tz', 'mutez', amount).toString(),
								destination: to,
								parameters: parameter
							};
							return [
								2,
								/*return*/
								operation
							];
						});
					});
				};

				exports.createTransferOperation = createTransferOperation;

				var createSetDelegateOperation = function (_a) {
					var delegate = _a.delegate,
						source = _a.source,
						_b = _a.fee,
						fee = _b === void 0 ? DEFAULT_FEE.DELEGATION : _b,
						_c = _a.gasLimit,
						gasLimit = _c === void 0 ? DEFAULT_GAS_LIMIT.DELEGATION : _c,
						_d = _a.storageLimit,
						storageLimit = _d === void 0 ? DEFAULT_STORAGE_LIMIT.DELEGATION : _d;
					return __awaiter(void 0, void 0, void 0, function () {
						var operation;
						return __generator(this, function (_e) {
							operation = {
								kind: _rpc2.OpKind.DELEGATION,
								source: source,
								fee: fee,
								gas_limit: gasLimit,
								storage_limit: storageLimit,
								delegate: delegate
							};
							return [
								2,
								/*return*/
								operation
							];
						});
					});
				};

				exports.createSetDelegateOperation = createSetDelegateOperation;

				var createRegisterDelegateOperation = function (_a, source) {
					var _b = _a.fee,
						fee = _b === void 0 ? DEFAULT_FEE.DELEGATION : _b,
						_c = _a.gasLimit,
						gasLimit = _c === void 0 ? DEFAULT_GAS_LIMIT.DELEGATION : _c,
						_d = _a.storageLimit,
						storageLimit = _d === void 0 ? DEFAULT_STORAGE_LIMIT.DELEGATION : _d;
					return __awaiter(void 0, void 0, void 0, function () {
						return __generator(this, function (_e) {
							return [
								2,
								/*return*/
								{
									kind: _rpc2.OpKind.DELEGATION,
									fee: fee,
									gas_limit: gasLimit,
									storage_limit: storageLimit,
									delegate: source
								}
							];
						});
					});
				};

				exports.createRegisterDelegateOperation = createRegisterDelegateOperation;

				var createRevealOperation = function (_a, source, publicKey) {
					var _b = _a.fee,
						fee = _b === void 0 ? DEFAULT_FEE.REVEAL : _b,
						_c = _a.gasLimit,
						gasLimit = _c === void 0 ? DEFAULT_GAS_LIMIT.REVEAL : _c,
						_d = _a.storageLimit,
						storageLimit = _d === void 0 ? DEFAULT_STORAGE_LIMIT.REVEAL : _d;
					return __awaiter(void 0, void 0, void 0, function () {
						return __generator(this, function (_e) {
							return [
								2,
								/*return*/
								{
									kind: _rpc2.OpKind.REVEAL,
									fee: fee,
									public_key: publicKey,
									source: source,
									gas_limit: gasLimit,
									storage_limit: storageLimit
								}
							];
						});
					});
				};

				exports.createRevealOperation = createRevealOperation;

				var attachKind = function (op, kind) {
					return __assign(__assign({}, op), {
						kind: kind
					});
				};

				var findWithKind = function (arr, kind) {
					if (Array.isArray(arr)) {
						var found = arr.find(function (op) {
							return op.kind === kind;
						});

						if (found && isKind(found, kind)) {
							return found;
						}
					}
				};

				var isKind = function (op, kind) {
					return op.kind === kind;
				};

				var isOpWithFee = function (op) {
					return ['transaction', 'delegation', 'origination', 'reveal'].indexOf(op.kind) !== -1;
				};

				var isOpRequireReveal = function (op) {
					return ['transaction', 'delegation', 'origination'].indexOf(op.kind) !== -1;
				};

				var hasMetadata = function (op) {
					return 'metadata' in op;
				};

				var hasMetadataWithResult = function (op) {
					return hasMetadata(op) && 'operation_result' in op.metadata;
				};

				var hasMetadataWithInternalOperationResult = function (op) {
					return hasMetadata(op) && 'internal_operation_results' in op.metadata;
				};

				var isErrorWithMessage = function (error) {
					return 'with' in error;
				};

				var TezosOperationError =
					/** @class */
					(function () {
						function TezosOperationError(errors) {
							this.errors = errors;
							this.name = 'TezosOperationError'; // Last error is 'often' the one with more detail

							var lastError = errors[errors.length - 1];
							this.id = lastError.id;
							this.kind = lastError.kind;
							this.message = '(' + this.kind + ') ' + this.id;

							if (isErrorWithMessage(lastError) && lastError.with.string) {
								this.message = lastError.with.string;
							}
						}

						return TezosOperationError;
					})();

				exports.TezosOperationError = TezosOperationError;

				var TezosPreapplyFailureError =
					/** @class */
					(function () {
						function TezosPreapplyFailureError(result) {
							this.result = result;
							this.name = 'TezosPreapplyFailureError';
							this.message = 'Preapply returned an unexpected result';
						}

						return TezosPreapplyFailureError;
					})(); // Flatten all operation content results and internal operation results into a single array
				// Some cases where we can have multiple operation results or internal operation results are:
				// - When an operation includes a reveal operation
				// - When an operation is made using the batch API
				// - Smart contract call can contains internal operation results when they call other smart contract internally or originate contracts

				exports.TezosPreapplyFailureError = TezosPreapplyFailureError;

				var flattenOperationResult = function (response) {
					var results = Array.isArray(response) ? response : [response];
					var returnedResults = [];

					for (var i = 0; i < results.length; i++) {
						for (var j = 0; j < results[i].contents.length; j++) {
							var content = results[i].contents[j];

							if (hasMetadataWithResult(content)) {
								returnedResults.push(
									__assign(
										{
											fee: content.fee
										},
										content.metadata.operation_result
									)
								);

								if (Array.isArray(content.metadata.internal_operation_results)) {
									content.metadata.internal_operation_results.forEach(function (x) {
										return returnedResults.push(x.result);
									});
								}
							}
						}
					}

					return returnedResults;
				};
				/***
				 * @description Flatten all error from preapply response (including internal error)
				 */

				var flattenErrors = function (response, status) {
					var e_1, _a;

					if (status === void 0) {
						status = 'failed';
					}

					var results = Array.isArray(response) ? response : [response];
					var errors = []; // Transaction that do not fail will be backtracked in case one failure occur

					for (var i = 0; i < results.length; i++) {
						for (var j = 0; j < results[i].contents.length; j++) {
							var content = results[i].contents[j];

							if (hasMetadata(content)) {
								if (
									hasMetadataWithResult(content) &&
									content.metadata.operation_result.status === status
								) {
									errors = errors.concat(content.metadata.operation_result.errors || []);
								}

								if (
									hasMetadataWithInternalOperationResult(content) &&
									Array.isArray(content.metadata.internal_operation_results)
								) {
									try {
										for (
											var _b =
													((e_1 = void 0), __values(content.metadata.internal_operation_results)),
												_c = _b.next();
											!_c.done;
											_c = _b.next()
										) {
											var internalResult = _c.value;

											if ('result' in internalResult && internalResult.result.status === status) {
												errors = errors.concat(internalResult.result.errors || []);
											}
										}
									} catch (e_1_1) {
										e_1 = {
											error: e_1_1
										};
									} finally {
										try {
											if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
										} finally {
											if (e_1) throw e_1.error;
										}
									}
								}
							}
						}
					}

					return errors;
				};
				/**
				 * @description Utility class to interact with Tezos operations
				 */

				var Operation =
					/** @class */
					(function () {
						/**
						 *
						 * @param hash Operation hash
						 * @param raw Raw operation that was injected
						 * @param context Taquito context allowing access to rpc and signer
						 */
						function Operation(hash, raw, results, context) {
							var _this = this;

							this.hash = hash;
							this.raw = raw;
							this.results = results;
							this.context = context;
							this._pollingConfig$ = new _rxjs.ReplaySubject(1);
							this._currentHeadPromise = undefined; // Caching the current head for one second

							this.currentHead$ = (0, _rxjs.defer)(function () {
								if (!_this._currentHeadPromise) {
									_this._currentHeadPromise = _this.context.rpc.getBlock();
									(0, _rxjs.timer)(1000)
										.pipe((0, _operators.first)())
										.subscribe(function () {
											_this._currentHeadPromise = undefined;
										});
								}

								return (0, _rxjs.from)(_this._currentHeadPromise);
							}); // Polling observable that emit until timeout is reached

							this.polling$ = (0, _rxjs.defer)(function () {
								return _this._pollingConfig$.pipe(
									(0, _operators.tap)(function (_a) {
										var timeout = _a.timeout,
											interval = _a.interval;

										if (timeout <= 0) {
											throw new Error('Timeout must be more than 0');
										}

										if (interval <= 0) {
											throw new Error('Interval must be more than 0');
										}
									}),
									(0, _operators.map)(function (config) {
										return __assign(__assign({}, config), {
											timeoutAt: Math.ceil(config.timeout / config.interval) + 1,
											count: 0
										});
									}),
									(0, _operators.switchMap)(function (config) {
										return (0, _rxjs.timer)(0, config.interval * 1000).pipe(
											(0, _operators.mapTo)(config)
										);
									}),
									(0, _operators.tap)(function (config) {
										config.count++;

										if (config.count > config.timeoutAt) {
											throw new Error('Confirmation polling timed out');
										}
									})
								);
							}); // Observable that emit once operation is seen in a block

							this.confirmed$ = this.polling$.pipe(
								(0, _operators.switchMapTo)(this.currentHead$),
								(0, _operators.map)(function (head) {
									for (var i = 3; i >= 0; i--) {
										head.operations[i].forEach(function (op) {
											if (op.hash === _this.hash) {
												_this._foundAt = head.header.level;
											}
										});
									}

									if (head.header.level - _this._foundAt >= 0) {
										return _this._foundAt;
									}
								}),
								(0, _operators.filter)(function (x) {
									return x !== undefined;
								}),
								(0, _operators.first)(),
								(0, _operators.shareReplay)()
							);
							this._foundAt = Number.POSITIVE_INFINITY;
							this.confirmed$
								.pipe(
									(0, _operators.first)(),
									(0, _operators.catchError)(function () {
										return (0, _rxjs.of)(_rxjs.EMPTY);
									})
								)
								.subscribe();
						}

						Object.defineProperty(Operation.prototype, 'includedInBlock', {
							get: function () {
								return this._foundAt;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(Operation.prototype, 'revealOperation', {
							get: function () {
								return (
									Array.isArray(this.results) &&
									this.results.find(function (op) {
										return op.kind === 'reveal';
									})
								);
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(Operation.prototype, 'revealStatus', {
							get: function () {
								if (this.revealOperation) {
									return this.revealOperation.metadata.operation_result.status;
								} else {
									return 'unknown';
								}
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(Operation.prototype, 'status', {
							get: function () {
								return (
									this.results.map(function (result) {
										if (hasMetadataWithResult(result)) {
											return result.metadata.operation_result.status;
										} else {
											return 'unknown';
										}
									})[0] || 'unknown'
								);
							},
							enumerable: false,
							configurable: true
						});
						/**
						 *
						 * @param confirmations [0] Number of confirmation to wait for
						 * @param interval [10] Polling interval
						 * @param timeout [180] Timeout
						 */

						Operation.prototype.confirmation = function (confirmations, interval, timeout) {
							return __awaiter(this, void 0, void 0, function () {
								var confirmationPollingIntervalSecond,
									_a,
									_b,
									defaultConfirmationCount,
									confirmationPollingTimeoutSecond,
									conf;

								var _this = this;

								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											if (typeof confirmations !== 'undefined' && confirmations < 1) {
												throw new Error('Confirmation count must be at least 1');
											}

											if (!(this.context.config.confirmationPollingIntervalSecond !== undefined))
												return [3 /*break*/, 1];
											_a = this.context.config.confirmationPollingIntervalSecond;
											return [3 /*break*/, 3];

										case 1:
											return [
												4,
												/*yield*/
												this.context.getConfirmationPollingInterval()
											];

										case 2:
											_a = _c.sent();
											_c.label = 3;

										case 3:
											confirmationPollingIntervalSecond = _a;
											(_b = this.context.config),
												(defaultConfirmationCount = _b.defaultConfirmationCount),
												(confirmationPollingTimeoutSecond = _b.confirmationPollingTimeoutSecond);

											this._pollingConfig$.next({
												interval: interval || confirmationPollingIntervalSecond,
												timeout: timeout || confirmationPollingTimeoutSecond
											});

											conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;
											return [
												2,
												/*return*/
												new Promise(function (resolve, reject) {
													_this.confirmed$
														.pipe(
															(0, _operators.switchMap)(function () {
																return _this.polling$;
															}),
															(0, _operators.switchMap)(function () {
																return _this.currentHead$;
															}),
															(0, _operators.filter)(function (head) {
																return head.header.level - _this._foundAt >= conf - 1;
															}),
															(0, _operators.first)()
														)
														.subscribe(function (_) {
															resolve(_this._foundAt + (conf - 1));
														}, reject);
												})
											];
									}
								});
							});
						};

						return Operation;
					})();

				exports.Operation = Operation;

				var BatchOperation =
					/** @class */
					(function (_super) {
						__extends(BatchOperation, _super);

						function BatchOperation(hash, params, source, raw, results, context) {
							var _this = _super.call(this, hash, raw, results, context) || this;

							_this.params = params;
							_this.source = source;
							return _this;
						}

						BatchOperation.prototype.sumProp = function (arr, prop) {
							return arr.reduce(function (prev, current) {
								return prop in current ? Number(current[prop]) + prev : prev;
							}, 0);
						};

						Object.defineProperty(BatchOperation.prototype, 'status', {
							get: function () {
								return (
									this.results
										.filter(function (result) {
											return BATCH_KINDS.indexOf(result.kind) !== -1;
										})
										.map(function (result) {
											if (hasMetadataWithResult(result)) {
												return result.metadata.operation_result.status;
											} else {
												return 'unknown';
											}
										})[0] || 'unknown'
								);
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(BatchOperation.prototype, 'fee', {
							get: function () {
								return this.sumProp(this.params, 'fee');
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(BatchOperation.prototype, 'gasLimit', {
							get: function () {
								return this.sumProp(this.params, 'gas_limit');
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(BatchOperation.prototype, 'storageLimit', {
							get: function () {
								return this.sumProp(this.params, 'storage_limit');
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(BatchOperation.prototype, 'consumedGas', {
							get: function () {
								return String(
									this.sumProp(
										flattenOperationResult({
											contents: this.results
										}),
										'consumed_gas'
									)
								);
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(BatchOperation.prototype, 'storageDiff', {
							get: function () {
								return String(
									this.sumProp(
										flattenOperationResult({
											contents: this.results
										}),
										'paid_storage_size_diff'
									)
								);
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(BatchOperation.prototype, 'errors', {
							get: function () {
								return flattenErrors({
									contents: this.results
								});
							},
							enumerable: false,
							configurable: true
						});
						return BatchOperation;
					})(Operation);

				exports.BatchOperation = BatchOperation;

				var OperationEmitter =
					/** @class */
					(function () {
						function OperationEmitter(context) {
							this.context = context;
						}

						Object.defineProperty(OperationEmitter.prototype, 'rpc', {
							get: function () {
								return this.context.rpc;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(OperationEmitter.prototype, 'signer', {
							get: function () {
								return this.context.signer;
							},
							enumerable: false,
							configurable: true
						});

						OperationEmitter.prototype.isRevealOpNeeded = function (op, pkh) {
							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.isAccountRevealRequired(pkh)
											];

										case 1:
											return [
												2,
												/*return*/
												!_a.sent() || !this.isRevealRequiredForOpType(op) ? false : true
											];
									}
								});
							});
						};

						OperationEmitter.prototype.isAccountRevealRequired = function (publicKeyHash) {
							return __awaiter(this, void 0, void 0, function () {
								var manager, haveManager;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.rpc.getManagerKey(publicKeyHash)
											];

										case 1:
											manager = _a.sent();
											haveManager =
												manager && _typeof(manager) === 'object' ? !!manager.key : !!manager;
											return [
												2,
												/*return*/
												!haveManager
											];
									}
								});
							});
						};

						OperationEmitter.prototype.isRevealRequiredForOpType = function (op) {
							var e_1, _a;

							var opRequireReveal = false;

							try {
								for (
									var op_1 = __values(op), op_1_1 = op_1.next();
									!op_1_1.done;
									op_1_1 = op_1.next()
								) {
									var operation = op_1_1.value;

									if (isOpRequireReveal(operation)) {
										opRequireReveal = true;
									}
								}
							} catch (e_1_1) {
								e_1 = {
									error: e_1_1
								};
							} finally {
								try {
									if (op_1_1 && !op_1_1.done && (_a = op_1.return)) _a.call(op_1);
								} finally {
									if (e_1) throw e_1.error;
								}
							}

							return opRequireReveal;
						}; // Originally from sotez (Copyright (c) 2018 Andrew Kishino)

						OperationEmitter.prototype.prepareOperation = function (_a) {
							var operation = _a.operation,
								source = _a.source;
							return __awaiter(this, void 0, void 0, function () {
								var counter,
									counters,
									ops,
									head,
									blockHeaderPromise,
									blockMetaPromise,
									publicKeyHash,
									counterPromise,
									i,
									counter_1,
									_b,
									header,
									metadata,
									headCounter,
									getFee,
									getSource,
									constructOps,
									branch,
									contents,
									protocol;

								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											counters = {};
											ops = [];
											blockHeaderPromise = this.rpc.getBlockHeader();
											blockMetaPromise = this.rpc.getBlockMetadata();

											if (Array.isArray(operation)) {
												ops = __spreadArray([], __read(operation));
											} else {
												ops = [operation];
											}

											return [
												4,
												/*yield*/
												this.signer.publicKeyHash()
											];

										case 1:
											publicKeyHash = _c.sent();
											counterPromise = Promise.resolve(undefined);
											i = 0;
											_c.label = 2;

										case 2:
											if (!(i < ops.length)) return [3 /*break*/, 5];
											if (!(isOpRequireReveal(ops[i]) || ops[i].kind === 'reveal'))
												return [3 /*break*/, 4];
											return [
												4,
												/*yield*/
												this.rpc.getContract(publicKeyHash)
											];

										case 3:
											counter_1 = _c.sent().counter;
											counterPromise = Promise.resolve(counter_1);
											return [3 /*break*/, 5];

										case 4:
											i++;
											return [3 /*break*/, 2];

										case 5:
											return [
												4,
												/*yield*/
												Promise.all([blockHeaderPromise, blockMetaPromise, counterPromise])
											];

										case 6:
											(_b = __read.apply(void 0, [_c.sent(), 3])),
												(header = _b[0]),
												(metadata = _b[1]),
												(headCounter = _b[2]);

											if (!header) {
												throw new Error('Unable to fetch latest block header');
											}

											if (!metadata) {
												throw new Error('Unable to fetch latest metadata');
											}

											head = header;
											counter = parseInt(headCounter || '0', 10);

											if (!counters[publicKeyHash] || counters[publicKeyHash] < counter) {
												counters[publicKeyHash] = counter;
											}

											getFee = function (op) {
												var opCounter = ++counters[publicKeyHash];
												return {
													counter: '' + opCounter,
													// tslint:disable-next-line: strict-type-predicates
													fee: typeof op.fee === 'undefined' ? '0' : '' + op.fee,
													// tslint:disable-next-line: strict-type-predicates
													gas_limit: typeof op.gas_limit === 'undefined' ? '0' : '' + op.gas_limit,
													// tslint:disable-next-line: strict-type-predicates
													storage_limit:
														typeof op.storage_limit === 'undefined' ? '0' : '' + op.storage_limit
												};
											};

											getSource = function (op) {
												return {
													source:
														typeof op.source === 'undefined' ? source || publicKeyHash : op.source
												};
											};

											constructOps = function (cOps) {
												// tslint:disable strict-type-predicates
												return cOps.map(function (op) {
													switch (op.kind) {
														case _rpc2.OpKind.ACTIVATION:
															return __assign({}, op);

														case _rpc2.OpKind.REVEAL:
															return __assign(
																__assign(__assign({}, op), getSource(op)),
																getFee(op)
															);

														case _rpc2.OpKind.ORIGINATION:
															return __assign(
																__assign(
																	__assign(__assign({}, op), {
																		balance:
																			typeof op.balance !== 'undefined' ? '' + op.balance : '0'
																	}),
																	getSource(op)
																),
																getFee(op)
															);

														case _rpc2.OpKind.TRANSACTION:
															var cops = __assign(
																__assign(
																	__assign(__assign({}, op), {
																		amount: typeof op.amount !== 'undefined' ? '' + op.amount : '0'
																	}),
																	getSource(op)
																),
																getFee(op)
															);

															if (cops.source.toLowerCase().startsWith('kt1')) {
																throw new Error(
																	'KT1 addresses are not supported as source since ' +
																		Protocols.PsBabyM1
																);
															}

															return cops;

														case _rpc2.OpKind.DELEGATION:
															return __assign(
																__assign(__assign({}, op), getSource(op)),
																getFee(op)
															);

														default:
															throw new Error('Unsupported operation');
													}
												});
											};

											branch = head.hash;
											contents = constructOps(ops);
											protocol = metadata.next_protocol;
											return [
												2,
												/*return*/
												{
													opOb: {
														branch: branch,
														contents: contents,
														protocol: protocol
													},
													counter: counter
												}
											];
									}
								});
							});
						};

						OperationEmitter.prototype.forge = function (_a) {
							var _b = _a.opOb,
								branch = _b.branch,
								contents = _b.contents,
								protocol = _b.protocol,
								counter = _a.counter;
							return __awaiter(this, void 0, void 0, function () {
								var forgedBytes;
								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.context.forger.forge({
													branch: branch,
													contents: contents
												})
											];

										case 1:
											forgedBytes = _c.sent();
											return [
												2,
												/*return*/
												{
													opbytes: forgedBytes,
													opOb: {
														branch: branch,
														contents: contents,
														protocol: protocol
													},
													counter: counter
												}
											];
									}
								});
							});
						};

						OperationEmitter.prototype.simulate = function (op) {
							return __awaiter(this, void 0, void 0, function () {
								var _a;

								return __generator(this, function (_b) {
									switch (_b.label) {
										case 0:
											_a = {};
											return [
												4,
												/*yield*/
												this.rpc.runOperation(op)
											];

										case 1:
											return [
												2,
												/*return*/
												((_a.opResponse = _b.sent()),
												(_a.op = op),
												(_a.context = this.context.clone()),
												_a)
											];
									}
								});
							});
						};

						OperationEmitter.prototype.estimate = function (_a, estimator) {
							var fee = _a.fee,
								gasLimit = _a.gasLimit,
								storageLimit = _a.storageLimit,
								rest = __rest(_a, ['fee', 'gasLimit', 'storageLimit']);

							return __awaiter(this, void 0, void 0, function () {
								var calculatedFee, calculatedGas, calculatedStorage, estimation;
								return __generator(this, function (_b) {
									switch (_b.label) {
										case 0:
											calculatedFee = fee;
											calculatedGas = gasLimit;
											calculatedStorage = storageLimit;
											if (
												!(fee === undefined || gasLimit === undefined || storageLimit === undefined)
											)
												return [3 /*break*/, 2];
											return [
												4,
												/*yield*/
												estimator(
													__assign(
														{
															fee: fee,
															gasLimit: gasLimit,
															storageLimit: storageLimit
														},
														rest
													)
												)
											];

										case 1:
											estimation = _b.sent();

											if (calculatedFee === undefined) {
												calculatedFee = estimation.suggestedFeeMutez;
											}

											if (calculatedGas === undefined) {
												calculatedGas = estimation.gasLimit;
											}

											if (calculatedStorage === undefined) {
												calculatedStorage = estimation.storageLimit;
											}

											_b.label = 2;

										case 2:
											return [
												2,
												/*return*/
												{
													fee: calculatedFee,
													gasLimit: calculatedGas,
													storageLimit: calculatedStorage
												}
											];
									}
								});
							});
						};

						OperationEmitter.prototype.signAndInject = function (forgedBytes) {
							return __awaiter(this, void 0, void 0, function () {
								var signed, opResponse, results, i, j, errors;

								var _a;

								return __generator(this, function (_b) {
									switch (_b.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.signer.sign(forgedBytes.opbytes, new Uint8Array([3]))
											];

										case 1:
											signed = _b.sent();
											forgedBytes.opbytes = signed.sbytes;
											forgedBytes.opOb.signature = signed.prefixSig;
											opResponse = [];
											return [
												4,
												/*yield*/
												this.rpc.preapplyOperations([forgedBytes.opOb])
											];

										case 2:
											results = _b.sent();

											if (!Array.isArray(results)) {
												throw new TezosPreapplyFailureError(results);
											}

											for (i = 0; i < results.length; i++) {
												for (j = 0; j < results[i].contents.length; j++) {
													opResponse.push(results[i].contents[j]);
												}
											}

											errors = flattenErrors(results);

											if (errors.length) {
												// @ts-ignore
												throw new TezosOperationError(errors);
											}

											_a = {};
											return [
												4,
												/*yield*/
												this.context.injector.inject(forgedBytes.opbytes)
											];

										case 3:
											return [
												2,
												/*return*/
												((_a.hash = _b.sent()),
												(_a.forgedBytes = forgedBytes),
												(_a.opResponse = opResponse),
												(_a.context = this.context.clone()),
												_a)
											];
									}
								});
							});
						};

						return OperationEmitter;
					})();

				var BATCH_KINDS = [
					_rpc2.OpKind.ACTIVATION,
					_rpc2.OpKind.ORIGINATION,
					_rpc2.OpKind.TRANSACTION,
					_rpc2.OpKind.DELEGATION
				];

				var OperationBatch =
					/** @class */
					(function (_super) {
						__extends(OperationBatch, _super);

						function OperationBatch(context, estimator) {
							var _this = _super.call(this, context) || this;

							_this.estimator = estimator;
							_this.operations = [];
							return _this;
						}
						/**
						 *
						 * @description Add a transaction operation to the batch
						 *
						 * @param params Transfer operation parameter
						 */

						OperationBatch.prototype.withTransfer = function (params) {
							this.operations.push(
								__assign(
									{
										kind: _rpc2.OpKind.TRANSACTION
									},
									params
								)
							);
							return this;
						};
						/**
						 *
						 * @description Add a transaction operation to the batch
						 *
						 * @param params Transfer operation parameter
						 */

						OperationBatch.prototype.withContractCall = function (params) {
							return this.withTransfer(params.toTransferParams());
						};
						/**
						 *
						 * @description Add a delegation operation to the batch
						 *
						 * @param params Delegation operation parameter
						 */

						OperationBatch.prototype.withDelegation = function (params) {
							this.operations.push(
								__assign(
									{
										kind: _rpc2.OpKind.DELEGATION
									},
									params
								)
							);
							return this;
						};
						/**
						 *
						 * @description Add an activation operation to the batch
						 *
						 * @param params Activation operation parameter
						 */

						OperationBatch.prototype.withActivation = function (_a) {
							var pkh = _a.pkh,
								secret = _a.secret;
							this.operations.push({
								kind: _rpc2.OpKind.ACTIVATION,
								pkh: pkh,
								secret: secret
							});
							return this;
						};
						/**
						 *
						 * @description Add an origination operation to the batch
						 *
						 * @param params Origination operation parameter
						 */

						OperationBatch.prototype.withOrigination = function (params) {
							this.operations.push(
								__assign(
									{
										kind: _rpc2.OpKind.ORIGINATION
									},
									params
								)
							);
							return this;
						};

						OperationBatch.prototype.getRPCOp = function (param) {
							return __awaiter(this, void 0, void 0, function () {
								var _a, _b;

								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											_a = param.kind;

											switch (_a) {
												case _rpc2.OpKind.TRANSACTION:
													return [3 /*break*/, 1];

												case _rpc2.OpKind.ORIGINATION:
													return [3 /*break*/, 2];

												case _rpc2.OpKind.DELEGATION:
													return [3 /*break*/, 4];

												case _rpc2.OpKind.ACTIVATION:
													return [3 /*break*/, 5];
											}

											return [3 /*break*/, 6];

										case 1:
											return [
												2,
												/*return*/
												createTransferOperation(__assign({}, param))
											];

										case 2:
											_b = createOriginationOperation;
											return [
												4,
												/*yield*/
												this.context.parser.prepareCodeOrigination(__assign({}, param))
											];

										case 3:
											return [
												2,
												/*return*/
												_b.apply(void 0, [_c.sent()])
											];

										case 4:
											return [
												2,
												/*return*/
												createSetDelegateOperation(__assign({}, param))
											];

										case 5:
											return [
												2,
												/*return*/
												__assign({}, param)
											];

										case 6:
											throw new Error('Unsupported operation kind: ' + param.kind);
									}
								});
							});
						};
						/**
						 *
						 * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array
						 *
						 * @param params Operations parameter
						 */

						OperationBatch.prototype.with = function (params) {
							var e_1, _a;

							try {
								for (
									var params_1 = __values(params), params_1_1 = params_1.next();
									!params_1_1.done;
									params_1_1 = params_1.next()
								) {
									var param = params_1_1.value;

									switch (param.kind) {
										case _rpc2.OpKind.TRANSACTION:
											this.withTransfer(param);
											break;

										case _rpc2.OpKind.ORIGINATION:
											this.withOrigination(param);
											break;

										case _rpc2.OpKind.DELEGATION:
											this.withDelegation(param);
											break;

										case _rpc2.OpKind.ACTIVATION:
											this.withActivation(param);
											break;

										default:
											throw new Error('Unsupported operation kind: ' + param.kind);
									}
								}
							} catch (e_1_1) {
								e_1 = {
									error: e_1_1
								};
							} finally {
								try {
									if (params_1_1 && !params_1_1.done && (_a = params_1.return)) _a.call(params_1);
								} finally {
									if (e_1) throw e_1.error;
								}
							}

							return this;
						};
						/**
						 *
						 * @description Forge and Inject the operation batch
						 *
						 * @param params Optionally specify the source of the operation
						 */

						OperationBatch.prototype.send = function (params) {
							return __awaiter(this, void 0, void 0, function () {
								var publicKeyHash,
									publicKey,
									estimates,
									revealNeeded,
									i,
									ops,
									_a,
									_b,
									op,
									estimated,
									_c,
									_d,
									e_2_1,
									reveal,
									estimatedReveal,
									_e,
									_f,
									source,
									prepared,
									opBytes,
									_g,
									hash,
									context,
									forgedBytes,
									opResponse;

								var e_2, _h;

								var _this = this;

								return __generator(this, function (_j) {
									switch (_j.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.signer.publicKeyHash()
											];

										case 1:
											publicKeyHash = _j.sent();
											return [
												4,
												/*yield*/
												this.signer.publicKey()
											];

										case 2:
											publicKey = _j.sent();
											return [
												4,
												/*yield*/
												this.estimator.batch(this.operations)
											];

										case 3:
											estimates = _j.sent();
											return [
												4,
												/*yield*/
												this.isRevealOpNeeded(this.operations, publicKeyHash)
											];

										case 4:
											revealNeeded = _j.sent();
											i = revealNeeded ? 1 : 0;
											ops = [];
											_j.label = 5;

										case 5:
											_j.trys.push([5, 13, 14, 15]);

											(_a = __values(this.operations)), (_b = _a.next());
											_j.label = 6;

										case 6:
											if (!!_b.done) return [3 /*break*/, 12];
											op = _b.value;
											if (!isOpWithFee(op)) return [3 /*break*/, 9];
											return [
												4,
												/*yield*/
												this.estimate(op, function () {
													return __awaiter(_this, void 0, void 0, function () {
														return __generator(this, function (_a) {
															return [
																2,
																/*return*/
																estimates[i]
															];
														});
													});
												})
											];

										case 7:
											estimated = _j.sent();
											_d = (_c = ops).push;
											return [
												4,
												/*yield*/
												this.getRPCOp(__assign(__assign({}, op), estimated))
											];

										case 8:
											_d.apply(_c, [_j.sent()]);

											return [3 /*break*/, 10];

										case 9:
											ops.push(__assign({}, op));
											_j.label = 10;

										case 10:
											i++;
											_j.label = 11;

										case 11:
											_b = _a.next();
											return [3 /*break*/, 6];

										case 12:
											return [3 /*break*/, 15];

										case 13:
											e_2_1 = _j.sent();
											e_2 = {
												error: e_2_1
											};
											return [3 /*break*/, 15];

										case 14:
											try {
												if (_b && !_b.done && (_h = _a.return)) _h.call(_a);
											} finally {
												if (e_2) throw e_2.error;
											}

											return [
												7
												/*endfinally*/
											];

										case 15:
											if (!revealNeeded) return [3 /*break*/, 18];
											reveal = {
												kind: _rpc2.OpKind.REVEAL
											};
											return [
												4,
												/*yield*/
												this.estimate(reveal, function () {
													return __awaiter(_this, void 0, void 0, function () {
														return __generator(this, function (_a) {
															return [
																2,
																/*return*/
																estimates[0]
															];
														});
													});
												})
											];

										case 16:
											estimatedReveal = _j.sent();
											_f = (_e = ops).unshift;
											return [
												4,
												/*yield*/
												createRevealOperation(
													__assign({}, estimatedReveal),
													publicKeyHash,
													publicKey
												)
											];

										case 17:
											_f.apply(_e, [_j.sent()]);

											_j.label = 18;

										case 18:
											source = (params && params.source) || publicKeyHash;
											return [
												4,
												/*yield*/
												this.prepareOperation({
													operation: ops,
													source: source
												})
											];

										case 19:
											prepared = _j.sent();
											return [
												4,
												/*yield*/
												this.forge(prepared)
											];

										case 20:
											opBytes = _j.sent();
											return [
												4,
												/*yield*/
												this.signAndInject(opBytes)
											];

										case 21:
											(_g = _j.sent()),
												(hash = _g.hash),
												(context = _g.context),
												(forgedBytes = _g.forgedBytes),
												(opResponse = _g.opResponse);
											return [
												2,
												/*return*/
												new BatchOperation(hash, ops, source, forgedBytes, opResponse, context)
											];
									}
								});
							});
						};

						return OperationBatch;
					})(OperationEmitter);

				exports.OperationBatch = OperationBatch;

				var RPCBatchProvider =
					/** @class */
					(function () {
						function RPCBatchProvider(context, estimator) {
							this.context = context;
							this.estimator = estimator;
						}
						/***
						 *
						 * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch
						 *
						 * @param params List of operation to batch together
						 */

						RPCBatchProvider.prototype.batch = function (params) {
							var batch = new OperationBatch(this.context, this.estimator);

							if (Array.isArray(params)) {
								batch.with(params);
							}

							return batch;
						};

						return RPCBatchProvider;
					})();

				var receiptFromOperation = function (op, _a) {
					var _b =
							_a === void 0
								? {
										ALLOCATION_BURN: 257,
										ORIGINATION_BURN: 257
								  }
								: _a,
						ALLOCATION_BURN = _b.ALLOCATION_BURN,
						ORIGINATION_BURN = _b.ORIGINATION_BURN;

					var operationResults = flattenOperationResult({
						contents: op
					});
					var totalGas = new _bignumber.default(0);
					var totalStorage = new _bignumber.default(0);
					var totalFee = new _bignumber.default(0);
					var totalOriginationBurn = new _bignumber.default(0);
					var totalAllocationBurn = new _bignumber.default(0);
					var totalPaidStorageDiff = new _bignumber.default(0);
					operationResults.forEach(function (result) {
						totalFee = totalFee.plus(result.fee || 0);
						totalOriginationBurn = totalOriginationBurn.plus(
							Array.isArray(result.originated_contracts)
								? result.originated_contracts.length * ORIGINATION_BURN
								: 0
						);
						totalAllocationBurn = totalAllocationBurn.plus(
							'allocated_destination_contract' in result ? ALLOCATION_BURN : 0
						);
						totalGas = totalGas.plus(result.consumed_gas || 0);
						totalPaidStorageDiff = totalPaidStorageDiff.plus(
							'paid_storage_size_diff' in result ? Number(result.paid_storage_size_diff) || 0 : 0
						);
					});
					totalStorage = totalStorage
						.plus(totalAllocationBurn)
						.plus(totalOriginationBurn)
						.plus(totalPaidStorageDiff);
					return {
						totalFee: totalFee,
						totalGas: totalGas,
						totalStorage: totalStorage,
						totalAllocationBurn: totalAllocationBurn,
						totalOriginationBurn: totalOriginationBurn,
						totalPaidStorageDiff: totalPaidStorageDiff,
						totalStorageBurn: new _bignumber.default(totalStorage.multipliedBy(1000))
					};
				};

				var MissedBlockDuringConfirmationError =
					/** @class */
					(function () {
						function MissedBlockDuringConfirmationError() {
							this.name = 'MissedBlockDuringConfirmationError';
							this.message =
								'Taquito missed a block while waiting for operation confirmation and was not able to find the operation';
						}

						return MissedBlockDuringConfirmationError;
					})();

				exports.MissedBlockDuringConfirmationError = MissedBlockDuringConfirmationError;
				var MAX_BRANCH_ANCESTORS = 60;
				/**
				 * @description WalletOperation allows to monitor operation inclusion on chains and surface information related to the operation
				 */

				var WalletOperation =
					/** @class */
					(function () {
						/**
						 *
						 * @param opHash Operation hash
						 * @param raw Raw operation that was injected
						 * @param context Taquito context allowing access to rpc and signer
						 */
						function WalletOperation(opHash, context, _newHead$) {
							var _this = this;

							this.opHash = opHash;
							this.context = context;
							this._newHead$ = _newHead$;
							this._operationResult = new _rxjs.ReplaySubject(1);
							this._includedInBlock = new _rxjs.ReplaySubject(1);
							this._included = false;
							this.newHead$ = this._newHead$.pipe(
								(0, _operators.tap)(function (newHead) {
									if (
										!_this._included &&
										_this.lastHead &&
										newHead.header.level - _this.lastHead.header.level > 1
									) {
										throw new MissedBlockDuringConfirmationError();
									}

									_this.lastHead = newHead;
								}),
								(0, _operators.shareReplay)({
									bufferSize: 1,
									refCount: true
								})
							); // Observable that emit once operation is seen in a block

							this.confirmed$ = this.newHead$.pipe(
								(0, _operators.map)(function (head) {
									var e_1, _a, e_2, _b;

									try {
										for (
											var _c = __values(head.operations), _d = _c.next();
											!_d.done;
											_d = _c.next()
										) {
											var opGroup = _d.value;

											try {
												for (
													var opGroup_1 = ((e_2 = void 0), __values(opGroup)),
														opGroup_1_1 = opGroup_1.next();
													!opGroup_1_1.done;
													opGroup_1_1 = opGroup_1.next()
												) {
													var op = opGroup_1_1.value;

													if (op.hash === _this.opHash) {
														_this._included = true;

														_this._includedInBlock.next(head);

														_this._operationResult.next(op.contents); // Return the block where the operation was found

														return head;
													}
												}
											} catch (e_2_1) {
												e_2 = {
													error: e_2_1
												};
											} finally {
												try {
													if (opGroup_1_1 && !opGroup_1_1.done && (_b = opGroup_1.return))
														_b.call(opGroup_1);
												} finally {
													if (e_2) throw e_2.error;
												}
											}
										}
									} catch (e_1_1) {
										e_1 = {
											error: e_1_1
										};
									} finally {
										try {
											if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
										} finally {
											if (e_1) throw e_1.error;
										}
									}
								}),
								(0, _operators.filter)(function (x) {
									return typeof x !== 'undefined';
								}),
								(0, _operators.first)(),
								(0, _operators.shareReplay)({
									bufferSize: 1,
									refCount: true
								})
							);
							this.confirmed$
								.pipe(
									(0, _operators.first)(),
									(0, _operators.catchError)(function () {
										return (0, _rxjs.of)(undefined);
									})
								)
								.subscribe();
						}

						WalletOperation.prototype.operationResults = function () {
							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_a) {
									return [
										2,
										/*return*/
										this._operationResult.pipe((0, _operators.first)()).toPromise()
									];
								});
							});
						};
						/**
						 * @description Receipt expose the total amount of tezos token burn and spent on fees
						 * The promise returned by receipt will resolve only once the transaction is included
						 */

						WalletOperation.prototype.receipt = function () {
							return __awaiter(this, void 0, void 0, function () {
								var _a;

								return __generator(this, function (_b) {
									switch (_b.label) {
										case 0:
											_a = receiptFromOperation;
											return [
												4,
												/*yield*/
												this.operationResults()
											];

										case 1:
											return [
												2,
												/*return*/
												_a.apply(void 0, [_b.sent()])
											];
									}
								});
							});
						};

						WalletOperation.prototype.getCurrentConfirmation = function () {
							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_a) {
									if (!this._included) {
										return [2 /*return*/, 0];
									}

									return [
										2,
										/*return*/
										(0, _rxjs.combineLatest)([
											this._includedInBlock,
											(0, _rxjs.from)(this.context.rpc.getBlock())
										])
											.pipe(
												(0, _operators.map)(function (_a) {
													var _b = __read(_a, 2),
														foundAtBlock = _b[0],
														head = _b[1];

													return head.header.level - foundAtBlock.header.level + 1;
												}),
												(0, _operators.first)()
											)
											.toPromise()
									];
								});
							});
						};

						WalletOperation.prototype.isInCurrentBranch = function (tipBlockIdentifier) {
							if (tipBlockIdentifier === void 0) {
								tipBlockIdentifier = 'head';
							}

							return __awaiter(this, void 0, void 0, function () {
								var tipBlockHeader, inclusionBlock, levelDiff, tipBlockLevel, blocks, _a;

								return __generator(this, function (_b) {
									switch (_b.label) {
										case 0:
											// By default it is assumed that the operation is in the current branch
											if (!this._included) {
												return [
													2,
													/*return*/
													true
												];
											}

											return [
												4,
												/*yield*/
												this.context.rpc.getBlockHeader({
													block: tipBlockIdentifier
												})
											];

										case 1:
											tipBlockHeader = _b.sent();
											return [
												4,
												/*yield*/
												this._includedInBlock.pipe((0, _operators.first)()).toPromise()
											];

										case 2:
											inclusionBlock = _b.sent();
											levelDiff = tipBlockHeader.level - inclusionBlock.header.level; // Block produced before the operation is included are assumed to be part of the current branch

											if (levelDiff <= 0) {
												return [
													2,
													/*return*/
													true
												];
											}

											tipBlockLevel = Math.min(
												inclusionBlock.header.level + levelDiff,
												inclusionBlock.header.level + MAX_BRANCH_ANCESTORS
											);
											_a = Set.bind;
											return [
												4,
												/*yield*/
												this.context.rpc.getLiveBlocks({
													block: String(tipBlockLevel)
												})
											];

										case 3:
											blocks = new (_a.apply(Set, [void 0, _b.sent()]))();
											return [
												2,
												/*return*/
												blocks.has(inclusionBlock.hash)
											];
									}
								});
							});
						};

						WalletOperation.prototype.confirmationObservable = function (confirmations) {
							var _this = this;

							if (typeof confirmations !== 'undefined' && confirmations < 1) {
								throw new Error('Confirmation count must be at least 1');
							}

							var defaultConfirmationCount = this.context.config.defaultConfirmationCount;
							var conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;

							if (conf === undefined) {
								throw new Error('Default confirmation count can not be undefined!');
							}

							return (0, _rxjs.combineLatest)([this._includedInBlock, this.newHead$]).pipe(
								(0, _operators.distinctUntilChanged)(function (_a, _b) {
									var _c = __read(_a, 2),
										previousHead = _c[1];

									var _d = __read(_b, 2),
										newHead = _d[1];

									return previousHead.hash === newHead.hash;
								}),
								(0, _operators.map)(function (_a) {
									var _b = __read(_a, 2),
										foundAtBlock = _b[0],
										head = _b[1];

									return {
										block: head,
										expectedConfirmation: conf,
										currentConfirmation: head.header.level - foundAtBlock.header.level + 1,
										completed: head.header.level - foundAtBlock.header.level >= conf - 1,
										isInCurrentBranch: function () {
											return _this.isInCurrentBranch(head.hash);
										}
									};
								}),
								(0, _operators.takeWhile)(function (_a) {
									var completed = _a.completed;
									return !completed;
								}, true)
							);
						};
						/**
						 *
						 * @param confirmations [0] Number of confirmation to wait for
						 */

						WalletOperation.prototype.confirmation = function (confirmations) {
							return this.confirmationObservable(confirmations).toPromise();
						};

						return WalletOperation;
					})();

				exports.WalletOperation = WalletOperation;

				var BatchWalletOperation =
					/** @class */
					(function (_super) {
						__extends(BatchWalletOperation, _super);

						function BatchWalletOperation(opHash, context, newHead$) {
							var _this = _super.call(this, opHash, context, newHead$) || this;

							_this.opHash = opHash;
							_this.context = context;
							return _this;
						}

						BatchWalletOperation.prototype.revealOperation = function () {
							return __awaiter(this, void 0, void 0, function () {
								var operationResult;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.operationResults()
											];

										case 1:
											operationResult = _a.sent();
											return [
												2,
												/*return*/
												operationResult.find(function (x) {
													return x.kind === _rpc2.OpKind.REVEAL;
												})
											];
									}
								});
							});
						};

						BatchWalletOperation.prototype.status = function () {
							return __awaiter(this, void 0, void 0, function () {
								var op;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											if (!this._included) {
												return [
													2,
													/*return*/
													'pending'
												];
											}

											return [
												4,
												/*yield*/
												this.operationResults()
											];

										case 1:
											op = _a.sent();
											return [
												2,
												/*return*/
												op
													.filter(function (result) {
														return BATCH_KINDS.indexOf(result.kind) !== -1;
													})
													.map(function (result) {
														if (hasMetadataWithResult(result)) {
															return result.metadata.operation_result.status;
														} else {
															return 'unknown';
														}
													})[0] || 'unknown'
											];
									}
								});
							});
						};

						return BatchWalletOperation;
					})(WalletOperation);

				var DelegationWalletOperation =
					/** @class */
					(function (_super) {
						__extends(DelegationWalletOperation, _super);

						function DelegationWalletOperation(opHash, context, newHead$) {
							var _this = _super.call(this, opHash, context, newHead$) || this;

							_this.opHash = opHash;
							_this.context = context;
							return _this;
						}

						DelegationWalletOperation.prototype.revealOperation = function () {
							return __awaiter(this, void 0, void 0, function () {
								var operationResult;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.operationResults()
											];

										case 1:
											operationResult = _a.sent();
											return [
												2,
												/*return*/
												operationResult.find(function (x) {
													return x.kind === _rpc2.OpKind.REVEAL;
												})
											];
									}
								});
							});
						};

						DelegationWalletOperation.prototype.delegationOperation = function () {
							return __awaiter(this, void 0, void 0, function () {
								var operationResult;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.operationResults()
											];

										case 1:
											operationResult = _a.sent();
											return [
												2,
												/*return*/
												operationResult.find(function (x) {
													return x.kind === _rpc2.OpKind.DELEGATION;
												})
											];
									}
								});
							});
						};

						DelegationWalletOperation.prototype.status = function () {
							return __awaiter(this, void 0, void 0, function () {
								var op;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											if (!this._included) {
												return [
													2,
													/*return*/
													'pending'
												];
											}

											return [
												4,
												/*yield*/
												this.delegationOperation()
											];

										case 1:
											op = _a.sent();

											if (!op) {
												return [
													2,
													/*return*/
													'unknown'
												];
											}

											return [
												2,
												/*return*/
												op.metadata.operation_result.status
											];
									}
								});
							});
						};

						return DelegationWalletOperation;
					})(WalletOperation);

				exports.DelegationWalletOperation = DelegationWalletOperation;

				var OriginationWalletOperation =
					/** @class */
					(function (_super) {
						__extends(OriginationWalletOperation, _super);

						function OriginationWalletOperation(opHash, context, newHead$) {
							var _this = _super.call(this, opHash, context, newHead$) || this;

							_this.opHash = opHash;
							_this.context = context;
							return _this;
						}

						OriginationWalletOperation.prototype.originationOperation = function () {
							return __awaiter(this, void 0, void 0, function () {
								var operationResult;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.operationResults()
											];

										case 1:
											operationResult = _a.sent();
											return [
												2,
												/*return*/
												findWithKind(operationResult, _rpc2.OpKind.ORIGINATION)
											];
									}
								});
							});
						};

						OriginationWalletOperation.prototype.revealOperation = function () {
							return __awaiter(this, void 0, void 0, function () {
								var operationResult;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.operationResults()
											];

										case 1:
											operationResult = _a.sent();
											return [
												2,
												/*return*/
												findWithKind(operationResult, _rpc2.OpKind.REVEAL)
											];
									}
								});
							});
						};

						OriginationWalletOperation.prototype.status = function () {
							return __awaiter(this, void 0, void 0, function () {
								var op;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											if (!this._included) {
												return [
													2,
													/*return*/
													'pending'
												];
											}

											return [
												4,
												/*yield*/
												this.originationOperation()
											];

										case 1:
											op = _a.sent();

											if (!op) {
												return [
													2,
													/*return*/
													'unknown'
												];
											}

											return [
												2,
												/*return*/
												op.metadata.operation_result.status
											];
									}
								});
							});
						};

						OriginationWalletOperation.prototype.contract = function () {
							return __awaiter(this, void 0, void 0, function () {
								var op, address;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.originationOperation()
											];

										case 1:
											op = _a.sent();
											address = (op.metadata.operation_result.originated_contracts || [])[0];
											return [
												2,
												/*return*/
												this.context.wallet.at(address)
											];
									}
								});
							});
						};

						return OriginationWalletOperation;
					})(WalletOperation);

				exports.OriginationWalletOperation = OriginationWalletOperation;

				var TransactionWalletOperation =
					/** @class */
					(function (_super) {
						__extends(TransactionWalletOperation, _super);

						function TransactionWalletOperation(opHash, context, newHead$) {
							var _this = _super.call(this, opHash, context, newHead$) || this;

							_this.opHash = opHash;
							_this.context = context;
							return _this;
						}

						TransactionWalletOperation.prototype.revealOperation = function () {
							return __awaiter(this, void 0, void 0, function () {
								var operationResult;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.operationResults()
											];

										case 1:
											operationResult = _a.sent();
											return [
												2,
												/*return*/
												operationResult.find(function (x) {
													return x.kind === _rpc2.OpKind.REVEAL;
												})
											];
									}
								});
							});
						};

						TransactionWalletOperation.prototype.transactionOperation = function () {
							return __awaiter(this, void 0, void 0, function () {
								var operationResult;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.operationResults()
											];

										case 1:
											operationResult = _a.sent();
											return [
												2,
												/*return*/
												operationResult.find(function (x) {
													return x.kind === _rpc2.OpKind.TRANSACTION;
												})
											];
									}
								});
							});
						};

						TransactionWalletOperation.prototype.status = function () {
							return __awaiter(this, void 0, void 0, function () {
								var op;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											if (!this._included) {
												return [
													2,
													/*return*/
													'pending'
												];
											}

											return [
												4,
												/*yield*/
												this.transactionOperation()
											];

										case 1:
											op = _a.sent();

											if (!op) {
												return [
													2,
													/*return*/
													'unknown'
												];
											}

											return [
												2,
												/*return*/
												op.metadata.operation_result.status
											];
									}
								});
							});
						};

						return TransactionWalletOperation;
					})(WalletOperation);

				exports.TransactionWalletOperation = TransactionWalletOperation;

				var cacheUntil = function (cacheUntilObs) {
					return function (source) {
						var subject = null;
						return (0, _rxjs.defer)(function () {
							if (!subject) {
								subject = new _rxjs.ReplaySubject();
								source.pipe((0, _operators.first)()).subscribe(subject);
								cacheUntilObs.pipe((0, _operators.first)()).subscribe(function () {
									subject = null;
								});
							}

							return subject;
						});
					};
				};

				var createNewPollingBasedHeadObservable = function (
					pollingTimer,
					sharedHeadOb,
					context,
					scheduler
				) {
					return pollingTimer.pipe(
						(0, _operators.switchMap)(function () {
							return sharedHeadOb;
						}),
						(0, _operators.distinctUntilKeyChanged)('hash'),
						(0, _operators.timeoutWith)(
							context.config.confirmationPollingTimeoutSecond * 1000,
							(0, _rxjs.throwError)(new Error('Confirmation polling timed out')),
							scheduler
						),
						(0, _operators.shareReplay)({
							refCount: true,
							scheduler: scheduler
						})
					);
				};

				var OperationFactory =
					/** @class */
					(function () {
						function OperationFactory(context) {
							var _this = this;

							this.context = context; // Cache the last block for one second across all operations

							this.sharedHeadObs = (0, _rxjs.defer)(function () {
								return (0, _rxjs.from)(_this.context.rpc.getBlock());
							}).pipe(cacheUntil((0, _rxjs.timer)(0, 1000)));
						}

						OperationFactory.prototype.createNewHeadObservable = function () {
							return __awaiter(this, void 0, void 0, function () {
								var confirmationPollingIntervalSecond, _a;

								return __generator(this, function (_b) {
									switch (_b.label) {
										case 0:
											if (!(this.context.config.confirmationPollingIntervalSecond !== undefined))
												return [3 /*break*/, 1];
											_a = this.context.config.confirmationPollingIntervalSecond;
											return [3 /*break*/, 3];

										case 1:
											return [
												4,
												/*yield*/
												this.context.getConfirmationPollingInterval()
											];

										case 2:
											_a = _b.sent();
											_b.label = 3;

										case 3:
											confirmationPollingIntervalSecond = _a;
											return [
												2,
												/*return*/
												createNewPollingBasedHeadObservable(
													(0, _rxjs.timer)(0, confirmationPollingIntervalSecond * 1000),
													this.sharedHeadObs,
													this.context
												)
											];
									}
								});
							});
						};

						OperationFactory.prototype.createPastBlockWalker = function (startBlock, count) {
							var _this = this;

							if (count === void 0) {
								count = 1;
							}

							return (0, _rxjs.from)(
								this.context.rpc.getBlock({
									block: startBlock
								})
							).pipe(
								(0, _operators.switchMap)(function (block) {
									if (count === 1) {
										return (0, _rxjs.of)(block);
									}

									return (0, _rxjs.range)(block.header.level, count - 1).pipe(
										(0, _operators.startWith)(block),
										(0, _operators.concatMap)(function (level) {
											return __awaiter(_this, void 0, void 0, function () {
												return __generator(this, function (_a) {
													return [
														2,
														/*return*/
														this.context.rpc.getBlock({
															block: String(level)
														})
													];
												});
											});
										})
									);
								})
							);
						};

						OperationFactory.prototype.createHeadObservableFromConfig = function (_a) {
							var blockIdentifier = _a.blockIdentifier;
							return __awaiter(this, void 0, void 0, function () {
								var observableSequence, _b, _c;

								return __generator(this, function (_d) {
									switch (_d.label) {
										case 0:
											observableSequence = [];

											if (blockIdentifier) {
												observableSequence.push(this.createPastBlockWalker(blockIdentifier));
											}

											_c = (_b = observableSequence).push;
											return [
												4,
												/*yield*/
												this.createNewHeadObservable()
											];

										case 1:
											_c.apply(_b, [_d.sent()]);

											return [
												2,
												/*return*/
												_rxjs.concat.apply(void 0, __spreadArray([], __read(observableSequence)))
											];
									}
								});
							});
						};

						OperationFactory.prototype.createOperation = function (hash, config) {
							if (config === void 0) {
								config = {};
							}

							return __awaiter(this, void 0, void 0, function () {
								var _a, _b;

								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											_a = WalletOperation.bind;
											_b = [void 0, hash, this.context.clone()];
											return [
												4,
												/*yield*/
												this.createHeadObservableFromConfig(config)
											];

										case 1:
											return [
												2,
												/*return*/
												new (_a.apply(WalletOperation, _b.concat([_c.sent()])))()
											];
									}
								});
							});
						};

						OperationFactory.prototype.createBatchOperation = function (hash, config) {
							if (config === void 0) {
								config = {};
							}

							return __awaiter(this, void 0, void 0, function () {
								var _a, _b;

								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											_a = BatchWalletOperation.bind;
											_b = [void 0, hash, this.context.clone()];
											return [
												4,
												/*yield*/
												this.createHeadObservableFromConfig(config)
											];

										case 1:
											return [
												2,
												/*return*/
												new (_a.apply(BatchWalletOperation, _b.concat([_c.sent()])))()
											];
									}
								});
							});
						};

						OperationFactory.prototype.createTransactionOperation = function (hash, config) {
							if (config === void 0) {
								config = {};
							}

							return __awaiter(this, void 0, void 0, function () {
								var _a, _b;

								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											_a = TransactionWalletOperation.bind;
											_b = [void 0, hash, this.context.clone()];
											return [
												4,
												/*yield*/
												this.createHeadObservableFromConfig(config)
											];

										case 1:
											return [
												2,
												/*return*/
												new (_a.apply(TransactionWalletOperation, _b.concat([_c.sent()])))()
											];
									}
								});
							});
						};

						OperationFactory.prototype.createDelegationOperation = function (hash, config) {
							if (config === void 0) {
								config = {};
							}

							return __awaiter(this, void 0, void 0, function () {
								var _a, _b;

								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											_a = DelegationWalletOperation.bind;
											_b = [void 0, hash, this.context.clone()];
											return [
												4,
												/*yield*/
												this.createHeadObservableFromConfig(config)
											];

										case 1:
											return [
												2,
												/*return*/
												new (_a.apply(DelegationWalletOperation, _b.concat([_c.sent()])))()
											];
									}
								});
							});
						};

						OperationFactory.prototype.createOriginationOperation = function (hash, config) {
							if (config === void 0) {
								config = {};
							}

							return __awaiter(this, void 0, void 0, function () {
								var _a, _b;

								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											_a = OriginationWalletOperation.bind;
											_b = [void 0, hash, this.context.clone()];
											return [
												4,
												/*yield*/
												this.createHeadObservableFromConfig(config)
											];

										case 1:
											return [
												2,
												/*return*/
												new (_a.apply(OriginationWalletOperation, _b.concat([_c.sent()])))()
											];
									}
								});
							});
						};

						return OperationFactory;
					})();

				var RpcTzProvider =
					/** @class */
					(function (_super) {
						__extends(RpcTzProvider, _super);

						function RpcTzProvider(context) {
							return _super.call(this, context) || this;
						}

						RpcTzProvider.prototype.getBalance = function (address) {
							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_a) {
									return [
										2,
										/*return*/
										this.rpc.getBalance(address)
									];
								});
							});
						};

						RpcTzProvider.prototype.getDelegate = function (address) {
							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_a) {
									return [
										2,
										/*return*/
										this.rpc.getDelegate(address)
									];
								});
							});
						};

						RpcTzProvider.prototype.activate = function (pkh, secret) {
							return __awaiter(this, void 0, void 0, function () {
								var operation, prepared, forgedBytes, bytes, _a;

								return __generator(this, function (_b) {
									switch (_b.label) {
										case 0:
											operation = {
												kind: _rpc2.OpKind.ACTIVATION,
												pkh: pkh,
												secret: secret
											};
											return [
												4,
												/*yield*/
												this.prepareOperation({
													operation: [operation],
													source: pkh
												})
											];

										case 1:
											prepared = _b.sent();
											return [
												4,
												/*yield*/
												this.forge(prepared)
											];

										case 2:
											forgedBytes = _b.sent();
											bytes =
												forgedBytes.opbytes +
												'00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';
											_a = Operation.bind;
											return [
												4,
												/*yield*/
												this.rpc.injectOperation(bytes)
											];

										case 3:
											return [
												2,
												/*return*/
												new (_a.apply(Operation, [
													void 0,
													_b.sent(),
													__assign(__assign({}, forgedBytes), {
														opbytes: bytes
													}),
													[],
													this.context.clone()
												]))()
											];
									}
								});
							});
						};

						return RpcTzProvider;
					})(OperationEmitter);

				var MINIMAL_FEE_MUTEZ = 100;
				var MINIMAL_FEE_PER_BYTE_MUTEZ = 1;
				var MINIMAL_FEE_PER_GAS_MUTEZ = 0.1;
				var GAS_BUFFER = 100;
				/**
				 * Examples of use :
				 *
				 *  Estimate a transfer operation :
				 * ```
				 * // Assuming that provider and signer are already configured...
				 *
				 * const amount = 2;
				 * const address = 'tz1h3rQ8wBxFd8L9B3d7Jhaawu6Z568XU3xY';
				 *
				 * // Estimate gasLimit, storageLimit and fees for a transfer operation
				 * const est = await Tezos.estimate.transfer({ to: address, amount: amount })
				 * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,
				 *  est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)
				 *
				 * ```
				 *
				 * Estimate a contract origination :
				 * ```
				 * // generic.json is referring to a Michelson Smart Contract
				 *
				 * const genericMultisigJSON = require('./generic.json')
				 * const est = await Tezos.estimate.originate({
				 *   code: genericMultisigJSON,
				 *   storage: {
				 *     stored_counter: 0,
				 *     threshold: 1,
				 *     keys: ['edpkuLxx9PQD8fZ45eUzrK3BhfDZJHhBuK4Zi49DcEGANwd2rpX82t']
				 *   }
				 * })
				 * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,
				 *   est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)
				 *
				 * ```
				 */

				var Estimate =
					/** @class */
					(function () {
						function Estimate(
							_milligasLimit,
							_storageLimit,
							opSize,
							minimalFeePerStorageByteMutez,
							/**
							 * @description Base fee in mutez (1 mutez = 1e10−6 tez)
							 */
							baseFeeMutez
						) {
							if (baseFeeMutez === void 0) {
								baseFeeMutez = MINIMAL_FEE_MUTEZ;
							}

							this._milligasLimit = _milligasLimit;
							this._storageLimit = _storageLimit;
							this.opSize = opSize;
							this.minimalFeePerStorageByteMutez = minimalFeePerStorageByteMutez;
							this.baseFeeMutez = baseFeeMutez;
						}

						Object.defineProperty(Estimate.prototype, 'burnFeeMutez', {
							/**
							 * @description The number of Mutez that will be burned for the storage of the [operation](https://tezos.gitlab.io/user/glossary.html#operations). (Storage + Allocation fees)
							 */
							get: function () {
								return this.roundUp(
									Number(this.storageLimit) * Number(this.minimalFeePerStorageByteMutez)
								);
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(Estimate.prototype, 'storageLimit', {
							/**
							 * @description  The limit on the amount of storage an [operation](https://tezos.gitlab.io/user/glossary.html#operations) can use.
							 */
							get: function () {
								var limit = Math.max(Number(this._storageLimit), 0);
								return limit > 0 ? limit : 0;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(Estimate.prototype, 'gasLimit', {
							/**
							 * @description The limit on the amount of [gas](https://tezos.gitlab.io/user/glossary.html#gas) a given operation can consume.
							 */
							get: function () {
								return this.roundUp(Number(this._milligasLimit) / 1000 + GAS_BUFFER);
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(Estimate.prototype, 'operationFeeMutez', {
							get: function () {
								return (
									(Number(this._milligasLimit) / 1000 + GAS_BUFFER) * MINIMAL_FEE_PER_GAS_MUTEZ +
									Number(this.opSize) * MINIMAL_FEE_PER_BYTE_MUTEZ
								);
							},
							enumerable: false,
							configurable: true
						});

						Estimate.prototype.roundUp = function (nanotez) {
							return Math.ceil(Number(nanotez));
						};

						Object.defineProperty(Estimate.prototype, 'minimalFeeMutez', {
							/**
							 * @description Minimum fees for the [operation](https://tezos.gitlab.io/user/glossary.html#operations) according to [baker](https://tezos.gitlab.io/user/glossary.html#baker) defaults.
							 */
							get: function () {
								return this.roundUp(MINIMAL_FEE_MUTEZ + this.operationFeeMutez);
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(Estimate.prototype, 'suggestedFeeMutez', {
							/**
							 * @description The suggested fee for the operation which includes minimal fees and a small buffer.
							 */
							get: function () {
								return this.roundUp(this.operationFeeMutez + MINIMAL_FEE_MUTEZ * 2);
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(Estimate.prototype, 'usingBaseFeeMutez', {
							/**
							 * @description Fees according to your specified base fee will ensure that at least minimum fees are used.
							 */
							get: function () {
								return (
									Math.max(Number(this.baseFeeMutez), MINIMAL_FEE_MUTEZ) +
									this.roundUp(this.operationFeeMutez)
								);
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(Estimate.prototype, 'totalCost', {
							/**
							 * @description The sum of `minimalFeeMutez` + `burnFeeMutez`.
							 */
							get: function () {
								return this.minimalFeeMutez + this.burnFeeMutez;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(Estimate.prototype, 'consumedMilligas', {
							/**
							 * @description Since Delphinet, consumed gas is provided in milligas for more precision.
							 * This function returns an estimation of the gas that operation will consume in milligas.
							 */
							get: function () {
								return Number(this._milligasLimit);
							},
							enumerable: false,
							configurable: true
						});

						Estimate.createEstimateInstanceFromProperties = function (estimateProperties) {
							var milligasLimit = 0;
							var storageLimit = 0;
							var opSize = 0;
							var minimalFeePerStorageByteMutez = 0;
							var baseFeeMutez;
							estimateProperties.forEach(function (estimate) {
								milligasLimit += estimate.milligasLimit;
								storageLimit += estimate.storageLimit;
								opSize += estimate.opSize;
								minimalFeePerStorageByteMutez = Math.max(
									estimate.minimalFeePerStorageByteMutez,
									minimalFeePerStorageByteMutez
								);

								if (estimate.baseFeeMutez) {
									baseFeeMutez = baseFeeMutez
										? baseFeeMutez + estimate.baseFeeMutez
										: estimate.baseFeeMutez;
								}
							});
							return new Estimate(
								milligasLimit,
								storageLimit,
								opSize,
								minimalFeePerStorageByteMutez,
								baseFeeMutez
							);
						};

						Estimate.createArrayEstimateInstancesFromProperties = function (estimateProperties) {
							return estimateProperties.map(function (x) {
								return new Estimate(
									x.milligasLimit,
									x.storageLimit,
									x.opSize,
									x.minimalFeePerStorageByteMutez,
									x.baseFeeMutez
								);
							});
						};

						return Estimate;
					})();

				var mergeLimits = function (userDefinedLimit, defaultLimits) {
					return {
						fee:
							typeof userDefinedLimit.fee === 'undefined'
								? defaultLimits.fee
								: userDefinedLimit.fee,
						gasLimit:
							typeof userDefinedLimit.gasLimit === 'undefined'
								? defaultLimits.gasLimit
								: userDefinedLimit.gasLimit,
						storageLimit:
							typeof userDefinedLimit.storageLimit === 'undefined'
								? defaultLimits.storageLimit
								: userDefinedLimit.storageLimit
					};
				}; // RPC requires a signature but does not verify it

				var SIGNATURE_STUB =
					'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg';

				var RPCEstimateProvider =
					/** @class */
					(function (_super) {
						__extends(RPCEstimateProvider, _super);

						function RPCEstimateProvider() {
							var _this = (_super !== null && _super.apply(this, arguments)) || this;

							_this.ALLOCATION_STORAGE = 257;
							_this.ORIGINATION_STORAGE = 257;
							_this.OP_SIZE_REVEAL = 128;
							return _this;
						} // Maximum values defined by the protocol

						RPCEstimateProvider.prototype.getAccountLimits = function (
							pkh,
							constants,
							numberOfOps
						) {
							return __awaiter(this, void 0, void 0, function () {
								var balance,
									hard_gas_limit_per_operation,
									hard_gas_limit_per_block,
									hard_storage_limit_per_operation,
									cost_per_byte;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.rpc.getBalance(pkh)
											];

										case 1:
											balance = _a.sent();
											(hard_gas_limit_per_operation = constants.hard_gas_limit_per_operation),
												(hard_gas_limit_per_block = constants.hard_gas_limit_per_block),
												(hard_storage_limit_per_operation =
													constants.hard_storage_limit_per_operation),
												(cost_per_byte = constants.cost_per_byte);
											return [
												2,
												/*return*/
												{
													fee: 0,
													gasLimit: numberOfOps
														? Math.floor(
																this.ajustGasForBatchOperation(
																	hard_gas_limit_per_block,
																	hard_gas_limit_per_operation,
																	numberOfOps
																).toNumber()
														  )
														: hard_gas_limit_per_operation.toNumber(),
													storageLimit: Math.floor(
														_bignumber.default
															.min(
																balance.dividedBy(cost_per_byte),
																hard_storage_limit_per_operation
															)
															.toNumber()
													)
												}
											];
									}
								});
							});
						}; // Fix for Granada where the total gasLimit of a batch can not exceed the hard_gas_limit_per_block.
						// If the total gasLimit of the batch is higher than the hard_gas_limit_per_block,
						// the gasLimit is calculated by dividing the hard_gas_limit_per_block by the number of operation in the batch (numberOfOps).
						// numberOfOps is incremented by 1 for safety in case a reveal operation is needed

						RPCEstimateProvider.prototype.ajustGasForBatchOperation = function (
							gasLimitBlock,
							gaslimitOp,
							numberOfOps
						) {
							return _bignumber.default.min(gaslimitOp, gasLimitBlock.div(numberOfOps + 1));
						};

						RPCEstimateProvider.prototype.getEstimationPropertiesFromOperationContent = function (
							content,
							size,
							costPerByte
						) {
							var _this = this;

							var operationResults = flattenOperationResult({
								contents: [content]
							});
							var totalGas = 0;
							var totalMilligas = 0;
							var totalStorage = 0;
							operationResults.forEach(function (result) {
								totalStorage +=
									'originated_contracts' in result &&
									typeof result.originated_contracts !== 'undefined'
										? result.originated_contracts.length * _this.ORIGINATION_STORAGE
										: 0;
								totalStorage +=
									'allocated_destination_contract' in result ? _this.ALLOCATION_STORAGE : 0;
								totalGas += Number(result.consumed_gas) || 0;
								totalMilligas += Number(result.consumed_milligas) || 0;
								totalStorage +=
									'paid_storage_size_diff' in result
										? Number(result.paid_storage_size_diff) || 0
										: 0;
							});

							if (totalGas !== 0 && totalMilligas === 0) {
								// This will convert gas to milligas for Carthagenet where result does not contain consumed gas in milligas.
								totalMilligas = totalGas * 1000;
							}

							if (isOpWithFee(content)) {
								return {
									milligasLimit: totalMilligas || 0,
									storageLimit: Number(totalStorage || 0),
									opSize: size,
									minimalFeePerStorageByteMutez: costPerByte.toNumber()
								};
							} else {
								return {
									milligasLimit: 0,
									storageLimit: 0,
									opSize: size,
									minimalFeePerStorageByteMutez: costPerByte.toNumber(),
									baseFeeMutez: 0
								};
							}
						};

						RPCEstimateProvider.prototype.prepareEstimate = function (params, constants) {
							return __awaiter(this, void 0, void 0, function () {
								var prepared,
									_a,
									opbytes,
									_b,
									branch,
									contents,
									operation,
									opResponse,
									cost_per_byte,
									errors,
									numberOfOps;

								var _c;

								var _this = this;

								return __generator(this, function (_d) {
									switch (_d.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.prepareOperation(params)
											];

										case 1:
											prepared = _d.sent();
											return [
												4,
												/*yield*/
												this.forge(prepared)
											];

										case 2:
											(_a = _d.sent()),
												(opbytes = _a.opbytes),
												(_b = _a.opOb),
												(branch = _b.branch),
												(contents = _b.contents);
											_c = {
												operation: {
													branch: branch,
													contents: contents,
													signature: SIGNATURE_STUB
												}
											};
											return [
												4,
												/*yield*/
												this.rpc.getChainId()
											];

										case 3:
											operation = ((_c.chain_id = _d.sent()), _c);
											return [
												4,
												/*yield*/
												this.simulate(operation)
											];

										case 4:
											opResponse = _d.sent().opResponse;
											cost_per_byte = constants.cost_per_byte;
											errors = __spreadArray(
												__spreadArray([], __read(flattenErrors(opResponse, 'backtracked'))),
												__read(flattenErrors(opResponse))
											); // Fail early in case of errors

											if (errors.length) {
												throw new TezosOperationError(errors);
											}

											numberOfOps = 1;

											if (Array.isArray(params.operation) && params.operation.length > 1) {
												numberOfOps =
													opResponse.contents[0].kind === 'reveal'
														? params.operation.length - 1
														: params.operation.length;
											}

											return [
												2,
												/*return*/
												opResponse.contents.map(function (x) {
													return _this.getEstimationPropertiesFromOperationContent(
														x, // TODO: Calculate a specific opSize for each operation.
														x.kind === 'reveal'
															? _this.OP_SIZE_REVEAL / 2
															: opbytes.length / 2 / numberOfOps,
														cost_per_byte
													);
												})
											];
									}
								});
							});
						};
						/**
						 *
						 * @description Estimate gasLimit, storageLimit and fees for an origination operation
						 *
						 * @returns An estimation of gasLimit, storageLimit and fees for the operation
						 *
						 * @param OriginationOperation Originate operation parameter
						 */

						RPCEstimateProvider.prototype.originate = function (_a) {
							var fee = _a.fee,
								storageLimit = _a.storageLimit,
								gasLimit = _a.gasLimit,
								rest = __rest(_a, ['fee', 'storageLimit', 'gasLimit']);

							return __awaiter(this, void 0, void 0, function () {
								var pkh,
									protocolConstants,
									DEFAULT_PARAMS,
									op,
									_b,
									isRevealNeeded,
									ops,
									_c,
									estimateProperties;

								return __generator(this, function (_d) {
									switch (_d.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.signer.publicKeyHash()
											];

										case 1:
											pkh = _d.sent();
											return [
												4,
												/*yield*/
												this.rpc.getConstants()
											];

										case 2:
											protocolConstants = _d.sent();
											return [
												4,
												/*yield*/
												this.getAccountLimits(pkh, protocolConstants)
											];

										case 3:
											DEFAULT_PARAMS = _d.sent();
											_b = createOriginationOperation;
											return [
												4,
												/*yield*/
												this.context.parser.prepareCodeOrigination(
													__assign(
														__assign({}, rest),
														mergeLimits(
															{
																fee: fee,
																storageLimit: storageLimit,
																gasLimit: gasLimit
															},
															DEFAULT_PARAMS
														)
													)
												)
											];

										case 4:
											return [
												4,
												/*yield*/
												_b.apply(void 0, [_d.sent()])
											];

										case 5:
											op = _d.sent();
											return [
												4,
												/*yield*/
												this.isRevealOpNeeded([op], pkh)
											];

										case 6:
											isRevealNeeded = _d.sent();
											if (!isRevealNeeded) return [3 /*break*/, 8];
											return [
												4,
												/*yield*/
												this.addRevealOp([op], pkh)
											];

										case 7:
											_c = _d.sent();
											return [3 /*break*/, 9];

										case 8:
											_c = op;
											_d.label = 9;

										case 9:
											ops = _c;
											return [
												4,
												/*yield*/
												this.prepareEstimate(
													{
														operation: ops,
														source: pkh
													},
													protocolConstants
												)
											];

										case 10:
											estimateProperties = _d.sent();

											if (isRevealNeeded) {
												estimateProperties.shift();
											}

											return [
												2,
												/*return*/
												Estimate.createEstimateInstanceFromProperties(estimateProperties)
											];
									}
								});
							});
						};
						/**
						 *
						 * @description Estimate gasLimit, storageLimit and fees for an transfer operation
						 *
						 * @returns An estimation of gasLimit, storageLimit and fees for the operation
						 *
						 * @param TransferOperation Originate operation parameter
						 */

						RPCEstimateProvider.prototype.transfer = function (_a) {
							var fee = _a.fee,
								storageLimit = _a.storageLimit,
								gasLimit = _a.gasLimit,
								rest = __rest(_a, ['fee', 'storageLimit', 'gasLimit']);

							return __awaiter(this, void 0, void 0, function () {
								var pkh,
									protocolConstants,
									DEFAULT_PARAMS,
									op,
									isRevealNeeded,
									ops,
									_b,
									estimateProperties;

								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.signer.publicKeyHash()
											];

										case 1:
											pkh = _c.sent();
											return [
												4,
												/*yield*/
												this.rpc.getConstants()
											];

										case 2:
											protocolConstants = _c.sent();
											return [
												4,
												/*yield*/
												this.getAccountLimits(pkh, protocolConstants)
											];

										case 3:
											DEFAULT_PARAMS = _c.sent();
											return [
												4,
												/*yield*/
												createTransferOperation(
													__assign(
														__assign({}, rest),
														mergeLimits(
															{
																fee: fee,
																storageLimit: storageLimit,
																gasLimit: gasLimit
															},
															DEFAULT_PARAMS
														)
													)
												)
											];

										case 4:
											op = _c.sent();
											return [
												4,
												/*yield*/
												this.isRevealOpNeeded([op], pkh)
											];

										case 5:
											isRevealNeeded = _c.sent();
											if (!isRevealNeeded) return [3 /*break*/, 7];
											return [
												4,
												/*yield*/
												this.addRevealOp([op], pkh)
											];

										case 6:
											_b = _c.sent();
											return [3 /*break*/, 8];

										case 7:
											_b = op;
											_c.label = 8;

										case 8:
											ops = _b;
											return [
												4,
												/*yield*/
												this.prepareEstimate(
													{
														operation: ops,
														source: pkh
													},
													protocolConstants
												)
											];

										case 9:
											estimateProperties = _c.sent();

											if (isRevealNeeded) {
												estimateProperties.shift();
											}

											return [
												2,
												/*return*/
												Estimate.createEstimateInstanceFromProperties(estimateProperties)
											];
									}
								});
							});
						};
						/**
						 *
						 * @description Estimate gasLimit, storageLimit and fees for a delegate operation
						 *
						 * @returns An estimation of gasLimit, storageLimit and fees for the operation
						 *
						 * @param Estimate
						 */

						RPCEstimateProvider.prototype.setDelegate = function (_a) {
							var fee = _a.fee,
								gasLimit = _a.gasLimit,
								storageLimit = _a.storageLimit,
								rest = __rest(_a, ['fee', 'gasLimit', 'storageLimit']);

							return __awaiter(this, void 0, void 0, function () {
								var pkh,
									sourceOrDefault,
									protocolConstants,
									DEFAULT_PARAMS,
									op,
									isRevealNeeded,
									ops,
									_b,
									estimateProperties;

								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.signer.publicKeyHash()
											];

										case 1:
											pkh = _c.sent();
											sourceOrDefault = rest.source || pkh;
											return [
												4,
												/*yield*/
												this.rpc.getConstants()
											];

										case 2:
											protocolConstants = _c.sent();
											return [
												4,
												/*yield*/
												this.getAccountLimits(sourceOrDefault, protocolConstants)
											];

										case 3:
											DEFAULT_PARAMS = _c.sent();
											return [
												4,
												/*yield*/
												createSetDelegateOperation(
													__assign(
														__assign({}, rest),
														mergeLimits(
															{
																fee: fee,
																storageLimit: storageLimit,
																gasLimit: gasLimit
															},
															DEFAULT_PARAMS
														)
													)
												)
											];

										case 4:
											op = _c.sent();
											return [
												4,
												/*yield*/
												this.isRevealOpNeeded([op], pkh)
											];

										case 5:
											isRevealNeeded = _c.sent();
											if (!isRevealNeeded) return [3 /*break*/, 7];
											return [
												4,
												/*yield*/
												this.addRevealOp([op], pkh)
											];

										case 6:
											_b = _c.sent();
											return [3 /*break*/, 8];

										case 7:
											_b = op;
											_c.label = 8;

										case 8:
											ops = _b;
											return [
												4,
												/*yield*/
												this.prepareEstimate(
													{
														operation: ops,
														source: pkh
													},
													protocolConstants
												)
											];

										case 9:
											estimateProperties = _c.sent();

											if (isRevealNeeded) {
												estimateProperties.shift();
											}

											return [
												2,
												/*return*/
												Estimate.createEstimateInstanceFromProperties(estimateProperties)
											];
									}
								});
							});
						};
						/**
						 *
						 * @description Estimate gasLimit, storageLimit and fees for a each operation in the batch
						 *
						 * @returns An array of Estimate objects. If a reveal operation is needed, the first element of the array is the Estimate for the reveal operation.
						 */

						RPCEstimateProvider.prototype.batch = function (params) {
							return __awaiter(this, void 0, void 0, function () {
								var pkh,
									operations,
									protocolConstants,
									DEFAULT_PARAMS,
									params_1,
									params_1_1,
									param,
									_a,
									_b,
									_c,
									_d,
									_e,
									_f,
									_g,
									_h,
									e_1_1,
									isRevealNeeded,
									_j,
									estimateProperties;

								var e_1, _k;

								return __generator(this, function (_l) {
									switch (_l.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.signer.publicKeyHash()
											];

										case 1:
											pkh = _l.sent();
											operations = [];
											return [
												4,
												/*yield*/
												this.rpc.getConstants()
											];

										case 2:
											protocolConstants = _l.sent();
											return [
												4,
												/*yield*/
												this.getAccountLimits(pkh, protocolConstants, params.length)
											];

										case 3:
											DEFAULT_PARAMS = _l.sent();
											_l.label = 4;

										case 4:
											_l.trys.push([4, 17, 18, 19]);

											(params_1 = __values(params)), (params_1_1 = params_1.next());
											_l.label = 5;

										case 5:
											if (!!params_1_1.done) return [3 /*break*/, 16];
											param = params_1_1.value;
											_a = param.kind;

											switch (_a) {
												case _rpc2.OpKind.TRANSACTION:
													return [3 /*break*/, 6];

												case _rpc2.OpKind.ORIGINATION:
													return [3 /*break*/, 8];

												case _rpc2.OpKind.DELEGATION:
													return [3 /*break*/, 11];

												case _rpc2.OpKind.ACTIVATION:
													return [3 /*break*/, 13];
											}

											return [3 /*break*/, 14];

										case 6:
											_c = (_b = operations).push;
											return [
												4,
												/*yield*/
												createTransferOperation(
													__assign(__assign({}, param), mergeLimits(param, DEFAULT_PARAMS))
												)
											];

										case 7:
											_c.apply(_b, [_l.sent()]);

											return [3 /*break*/, 15];

										case 8:
											_e = (_d = operations).push;
											_f = createOriginationOperation;
											return [
												4,
												/*yield*/
												this.context.parser.prepareCodeOrigination(
													__assign(__assign({}, param), mergeLimits(param, DEFAULT_PARAMS))
												)
											];

										case 9:
											return [
												4,
												/*yield*/
												_f.apply(void 0, [_l.sent()])
											];

										case 10:
											_e.apply(_d, [_l.sent()]);

											return [3 /*break*/, 15];

										case 11:
											_h = (_g = operations).push;
											return [
												4,
												/*yield*/
												createSetDelegateOperation(
													__assign(__assign({}, param), mergeLimits(param, DEFAULT_PARAMS))
												)
											];

										case 12:
											_h.apply(_g, [_l.sent()]);

											return [3 /*break*/, 15];

										case 13:
											operations.push(__assign(__assign({}, param), DEFAULT_PARAMS));
											return [3 /*break*/, 15];

										case 14:
											throw new Error('Unsupported operation kind: ' + param.kind);

										case 15:
											params_1_1 = params_1.next();
											return [3 /*break*/, 5];

										case 16:
											return [3 /*break*/, 19];

										case 17:
											e_1_1 = _l.sent();
											e_1 = {
												error: e_1_1
											};
											return [3 /*break*/, 19];

										case 18:
											try {
												if (params_1_1 && !params_1_1.done && (_k = params_1.return))
													_k.call(params_1);
											} finally {
												if (e_1) throw e_1.error;
											}

											return [
												7
												/*endfinally*/
											];

										case 19:
											return [
												4,
												/*yield*/
												this.isRevealOpNeeded(operations, pkh)
											];

										case 20:
											isRevealNeeded = _l.sent();
											if (!isRevealNeeded) return [3 /*break*/, 22];
											return [
												4,
												/*yield*/
												this.addRevealOp(operations, pkh)
											];

										case 21:
											_j = _l.sent();
											return [3 /*break*/, 23];

										case 22:
											_j = operations;
											_l.label = 23;

										case 23:
											operations = _j;
											return [
												4,
												/*yield*/
												this.prepareEstimate(
													{
														operation: operations,
														source: pkh
													},
													protocolConstants
												)
											];

										case 24:
											estimateProperties = _l.sent();
											return [
												2,
												/*return*/
												Estimate.createArrayEstimateInstancesFromProperties(estimateProperties)
											];
									}
								});
							});
						};
						/**
						 *
						 * @description Estimate gasLimit, storageLimit and fees for a delegate operation
						 *
						 * @returns An estimation of gasLimit, storageLimit and fees for the operation
						 *
						 * @param Estimate
						 */

						RPCEstimateProvider.prototype.registerDelegate = function (params) {
							return __awaiter(this, void 0, void 0, function () {
								var pkh,
									protocolConstants,
									DEFAULT_PARAMS,
									op,
									isRevealNeeded,
									ops,
									_a,
									estimateProperties;

								return __generator(this, function (_b) {
									switch (_b.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.signer.publicKeyHash()
											];

										case 1:
											pkh = _b.sent();
											return [
												4,
												/*yield*/
												this.rpc.getConstants()
											];

										case 2:
											protocolConstants = _b.sent();
											return [
												4,
												/*yield*/
												this.getAccountLimits(pkh, protocolConstants)
											];

										case 3:
											DEFAULT_PARAMS = _b.sent();
											return [
												4,
												/*yield*/
												createRegisterDelegateOperation(
													__assign(__assign({}, params), DEFAULT_PARAMS),
													pkh
												)
											];

										case 4:
											op = _b.sent();
											return [
												4,
												/*yield*/
												this.isRevealOpNeeded([op], pkh)
											];

										case 5:
											isRevealNeeded = _b.sent();
											if (!isRevealNeeded) return [3 /*break*/, 7];
											return [
												4,
												/*yield*/
												this.addRevealOp([op], pkh)
											];

										case 6:
											_a = _b.sent();
											return [3 /*break*/, 8];

										case 7:
											_a = op;
											_b.label = 8;

										case 8:
											ops = _a;
											return [
												4,
												/*yield*/
												this.prepareEstimate(
													{
														operation: ops,
														source: pkh
													},
													protocolConstants
												)
											];

										case 9:
											estimateProperties = _b.sent();

											if (isRevealNeeded) {
												estimateProperties.shift();
											}

											return [
												2,
												/*return*/
												Estimate.createEstimateInstanceFromProperties(estimateProperties)
											];
									}
								});
							});
						};
						/**
						 *
						 * @description Estimate gasLimit, storageLimit and fees to reveal the current account
						 *
						 * @returns An estimation of gasLimit, storageLimit and fees for the operation or undefined if the account is already revealed
						 *
						 * @param Estimate
						 */

						RPCEstimateProvider.prototype.reveal = function (params) {
							return __awaiter(this, void 0, void 0, function () {
								var pkh, protocolConstants, DEFAULT_PARAMS, op, _a, _b, estimateProperties;

								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.signer.publicKeyHash()
											];

										case 1:
											pkh = _c.sent();
											return [
												4,
												/*yield*/
												this.isAccountRevealRequired(pkh)
											];

										case 2:
											if (!_c.sent()) return [3 /*break*/, 8];
											return [
												4,
												/*yield*/
												this.rpc.getConstants()
											];

										case 3:
											protocolConstants = _c.sent();
											return [
												4,
												/*yield*/
												this.getAccountLimits(pkh, protocolConstants)
											];

										case 4:
											DEFAULT_PARAMS = _c.sent();
											_a = createRevealOperation;
											_b = [__assign(__assign({}, params), DEFAULT_PARAMS), pkh];
											return [
												4,
												/*yield*/
												this.signer.publicKey()
											];

										case 5:
											return [
												4,
												/*yield*/
												_a.apply(void 0, _b.concat([_c.sent()]))
											];

										case 6:
											op = _c.sent();
											return [
												4,
												/*yield*/
												this.prepareEstimate(
													{
														operation: op,
														source: pkh
													},
													protocolConstants
												)
											];

										case 7:
											estimateProperties = _c.sent();
											return [
												2,
												/*return*/
												Estimate.createEstimateInstanceFromProperties(estimateProperties)
											];

										case 8:
											return [
												2
												/*return*/
											];
									}
								});
							});
						};

						RPCEstimateProvider.prototype.addRevealOp = function (op, pkh) {
							return __awaiter(this, void 0, void 0, function () {
								var _a, _b, _c, _d;

								return __generator(this, function (_e) {
									switch (_e.label) {
										case 0:
											_b = (_a = op).unshift;
											_c = createRevealOperation;
											_d = [
												__assign({
													fee: DEFAULT_FEE.REVEAL,
													gasLimit: DEFAULT_GAS_LIMIT.REVEAL,
													storageLimit: DEFAULT_STORAGE_LIMIT.REVEAL
												}),
												pkh
											];
											return [
												4,
												/*yield*/
												this.signer.publicKey()
											];

										case 1:
											return [
												4,
												/*yield*/
												_c.apply(void 0, _d.concat([_e.sent()]))
											];

										case 2:
											_b.apply(_a, [_e.sent()]);

											return [
												2,
												/*return*/
												op
											];
									}
								});
							});
						};

						return RPCEstimateProvider;
					})(OperationEmitter);
				/**
				 * @description Delegation operation provide utility function to fetch newly issued delegation
				 *
				 * @warn Currently support only one delegation per operation
				 */

				var DelegateOperation =
					/** @class */
					(function (_super) {
						__extends(DelegateOperation, _super);

						function DelegateOperation(hash, params, source, raw, results, context) {
							var _this = _super.call(this, hash, raw, results, context) || this;

							_this.params = params;
							_this.source = source;
							return _this;
						}

						Object.defineProperty(DelegateOperation.prototype, 'operationResults', {
							get: function () {
								var delegationOp =
									Array.isArray(this.results) &&
									this.results.find(function (op) {
										return op.kind === 'delegation';
									});
								var result =
									delegationOp && delegationOp.metadata && delegationOp.metadata.operation_result;
								return result ? result : undefined;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(DelegateOperation.prototype, 'status', {
							get: function () {
								var operationResults = this.operationResults;

								if (operationResults) {
									return operationResults.status;
								} else {
									return 'unknown';
								}
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(DelegateOperation.prototype, 'delegate', {
							get: function () {
								return this.delegate;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(DelegateOperation.prototype, 'isRegisterOperation', {
							get: function () {
								return this.delegate === this.source;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(DelegateOperation.prototype, 'fee', {
							get: function () {
								return this.params.fee;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(DelegateOperation.prototype, 'gasLimit', {
							get: function () {
								return this.params.gas_limit;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(DelegateOperation.prototype, 'storageLimit', {
							get: function () {
								return this.params.storage_limit;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(DelegateOperation.prototype, 'consumedGas', {
							get: function () {
								var consumedGas = this.operationResults && this.operationResults.consumed_gas;
								return consumedGas ? consumedGas : undefined;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(DelegateOperation.prototype, 'errors', {
							get: function () {
								return this.operationResults && this.operationResults.errors;
							},
							enumerable: false,
							configurable: true
						});
						return DelegateOperation;
					})(Operation);
				/**
				 * @description Origination operation provide utility function to fetch newly originated contract
				 *
				 * @warn Currently support only one origination per operation
				 */

				exports.DelegateOperation = DelegateOperation;

				var OriginationOperation =
					/** @class */
					(function (_super) {
						__extends(OriginationOperation, _super);

						function OriginationOperation(hash, params, raw, results, context, contractProvider) {
							var _this = _super.call(this, hash, raw, results, context) || this;

							_this.params = params;
							_this.contractProvider = contractProvider;
							var originatedContracts =
								_this.operationResults && _this.operationResults.originated_contracts;

							if (Array.isArray(originatedContracts)) {
								_this.contractAddress = originatedContracts[0];
							}

							return _this;
						}

						Object.defineProperty(OriginationOperation.prototype, 'status', {
							get: function () {
								var operationResults = this.operationResults;

								if (operationResults) {
									return operationResults.status;
								} else {
									return 'unknown';
								}
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(OriginationOperation.prototype, 'operationResults', {
							get: function () {
								var originationOp =
									Array.isArray(this.results) &&
									this.results.find(function (op) {
										return op.kind === 'origination';
									});
								var result =
									originationOp &&
									hasMetadataWithResult(originationOp) &&
									originationOp.metadata.operation_result;
								return result ? result : undefined;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(OriginationOperation.prototype, 'fee', {
							get: function () {
								return this.params.fee;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(OriginationOperation.prototype, 'gasLimit', {
							get: function () {
								return this.params.gas_limit;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(OriginationOperation.prototype, 'storageLimit', {
							get: function () {
								return this.params.storage_limit;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(OriginationOperation.prototype, 'consumedGas', {
							get: function () {
								var consumedGas = this.operationResults && this.operationResults.consumed_gas;
								return consumedGas ? consumedGas : undefined;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(OriginationOperation.prototype, 'storageDiff', {
							get: function () {
								var storageDiff =
									this.operationResults && this.operationResults.paid_storage_size_diff;
								return storageDiff ? storageDiff : undefined;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(OriginationOperation.prototype, 'storageSize', {
							get: function () {
								var storageSize = this.operationResults && this.operationResults.storage_size;
								return storageSize ? storageSize : undefined;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(OriginationOperation.prototype, 'errors', {
							get: function () {
								return this.operationResults && this.operationResults.errors;
							},
							enumerable: false,
							configurable: true
						});
						/**
						 * @description Provide the contract abstract of the newly originated contract
						 */

						OriginationOperation.prototype.contract = function (confirmations, interval, timeout) {
							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											if (!this.contractAddress) {
												throw new Error('No contract was originated in this operation');
											}

											return [
												4,
												/*yield*/
												this.confirmation(confirmations, interval, timeout)
											];

										case 1:
											_a.sent();

											return [
												2,
												/*return*/
												this.contractProvider.at(this.contractAddress)
											];
									}
								});
							});
						};

						return OriginationOperation;
					})(Operation);
				/**
				 * @description Reveal operation provides utility functions to fetch a newly issued revelation
				 */

				exports.OriginationOperation = OriginationOperation;

				var RevealOperation =
					/** @class */
					(function (_super) {
						__extends(RevealOperation, _super);

						function RevealOperation(hash, params, source, raw, results, context) {
							var _this = _super.call(this, hash, raw, results, context) || this;

							_this.params = params;
							_this.source = source;
							return _this;
						}

						Object.defineProperty(RevealOperation.prototype, 'operationResults', {
							get: function () {
								var revealOp =
									Array.isArray(this.results) &&
									this.results.find(function (op) {
										return op.kind === 'reveal';
									});
								return revealOp ? [revealOp] : [];
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(RevealOperation.prototype, 'status', {
							get: function () {
								var operationResults = this.operationResults;
								var txResult = operationResults[0];

								if (txResult) {
									return txResult.metadata.operation_result.status;
								} else {
									return 'unknown';
								}
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(RevealOperation.prototype, 'fee', {
							get: function () {
								return this.params.fee;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(RevealOperation.prototype, 'gasLimit', {
							get: function () {
								return this.params.gas_limit;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(RevealOperation.prototype, 'storageLimit', {
							get: function () {
								return this.params.storage_limit;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(RevealOperation.prototype, 'publicKey', {
							get: function () {
								return this.params.public_key;
							},
							enumerable: false,
							configurable: true
						});

						RevealOperation.prototype.sumProp = function (arr, prop) {
							return arr.reduce(function (prev, current) {
								return prop in current ? Number(current[prop]) + prev : prev;
							}, 0);
						};

						Object.defineProperty(RevealOperation.prototype, 'consumedGas', {
							get: function () {
								return String(
									this.sumProp(
										flattenOperationResult({
											contents: this.operationResults
										}),
										'consumed_gas'
									)
								);
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(RevealOperation.prototype, 'storageDiff', {
							get: function () {
								return String(
									this.sumProp(
										flattenOperationResult({
											contents: this.operationResults
										}),
										'paid_storage_size_diff'
									)
								);
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(RevealOperation.prototype, 'storageSize', {
							get: function () {
								return String(
									this.sumProp(
										flattenOperationResult({
											contents: this.operationResults
										}),
										'storage_size'
									)
								);
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(RevealOperation.prototype, 'errors', {
							get: function () {
								return flattenErrors({
									contents: this.operationResults
								});
							},
							enumerable: false,
							configurable: true
						});
						return RevealOperation;
					})(Operation);
				/**
				 * @description Transaction operation provides utility functions to fetch a newly issued transaction
				 *
				 * @warn Currently supports one transaction per operation
				 */

				var TransactionOperation =
					/** @class */
					(function (_super) {
						__extends(TransactionOperation, _super);

						function TransactionOperation(hash, params, source, raw, results, context) {
							var _this = _super.call(this, hash, raw, results, context) || this;

							_this.params = params;
							_this.source = source;
							return _this;
						}

						Object.defineProperty(TransactionOperation.prototype, 'operationResults', {
							get: function () {
								var transactionOp =
									Array.isArray(this.results) &&
									this.results.find(function (op) {
										return op.kind === 'transaction';
									});
								return transactionOp ? [transactionOp] : [];
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(TransactionOperation.prototype, 'status', {
							get: function () {
								var operationResults = this.operationResults;
								var txResult = operationResults[0];

								if (txResult) {
									return txResult.metadata.operation_result.status;
								} else {
									return 'unknown';
								}
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(TransactionOperation.prototype, 'amount', {
							get: function () {
								return new _bignumber.default(this.params.amount);
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(TransactionOperation.prototype, 'destination', {
							get: function () {
								return this.params.destination;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(TransactionOperation.prototype, 'fee', {
							get: function () {
								return this.params.fee;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(TransactionOperation.prototype, 'gasLimit', {
							get: function () {
								return this.params.gas_limit;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(TransactionOperation.prototype, 'storageLimit', {
							get: function () {
								return this.params.storage_limit;
							},
							enumerable: false,
							configurable: true
						});

						TransactionOperation.prototype.sumProp = function (arr, prop) {
							return arr.reduce(function (prev, current) {
								return prop in current ? Number(current[prop]) + prev : prev;
							}, 0);
						};

						Object.defineProperty(TransactionOperation.prototype, 'consumedGas', {
							get: function () {
								return String(
									this.sumProp(
										flattenOperationResult({
											contents: this.operationResults
										}),
										'consumed_gas'
									)
								);
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(TransactionOperation.prototype, 'storageDiff', {
							get: function () {
								return String(
									this.sumProp(
										flattenOperationResult({
											contents: this.operationResults
										}),
										'paid_storage_size_diff'
									)
								);
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(TransactionOperation.prototype, 'storageSize', {
							get: function () {
								return String(
									this.sumProp(
										flattenOperationResult({
											contents: this.operationResults
										}),
										'storage_size'
									)
								);
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(TransactionOperation.prototype, 'errors', {
							get: function () {
								return flattenErrors({
									contents: this.operationResults
								});
							},
							enumerable: false,
							configurable: true
						});
						return TransactionOperation;
					})(Operation);

				exports.TransactionOperation = TransactionOperation;

				var setDelegate = function (key) {
					return [
						{
							prim: 'DROP'
						},
						{
							prim: 'NIL',
							args: [
								{
									prim: 'operation'
								}
							]
						},
						{
							prim: 'PUSH',
							args: [
								{
									prim: 'key_hash'
								},
								{
									string: key
								}
							]
						},
						{
							prim: 'SOME'
						},
						{
							prim: 'SET_DELEGATE'
						},
						{
							prim: 'CONS'
						}
					];
				};

				var transferImplicit = function (key, mutez) {
					return [
						{
							prim: 'DROP'
						},
						{
							prim: 'NIL',
							args: [
								{
									prim: 'operation'
								}
							]
						},
						{
							prim: 'PUSH',
							args: [
								{
									prim: 'key_hash'
								},
								{
									string: key
								}
							]
						},
						{
							prim: 'IMPLICIT_ACCOUNT'
						},
						{
							prim: 'PUSH',
							args: [
								{
									prim: 'mutez'
								},
								{
									int: '' + mutez
								}
							]
						},
						{
							prim: 'UNIT'
						},
						{
							prim: 'TRANSFER_TOKENS'
						},
						{
							prim: 'CONS'
						}
					];
				};

				var removeDelegate = function () {
					return [
						{
							prim: 'DROP'
						},
						{
							prim: 'NIL',
							args: [
								{
									prim: 'operation'
								}
							]
						},
						{
							prim: 'NONE',
							args: [
								{
									prim: 'key_hash'
								}
							]
						},
						{
							prim: 'SET_DELEGATE'
						},
						{
							prim: 'CONS'
						}
					];
				};

				var transferToContract = function (key, amount) {
					return [
						{
							prim: 'DROP'
						},
						{
							prim: 'NIL',
							args: [
								{
									prim: 'operation'
								}
							]
						},
						{
							prim: 'PUSH',
							args: [
								{
									prim: 'address'
								},
								{
									string: key
								}
							]
						},
						{
							prim: 'CONTRACT',
							args: [
								{
									prim: 'unit'
								}
							]
						},
						[
							{
								prim: 'IF_NONE',
								args: [
									[
										[
											{
												prim: 'UNIT'
											},
											{
												prim: 'FAILWITH'
											}
										]
									],
									[]
								]
							}
						],
						{
							prim: 'PUSH',
							args: [
								{
									prim: 'mutez'
								},
								{
									int: '' + amount
								}
							]
						},
						{
							prim: 'UNIT'
						},
						{
							prim: 'TRANSFER_TOKENS'
						},
						{
							prim: 'CONS'
						}
					];
				};

				var MANAGER_LAMBDA = {
					setDelegate: setDelegate,
					removeDelegate: removeDelegate,
					transferImplicit: transferImplicit,
					transferToContract: transferToContract
				};
				exports.MANAGER_LAMBDA = MANAGER_LAMBDA;
				var code = [
					{
						prim: 'parameter',
						args: [
							{
								prim: 'lambda',
								args: [
									{
										prim: 'unit'
									},
									{
										prim: 'pair',
										args: [
											{
												prim: 'list',
												args: [
													{
														prim: 'operation'
													}
												]
											},
											{
												prim: 'unit'
											}
										]
									}
								]
							}
						]
					},
					{
						prim: 'storage',
						args: [
							{
								prim: 'unit'
							}
						]
					},
					{
						prim: 'code',
						args: [
							[
								{
									prim: 'CAR'
								},
								{
									prim: 'UNIT'
								},
								{
									prim: 'EXEC'
								}
							]
						]
					}
				];
				var storage = 'Unit';
				var VIEW_LAMBDA = {
					code: code,
					storage: storage
				};
				exports.VIEW_LAMBDA = VIEW_LAMBDA;

				function compose(functioncomposer1, functioncomposer2) {
					return function (contractAbstraction, context) {
						return functioncomposer2(functioncomposer1(contractAbstraction, context), context);
					};
				}
				/**
				 * @description Utility class to send smart contract operation
				 * The format for the arguments is the flattened representation
				 */

				var ContractMethod =
					/** @class */
					(function () {
						function ContractMethod(
							provider,
							address,
							parameterSchema,
							name,
							args,
							isMultipleEntrypoint,
							isAnonymous
						) {
							if (isMultipleEntrypoint === void 0) {
								isMultipleEntrypoint = true;
							}

							if (isAnonymous === void 0) {
								isAnonymous = false;
							}

							this.provider = provider;
							this.address = address;
							this.parameterSchema = parameterSchema;
							this.name = name;
							this.args = args;
							this.isMultipleEntrypoint = isMultipleEntrypoint;
							this.isAnonymous = isAnonymous;
						}

						ContractMethod.prototype.validateArgs = function (args, schema, name) {
							var sigs = schema.ExtractSignatures();

							if (
								!sigs.find(function (x) {
									return x.length === args.length;
								})
							) {
								throw new InvalidParameterError(name, sigs, args);
							}
						};

						Object.defineProperty(ContractMethod.prototype, 'schema', {
							/**
							 * @description Get the schema of the smart contract method
							 */
							get: function () {
								return this.isAnonymous
									? this.parameterSchema.ExtractSchema()[this.name]
									: this.parameterSchema.ExtractSchema();
							},
							enumerable: false,
							configurable: true
						});
						/**
						 * @description Get the signature of the smart contract method
						 */

						ContractMethod.prototype.getSignature = function () {
							var _this = this;

							if (this.isAnonymous) {
								var sig = this.parameterSchema.ExtractSignatures().find(function (x) {
									return x[0] === _this.name;
								});

								if (sig) {
									sig.shift();
									return sig;
								}
							} else {
								var sig = this.parameterSchema.ExtractSignatures();
								return sig.length == 1 ? sig[0] : sig;
							}
						};
						/**
						 *
						 * @description Send the smart contract operation
						 *
						 * @param Options generic operation parameter
						 */

						ContractMethod.prototype.send = function (params) {
							if (params === void 0) {
								params = {};
							}

							if (this.provider instanceof Wallet) {
								return this.provider.transfer(this.toTransferParams(params)).send();
							} else {
								return this.provider.transfer(this.toTransferParams(params));
							}
						};
						/**
						 *
						 * @description Create transfer params to be used with TezosToolkit.contract.transfer methods
						 *
						 * @param Options generic transfer operation parameters
						 */

						ContractMethod.prototype.toTransferParams = function (_a) {
							var _b, _c;

							var _d = _a === void 0 ? {} : _a,
								fee = _d.fee,
								gasLimit = _d.gasLimit,
								storageLimit = _d.storageLimit,
								source = _d.source,
								_e = _d.amount,
								amount = _e === void 0 ? 0 : _e,
								_f = _d.mutez,
								mutez = _f === void 0 ? false : _f;

							var fullTransferParams = {
								to: this.address,
								amount: amount,
								fee: fee,
								mutez: mutez,
								source: source,
								gasLimit: gasLimit,
								storageLimit: storageLimit,
								parameter: {
									entrypoint: this.isMultipleEntrypoint
										? this.name
										: DEFAULT_SMART_CONTRACT_METHOD_NAME,
									value: this.isAnonymous
										? (_b = this.parameterSchema).Encode.apply(
												_b,
												__spreadArray([this.name], __read(this.args))
										  )
										: (_c = this.parameterSchema).Encode.apply(
												_c,
												__spreadArray([], __read(this.args))
										  )
								}
							};
							return fullTransferParams;
						};

						return ContractMethod;
					})();

				exports.ContractMethod = ContractMethod;

				var WalletOperationBatch =
					/** @class */
					(function () {
						function WalletOperationBatch(walletProvider, context) {
							this.walletProvider = walletProvider;
							this.context = context;
							this.operations = [];
						}
						/**
						 *
						 * @description Add a transaction operation to the batch
						 *
						 * @param params Transfer operation parameter
						 */

						WalletOperationBatch.prototype.withTransfer = function (params) {
							this.operations.push(
								__assign(
									{
										kind: _rpc2.OpKind.TRANSACTION
									},
									params
								)
							);
							return this;
						};
						/**
						 *
						 * @description Add a transaction operation to the batch
						 *
						 * @param params Transfer operation parameter
						 */

						WalletOperationBatch.prototype.withContractCall = function (params) {
							return this.withTransfer(params.toTransferParams());
						};
						/**
						 *
						 * @description Add a delegation operation to the batch
						 *
						 * @param params Delegation operation parameter
						 */

						WalletOperationBatch.prototype.withDelegation = function (params) {
							this.operations.push(
								__assign(
									{
										kind: _rpc2.OpKind.DELEGATION
									},
									params
								)
							);
							return this;
						};
						/**
						 *
						 * @description Add an origination operation to the batch
						 *
						 * @param params Origination operation parameter
						 */

						WalletOperationBatch.prototype.withOrigination = function (params) {
							this.operations.push(
								__assign(
									{
										kind: _rpc2.OpKind.ORIGINATION
									},
									params
								)
							);
							return this;
						};

						WalletOperationBatch.prototype.mapOperation = function (param) {
							return __awaiter(this, void 0, void 0, function () {
								var _this = this;

								return __generator(this, function (_a) {
									switch (param.kind) {
										case _rpc2.OpKind.TRANSACTION:
											return [
												2,
												/*return*/
												this.walletProvider.mapTransferParamsToWalletParams(function () {
													return __awaiter(_this, void 0, void 0, function () {
														return __generator(this, function (_a) {
															return [
																2,
																/*return*/
																param
															];
														});
													});
												})
											];

										case _rpc2.OpKind.ORIGINATION:
											return [
												2,
												/*return*/
												this.walletProvider.mapOriginateParamsToWalletParams(function () {
													return __awaiter(_this, void 0, void 0, function () {
														return __generator(this, function (_a) {
															return [
																2,
																/*return*/
																this.context.parser.prepareCodeOrigination(__assign({}, param))
															];
														});
													});
												})
											];

										case _rpc2.OpKind.DELEGATION:
											return [
												2,
												/*return*/
												this.walletProvider.mapDelegateParamsToWalletParams(function () {
													return __awaiter(_this, void 0, void 0, function () {
														return __generator(this, function (_a) {
															return [
																2,
																/*return*/
																param
															];
														});
													});
												})
											];

										default:
											throw new Error('Unsupported operation kind: ' + param.kind);
									}
								});
							});
						};
						/**
						 *
						 * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array
						 *
						 * @param params Operations parameter
						 */

						WalletOperationBatch.prototype.with = function (params) {
							var e_1, _a;

							try {
								for (
									var params_1 = __values(params), params_1_1 = params_1.next();
									!params_1_1.done;
									params_1_1 = params_1.next()
								) {
									var param = params_1_1.value;

									switch (param.kind) {
										case _rpc2.OpKind.TRANSACTION:
											this.withTransfer(param);
											break;

										case _rpc2.OpKind.ORIGINATION:
											this.withOrigination(param);
											break;

										case _rpc2.OpKind.DELEGATION:
											this.withDelegation(param);
											break;

										default:
											throw new Error('Unsupported operation kind: ' + param.kind);
									}
								}
							} catch (e_1_1) {
								e_1 = {
									error: e_1_1
								};
							} finally {
								try {
									if (params_1_1 && !params_1_1.done && (_a = params_1.return)) _a.call(params_1);
								} finally {
									if (e_1) throw e_1.error;
								}
							}

							return this;
						};
						/**
						 *
						 * @description Submit batch operation to wallet
						 *
						 */

						WalletOperationBatch.prototype.send = function () {
							return __awaiter(this, void 0, void 0, function () {
								var ops, _a, _b, op, _c, _d, e_2_1, opHash;

								var e_2, _e;

								return __generator(this, function (_f) {
									switch (_f.label) {
										case 0:
											ops = [];
											_f.label = 1;

										case 1:
											_f.trys.push([1, 6, 7, 8]);

											(_a = __values(this.operations)), (_b = _a.next());
											_f.label = 2;

										case 2:
											if (!!_b.done) return [3 /*break*/, 5];
											op = _b.value;
											_d = (_c = ops).push;
											return [
												4,
												/*yield*/
												this.mapOperation(op)
											];

										case 3:
											_d.apply(_c, [_f.sent()]);

											_f.label = 4;

										case 4:
											_b = _a.next();
											return [3 /*break*/, 2];

										case 5:
											return [3 /*break*/, 8];

										case 6:
											e_2_1 = _f.sent();
											e_2 = {
												error: e_2_1
											};
											return [3 /*break*/, 8];

										case 7:
											try {
												if (_b && !_b.done && (_e = _a.return)) _e.call(_a);
											} finally {
												if (e_2) throw e_2.error;
											}

											return [
												7
												/*endfinally*/
											];

										case 8:
											return [
												4,
												/*yield*/
												this.walletProvider.sendOperations(ops)
											];

										case 9:
											opHash = _f.sent();
											return [
												2,
												/*return*/
												this.context.operationFactory.createBatchOperation(opHash)
											];
									}
								});
							});
						};

						return WalletOperationBatch;
					})();

				exports.WalletOperationBatch = WalletOperationBatch;

				var Wallet =
					/** @class */
					(function () {
						function Wallet(context) {
							this.context = context;

							this.walletCommand = function (send) {
								return {
									send: send
								};
							};
						}

						Object.defineProperty(Wallet.prototype, 'walletProvider', {
							get: function () {
								return this.context.walletProvider;
							},
							enumerable: false,
							configurable: true
						});
						/**
						 * @description Retrieve the PKH of the account that is currently in use by the wallet
						 *
						 * @param option Option to use while fetching the PKH.
						 * If forceRefetch is specified the wallet provider implementation will refetch the PKH from the wallet
						 */

						Wallet.prototype.pkh = function (_a) {
							var _b = _a === void 0 ? {} : _a,
								forceRefetch = _b.forceRefetch;

							return __awaiter(this, void 0, void 0, function () {
								var _c;

								return __generator(this, function (_d) {
									switch (_d.label) {
										case 0:
											if (!(!this._pkh || forceRefetch)) return [3 /*break*/, 2];
											_c = this;
											return [
												4,
												/*yield*/
												this.walletProvider.getPKH()
											];

										case 1:
											_c._pkh = _d.sent();
											_d.label = 2;

										case 2:
											return [
												2,
												/*return*/
												this._pkh
											];
									}
								});
							});
						};
						/**
						 *
						 * @description Originate a new contract according to the script in parameters.
						 *
						 * @returns An operation handle with the result from the rpc node
						 *
						 * @param originateParams Originate operation parameter
						 */

						Wallet.prototype.originate = function (params) {
							var _this = this;

							return this.walletCommand(function () {
								return __awaiter(_this, void 0, void 0, function () {
									var mappedParams, opHash, _a;

									var _this = this;

									return __generator(this, function (_b) {
										switch (_b.label) {
											case 0:
												return [
													4,
													/*yield*/
													this.walletProvider.mapOriginateParamsToWalletParams(function () {
														return _this.context.parser.prepareCodeOrigination(
															__assign({}, params)
														);
													})
												];

											case 1:
												mappedParams = _b.sent();
												return [
													4,
													/*yield*/
													this.walletProvider.sendOperations([mappedParams])
												];

											case 2:
												opHash = _b.sent();
												if (!!this.context.proto) return [3 /*break*/, 4];
												_a = this.context;
												return [
													4,
													/*yield*/
													this.context.rpc.getBlock()
												];

											case 3:
												_a.proto = _b.sent().protocol;
												_b.label = 4;

											case 4:
												return [
													2,
													/*return*/
													this.context.operationFactory.createOriginationOperation(opHash)
												];
										}
									});
								});
							});
						};
						/**
						 *
						 * @description Set the delegate for a contract.
						 *
						 * @returns An operation handle with the result from the rpc node
						 *
						 * @param delegateParams operation parameter
						 */

						Wallet.prototype.setDelegate = function (params) {
							var _this = this;

							return this.walletCommand(function () {
								return __awaiter(_this, void 0, void 0, function () {
									var mappedParams, opHash;

									var _this = this;

									return __generator(this, function (_a) {
										switch (_a.label) {
											case 0:
												return [
													4,
													/*yield*/
													this.walletProvider.mapDelegateParamsToWalletParams(function () {
														return __awaiter(_this, void 0, void 0, function () {
															return __generator(this, function (_a) {
																return [
																	2,
																	/*return*/
																	params
																];
															});
														});
													})
												];

											case 1:
												mappedParams = _a.sent();
												return [
													4,
													/*yield*/
													this.walletProvider.sendOperations([mappedParams])
												];

											case 2:
												opHash = _a.sent();
												return [
													2,
													/*return*/
													this.context.operationFactory.createDelegationOperation(opHash)
												];
										}
									});
								});
							});
						};
						/**
						 *
						 * @description Register the current address as delegate.
						 *
						 * @returns An operation handle with the result from the rpc node
						 *
						 */

						Wallet.prototype.registerDelegate = function () {
							var _this = this;

							return this.walletCommand(function () {
								return __awaiter(_this, void 0, void 0, function () {
									var mappedParams, opHash;

									var _this = this;

									return __generator(this, function (_a) {
										switch (_a.label) {
											case 0:
												return [
													4,
													/*yield*/
													this.walletProvider.mapDelegateParamsToWalletParams(function () {
														return __awaiter(_this, void 0, void 0, function () {
															var delegate;
															return __generator(this, function (_a) {
																switch (_a.label) {
																	case 0:
																		return [
																			4,
																			/*yield*/
																			this.pkh()
																		];

																	case 1:
																		delegate = _a.sent();
																		return [
																			2,
																			/*return*/
																			{
																				delegate: delegate
																			}
																		];
																}
															});
														});
													})
												];

											case 1:
												mappedParams = _a.sent();
												return [
													4,
													/*yield*/
													this.walletProvider.sendOperations([mappedParams])
												];

											case 2:
												opHash = _a.sent();
												return [
													2,
													/*return*/
													this.context.operationFactory.createDelegationOperation(opHash)
												];
										}
									});
								});
							});
						};
						/**
						 *
						 * @description Transfer tezos tokens from current address to a specific address or call a smart contract.
						 *
						 * @returns A wallet command from which we can send the operation to the wallet
						 *
						 * @param params operation parameter
						 */

						Wallet.prototype.transfer = function (params) {
							var _this = this;

							return this.walletCommand(function () {
								return __awaiter(_this, void 0, void 0, function () {
									var mappedParams, opHash;

									var _this = this;

									return __generator(this, function (_a) {
										switch (_a.label) {
											case 0:
												return [
													4,
													/*yield*/
													this.walletProvider.mapTransferParamsToWalletParams(function () {
														return __awaiter(_this, void 0, void 0, function () {
															return __generator(this, function (_a) {
																return [
																	2,
																	/*return*/
																	params
																];
															});
														});
													})
												];

											case 1:
												mappedParams = _a.sent();
												return [
													4,
													/*yield*/
													this.walletProvider.sendOperations([mappedParams])
												];

											case 2:
												opHash = _a.sent();
												return [
													2,
													/*return*/
													this.context.operationFactory.createTransactionOperation(opHash)
												];
										}
									});
								});
							});
						};
						/**
						 *
						 * @description Create a batch of operation
						 *
						 * @returns A batch object from which we can add more operation or send a command to the wallet to execute the batch
						 *
						 * @param params List of operation to initialize the batch with
						 */

						Wallet.prototype.batch = function (params) {
							var batch = new WalletOperationBatch(this.walletProvider, this.context);

							if (Array.isArray(params)) {
								batch.with(params);
							}

							return batch;
						};
						/**
						 *
						 * @description Create an smart contract abstraction for the address specified. Calling entrypoints with the returned
						 * smart contract abstraction will leverage the wallet provider to make smart contract calls
						 *
						 * @param address Smart contract address
						 */

						Wallet.prototype.at = function (address, contractAbstractionComposer) {
							if (contractAbstractionComposer === void 0) {
								contractAbstractionComposer = function (x) {
									return x;
								};
							}

							return __awaiter(this, void 0, void 0, function () {
								var rpc, script, entrypoints, blockHeader, chainId, abs;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											rpc = this.context.withExtensions().rpc;
											return [
												4,
												/*yield*/
												rpc.getScript(address)
											];

										case 1:
											script = _a.sent();
											return [
												4,
												/*yield*/
												rpc.getEntrypoints(address)
											];

										case 2:
											entrypoints = _a.sent();
											return [
												4,
												/*yield*/
												this.context.rpc.getBlockHeader()
											];

										case 3:
											blockHeader = _a.sent();
											chainId = blockHeader.chain_id;
											abs = new ContractAbstraction(
												address,
												script,
												this,
												this.context.contract,
												entrypoints,
												chainId
											);
											return [
												2,
												/*return*/
												contractAbstractionComposer(abs, this.context)
											];
									}
								});
							});
						};

						return Wallet;
					})();

				exports.Wallet = Wallet;

				var LegacyWalletProvider =
					/** @class */
					(function () {
						function LegacyWalletProvider(context) {
							this.context = context;
						}

						LegacyWalletProvider.prototype.getPKH = function () {
							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_a) {
									return [
										2,
										/*return*/
										this.context.signer.publicKeyHash()
									];
								});
							});
						};

						LegacyWalletProvider.prototype.mapTransferParamsToWalletParams = function (params) {
							return __awaiter(this, void 0, void 0, function () {
								var _a;

								return __generator(this, function (_b) {
									switch (_b.label) {
										case 0:
											_a = attachKind;
											return [
												4,
												/*yield*/
												params()
											];

										case 1:
											return [
												2,
												/*return*/
												_a.apply(void 0, [_b.sent(), _rpc2.OpKind.TRANSACTION])
											];
									}
								});
							});
						};

						LegacyWalletProvider.prototype.mapOriginateParamsToWalletParams = function (params) {
							return __awaiter(this, void 0, void 0, function () {
								var _a;

								return __generator(this, function (_b) {
									switch (_b.label) {
										case 0:
											_a = attachKind;
											return [
												4,
												/*yield*/
												params()
											];

										case 1:
											return [
												2,
												/*return*/
												_a.apply(void 0, [_b.sent(), _rpc2.OpKind.ORIGINATION])
											];
									}
								});
							});
						};

						LegacyWalletProvider.prototype.mapDelegateParamsToWalletParams = function (params) {
							return __awaiter(this, void 0, void 0, function () {
								var _a;

								return __generator(this, function (_b) {
									switch (_b.label) {
										case 0:
											_a = attachKind;
											return [
												4,
												/*yield*/
												params()
											];

										case 1:
											return [
												2,
												/*return*/
												_a.apply(void 0, [_b.sent(), _rpc2.OpKind.DELEGATION])
											];
									}
								});
							});
						};

						LegacyWalletProvider.prototype.sendOperations = function (params) {
							return __awaiter(this, void 0, void 0, function () {
								var op;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.context.batch.batch(params).send()
											];

										case 1:
											op = _a.sent();
											return [
												2,
												/*return*/
												op.hash
											];
									}
								});
							});
						};

						return LegacyWalletProvider;
					})();
				/**
				 * @description Utility class to send smart contract operation
				 * The format for the arguments is the object representation
				 */

				exports.LegacyWalletProvider = LegacyWalletProvider;

				var ContractMethodObject =
					/** @class */
					(function () {
						function ContractMethodObject(
							provider,
							address,
							parameterSchema,
							name,
							args,
							isMultipleEntrypoint,
							isAnonymous
						) {
							if (args === void 0) {
								args = 'unit';
							}

							if (isMultipleEntrypoint === void 0) {
								isMultipleEntrypoint = true;
							}

							if (isAnonymous === void 0) {
								isAnonymous = false;
							}

							this.provider = provider;
							this.address = address;
							this.parameterSchema = parameterSchema;
							this.name = name;
							this.args = args;
							this.isMultipleEntrypoint = isMultipleEntrypoint;
							this.isAnonymous = isAnonymous;
						}
						/**
						 * @description Get the signature of the smart contract method
						 */

						ContractMethodObject.prototype.getSignature = function () {
							return this.isAnonymous
								? this.parameterSchema.ExtractSchema()[this.name]
								: this.parameterSchema.ExtractSchema();
						};
						/**
						 *
						 * @description Send the smart contract operation
						 *
						 * @param Options generic operation parameter
						 */

						ContractMethodObject.prototype.send = function (params) {
							if (params === void 0) {
								params = {};
							}

							if (this.provider instanceof Wallet) {
								return this.provider.transfer(this.toTransferParams(params)).send();
							} else {
								return this.provider.transfer(this.toTransferParams(params));
							}
						};
						/**
						 *
						 * @description Create transfer params to be used with TezosToolkit.contract.transfer methods
						 *
						 * @param Options generic transfer operation parameters
						 */

						ContractMethodObject.prototype.toTransferParams = function (_a) {
							var _b;

							var _c = _a === void 0 ? {} : _a,
								fee = _c.fee,
								gasLimit = _c.gasLimit,
								storageLimit = _c.storageLimit,
								source = _c.source,
								_d = _c.amount,
								amount = _d === void 0 ? 0 : _d,
								_e = _c.mutez,
								mutez = _e === void 0 ? false : _e;

							var fullTransferParams = {
								to: this.address,
								amount: amount,
								fee: fee,
								mutez: mutez,
								source: source,
								gasLimit: gasLimit,
								storageLimit: storageLimit,
								parameter: {
									entrypoint: this.isMultipleEntrypoint
										? this.name
										: DEFAULT_SMART_CONTRACT_METHOD_NAME,
									value: this.isAnonymous
										? this.parameterSchema.EncodeObject(
												((_b = {}), (_b[this.name] = this.args), _b)
										  )
										: this.parameterSchema.EncodeObject(this.args)
								}
							};
							return fullTransferParams;
						};

						return ContractMethodObject;
					})();

				exports.ContractMethodObject = ContractMethodObject;

				var ContractMethodFactory =
					/** @class */
					(function () {
						function ContractMethodFactory() {}

						ContractMethodFactory.prototype.createContractMethodFlatParams = function (
							provider,
							address,
							smartContractMethodSchema,
							smartContractMethodName,
							args,
							isMultipleEntrypoint,
							isAnonymous
						) {
							if (isMultipleEntrypoint === void 0) {
								isMultipleEntrypoint = true;
							}

							if (isAnonymous === void 0) {
								isAnonymous = false;
							}

							return new ContractMethod(
								provider,
								address,
								smartContractMethodSchema,
								smartContractMethodName,
								args,
								isMultipleEntrypoint,
								isAnonymous
							);
						};

						ContractMethodFactory.prototype.createContractMethodObjectParam = function (
							provider,
							address,
							smartContractMethodSchema,
							smartContractMethodName,
							args,
							isMultipleEntrypoint,
							isAnonymous
						) {
							if (isMultipleEntrypoint === void 0) {
								isMultipleEntrypoint = true;
							}

							if (isAnonymous === void 0) {
								isAnonymous = false;
							}

							return new ContractMethodObject(
								provider,
								address,
								smartContractMethodSchema,
								smartContractMethodName,
								args,
								isMultipleEntrypoint,
								isAnonymous
							);
						};

						return ContractMethodFactory;
					})();

				var LambdaView =
					/** @class */
					(function () {
						function LambdaView(lambdaContract, viewContract, viewMethod, contractParameter) {
							if (viewMethod === void 0) {
								viewMethod = 'default';
							}

							if (contractParameter === void 0) {
								contractParameter = {
									prim: 'Unit'
								};
							}

							this.lambdaContract = lambdaContract;
							this.viewContract = viewContract;
							this.viewMethod = viewMethod;
							this.contractParameter = contractParameter;
							this.voidLambda = this.createVoidLambda();
						}

						LambdaView.prototype.execute = function () {
							return __awaiter(this, void 0, void 0, function () {
								var ex_1, lastError, failedWith;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											_a.trys.push([0, 2, , 3]);

											return [
												4,
												/*yield*/
												this.lambdaContract.methods.default(this.voidLambda).send()
											];

										case 1:
											_a.sent();

											return [3 /*break*/, 3];

										case 2:
											ex_1 = _a.sent();

											if (ex_1 instanceof TezosOperationError) {
												lastError = ex_1.errors[ex_1.errors.length - 1];
												failedWith = lastError.with;
												return [
													2,
													/*return*/
													failedWith
												];
											} else {
												throw ex_1;
											}

										case 3:
											return [
												2
												/*return*/
											];
									}
								});
							});
						};

						LambdaView.prototype.createVoidLambda = function () {
							var _a = __read(this.getView(), 2),
								parameter = _a[0],
								callback = _a[1];

							var contractArgs = [
								{
									prim: 'pair',
									args: [
										parameter,
										{
											prim: 'contract',
											args: [callback]
										}
									]
								}
							];

							if (this.viewMethod === 'default') {
								contractArgs = [
									{
										string: '%default'
									}
								].concat(contractArgs);
							}

							return [
								{
									prim: 'PUSH',
									args: [
										{
											prim: 'mutez'
										},
										{
											int: '0'
										}
									]
								},
								{
									prim: 'NONE',
									args: [
										{
											prim: 'key_hash'
										}
									]
								},
								{
									prim: 'CREATE_CONTRACT',
									args: [
										[
											{
												prim: 'parameter',
												args: [callback]
											},
											{
												prim: 'storage',
												args: [
													{
														prim: 'unit'
													}
												]
											},
											{
												prim: 'code',
												args: [
													[
														{
															prim: 'CAR'
														},
														{
															prim: 'FAILWITH'
														}
													]
												]
											}
										]
									]
								},
								{
									prim: 'DIP',
									args: [
										[
											{
												prim: 'DIP',
												args: [
													[
														{
															prim: 'LAMBDA',
															args: [
																{
																	prim: 'pair',
																	args: [
																		{
																			prim: 'address'
																		},
																		{
																			prim: 'unit'
																		}
																	]
																},
																{
																	prim: 'pair',
																	args: [
																		{
																			prim: 'list',
																			args: [
																				{
																					prim: 'operation'
																				}
																			]
																		},
																		{
																			prim: 'unit'
																		}
																	]
																},
																[
																	{
																		prim: 'CAR'
																	},
																	{
																		prim: 'CONTRACT',
																		args: [callback]
																	},
																	{
																		prim: 'IF_NONE',
																		args: [
																			[
																				{
																					prim: 'PUSH',
																					args: [
																						{
																							prim: 'string'
																						},
																						{
																							string: 'Callback type unmatched'
																						}
																					]
																				},
																				{
																					prim: 'FAILWITH'
																				}
																			],
																			[]
																		]
																	},
																	{
																		prim: 'PUSH',
																		args: [parameter, this.contractParameter]
																	},
																	{
																		prim: 'PAIR'
																	},
																	{
																		prim: 'DIP',
																		args: [
																			[
																				{
																					prim: 'PUSH',
																					args: [
																						{
																							prim: 'address'
																						},
																						{
																							string:
																								this.viewContract.address + '%' + this.viewMethod
																						}
																					]
																				},
																				{
																					prim: 'DUP'
																				},
																				{
																					prim: 'CONTRACT',
																					args: contractArgs
																				},
																				{
																					prim: 'IF_NONE',
																					args: [
																						[
																							{
																								prim: 'PUSH',
																								args: [
																									{
																										prim: 'string'
																									},
																									{
																										string: 'Contract does not exist'
																									}
																								]
																							},
																							{
																								prim: 'FAILWITH'
																							}
																						],
																						[
																							{
																								prim: 'DIP',
																								args: [
																									[
																										{
																											prim: 'DROP'
																										}
																									]
																								]
																							}
																						]
																					]
																				},
																				{
																					prim: 'PUSH',
																					args: [
																						{
																							prim: 'mutez'
																						},
																						{
																							int: '0'
																						}
																					]
																				}
																			]
																		]
																	},
																	{
																		prim: 'TRANSFER_TOKENS'
																	},
																	{
																		prim: 'DIP',
																		args: [
																			[
																				{
																					prim: 'NIL',
																					args: [
																						{
																							prim: 'operation'
																						}
																					]
																				}
																			]
																		]
																	},
																	{
																		prim: 'CONS'
																	},
																	{
																		prim: 'DIP',
																		args: [
																			[
																				{
																					prim: 'UNIT'
																				}
																			]
																		]
																	},
																	{
																		prim: 'PAIR'
																	}
																]
															]
														}
													]
												]
											},
											{
												prim: 'APPLY'
											},
											{
												prim: 'DIP',
												args: [
													[
														{
															prim: 'PUSH',
															args: [
																{
																	prim: 'address'
																},
																{
																	string: this.lambdaContract.address
																}
															]
														},
														{
															prim: 'DUP'
														},
														{
															prim: 'CONTRACT',
															args: [
																{
																	prim: 'lambda',
																	args: [
																		{
																			prim: 'unit'
																		},
																		{
																			prim: 'pair',
																			args: [
																				{
																					prim: 'list',
																					args: [
																						{
																							prim: 'operation'
																						}
																					]
																				},
																				{
																					prim: 'unit'
																				}
																			]
																		}
																	]
																}
															]
														},
														{
															prim: 'IF_NONE',
															args: [
																[
																	{
																		prim: 'PUSH',
																		args: [
																			{
																				prim: 'string'
																			},
																			{
																				string: 'Contract does not exists'
																			}
																		]
																	},
																	{
																		prim: 'FAILWITH'
																	}
																],
																[
																	{
																		prim: 'DIP',
																		args: [
																			[
																				{
																					prim: 'DROP'
																				}
																			]
																		]
																	}
																]
															]
														},
														{
															prim: 'PUSH',
															args: [
																{
																	prim: 'mutez'
																},
																{
																	int: '0'
																}
															]
														}
													]
												]
											},
											{
												prim: 'TRANSFER_TOKENS'
											},
											{
												prim: 'DIP',
												args: [
													[
														{
															prim: 'NIL',
															args: [
																{
																	prim: 'operation'
																}
															]
														}
													]
												]
											},
											{
												prim: 'CONS'
											}
										]
									]
								},
								{
									prim: 'CONS'
								},
								{
									prim: 'DIP',
									args: [
										[
											{
												prim: 'UNIT'
											}
										]
									]
								},
								{
									prim: 'PAIR'
								}
							];
						};

						LambdaView.prototype.getView = function () {
							var entrypoints = this.viewContract.entrypoints.entrypoints;
							var entrypoint = entrypoints[this.viewMethod];

							if (!entrypoint) {
								throw Error(
									'Contract at ' +
										this.viewContract.address +
										' does not have entrypoint: ' +
										this.viewMethod
								);
							}

							if (!('prim' in entrypoint) || !entrypoint.args) {
								// TODO: Enhance this error message to be more descriptive
								throw Error('Entrypoint args undefined');
							}

							var args = Array.from(entrypoint.args);

							var _a = __read(args, 2),
								parameter = _a[0],
								callbackContract = _a[1];

							if ('annots' in parameter) {
								delete parameter['annots'];
							}

							if (!('prim' in callbackContract) || !callbackContract.args) {
								// TODO: Enhance this error message to be more descriptive
								throw Error('Callback contract args undefined');
							}

							var message;

							if (entrypoint.prim !== 'pair') {
								message =
									"Expected {'prim': 'pair', ..} but found {'prim': " + entrypoint.prim + ', ..}';
							} else if (args.length !== 2) {
								message = 'Expected an Array of length 2, but found: ' + args;
							} else if (callbackContract.prim !== 'contract') {
								message = "Expected a {prim: 'contract', ...}, but found: " + callbackContract.prim;
							} else if (callbackContract.args && callbackContract.args.length !== 1) {
								message =
									"Expected a single argument to 'contract', but found: " + callbackContract.args;
							}

							if (message) throw Error(message);
							return [parameter, callbackContract.args[0]];
						};

						return LambdaView;
					})();

				var DEFAULT_SMART_CONTRACT_METHOD_NAME = 'default';
				/**
				 * @description Utility class to retrieve data from a smart contract's storage without incurring fees via a contract's view method
				 */

				exports.DEFAULT_SMART_CONTRACT_METHOD_NAME = DEFAULT_SMART_CONTRACT_METHOD_NAME;

				var ContractView =
					/** @class */
					(function () {
						function ContractView(
							currentContract,
							provider,
							name,
							chainId,
							callbackParametersSchema,
							parameterSchema,
							args
						) {
							this.currentContract = currentContract;
							this.provider = provider;
							this.name = name;
							this.chainId = chainId;
							this.callbackParametersSchema = callbackParametersSchema;
							this.parameterSchema = parameterSchema;
							this.args = args;
						}
						/**
						 *
						 * @description Find which lambda contract to use based on the current network,
						 * encode parameters to Michelson,
						 * create an instance of Lambdaview to retrive data, and
						 * Decode Michelson response
						 *
						 * @param Options Address of a lambda contract (sandbox users)
						 */

						ContractView.prototype.read = function (customLambdaAddress) {
							return __awaiter(this, void 0, void 0, function () {
								var lambdaAddress, lambdaContract, arg, lambdaView, failedWith, response;

								var _a;

								return __generator(this, function (_b) {
									switch (_b.label) {
										case 0:
											// TODO Verify if the 'customLambdaAdress' is a valid originated contract and if not, return an appropriate error message.
											if (customLambdaAddress) {
												lambdaAddress = customLambdaAddress;
											} else if (this.chainId === ChainIds.EDONET) {
												lambdaAddress = DefaultLambdaAddresses.EDONET;
											} else if (this.chainId === ChainIds.FLORENCENET) {
												lambdaAddress = DefaultLambdaAddresses.FLORENCENET;
											} else if (this.chainId === ChainIds.GRANADANET) {
												lambdaAddress = DefaultLambdaAddresses.GRANADANET;
											} else if (this.chainId === ChainIds.HANGZHOUNET) {
												lambdaAddress = DefaultLambdaAddresses.HANGZHOUNET;
											} else if (this.chainId === ChainIds.MAINNET) {
												lambdaAddress = DefaultLambdaAddresses.MAINNET;
											} else {
												throw new UndefinedLambdaContractError();
											}

											return [
												4,
												/*yield*/
												this.provider.at(lambdaAddress)
											];

										case 1:
											lambdaContract = _b.sent();
											arg = (_a = this.parameterSchema).Encode.apply(
												_a,
												__spreadArray([], __read(this.args))
											);
											lambdaView = new LambdaView(
												lambdaContract,
												this.currentContract,
												this.name,
												arg
											);
											return [
												4,
												/*yield*/
												lambdaView.execute()
											];

										case 2:
											failedWith = _b.sent();
											response = this.callbackParametersSchema.Execute(failedWith);
											return [
												2,
												/*return*/
												response
											];
									}
								});
							});
						};

						return ContractView;
					})();

				exports.ContractView = ContractView;

				var validateArgs = function (args, schema, name) {
					var sigs = schema.ExtractSignatures();

					if (
						!sigs.find(function (x) {
							return x.length === args.length;
						})
					) {
						throw new InvalidParameterError(name, sigs, args);
					}
				};

				var isView = function (schema) {
					var isView = false;
					var sigs = schema.ExtractSignatures();

					if (sigs[0][sigs[0].length - 1] === 'contract') {
						isView = true;
					}

					return isView;
				};

				var isContractProvider = function (variableToCheck) {
					return variableToCheck.contractProviderTypeSymbol !== undefined;
				};
				/**
				 * @description Smart contract abstraction
				 */

				var ContractAbstraction =
					/** @class */
					(function () {
						function ContractAbstraction(
							address,
							script,
							provider,
							storageProvider,
							entrypoints,
							chainId
						) {
							this.address = address;
							this.script = script;
							this.storageProvider = storageProvider;
							this.entrypoints = entrypoints;
							this.chainId = chainId;
							this.contractMethodFactory = new ContractMethodFactory();
							/**
							 * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.
							 * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.
							 *
							 */

							this.methods = {};
							/**
							 * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.
							 * `methodsObject` serves the exact same purpose as the `methods` member. The difference is that it allows passing the parameter in an object format when calling the smart contract method (instead of the flattened representation)
							 * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.
							 *
							 */

							this.methodsObject = {};
							this.views = {};
							this.schema = _michelsonEncoder.Schema.fromRPCResponse({
								script: this.script
							});
							this.parameterSchema = _michelsonEncoder.ParameterSchema.fromRPCResponse({
								script: this.script
							});

							this._initializeMethods(
								this,
								address,
								provider,
								this.entrypoints.entrypoints,
								this.chainId
							);
						}

						ContractAbstraction.prototype._initializeMethods = function (
							currentContract,
							address,
							provider,
							entrypoints,
							chainId
						) {
							var _this = this;

							var parameterSchema = this.parameterSchema;
							var keys = Object.keys(entrypoints);

							if (parameterSchema.isMultipleEntryPoint) {
								keys.forEach(function (smartContractMethodName) {
									var smartContractMethodSchema = new _michelsonEncoder.ParameterSchema(
										entrypoints[smartContractMethodName]
									);

									_this.methods[smartContractMethodName] = function () {
										var args = [];

										for (var _i = 0; _i < arguments.length; _i++) {
											args[_i] = arguments[_i];
										}

										return currentContract.contractMethodFactory.createContractMethodFlatParams(
											provider,
											address,
											smartContractMethodSchema,
											smartContractMethodName,
											args
										);
									};

									_this.methodsObject[smartContractMethodName] = function (args) {
										return currentContract.contractMethodFactory.createContractMethodObjectParam(
											provider,
											address,
											smartContractMethodSchema,
											smartContractMethodName,
											args
										);
									};

									if (isContractProvider(provider)) {
										if (isView(smartContractMethodSchema)) {
											var view = function () {
												var args = [];

												for (var _i = 0; _i < arguments.length; _i++) {
													args[_i] = arguments[_i];
												}

												var entrypointParamWithoutCallback =
													entrypoints[smartContractMethodName].args[0];
												var smartContractMethodSchemaWithoutCallback =
													new _michelsonEncoder.ParameterSchema(entrypointParamWithoutCallback);
												var parametersCallback =
													entrypoints[smartContractMethodName].args[1].args[0];
												var smartContractMethodCallbackSchema =
													new _michelsonEncoder.ParameterSchema(parametersCallback);
												validateArgs(
													args,
													smartContractMethodSchemaWithoutCallback,
													smartContractMethodName
												);
												return new ContractView(
													currentContract,
													provider,
													smartContractMethodName,
													chainId,
													smartContractMethodCallbackSchema,
													smartContractMethodSchemaWithoutCallback,
													args
												);
											};

											_this.views[smartContractMethodName] = view;
										}
									}
								}); // Deal with methods with no annotations which were not discovered by the RPC endpoint
								// Methods with no annotations are discovered using parameter schema

								var anonymousMethods = Object.keys(parameterSchema.ExtractSchema()).filter(
									function (key) {
										return Object.keys(entrypoints).indexOf(key) === -1;
									}
								);
								anonymousMethods.forEach(function (smartContractMethodName) {
									_this.methods[smartContractMethodName] = function () {
										var args = [];

										for (var _i = 0; _i < arguments.length; _i++) {
											args[_i] = arguments[_i];
										}

										return currentContract.contractMethodFactory.createContractMethodFlatParams(
											provider,
											address,
											parameterSchema,
											smartContractMethodName,
											args,
											false,
											true
										);
									};

									_this.methodsObject[smartContractMethodName] = function (args) {
										return currentContract.contractMethodFactory.createContractMethodObjectParam(
											provider,
											address,
											parameterSchema,
											smartContractMethodName,
											args,
											false,
											true
										);
									};
								});
							} else {
								var smartContractMethodSchema_1 = this.parameterSchema;

								this.methods[DEFAULT_SMART_CONTRACT_METHOD_NAME] = function () {
									var args = [];

									for (var _i = 0; _i < arguments.length; _i++) {
										args[_i] = arguments[_i];
									}

									return currentContract.contractMethodFactory.createContractMethodFlatParams(
										provider,
										address,
										smartContractMethodSchema_1,
										DEFAULT_SMART_CONTRACT_METHOD_NAME,
										args,
										false
									);
								};

								this.methodsObject[DEFAULT_SMART_CONTRACT_METHOD_NAME] = function (args) {
									return currentContract.contractMethodFactory.createContractMethodObjectParam(
										provider,
										address,
										smartContractMethodSchema_1,
										DEFAULT_SMART_CONTRACT_METHOD_NAME,
										args,
										false
									);
								};
							}
						};
						/**
						 * @description Return a friendly representation of the smart contract storage
						 */

						ContractAbstraction.prototype.storage = function () {
							return this.storageProvider.getStorage(this.address, this.schema);
						};
						/**
						 *
						 * @description Return a friendly representation of the smart contract big map value
						 *
						 * @param key BigMap key to fetch
						 *
						 * @deprecated getBigMapKey has been deprecated in favor of getBigMapKeyByID
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get
						 */

						ContractAbstraction.prototype.bigMap = function (key) {
							// tslint:disable-next-line: deprecation
							return this.storageProvider.getBigMapKey(this.address, key, this.schema);
						};

						return ContractAbstraction;
					})();

				exports.ContractAbstraction = ContractAbstraction;

				var BigMapAbstraction =
					/** @class */
					(function () {
						function BigMapAbstraction(id, schema, provider) {
							this.id = id;
							this.schema = schema;
							this.provider = provider;
						}
						/**
						 *
						 * @description Fetch one value in a big map
						 *
						 * @param keysToEncode Key to query (will be encoded properly according to the schema)
						 * @param block optional block level to fetch the values from (head will be use by default)
						 * @returns Return a well formatted json object of a big map value or undefined if the key is not found in the big map
						 *
						 */

						BigMapAbstraction.prototype.get = function (keyToEncode, block) {
							return __awaiter(this, void 0, void 0, function () {
								var id, e_1;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											_a.trys.push([0, 2, , 3]);

											return [
												4,
												/*yield*/
												this.provider.getBigMapKeyByID(
													this.id.toString(),
													keyToEncode,
													this.schema,
													block
												)
											];

										case 1:
											id = _a.sent();
											return [
												2,
												/*return*/
												id
											];

										case 2:
											e_1 = _a.sent();

											if (
												e_1 instanceof _httpUtils.HttpResponseError &&
												e_1.status === _httpUtils.STATUS_CODE.NOT_FOUND
											) {
												return [
													2,
													/*return*/
													undefined
												];
											} else {
												throw e_1;
											}

										case 3:
											return [
												2
												/*return*/
											];
									}
								});
							});
						};
						/**
						 *
						 * @description Fetch multiple values in a big map
						 * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.
						 * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.
						 * If one of the keys does not exist in the big map, its value will be set to undefined.
						 *
						 * @param keysToEncode Array of keys to query (will be encoded properly according to the schema)
						 * @param block optional block level to fetch the values from
						 * @param batchSize optional batch size representing the number of requests to execute in parallel
						 * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format
						 *
						 */

						BigMapAbstraction.prototype.getMultipleValues = function (
							keysToEncode,
							block,
							batchSize
						) {
							if (batchSize === void 0) {
								batchSize = 5;
							}

							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_a) {
									return [
										2,
										/*return*/
										this.provider.getBigMapKeysByID(
											this.id.toString(),
											keysToEncode,
											this.schema,
											block,
											batchSize
										)
									];
								});
							});
						};

						BigMapAbstraction.prototype.toJSON = function () {
							return this.id.toString();
						};

						BigMapAbstraction.prototype.toString = function () {
							return this.id.toString();
						};

						return BigMapAbstraction;
					})();

				exports.BigMapAbstraction = BigMapAbstraction;

				var SaplingStateAbstraction =
					/** @class */
					(function () {
						function SaplingStateAbstraction(id, provider) {
							this.id = id;
							this.provider = provider;
						}
						/**
						 *
						 * @description Fetch the sapling state
						 *
						 * @param block optional block level to fetch the values from (head will be use by default)
						 * @returns Return a json object of the sapling_state
						 *
						 */

						SaplingStateAbstraction.prototype.getSaplingDiff = function (block) {
							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_a) {
									return [
										2,
										/*return*/
										this.provider.getSaplingDiffByID(this.id.toString(), block)
									];
								});
							});
						};

						SaplingStateAbstraction.prototype.getId = function () {
							return this.id.toString();
						};

						return SaplingStateAbstraction;
					})(); // Override the default michelson encoder semantic to provide richer abstraction over storage properties

				var smartContractAbstractionSemantic = function (provider) {
					return {
						// Provide a specific abstraction for BigMaps
						big_map: function (val, code) {
							if (!val || !('int' in val) || val.int === undefined) {
								// Return an empty object in case of missing big map ID
								return {};
							} else {
								var schema = new _michelsonEncoder.Schema(code);
								return new BigMapAbstraction(new _bignumber.default(val.int), schema, provider);
							}
						},
						sapling_state: function (val) {
							if (!val || !('int' in val) || val.int === undefined) {
								// Return an empty object in case of missing sapling state ID
								return {};
							} else {
								return new SaplingStateAbstraction(new _bignumber.default(val.int), provider);
							}
						}
						/*
    // TODO: embed useful other abstractions
    'contract':  () => {},
    'address':  () => {}
    */
					};
				};

				var RpcContractProvider =
					/** @class */
					(function (_super) {
						__extends(RpcContractProvider, _super);

						function RpcContractProvider(context, estimator) {
							var _this = _super.call(this, context) || this;

							_this.estimator = estimator;
							_this.contractProviderTypeSymbol = Symbol.for('taquito--provider-type-symbol');
							return _this;
						}
						/**
						 *
						 * @description Return a well formatted json object of the contract storage
						 *
						 * @param contract contract address you want to get the storage from
						 * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script
						 */

						RpcContractProvider.prototype.getStorage = function (contract, schema) {
							return __awaiter(this, void 0, void 0, function () {
								var contractSchema, storage;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											if (!!schema) return [3 /*break*/, 2];
											return [
												4,
												/*yield*/
												this.rpc.getScript(contract)
											];

										case 1:
											schema = _a.sent();
											_a.label = 2;

										case 2:
											if (_michelsonEncoder.Schema.isSchema(schema)) {
												contractSchema = schema;
											} else {
												contractSchema = _michelsonEncoder.Schema.fromRPCResponse({
													script: schema
												});
											}

											return [
												4,
												/*yield*/
												this.rpc.getStorage(contract)
											];

										case 3:
											storage = _a.sent();
											return [
												2,
												/*return*/
												contractSchema.Execute(storage, smartContractAbstractionSemantic(this))
											];
										// Cast into T because only the caller can know the true type of the storage
									}
								});
							});
						};
						/**
						 *
						 * @description Return a well formatted json object of the contract big map storage
						 *
						 * @param contract contract address you want to get the storage from
						 * @param key contract big map key to fetch value from
						 * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema
						 *
						 * @deprecated Deprecated in favor of getBigMapKeyByID
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get
						 */

						RpcContractProvider.prototype.getBigMapKey = function (contract, key, schema) {
							return __awaiter(this, void 0, void 0, function () {
								var contractSchema, encodedKey, val;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											if (!!schema) return [3 /*break*/, 2];
											return [
												4,
												/*yield*/
												this.rpc.getScript(contract)
											];

										case 1:
											schema = _a.sent();
											_a.label = 2;

										case 2:
											if (_michelsonEncoder.Schema.isSchema(schema)) {
												contractSchema = schema;
											} else {
												contractSchema = _michelsonEncoder.Schema.fromRPCResponse({
													script: schema
												});
											}

											encodedKey = contractSchema.EncodeBigMapKey(key);
											return [
												4,
												/*yield*/
												this.rpc.getBigMapKey(contract, encodedKey)
											];

										case 3:
											val = _a.sent();
											return [
												2,
												/*return*/
												contractSchema.ExecuteOnBigMapValue(val)
											];
										// Cast into T because only the caller can know the true type of the storage
									}
								});
							});
						};
						/**
						 *
						 * @description Return a well formatted json object of a big map value
						 *
						 * @param id Big Map ID
						 * @param keyToEncode key to query (will be encoded properly according to the schema)
						 * @param schema Big Map schema (can be determined using your contract type)
						 * @param block optional block level to fetch the values from
						 *
						 * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr
						 */

						RpcContractProvider.prototype.getBigMapKeyByID = function (
							id,
							keyToEncode,
							schema,
							block
						) {
							return __awaiter(this, void 0, void 0, function () {
								var _a, key, type, packed, encodedExpr, bigMapValue, _b;

								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											(_a = schema.EncodeBigMapKey(keyToEncode)), (key = _a.key), (type = _a.type);
											return [
												4,
												/*yield*/
												this.context.packer.packData({
													data: key,
													type: type
												})
											];

										case 1:
											packed = _c.sent().packed;
											encodedExpr = (0, _utils.encodeExpr)(packed);
											if (!block) return [3 /*break*/, 3];
											return [
												4,
												/*yield*/
												this.context.rpc.getBigMapExpr(id.toString(), encodedExpr, {
													block: String(block)
												})
											];

										case 2:
											_b = _c.sent();
											return [3 /*break*/, 5];

										case 3:
											return [
												4,
												/*yield*/
												this.context.rpc.getBigMapExpr(id.toString(), encodedExpr)
											];

										case 4:
											_b = _c.sent();
											_c.label = 5;

										case 5:
											bigMapValue = _b;
											return [
												2,
												/*return*/
												schema.ExecuteOnBigMapValue(
													bigMapValue,
													smartContractAbstractionSemantic(this)
												)
											];
									}
								});
							});
						};
						/**
						 *
						 * @description Fetch multiple values in a big map
						 * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.
						 * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.
						 * If one of the keys does not exist in the big map, its value will be set to undefined.
						 *
						 * @param id Big Map ID
						 * @param keys Array of keys to query (will be encoded properly according to the schema)
						 * @param schema Big Map schema (can be determined using your contract type)
						 * @param block optional block level to fetch the values from
						 * @param batchSize optional batch size representing the number of requests to execute in parallel
						 * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format
						 *
						 */

						RpcContractProvider.prototype.getBigMapKeysByID = function (
							id,
							keys,
							schema,
							block,
							batchSize
						) {
							if (batchSize === void 0) {
								batchSize = 5;
							}

							return __awaiter(this, void 0, void 0, function () {
								var level, bigMapValues, position, results, keysBatch, batch, _a, i;

								var _this = this;

								return __generator(this, function (_b) {
									switch (_b.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.getBlockForRequest(keys, block)
											];

										case 1:
											level = _b.sent();
											bigMapValues = new _michelsonEncoder.MichelsonMap();
											position = 0;
											results = [];
											_b.label = 2;

										case 2:
											if (!(position < keys.length)) return [3 /*break*/, 4];
											keysBatch = keys.slice(position, position + batchSize);
											batch = keysBatch.map(function (keyToEncode) {
												return _this.getBigMapValueOrUndefined(keyToEncode, id, schema, level);
											});
											_a = [__spreadArray([], __read(results))];
											return [
												4,
												/*yield*/
												Promise.all(batch)
											];

										case 3:
											results = __spreadArray.apply(
												void 0,
												_a.concat([__read.apply(void 0, [_b.sent()])])
											);
											position += batchSize;
											return [3 /*break*/, 2];

										case 4:
											for (i = 0; i < results.length; i++) {
												bigMapValues.set(keys[i], results[i]);
											}

											return [
												2,
												/*return*/
												bigMapValues
											];
									}
								});
							});
						};

						RpcContractProvider.prototype.getBlockForRequest = function (keys, block) {
							var _a;

							return __awaiter(this, void 0, void 0, function () {
								var _b;

								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											if (!(keys.length === 1 || typeof block !== 'undefined'))
												return [3 /*break*/, 1];
											_b = block;
											return [3 /*break*/, 3];

										case 1:
											return [
												4,
												/*yield*/
												this.rpc.getBlock()
											];

										case 2:
											_b = (_a = _c.sent()) === null || _a === void 0 ? void 0 : _a.header.level;
											_c.label = 3;

										case 3:
											return [
												2,
												/*return*/
												_b
											];
									}
								});
							});
						};

						RpcContractProvider.prototype.getBigMapValueOrUndefined = function (
							keyToEncode,
							id,
							schema,
							level
						) {
							return __awaiter(this, void 0, void 0, function () {
								var ex_1;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											_a.trys.push([0, 2, , 3]);

											return [
												4,
												/*yield*/
												this.getBigMapKeyByID(id, keyToEncode, schema, level)
											];

										case 1:
											return [
												2,
												/*return*/
												_a.sent()
											];

										case 2:
											ex_1 = _a.sent();

											if (
												ex_1 instanceof _httpUtils.HttpResponseError &&
												ex_1.status === _httpUtils.STATUS_CODE.NOT_FOUND
											) {
												return [
													2
													/*return*/
												];
											} else {
												throw ex_1;
											}

										case 3:
											return [
												2
												/*return*/
											];
									}
								});
							});
						};
						/**
						 *
						 * @description Return a well formatted json object of a sapling state
						 *
						 * @param id Sapling state ID
						 * @param block optional block level to fetch the value from
						 *
						 */

						RpcContractProvider.prototype.getSaplingDiffByID = function (id, block) {
							return __awaiter(this, void 0, void 0, function () {
								var saplingState, _a;

								return __generator(this, function (_b) {
									switch (_b.label) {
										case 0:
											if (!block) return [3 /*break*/, 2];
											return [
												4,
												/*yield*/
												this.context.rpc.getSaplingDiffById(id.toString(), {
													block: String(block)
												})
											];

										case 1:
											_a = _b.sent();
											return [3 /*break*/, 4];

										case 2:
											return [
												4,
												/*yield*/
												this.context.rpc.getSaplingDiffById(id.toString())
											];

										case 3:
											_a = _b.sent();
											_b.label = 4;

										case 4:
											saplingState = _a;
											return [
												2,
												/*return*/
												saplingState
											];
									}
								});
							});
						};

						RpcContractProvider.prototype.addRevealOperationIfNeeded = function (
							operation,
							publicKeyHash
						) {
							return __awaiter(this, void 0, void 0, function () {
								var ops, publicKey, estimateReveal_1, reveal, estimatedReveal, _a, _b;

								var _this = this;

								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											if (!isOpRequireReveal(operation)) return [3 /*break*/, 5];
											ops = [operation];
											return [
												4,
												/*yield*/
												this.signer.publicKey()
											];

										case 1:
											publicKey = _c.sent();
											return [
												4,
												/*yield*/
												this.estimator.reveal()
											];

										case 2:
											estimateReveal_1 = _c.sent();
											if (!estimateReveal_1) return [3 /*break*/, 5];
											reveal = {
												kind: _rpc2.OpKind.REVEAL
											};
											return [
												4,
												/*yield*/
												this.estimate(reveal, function () {
													return __awaiter(_this, void 0, void 0, function () {
														return __generator(this, function (_a) {
															return [
																2,
																/*return*/
																estimateReveal_1
															];
														});
													});
												})
											];

										case 3:
											estimatedReveal = _c.sent();
											_b = (_a = ops).unshift;
											return [
												4,
												/*yield*/
												createRevealOperation(
													__assign({}, estimatedReveal),
													publicKeyHash,
													publicKey
												)
											];

										case 4:
											_b.apply(_a, [_c.sent()]);

											return [
												2,
												/*return*/
												ops
											];

										case 5:
											return [
												2,
												/*return*/
												operation
											];
									}
								});
							});
						};
						/**
						 *
						 * @description Originate a new contract according to the script in parameters. Will sign and inject an operation using the current context
						 *
						 * @returns An operation handle with the result from the rpc node
						 *
						 * @warn You cannot specify storage and init at the same time (use init to pass the raw michelson representation of storage)
						 *
						 * @param OriginationOperation Originate operation parameter
						 */

						RpcContractProvider.prototype.originate = function (params) {
							return __awaiter(this, void 0, void 0, function () {
								var estimate,
									publicKeyHash,
									operation,
									_a,
									ops,
									preparedOrigination,
									forgedOrigination,
									_b,
									hash,
									context,
									forgedBytes,
									opResponse;

								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.estimate(params, this.estimator.originate.bind(this.estimator))
											];

										case 1:
											estimate = _c.sent();
											return [
												4,
												/*yield*/
												this.signer.publicKeyHash()
											];

										case 2:
											publicKeyHash = _c.sent();
											_a = createOriginationOperation;
											return [
												4,
												/*yield*/
												this.context.parser.prepareCodeOrigination(
													__assign(__assign({}, params), estimate)
												)
											];

										case 3:
											return [
												4,
												/*yield*/
												_a.apply(void 0, [_c.sent()])
											];

										case 4:
											operation = _c.sent();
											return [
												4,
												/*yield*/
												this.addRevealOperationIfNeeded(operation, publicKeyHash)
											];

										case 5:
											ops = _c.sent();
											return [
												4,
												/*yield*/
												this.prepareOperation({
													operation: ops,
													source: publicKeyHash
												})
											];

										case 6:
											preparedOrigination = _c.sent();
											return [
												4,
												/*yield*/
												this.forge(preparedOrigination)
											];

										case 7:
											forgedOrigination = _c.sent();
											return [
												4,
												/*yield*/
												this.signAndInject(forgedOrigination)
											];

										case 8:
											(_b = _c.sent()),
												(hash = _b.hash),
												(context = _b.context),
												(forgedBytes = _b.forgedBytes),
												(opResponse = _b.opResponse);
											return [
												2,
												/*return*/
												new OriginationOperation(
													hash,
													operation,
													forgedBytes,
													opResponse,
													context,
													this
												)
											];
									}
								});
							});
						};
						/**
						 *
						 * @description Set the delegate for a contract. Will sign and inject an operation using the current context
						 *
						 * @returns An operation handle with the result from the rpc node
						 *
						 * @param SetDelegate operation parameter
						 */

						RpcContractProvider.prototype.setDelegate = function (params) {
							return __awaiter(this, void 0, void 0, function () {
								var estimate,
									publicKeyHash,
									operation,
									sourceOrDefault,
									ops,
									prepared,
									opBytes,
									_a,
									hash,
									context,
									forgedBytes,
									opResponse;

								return __generator(this, function (_b) {
									switch (_b.label) {
										case 0:
											// Since babylon delegation source cannot smart contract
											if (/kt1/i.test(params.source)) {
												throw new InvalidDelegationSource(params.source);
											}

											return [
												4,
												/*yield*/
												this.estimate(params, this.estimator.setDelegate.bind(this.estimator))
											];

										case 1:
											estimate = _b.sent();
											return [
												4,
												/*yield*/
												this.signer.publicKeyHash()
											];

										case 2:
											publicKeyHash = _b.sent();
											return [
												4,
												/*yield*/
												createSetDelegateOperation(__assign(__assign({}, params), estimate))
											];

										case 3:
											operation = _b.sent();
											sourceOrDefault = params.source || publicKeyHash;
											return [
												4,
												/*yield*/
												this.addRevealOperationIfNeeded(operation, publicKeyHash)
											];

										case 4:
											ops = _b.sent();
											return [
												4,
												/*yield*/
												this.prepareOperation({
													operation: ops,
													source: sourceOrDefault
												})
											];

										case 5:
											prepared = _b.sent();
											return [
												4,
												/*yield*/
												this.forge(prepared)
											];

										case 6:
											opBytes = _b.sent();
											return [
												4,
												/*yield*/
												this.signAndInject(opBytes)
											];

										case 7:
											(_a = _b.sent()),
												(hash = _a.hash),
												(context = _a.context),
												(forgedBytes = _a.forgedBytes),
												(opResponse = _a.opResponse);
											return [
												2,
												/*return*/
												new DelegateOperation(
													hash,
													operation,
													sourceOrDefault,
													forgedBytes,
													opResponse,
													context
												)
											];
									}
								});
							});
						};
						/**
						 *
						 * @description Register the current address as delegate. Will sign and inject an operation using the current context
						 *
						 * @returns An operation handle with the result from the rpc node
						 *
						 * @param RegisterDelegate operation parameter
						 */

						RpcContractProvider.prototype.registerDelegate = function (params) {
							return __awaiter(this, void 0, void 0, function () {
								var estimate,
									source,
									operation,
									ops,
									prepared,
									opBytes,
									_a,
									hash,
									context,
									forgedBytes,
									opResponse;

								return __generator(this, function (_b) {
									switch (_b.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.estimate(params, this.estimator.registerDelegate.bind(this.estimator))
											];

										case 1:
											estimate = _b.sent();
											return [
												4,
												/*yield*/
												this.signer.publicKeyHash()
											];

										case 2:
											source = _b.sent();
											return [
												4,
												/*yield*/
												createRegisterDelegateOperation(
													__assign(__assign({}, params), estimate),
													source
												)
											];

										case 3:
											operation = _b.sent();
											return [
												4,
												/*yield*/
												this.addRevealOperationIfNeeded(operation, source)
											];

										case 4:
											ops = _b.sent();
											return [
												4,
												/*yield*/
												this.prepareOperation({
													operation: ops
												})
											];

										case 5:
											prepared = _b.sent();
											return [
												4,
												/*yield*/
												this.forge(prepared)
											];

										case 6:
											opBytes = _b.sent();
											return [
												4,
												/*yield*/
												this.signAndInject(opBytes)
											];

										case 7:
											(_a = _b.sent()),
												(hash = _a.hash),
												(context = _a.context),
												(forgedBytes = _a.forgedBytes),
												(opResponse = _a.opResponse);
											return [
												2,
												/*return*/
												new DelegateOperation(
													hash,
													operation,
													source,
													forgedBytes,
													opResponse,
													context
												)
											];
									}
								});
							});
						};
						/**
						 *
						 * @description Transfer tz from current address to a specific address. Will sign and inject an operation using the current context
						 *
						 * @returns An operation handle with the result from the rpc node
						 *
						 * @param Transfer operation parameter
						 */

						RpcContractProvider.prototype.transfer = function (params) {
							return __awaiter(this, void 0, void 0, function () {
								var publickKeyHash,
									estimate,
									operation,
									source,
									ops,
									prepared,
									opBytes,
									_a,
									hash,
									context,
									forgedBytes,
									opResponse;

								return __generator(this, function (_b) {
									switch (_b.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.signer.publicKeyHash()
											];

										case 1:
											publickKeyHash = _b.sent();
											return [
												4,
												/*yield*/
												this.estimate(params, this.estimator.transfer.bind(this.estimator))
											];

										case 2:
											estimate = _b.sent();
											return [
												4,
												/*yield*/
												createTransferOperation(__assign(__assign({}, params), estimate))
											];

										case 3:
											operation = _b.sent();
											source = params.source || publickKeyHash;
											return [
												4,
												/*yield*/
												this.addRevealOperationIfNeeded(operation, publickKeyHash)
											];

										case 4:
											ops = _b.sent();
											return [
												4,
												/*yield*/
												this.prepareOperation({
													operation: ops,
													source: params.source
												})
											];

										case 5:
											prepared = _b.sent();
											return [
												4,
												/*yield*/
												this.forge(prepared)
											];

										case 6:
											opBytes = _b.sent();
											return [
												4,
												/*yield*/
												this.signAndInject(opBytes)
											];

										case 7:
											(_a = _b.sent()),
												(hash = _a.hash),
												(context = _a.context),
												(forgedBytes = _a.forgedBytes),
												(opResponse = _a.opResponse);
											return [
												2,
												/*return*/
												new TransactionOperation(
													hash,
													operation,
													source,
													forgedBytes,
													opResponse,
													context
												)
											];
									}
								});
							});
						};
						/**
						 *
						 * @description Reveal the current address. Will throw an error if the address is already revealed.
						 *
						 * @returns An operation handle with the result from the rpc node
						 *
						 * @param RevealParams operation parameter
						 */

						RpcContractProvider.prototype.reveal = function (params) {
							return __awaiter(this, void 0, void 0, function () {
								var publicKeyHash,
									estimateReveal,
									estimated,
									operation,
									_a,
									_b,
									prepared,
									opBytes,
									_c,
									hash,
									context,
									forgedBytes,
									opResponse;

								var _this = this;

								return __generator(this, function (_d) {
									switch (_d.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.signer.publicKeyHash()
											];

										case 1:
											publicKeyHash = _d.sent();
											return [
												4,
												/*yield*/
												this.estimator.reveal(params)
											];

										case 2:
											estimateReveal = _d.sent();
											if (!estimateReveal) return [3 /*break*/, 9];
											return [
												4,
												/*yield*/
												this.estimate(params, function () {
													return __awaiter(_this, void 0, void 0, function () {
														return __generator(this, function (_a) {
															return [
																2,
																/*return*/
																estimateReveal
															];
														});
													});
												})
											];

										case 3:
											estimated = _d.sent();
											_a = createRevealOperation;
											_b = [__assign({}, estimated), publicKeyHash];
											return [
												4,
												/*yield*/
												this.signer.publicKey()
											];

										case 4:
											return [
												4,
												/*yield*/
												_a.apply(void 0, _b.concat([_d.sent()]))
											];

										case 5:
											operation = _d.sent();
											return [
												4,
												/*yield*/
												this.prepareOperation({
													operation: operation,
													source: publicKeyHash
												})
											];

										case 6:
											prepared = _d.sent();
											return [
												4,
												/*yield*/
												this.forge(prepared)
											];

										case 7:
											opBytes = _d.sent();
											return [
												4,
												/*yield*/
												this.signAndInject(opBytes)
											];

										case 8:
											(_c = _d.sent()),
												(hash = _c.hash),
												(context = _c.context),
												(forgedBytes = _c.forgedBytes),
												(opResponse = _c.opResponse);
											return [
												2,
												/*return*/
												new RevealOperation(
													hash,
													operation,
													publicKeyHash,
													forgedBytes,
													opResponse,
													context
												)
											];

										case 9:
											throw new Error('The current address is already revealed.');
									}
								});
							});
						};

						RpcContractProvider.prototype.at = function (address, contractAbstractionComposer) {
							if (contractAbstractionComposer === void 0) {
								contractAbstractionComposer = function (x) {
									return x;
								};
							}

							return __awaiter(this, void 0, void 0, function () {
								var rpc, script, entrypoints, blockHeader, chainId, abs;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											rpc = this.context.withExtensions().rpc;
											return [
												4,
												/*yield*/
												rpc.getScript(address)
											];

										case 1:
											script = _a.sent();
											return [
												4,
												/*yield*/
												rpc.getEntrypoints(address)
											];

										case 2:
											entrypoints = _a.sent();
											return [
												4,
												/*yield*/
												this.rpc.getBlockHeader()
											];

										case 3:
											blockHeader = _a.sent();
											chainId = blockHeader.chain_id;
											abs = new ContractAbstraction(
												address,
												script,
												this,
												this,
												entrypoints,
												chainId
											);
											return [
												2,
												/*return*/
												contractAbstractionComposer(abs, this.context)
											];
									}
								});
							});
						};
						/**
						 *
						 * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch
						 *
						 * @returns A batch object from which we can add more operation or send a command to execute the batch
						 *
						 * @param params List of operation to batch together
						 */

						RpcContractProvider.prototype.batch = function (params) {
							var batch = new OperationBatch(this.context, this.estimator);

							if (Array.isArray(params)) {
								batch.with(params);
							}

							return batch;
						};

						return RpcContractProvider;
					})(OperationEmitter);

				var MichelCodecParser =
					/** @class */
					(function () {
						function MichelCodecParser(context) {
							this.context = context;
						}

						MichelCodecParser.prototype.getNextProto = function () {
							return __awaiter(this, void 0, void 0, function () {
								var next_protocol;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											return [
												4,
												/*yield*/
												this.context.rpc.getBlockMetadata()
											];

										case 1:
											next_protocol = _a.sent().next_protocol;
											return [
												2,
												/*return*/
												next_protocol
											];
									}
								});
							});
						};

						MichelCodecParser.prototype.parseScript = function (src) {
							return __awaiter(this, void 0, void 0, function () {
								var parser, _a;

								var _b;

								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											_a = _michelCodec.Parser.bind;
											_b = {};
											return [
												4,
												/*yield*/
												this.getNextProto()
											];

										case 1:
											parser = new (_a.apply(_michelCodec.Parser, [
												void 0,
												((_b.protocol = _c.sent()), _b)
											]))();
											return [
												2,
												/*return*/
												parser.parseScript(src)
											];
									}
								});
							});
						};

						MichelCodecParser.prototype.parseMichelineExpression = function (src) {
							return __awaiter(this, void 0, void 0, function () {
								var parser, _a;

								var _b;

								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											_a = _michelCodec.Parser.bind;
											_b = {};
											return [
												4,
												/*yield*/
												this.getNextProto()
											];

										case 1:
											parser = new (_a.apply(_michelCodec.Parser, [
												void 0,
												((_b.protocol = _c.sent()), _b)
											]))();
											return [
												2,
												/*return*/
												parser.parseMichelineExpression(src)
											];
									}
								});
							});
						};

						MichelCodecParser.prototype.parseJSON = function (src) {
							return __awaiter(this, void 0, void 0, function () {
								var parser, _a;

								var _b;

								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											_a = _michelCodec.Parser.bind;
											_b = {};
											return [
												4,
												/*yield*/
												this.getNextProto()
											];

										case 1:
											parser = new (_a.apply(_michelCodec.Parser, [
												void 0,
												((_b.protocol = _c.sent()), _b)
											]))();
											return [
												2,
												/*return*/
												parser.parseJSON(src)
											];
									}
								});
							});
						};

						MichelCodecParser.prototype.prepareCodeOrigination = function (params) {
							return __awaiter(this, void 0, void 0, function () {
								var parsedParams, _a, _b;

								return __generator(this, function (_c) {
									switch (_c.label) {
										case 0:
											parsedParams = params;
											_a = parsedParams;
											return [
												4,
												/*yield*/
												this.formatCodeParam(params.code)
											];

										case 1:
											_a.code = _c.sent();
											if (!params.init) return [3 /*break*/, 3];
											_b = parsedParams;
											return [
												4,
												/*yield*/
												this.formatInitParam(params.init)
											];

										case 2:
											_b.init = _c.sent();
											_c.label = 3;

										case 3:
											return [
												2,
												/*return*/
												parsedParams
											];
									}
								});
							});
						};

						MichelCodecParser.prototype.formatCodeParam = function (code) {
							return __awaiter(this, void 0, void 0, function () {
								var parsedCode, c, c, order_1;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											if (!(typeof code === 'string')) return [3 /*break*/, 2];
											return [
												4,
												/*yield*/
												this.parseScript(code)
											];

										case 1:
											c = _a.sent();

											if (c === null) {
												throw new InvalidCodeParameter('Invalid code parameter', code);
											}

											parsedCode = c;
											return [3 /*break*/, 4];

										case 2:
											return [
												4,
												/*yield*/
												this.parseJSON(code)
											];

										case 3:
											c = _a.sent();
											order_1 = ['parameter', 'storage', 'code']; // Ensure correct ordering for RPC

											parsedCode = c.sort(function (a, b) {
												return order_1.indexOf(a.prim) - order_1.indexOf(b.prim);
											});
											_a.label = 4;

										case 4:
											return [
												2,
												/*return*/
												parsedCode
											];
									}
								});
							});
						};

						MichelCodecParser.prototype.formatInitParam = function (init) {
							return __awaiter(this, void 0, void 0, function () {
								var parsedInit, c;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											if (!(typeof init === 'string')) return [3 /*break*/, 2];
											return [
												4,
												/*yield*/
												this.parseMichelineExpression(init)
											];

										case 1:
											c = _a.sent();

											if (c === null) {
												throw new InvalidInitParameter('Invalid init parameter', init);
											}

											parsedInit = c;
											return [3 /*break*/, 4];

										case 2:
											return [
												4,
												/*yield*/
												this.parseJSON(init)
											];

										case 3:
											parsedInit = _a.sent();
											_a.label = 4;

										case 4:
											return [
												2,
												/*return*/
												parsedInit
											];
									}
								});
							});
						};

						return MichelCodecParser;
					})();

				exports.MichelCodecParser = MichelCodecParser;

				var RpcPacker =
					/** @class */
					(function () {
						function RpcPacker(context) {
							this.context = context;
						}

						RpcPacker.prototype.packData = function (data) {
							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_a) {
									return [
										2,
										/*return*/
										this.context.rpc.packData(data)
									];
								});
							});
						};

						return RpcPacker;
					})();

				exports.RpcPacker = RpcPacker;
				var defaultConfigConfirmation = {
					defaultConfirmationCount: 1,
					confirmationPollingTimeoutSecond: 180
				};
				exports.defaultConfigConfirmation = defaultConfigConfirmation;
				var defaultConfigStreamer = {
					streamerPollingIntervalMilliseconds: 20000,
					shouldObservableSubscriptionRetry: false,
					observableSubscriptionRetryFunction: (0, _operators.retry)()
				};
				/**
				 * @description Encapsulate common service used throughout different part of the library
				 */

				exports.defaultConfigStreamer = defaultConfigStreamer;

				var Context =
					/** @class */
					(function () {
						function Context(
							_rpc,
							_signer,
							_proto,
							_config,
							forger,
							injector,
							packer,
							wallet,
							parser
						) {
							if (_signer === void 0) {
								_signer = new NoopSigner();
							}

							if (_config === void 0) {
								_config = new _rxjs.BehaviorSubject(
									__assign(__assign({}, defaultConfigStreamer), defaultConfigConfirmation)
								);
							}

							this._rpc = _rpc;
							this._signer = _signer;
							this._proto = _proto;
							this._config = _config;
							this._extensions = {};
							this.providerDecorator = [];
							this.tz = new RpcTzProvider(this);
							this.estimate = new RPCEstimateProvider(this);
							this.contract = new RpcContractProvider(this, this.estimate);
							this.batch = new RPCBatchProvider(this, this.estimate);
							this.wallet = new Wallet(this);

							if (typeof this._rpc === 'string') {
								this._rpcClient = new _rpc2.RpcClient(this._rpc);
							} else {
								this._rpcClient = this._rpc;
							}

							this._forger = forger ? forger : new RpcForger(this);
							this._injector = injector ? injector : new RpcInjector(this);
							this.operationFactory = new OperationFactory(this);
							this._walletProvider = wallet ? wallet : new LegacyWalletProvider(this);
							this._parser = parser ? parser : new MichelCodecParser(this);
							this._packer = packer ? packer : new RpcPacker(this);
						}

						Object.defineProperty(Context.prototype, 'config', {
							get: function () {
								return this._config.getValue();
							},
							set: function (value) {
								this._config.next(__assign({}, value));
							},
							enumerable: false,
							configurable: true
						});

						Context.prototype.setPartialConfig = function (value) {
							this._config.next(__assign(__assign({}, this._config.getValue()), value));
						};

						Object.defineProperty(Context.prototype, 'rpc', {
							get: function () {
								return this._rpcClient;
							},
							set: function (value) {
								this._rpcClient = value;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(Context.prototype, 'injector', {
							get: function () {
								return this._injector;
							},
							set: function (value) {
								this._injector = value;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(Context.prototype, 'forger', {
							get: function () {
								return this._forger;
							},
							set: function (value) {
								this._forger = value;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(Context.prototype, 'signer', {
							get: function () {
								return this._signer;
							},
							set: function (value) {
								this._signer = value;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(Context.prototype, 'walletProvider', {
							get: function () {
								return this._walletProvider;
							},
							set: function (value) {
								this._walletProvider = value;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(Context.prototype, 'proto', {
							get: function () {
								return this._proto;
							},
							set: function (value) {
								this._proto = value;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(Context.prototype, 'parser', {
							get: function () {
								return this._parser;
							},
							set: function (value) {
								this._parser = value;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(Context.prototype, 'packer', {
							get: function () {
								return this._packer;
							},
							set: function (value) {
								this._packer = value;
							},
							enumerable: false,
							configurable: true
						});

						Context.prototype.isAnyProtocolActive = function (protocol) {
							if (protocol === void 0) {
								protocol = [];
							}

							return __awaiter(this, void 0, void 0, function () {
								var next_protocol;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											if (!this._proto) return [3 /*break*/, 1];
											return [
												2,
												/*return*/
												protocol.includes(this._proto)
											];

										case 1:
											return [
												4,
												/*yield*/
												this.rpc.getBlockMetadata()
											];

										case 2:
											next_protocol = _a.sent().next_protocol;
											return [
												2,
												/*return*/
												protocol.includes(next_protocol)
											];
									}
								});
							});
						};

						Context.prototype.getConfirmationPollingInterval = function () {
							return __awaiter(this, void 0, void 0, function () {
								var defaultInterval, constants, blockTime, confirmationPollingInterval;
								return __generator(this, function (_a) {
									switch (_a.label) {
										case 0:
											defaultInterval = 5;
											_a.label = 1;

										case 1:
											_a.trys.push([1, 3, , 4]);

											return [
												4,
												/*yield*/
												this.rpc.getConstants()
											];

										case 2:
											constants = _a.sent();
											blockTime = constants.time_between_blocks[0];

											if (constants.minimal_block_delay !== undefined) {
												blockTime = constants.minimal_block_delay;
											}

											confirmationPollingInterval = _bignumber.default.sum(
												blockTime,
												new _bignumber.default(
													constants.delay_per_missing_endorsement
												).multipliedBy(
													Math.max(0, constants.initial_endorsers - constants.endorsers_per_block)
												)
											); // Divide the polling interval by a constant 3
											// to improvise for polling time to work in prod,
											// testnet and sandbox enviornment.

											confirmationPollingInterval = confirmationPollingInterval.dividedBy(3);
											this.config.confirmationPollingIntervalSecond =
												confirmationPollingInterval.toNumber() === 0
													? 0.1
													: confirmationPollingInterval.toNumber();
											return [
												2,
												/*return*/
												this.config.confirmationPollingIntervalSecond
											];

										case 3:
											_a.sent(); // Return default value if there is
											// an issue returning from constants
											// file.

											return [
												2,
												/*return*/
												defaultInterval
											];

										case 4:
											return [
												2
												/*return*/
											];
									}
								});
							});
						};
						/**
						 * @description Create a copy of the current context. Useful when you have long running operation and you do not want a context change to affect the operation
						 */

						Context.prototype.clone = function () {
							return new Context(
								this.rpc,
								this.signer,
								this.proto,
								this._config,
								this.forger,
								this._injector,
								this.packer
							);
						};
						/**
						 * @description Allows extensions set on the TezosToolkit to inject logic into the context
						 */

						Context.prototype.registerProviderDecorator = function (fx) {
							this.providerDecorator.push(fx);
						};
						/**
						 * @description Applies the decorators on a cloned instance of the context and returned this cloned instance.
						 * The decorators are functions that inject logic into the context.
						 * They are provided by the extensions set on the TezosToolkit by calling the registerProviderDecorator method.
						 */

						Context.prototype.withExtensions = function () {
							var currentContext = this;
							this.providerDecorator.forEach(function (decorator) {
								currentContext = decorator(currentContext.clone());
							});
							return currentContext;
						};

						return Context;
					})();

				exports.Context = Context;

				var opHashFilter = function (op, filter) {
					return op.hash === filter.opHash;
				};

				var sourceFilter = function (x, filter) {
					switch (x.kind) {
						case 'endorsement':
							return 'metadata' in x && x.metadata.delegate === filter.source;

						case 'activate_account':
							return 'metadata' in x && x.pkh === filter.source;

						default:
							return 'source' in x && x.source === filter.source;
					}
				};

				var kindFilter = function (x, filter) {
					return 'kind' in x && x.kind === filter.kind;
				};

				var destinationFilter = function (x, filter) {
					switch (x.kind) {
						case 'delegation':
							return x.delegate === filter.destination;

						case 'origination':
							if (
								'metadata' in x &&
								'operation_result' in x.metadata &&
								'originated_contracts' in x.metadata.operation_result &&
								Array.isArray(x.metadata.operation_result.originated_contracts)
							) {
								return x.metadata.operation_result.originated_contracts.some(function (contract) {
									return contract === filter.destination;
								});
							}

							break;

						case 'transaction':
							return x.destination === filter.destination;

						default:
							return false;
					}
				};

				var evaluateOpFilter = function (op, filter) {
					if ('opHash' in filter) {
						return opHashFilter(op, filter);
					} else if ('source' in filter) {
						return sourceFilter(op, filter);
					} else if ('kind' in filter) {
						return kindFilter(op, filter);
					} else if ('destination' in filter) {
						return destinationFilter(op, filter);
					}

					return false;
				};

				var evaluateExpression = function (op, exp) {
					if (Array.isArray(exp.and)) {
						return exp.and.every(function (x) {
							return evaluateFilter(op, x);
						});
					} else if (Array.isArray(exp.or)) {
						return exp.or.some(function (x) {
							return evaluateFilter(op, x);
						});
					} else {
						throw new Error('Filter expression must contains either and/or property');
					}
				};

				var evaluateFilter = function (op, filter) {
					var filters = [];

					if (!Array.isArray(filter)) {
						filters.push(filter);
					} else {
						filters.push.apply(filters, __spreadArray([], __read(filter)));
					}

					return filters.every(function (filterOrExp) {
						if ('and' in filterOrExp || 'or' in filterOrExp) {
							return evaluateExpression(op, filterOrExp);
						} else {
							return evaluateOpFilter(op, filterOrExp);
						}
					});
				};

				var ObservableSubscription =
					/** @class */
					(function () {
						function ObservableSubscription(obs, shouldRetry, operatorFunction) {
							var _this = this;

							if (shouldRetry === void 0) {
								shouldRetry = false;
							}

							if (operatorFunction === void 0) {
								operatorFunction = (0, _operators.retry)();
							}

							this.shouldRetry = shouldRetry;
							this.operatorFunction = operatorFunction;
							this.errorListeners = [];
							this.messageListeners = [];
							this.closeListeners = [];
							this.completed$ = new _rxjs.Subject();
							obs
								.pipe(
									(0, _operators.takeUntil)(this.completed$),
									(0, _operators.tap)(
										function (data) {
											_this.call(_this.messageListeners, data);
										},
										function (error) {
											_this.call(_this.errorListeners, error);
										},
										function () {
											_this.call(_this.closeListeners);
										}
									),
									this.shouldRetry ? operatorFunction : (0, _operators.tap)(),
									(0, _operators.catchError)(function () {
										return _rxjs.NEVER;
									})
								)
								.subscribe();
						}

						ObservableSubscription.prototype.call = function (listeners, value) {
							var e_1, _a;

							try {
								for (
									var listeners_1 = __values(listeners), listeners_1_1 = listeners_1.next();
									!listeners_1_1.done;
									listeners_1_1 = listeners_1.next()
								) {
									var l = listeners_1_1.value;

									try {
										l(value);
									} catch (ex) {
										console.error(ex);
									}
								}
							} catch (e_1_1) {
								e_1 = {
									error: e_1_1
								};
							} finally {
								try {
									if (listeners_1_1 && !listeners_1_1.done && (_a = listeners_1.return))
										_a.call(listeners_1);
								} finally {
									if (e_1) throw e_1.error;
								}
							}
						};

						ObservableSubscription.prototype.remove = function (listeners, value) {
							var idx = listeners.indexOf(value);

							if (idx !== -1) {
								listeners.splice(idx, 1);
							}
						};

						ObservableSubscription.prototype.on = function (type, cb) {
							switch (type) {
								case 'data':
									this.messageListeners.push(cb);
									break;

								case 'error':
									this.errorListeners.push(cb);
									break;

								case 'close':
									this.closeListeners.push(cb);
									break;

								default:
									throw new Error('Trying to register on an unsupported event: ' + type);
							}
						};

						ObservableSubscription.prototype.off = function (type, cb) {
							switch (type) {
								case 'data':
									this.remove(this.messageListeners, cb);
									break;

								case 'error':
									this.remove(this.errorListeners, cb);
									break;

								case 'close':
									this.remove(this.closeListeners, cb);
									break;

								default:
									throw new Error('Trying to unregister on an unsupported event: ' + type);
							}
						};

						ObservableSubscription.prototype.close = function () {
							this.completed$.next();
						};

						return ObservableSubscription;
					})();

				var getLastBlock = function (context) {
					return (0, _rxjs.from)(context.rpc.getBlock()).pipe((0, _operators.first)());
				};

				var applyFilter = function (filter) {
					return (0, _operators.concatMap)(function (block) {
						return new _rxjs.Observable(function (sub) {
							var e_1, _a, e_2, _b, e_3, _c;

							try {
								for (
									var _d = __values(block.operations), _e = _d.next();
									!_e.done;
									_e = _d.next()
								) {
									var ops = _e.value;

									try {
										for (
											var ops_1 = ((e_2 = void 0), __values(ops)), ops_1_1 = ops_1.next();
											!ops_1_1.done;
											ops_1_1 = ops_1.next()
										) {
											var op = ops_1_1.value;

											try {
												for (
													var _f = ((e_3 = void 0), __values(op.contents)), _g = _f.next();
													!_g.done;
													_g = _f.next()
												) {
													var content = _g.value;

													if (
														evaluateFilter(
															__assign(
																{
																	hash: op.hash
																},
																content
															),
															filter
														)
													) {
														sub.next(
															__assign(
																{
																	hash: op.hash
																},
																content
															)
														);
													}
												}
											} catch (e_3_1) {
												e_3 = {
													error: e_3_1
												};
											} finally {
												try {
													if (_g && !_g.done && (_c = _f.return)) _c.call(_f);
												} finally {
													if (e_3) throw e_3.error;
												}
											}
										}
									} catch (e_2_1) {
										e_2 = {
											error: e_2_1
										};
									} finally {
										try {
											if (ops_1_1 && !ops_1_1.done && (_b = ops_1.return)) _b.call(ops_1);
										} finally {
											if (e_2) throw e_2.error;
										}
									}
								}
							} catch (e_1_1) {
								e_1 = {
									error: e_1_1
								};
							} finally {
								try {
									if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
								} finally {
									if (e_1) throw e_1.error;
								}
							}

							sub.complete();
						});
					});
				};

				var PollingSubscribeProvider =
					/** @class */
					(function () {
						function PollingSubscribeProvider(context) {
							var _this = this;

							this.context = context; // Map the changing polling interval to a timer, which will automatically terminate the previous timer when the next one starts.

							this.timer$ = this.context._config.pipe(
								(0, _operators.switchMap)(function (val) {
									return (0, _rxjs.timer)(0, val.streamerPollingIntervalMilliseconds);
								})
							);
							this.newBlock$ = this.timer$.pipe(
								(0, _operators.map)(function () {
									return _this.context;
								}),
								(0, _operators.switchMap)(getLastBlock),
								(0, _operators.distinctUntilKeyChanged)('hash'),
								(0, _operators.publish)(),
								(0, _operators.refCount)()
							);
						}

						PollingSubscribeProvider.prototype.subscribe = function (_filter) {
							return new ObservableSubscription(
								this.newBlock$.pipe((0, _operators.pluck)('hash')),
								this.context.config.shouldObservableSubscriptionRetry,
								this.context.config.observableSubscriptionRetryFunction
							);
						};

						PollingSubscribeProvider.prototype.subscribeOperation = function (filter) {
							return new ObservableSubscription(
								this.newBlock$.pipe(applyFilter(filter)),
								this.context.config.shouldObservableSubscriptionRetry,
								this.context.config.observableSubscriptionRetryFunction
							);
						};

						return PollingSubscribeProvider;
					})(); // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!

				/* tslint:disable */

				exports.PollingSubscribeProvider = PollingSubscribeProvider;
				var VERSION = {
					commitHash: '68be71fd14ffd87bd0a0f91dab60d69c8665e88c',
					version: '10.2.0'
				};
				/* tslint:enable */

				var ForgingMismatchError =
					/** @class */
					(function () {
						function ForgingMismatchError(results) {
							this.results = results;
							this.name = 'ForgingMismatchError';
							this.message = 'Forging mismatch error';
						}

						return ForgingMismatchError;
					})();

				var CompositeForger =
					/** @class */
					(function () {
						function CompositeForger(forgers) {
							this.forgers = forgers;

							if (forgers.length === 0) {
								throw new Error('At least one forger must be specified');
							}
						}

						CompositeForger.prototype.forge = function (_a) {
							var branch = _a.branch,
								contents = _a.contents;
							return __awaiter(this, void 0, void 0, function () {
								var results, lastResult, currentResult;
								return __generator(this, function (_b) {
									switch (_b.label) {
										case 0:
											return [
												4,
												/*yield*/
												Promise.all(
													this.forgers.map(function (forger) {
														return forger.forge({
															branch: branch,
															contents: contents
														});
													})
												)
											];

										case 1:
											results = _b.sent();

											if (results.length === 0) {
												throw new Error('At least one forger must be specified');
											}

											lastResult = results.pop();

											while (results.length) {
												currentResult = results.pop();

												if (currentResult !== lastResult) {
													throw new ForgingMismatchError([lastResult, currentResult]);
												}

												lastResult = currentResult;
											}

											return [
												2,
												/*return*/
												lastResult
											];
									}
								});
							});
						};

						return CompositeForger;
					})();

				exports.CompositeForger = CompositeForger;

				var NoopParser =
					/** @class */
					(function () {
						function NoopParser() {}

						NoopParser.prototype.prepareCodeOrigination = function (params) {
							return __awaiter(this, void 0, void 0, function () {
								return __generator(this, function (_a) {
									return [
										2,
										/*return*/
										params
									];
								});
							});
						};

						return NoopParser;
					})();

				exports.NoopParser = NoopParser;

				var MichelCodecPacker =
					/** @class */
					(function () {
						function MichelCodecPacker() {}

						MichelCodecPacker.prototype.packData = function (data) {
							return __awaiter(this, void 0, void 0, function () {
								var bytes;
								return __generator(this, function (_a) {
									bytes = (0, _michelCodec.packDataBytes)(data.data, data.type).bytes;
									return [
										2,
										/*return*/
										{
											packed: bytes
										}
									];
								});
							});
						};

						return MichelCodecPacker;
					})();
				/**
				 * @packageDocumentation
				 * @module @taquito/taquito
				 */

				/**
				 * @description Facade class that surfaces all of the libraries capability and allow it's configuration
				 *
				 * @param _rpc The RPC server to use
				 */

				exports.MichelCodecPacker = MichelCodecPacker;

				var TezosToolkit =
					/** @class */
					(function () {
						function TezosToolkit(_rpc) {
							this._rpc = _rpc;
							this._options = {};
							this.format = format;

							if (typeof this._rpc === 'string') {
								this._rpcClient = new _rpc2.RpcClient(this._rpc);
							} else {
								this._rpcClient = this._rpc;
							}

							this._context = new Context(_rpc);
							this._wallet = new Wallet(this._context);
							this.setProvider({
								rpc: this._rpcClient
							}); // tslint:disable-next-line: deprecation

							this.batch = this._context.batch.batch.bind(this._context.batch);
						}
						/**
						 * @description Sets configuration on the Tezos Taquito instance. Allows user to choose which signer, rpc client, rpc url, forger and so forth
						 *
						 * @param options rpc url or rpcClient to use to interact with the Tezos network
						 *
						 * @example Tezos.setProvider({rpc: 'https://mainnet.api.tez.ie/', signer: new InMemorySigner.fromSecretKey(“edsk...”)})
						 * @example Tezos.setProvider({ config: { confirmationPollingTimeoutSecond: 300 }})
						 *
						 */

						TezosToolkit.prototype.setProvider = function (_a) {
							var rpc = _a.rpc,
								stream = _a.stream,
								signer = _a.signer,
								protocol = _a.protocol,
								config = _a.config,
								forger = _a.forger,
								wallet = _a.wallet,
								packer = _a.packer;
							this.setRpcProvider(rpc);
							this.setStreamProvider(stream);
							this.setSignerProvider(signer);
							this.setForgerProvider(forger);
							this.setWalletProvider(wallet);
							this.setPackerProvider(packer);
							this._context.proto = protocol;

							if (config) {
								this._context.setPartialConfig(config);
							}
						};
						/**
						 * @description Sets signer provider on the Tezos Taquito instance.
						 *
						 * @param options signer to use to interact with the Tezos network
						 *
						 * @example Tezos.setSignerProvider(new InMemorySigner.fromSecretKey('edsk...'))
						 *
						 */

						TezosToolkit.prototype.setSignerProvider = function (signer) {
							if (!this._options.signer && typeof signer === 'undefined') {
								this._context.signer = new NoopSigner();
								this._options.signer = signer;
							} else if (typeof signer !== 'undefined') {
								this._context.signer = signer;
								this._options.signer = signer;
							}
						};
						/**
						 * @description Sets rpc provider on the Tezos Taquito instance
						 *
						 * @param options rpc url or rpcClient to use to interact with the Tezos network
						 *
						 * @example Tezos.setRpcProvider('https://mainnet.api.tez.ie/')
						 *
						 */

						TezosToolkit.prototype.setRpcProvider = function (rpc) {
							if (typeof rpc === 'string') {
								this._rpcClient = new _rpc2.RpcClient(rpc);
							} else if (rpc === undefined);
							else {
								this._rpcClient = rpc;
							}

							this._options.rpc = this._rpcClient;
							this._context.rpc = this._rpcClient;
						};
						/**
						 * @description Sets forger provider on the Tezos Taquito instance
						 *
						 * @param options forger to use to interact with the Tezos network
						 *
						 * @example Tezos.setForgerProvider(localForger)
						 *
						 */

						TezosToolkit.prototype.setForgerProvider = function (forger) {
							var f = typeof forger === 'undefined' ? this.getFactory(RpcForger)() : forger;
							this._options.forger = f;
							this._context.forger = f;
						};
						/**
						 * @description Sets stream provider on the Tezos Taquito instance
						 *
						 * @param options stream to use to interact with the Tezos network
						 *
						 * @example Tezos.setStreamProvider(...)
						 *
						 */

						TezosToolkit.prototype.setStreamProvider = function (stream) {
							if (typeof stream === 'string') {
								this._stream = new PollingSubscribeProvider(
									new Context(new _rpc2.RpcClient(stream))
								);
							} else if (typeof stream !== 'undefined') {
								this._stream = stream;
							} else if (this._options.stream === undefined) {
								this._stream = this.getFactory(PollingSubscribeProvider)();
							}

							this._options.stream = stream;
						};
						/**
						 * @description Sets wallet provider on the Tezos Taquito instance
						 *
						 * @param options wallet to use to interact with the Tezos network
						 *
						 * @example Tezos.setWalletProvider(...)
						 *
						 */

						TezosToolkit.prototype.setWalletProvider = function (wallet) {
							if (!this._options.wallet && typeof wallet === 'undefined') {
								var w = this.getFactory(LegacyWalletProvider)();
								this._options.wallet = w;
								this._context.walletProvider = w;
							} else if (typeof wallet !== 'undefined') {
								this._options.wallet = wallet;
								this._context.walletProvider = wallet;
							}
						};
						/**
						 * @description Sets Packer provider on the Tezos Taquito instance
						 *
						 * @param options packer to use to interact with the Tezos network
						 *
						 * @example Tezos.setPackerProvider(new MichelCodecPacker())
						 *
						 */

						TezosToolkit.prototype.setPackerProvider = function (packer) {
							var p = typeof packer === 'undefined' ? this.getFactory(RpcPacker)() : packer;
							this._options.packer = p;
							this._context.packer = p;
						};

						Object.defineProperty(TezosToolkit.prototype, 'tz', {
							/**
							 * @description Provide access to tezos account management
							 */
							get: function () {
								return this._context.tz;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(TezosToolkit.prototype, 'contract', {
							/**
							 * @description Provide access to smart contract utilities
							 */
							get: function () {
								return this._context.contract;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(TezosToolkit.prototype, 'wallet', {
							get: function () {
								return this._wallet;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(TezosToolkit.prototype, 'operation', {
							get: function () {
								return this._context.operationFactory;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(TezosToolkit.prototype, 'estimate', {
							/**
							 * @description Provide access to operation estimation utilities
							 */
							get: function () {
								return this._context.estimate;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(TezosToolkit.prototype, 'stream', {
							/**
							 * @description Provide access to streaming utilities backed by an streamer implementation
							 */
							get: function () {
								return this._stream;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(TezosToolkit.prototype, 'rpc', {
							/**
							 * @description Provide access to the currently used rpc client
							 */
							get: function () {
								return this._context.rpc;
							},
							enumerable: false,
							configurable: true
						});
						Object.defineProperty(TezosToolkit.prototype, 'signer', {
							/**
							 * @description Provide access to the currently used signer
							 */
							get: function () {
								return this._context.signer;
							},
							enumerable: false,
							configurable: true
						});
						/**
						 * @description Allow to add a module to the TezosToolkit instance. This method adds the appropriate Providers(s) required by the module to the internal context.
						 *
						 * @param module extension to add to the TezosToolkit instance
						 *
						 * @example Tezos.addExtension(new Tzip16Module());
						 */

						TezosToolkit.prototype.addExtension = function (module) {
							var _this = this;

							if (Array.isArray(module)) {
								module.forEach(function (extension) {
									return extension.configureContext(_this._context);
								});
							} else {
								module.configureContext(this._context);
							}
						};

						TezosToolkit.prototype.getFactory = function (ctor) {
							var _this = this;

							return function () {
								var args = [];

								for (var _i = 0; _i < arguments.length; _i++) {
									args[_i] = arguments[_i];
								}

								return new (ctor.bind.apply(
									ctor,
									__spreadArray([void 0, _this._context], __read(args))
								))();
							};
						};
						/**
						 * @description Gets an object containing the version of Taquito library and git sha of the commit this library is compiled from
						 */

						TezosToolkit.prototype.getVersionInfo = function () {
							return VERSION;
						};

						return TezosToolkit;
					})();

				exports.TezosToolkit = TezosToolkit;
			},
			{
				'@taquito/rpc': '../node_modules/@taquito/rpc/dist/taquito-rpc.es5.js',
				rxjs: '../node_modules/rxjs/_esm5/index.js',
				'rxjs/operators': '../node_modules/rxjs/_esm5/operators/index.js',
				'@taquito/michelson-encoder':
					'../node_modules/@taquito/michelson-encoder/dist/taquito-michelson-encoder.es5.js',
				'bignumber.js': '../node_modules/bignumber.js/bignumber.js',
				'@taquito/http-utils': '../node_modules/@taquito/http-utils/dist/taquito-http-utils.es5.js',
				'@taquito/utils': '../node_modules/@taquito/utils/dist/taquito-utils.es5.js',
				'@taquito/michel-codec':
					'../node_modules/@taquito/michel-codec/dist/taquito-michel-codec.es5.js'
			}
		],
		'../node_modules/jquery/dist/jquery.js': [
			function (require, module, exports) {
				var global = arguments[3];
				var process = require('process');
				var define;
				/*!
				 * jQuery JavaScript Library v3.5.1
				 * https://jquery.com/
				 *
				 * Includes Sizzle.js
				 * https://sizzlejs.com/
				 *
				 * Copyright JS Foundation and other contributors
				 * Released under the MIT license
				 * https://jquery.org/license
				 *
				 * Date: 2020-05-04T22:49Z
				 */
				(function (global, factory) {
					'use strict';

					if (typeof module === 'object' && typeof module.exports === 'object') {
						// For CommonJS and CommonJS-like environments where a proper `window`
						// is present, execute the factory and get jQuery.
						// For environments that do not have a `window` with a `document`
						// (such as Node.js), expose a factory as module.exports.
						// This accentuates the need for the creation of a real `window`.
						// e.g. var jQuery = require("jquery")(window);
						// See ticket #14549 for more info.
						module.exports = global.document
							? factory(global, true)
							: function (w) {
									if (!w.document) {
										throw new Error('jQuery requires a window with a document');
									}
									return factory(w);
							  };
					} else {
						factory(global);
					}

					// Pass this if window is not defined yet
				})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
					// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
					// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
					// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
					// enough that all such attempts are guarded in a try block.
					'use strict';

					var arr = [];

					var getProto = Object.getPrototypeOf;

					var slice = arr.slice;

					var flat = arr.flat
						? function (array) {
								return arr.flat.call(array);
						  }
						: function (array) {
								return arr.concat.apply([], array);
						  };

					var push = arr.push;

					var indexOf = arr.indexOf;

					var class2type = {};

					var toString = class2type.toString;

					var hasOwn = class2type.hasOwnProperty;

					var fnToString = hasOwn.toString;

					var ObjectFunctionString = fnToString.call(Object);

					var support = {};

					var isFunction = function isFunction(obj) {
						// Support: Chrome <=57, Firefox <=52
						// In some browsers, typeof returns "function" for HTML <object> elements
						// (i.e., `typeof document.createElement( "object" ) === "function"`).
						// We don't want to classify *any* DOM node as a function.
						return typeof obj === 'function' && typeof obj.nodeType !== 'number';
					};

					var isWindow = function isWindow(obj) {
						return obj != null && obj === obj.window;
					};

					var document = window.document;

					var preservedScriptAttributes = {
						type: true,
						src: true,
						nonce: true,
						noModule: true
					};

					function DOMEval(code, node, doc) {
						doc = doc || document;

						var i,
							val,
							script = doc.createElement('script');

						script.text = code;
						if (node) {
							for (i in preservedScriptAttributes) {
								// Support: Firefox 64+, Edge 18+
								// Some browsers don't support the "nonce" property on scripts.
								// On the other hand, just using `getAttribute` is not enough as
								// the `nonce` attribute is reset to an empty string whenever it
								// becomes browsing-context connected.
								// See https://github.com/whatwg/html/issues/2369
								// See https://html.spec.whatwg.org/#nonce-attributes
								// The `node.getAttribute` check was added for the sake of
								// `jQuery.globalEval` so that it can fake a nonce-containing node
								// via an object.
								val = node[i] || (node.getAttribute && node.getAttribute(i));
								if (val) {
									script.setAttribute(i, val);
								}
							}
						}
						doc.head.appendChild(script).parentNode.removeChild(script);
					}

					function toType(obj) {
						if (obj == null) {
							return obj + '';
						}

						// Support: Android <=2.3 only (functionish RegExp)
						return typeof obj === 'object' || typeof obj === 'function'
							? class2type[toString.call(obj)] || 'object'
							: typeof obj;
					}
					/* global Symbol */
					// Defining this global in .eslintrc.json would create a danger of using the global
					// unguarded in another place, it seems safer to define global only for this module

					var version = '3.5.1',
						// Define a local copy of jQuery
						jQuery = function (selector, context) {
							// The jQuery object is actually just the init constructor 'enhanced'
							// Need init if jQuery is called (just allow error to be thrown if not included)
							return new jQuery.fn.init(selector, context);
						};

					jQuery.fn = jQuery.prototype = {
						// The current version of jQuery being used
						jquery: version,

						constructor: jQuery,

						// The default length of a jQuery object is 0
						length: 0,

						toArray: function () {
							return slice.call(this);
						},

						// Get the Nth element in the matched element set OR
						// Get the whole matched element set as a clean array
						get: function (num) {
							// Return all the elements in a clean array
							if (num == null) {
								return slice.call(this);
							}

							// Return just the one element from the set
							return num < 0 ? this[num + this.length] : this[num];
						},

						// Take an array of elements and push it onto the stack
						// (returning the new matched element set)
						pushStack: function (elems) {
							// Build a new jQuery matched element set
							var ret = jQuery.merge(this.constructor(), elems);

							// Add the old object onto the stack (as a reference)
							ret.prevObject = this;

							// Return the newly-formed element set
							return ret;
						},

						// Execute a callback for every element in the matched set.
						each: function (callback) {
							return jQuery.each(this, callback);
						},

						map: function (callback) {
							return this.pushStack(
								jQuery.map(this, function (elem, i) {
									return callback.call(elem, i, elem);
								})
							);
						},

						slice: function () {
							return this.pushStack(slice.apply(this, arguments));
						},

						first: function () {
							return this.eq(0);
						},

						last: function () {
							return this.eq(-1);
						},

						even: function () {
							return this.pushStack(
								jQuery.grep(this, function (_elem, i) {
									return (i + 1) % 2;
								})
							);
						},

						odd: function () {
							return this.pushStack(
								jQuery.grep(this, function (_elem, i) {
									return i % 2;
								})
							);
						},

						eq: function (i) {
							var len = this.length,
								j = +i + (i < 0 ? len : 0);
							return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
						},

						end: function () {
							return this.prevObject || this.constructor();
						},

						// For internal use only.
						// Behaves like an Array's method, not like a jQuery method.
						push: push,
						sort: arr.sort,
						splice: arr.splice
					};

					jQuery.extend = jQuery.fn.extend = function () {
						var options,
							name,
							src,
							copy,
							copyIsArray,
							clone,
							target = arguments[0] || {},
							i = 1,
							length = arguments.length,
							deep = false;

						// Handle a deep copy situation
						if (typeof target === 'boolean') {
							deep = target;

							// Skip the boolean and the target
							target = arguments[i] || {};
							i++;
						}

						// Handle case when target is a string or something (possible in deep copy)
						if (typeof target !== 'object' && !isFunction(target)) {
							target = {};
						}

						// Extend jQuery itself if only one argument is passed
						if (i === length) {
							target = this;
							i--;
						}

						for (; i < length; i++) {
							// Only deal with non-null/undefined values
							if ((options = arguments[i]) != null) {
								// Extend the base object
								for (name in options) {
									copy = options[name];

									// Prevent Object.prototype pollution
									// Prevent never-ending loop
									if (name === '__proto__' || target === copy) {
										continue;
									}

									// Recurse if we're merging plain objects or arrays
									if (
										deep &&
										copy &&
										(jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))
									) {
										src = target[name];

										// Ensure proper type for the source value
										if (copyIsArray && !Array.isArray(src)) {
											clone = [];
										} else if (!copyIsArray && !jQuery.isPlainObject(src)) {
											clone = {};
										} else {
											clone = src;
										}
										copyIsArray = false;

										// Never move original objects, clone them
										target[name] = jQuery.extend(deep, clone, copy);

										// Don't bring in undefined values
									} else if (copy !== undefined) {
										target[name] = copy;
									}
								}
							}
						}

						// Return the modified object
						return target;
					};

					jQuery.extend({
						// Unique for each copy of jQuery on the page
						expando: 'jQuery' + (version + Math.random()).replace(/\D/g, ''),

						// Assume jQuery is ready without the ready module
						isReady: true,

						error: function (msg) {
							throw new Error(msg);
						},

						noop: function () {},

						isPlainObject: function (obj) {
							var proto, Ctor;

							// Detect obvious negatives
							// Use toString instead of jQuery.type to catch host objects
							if (!obj || toString.call(obj) !== '[object Object]') {
								return false;
							}

							proto = getProto(obj);

							// Objects with no prototype (e.g., `Object.create( null )`) are plain
							if (!proto) {
								return true;
							}

							// Objects with prototype are plain iff they were constructed by a global Object function
							Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;
							return typeof Ctor === 'function' && fnToString.call(Ctor) === ObjectFunctionString;
						},

						isEmptyObject: function (obj) {
							var name;

							for (name in obj) {
								return false;
							}
							return true;
						},

						// Evaluates a script in a provided context; falls back to the global one
						// if not specified.
						globalEval: function (code, options, doc) {
							DOMEval(code, { nonce: options && options.nonce }, doc);
						},

						each: function (obj, callback) {
							var length,
								i = 0;

							if (isArrayLike(obj)) {
								length = obj.length;
								for (; i < length; i++) {
									if (callback.call(obj[i], i, obj[i]) === false) {
										break;
									}
								}
							} else {
								for (i in obj) {
									if (callback.call(obj[i], i, obj[i]) === false) {
										break;
									}
								}
							}

							return obj;
						},

						// results is for internal usage only
						makeArray: function (arr, results) {
							var ret = results || [];

							if (arr != null) {
								if (isArrayLike(Object(arr))) {
									jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
								} else {
									push.call(ret, arr);
								}
							}

							return ret;
						},

						inArray: function (elem, arr, i) {
							return arr == null ? -1 : indexOf.call(arr, elem, i);
						},

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						merge: function (first, second) {
							var len = +second.length,
								j = 0,
								i = first.length;

							for (; j < len; j++) {
								first[i++] = second[j];
							}

							first.length = i;

							return first;
						},

						grep: function (elems, callback, invert) {
							var callbackInverse,
								matches = [],
								i = 0,
								length = elems.length,
								callbackExpect = !invert;

							// Go through the array, only saving the items
							// that pass the validator function
							for (; i < length; i++) {
								callbackInverse = !callback(elems[i], i);
								if (callbackInverse !== callbackExpect) {
									matches.push(elems[i]);
								}
							}

							return matches;
						},

						// arg is for internal usage only
						map: function (elems, callback, arg) {
							var length,
								value,
								i = 0,
								ret = [];

							// Go through the array, translating each of the items to their new values
							if (isArrayLike(elems)) {
								length = elems.length;
								for (; i < length; i++) {
									value = callback(elems[i], i, arg);

									if (value != null) {
										ret.push(value);
									}
								}

								// Go through every key on the object,
							} else {
								for (i in elems) {
									value = callback(elems[i], i, arg);

									if (value != null) {
										ret.push(value);
									}
								}
							}

							// Flatten any nested arrays
							return flat(ret);
						},

						// A global GUID counter for objects
						guid: 1,

						// jQuery.support is not used in Core but other projects attach their
						// properties to it so it needs to exist.
						support: support
					});

					if (typeof Symbol === 'function') {
						jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
					}

					// Populate the class2type map
					jQuery.each(
						'Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '),
						function (_i, name) {
							class2type['[object ' + name + ']'] = name.toLowerCase();
						}
					);

					function isArrayLike(obj) {
						// Support: real iOS 8.2 only (not reproducible in simulator)
						// `in` check used to prevent JIT error (gh-2145)
						// hasOwn isn't used here due to false negatives
						// regarding Nodelist length in IE
						var length = !!obj && 'length' in obj && obj.length,
							type = toType(obj);

						if (isFunction(obj) || isWindow(obj)) {
							return false;
						}

						return (
							type === 'array' ||
							length === 0 ||
							(typeof length === 'number' && length > 0 && length - 1 in obj)
						);
					}
					var Sizzle =
						/*!
						 * Sizzle CSS Selector Engine v2.3.5
						 * https://sizzlejs.com/
						 *
						 * Copyright JS Foundation and other contributors
						 * Released under the MIT license
						 * https://js.foundation/
						 *
						 * Date: 2020-03-14
						 */
						(function (window) {
							var i,
								support,
								Expr,
								getText,
								isXML,
								tokenize,
								compile,
								select,
								outermostContext,
								sortInput,
								hasDuplicate,
								// Local document vars
								setDocument,
								document,
								docElem,
								documentIsHTML,
								rbuggyQSA,
								rbuggyMatches,
								matches,
								contains,
								// Instance-specific data
								expando = 'sizzle' + 1 * new Date(),
								preferredDoc = window.document,
								dirruns = 0,
								done = 0,
								classCache = createCache(),
								tokenCache = createCache(),
								compilerCache = createCache(),
								nonnativeSelectorCache = createCache(),
								sortOrder = function (a, b) {
									if (a === b) {
										hasDuplicate = true;
									}
									return 0;
								},
								// Instance methods
								hasOwn = {}.hasOwnProperty,
								arr = [],
								pop = arr.pop,
								pushNative = arr.push,
								push = arr.push,
								slice = arr.slice,
								// Use a stripped-down indexOf as it's faster than native
								// https://jsperf.com/thor-indexof-vs-for/5
								indexOf = function (list, elem) {
									var i = 0,
										len = list.length;
									for (; i < len; i++) {
										if (list[i] === elem) {
											return i;
										}
									}
									return -1;
								},
								booleans =
									'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|' +
									'ismap|loop|multiple|open|readonly|required|scoped',
								// Regular expressions

								// http://www.w3.org/TR/css3-selectors/#whitespace
								whitespace = '[\\x20\\t\\r\\n\\f]',
								// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
								identifier =
									'(?:\\\\[\\da-fA-F]{1,6}' +
									whitespace +
									'?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+',
								// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
								attributes =
									'\\[' +
									whitespace +
									'*(' +
									identifier +
									')(?:' +
									whitespace +
									// Operator (capture 2)
									'*([*^$|!~]?=)' +
									whitespace +
									// "Attribute values must be CSS identifiers [capture 5]
									// or strings [capture 3 or capture 4]"
									'*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' +
									identifier +
									'))|)' +
									whitespace +
									'*\\]',
								pseudos =
									':(' +
									identifier +
									')(?:\\((' +
									// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
									// 1. quoted (capture 3; capture 4 or capture 5)
									'(\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|' +
									// 2. simple (capture 6)
									'((?:\\\\.|[^\\\\()[\\]]|' +
									attributes +
									')*)|' +
									// 3. anything else (capture 2)
									'.*' +
									')\\)|)',
								// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
								rwhitespace = new RegExp(whitespace + '+', 'g'),
								rtrim = new RegExp(
									'^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$',
									'g'
								),
								rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'),
								rcombinators = new RegExp(
									'^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'
								),
								rdescend = new RegExp(whitespace + '|>'),
								rpseudo = new RegExp(pseudos),
								ridentifier = new RegExp('^' + identifier + '$'),
								matchExpr = {
									ID: new RegExp('^#(' + identifier + ')'),
									CLASS: new RegExp('^\\.(' + identifier + ')'),
									TAG: new RegExp('^(' + identifier + '|[*])'),
									ATTR: new RegExp('^' + attributes),
									PSEUDO: new RegExp('^' + pseudos),
									CHILD: new RegExp(
										'^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' +
											whitespace +
											'*(even|odd|(([+-]|)(\\d*)n|)' +
											whitespace +
											'*(?:([+-]|)' +
											whitespace +
											'*(\\d+)|))' +
											whitespace +
											'*\\)|)',
										'i'
									),
									bool: new RegExp('^(?:' + booleans + ')$', 'i'),

									// For use in libraries implementing .is()
									// We use this for POS matching in `select`
									needsContext: new RegExp(
										'^' +
											whitespace +
											'*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' +
											whitespace +
											'*((?:-\\d)?\\d*)' +
											whitespace +
											'*\\)|)(?=[^-]|$)',
										'i'
									)
								},
								rhtml = /HTML$/i,
								rinputs = /^(?:input|select|textarea|button)$/i,
								rheader = /^h\d$/i,
								rnative = /^[^{]+\{\s*\[native \w/,
								// Easily-parseable/retrievable ID or TAG or CLASS selectors
								rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
								rsibling = /[+~]/,
								// CSS escapes
								// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
								runescape = new RegExp(
									'\\\\[\\da-fA-F]{1,6}' + whitespace + '?|\\\\([^\\r\\n\\f])',
									'g'
								),
								funescape = function (escape, nonHex) {
									var high = '0x' + escape.slice(1) - 0x10000;

									return nonHex
										? // Strip the backslash prefix from a non-hex escape sequence
										  nonHex
										: // Replace a hexadecimal escape sequence with the encoded Unicode code point
										// Support: IE <=11+
										// For values outside the Basic Multilingual Plane (BMP), manually construct a
										// surrogate pair
										high < 0
										? String.fromCharCode(high + 0x10000)
										: String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);
								},
								// CSS string/identifier serialization
								// https://drafts.csswg.org/cssom/#common-serializing-idioms
								rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
								fcssescape = function (ch, asCodePoint) {
									if (asCodePoint) {
										// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
										if (ch === '\0') {
											return '\uFFFD';
										}

										// Control characters and (dependent upon position) numbers get escaped as code points
										return ch.slice(0, -1) + '\\' + ch.charCodeAt(ch.length - 1).toString(16) + ' ';
									}

									// Other potentially-special ASCII characters get backslash-escaped
									return '\\' + ch;
								},
								// Used for iframes
								// See setDocument()
								// Removing the function wrapper causes a "Permission Denied"
								// error in IE
								unloadHandler = function () {
									setDocument();
								},
								inDisabledFieldset = addCombinator(
									function (elem) {
										return elem.disabled === true && elem.nodeName.toLowerCase() === 'fieldset';
									},
									{ dir: 'parentNode', next: 'legend' }
								);

							// Optimize for push.apply( _, NodeList )
							try {
								push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);

								// Support: Android<4.0
								// Detect silently failing push.apply
								// eslint-disable-next-line no-unused-expressions
								arr[preferredDoc.childNodes.length].nodeType;
							} catch (e) {
								push = {
									apply: arr.length
										? // Leverage slice if possible
										  function (target, els) {
												pushNative.apply(target, slice.call(els));
										  }
										: // Support: IE<9
										  // Otherwise append directly
										  function (target, els) {
												var j = target.length,
													i = 0;

												// Can't trust NodeList.length
												while ((target[j++] = els[i++])) {}
												target.length = j - 1;
										  }
								};
							}

							function Sizzle(selector, context, results, seed) {
								var m,
									i,
									elem,
									nid,
									match,
									groups,
									newSelector,
									newContext = context && context.ownerDocument,
									// nodeType defaults to 9, since context defaults to document
									nodeType = context ? context.nodeType : 9;

								results = results || [];

								// Return early from calls with invalid selector or context
								if (
									typeof selector !== 'string' ||
									!selector ||
									(nodeType !== 1 && nodeType !== 9 && nodeType !== 11)
								) {
									return results;
								}

								// Try to shortcut find operations (as opposed to filters) in HTML documents
								if (!seed) {
									setDocument(context);
									context = context || document;

									if (documentIsHTML) {
										// If the selector is sufficiently simple, try using a "get*By*" DOM method
										// (excepting DocumentFragment context, where the methods don't exist)
										if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
											// ID selector
											if ((m = match[1])) {
												// Document context
												if (nodeType === 9) {
													if ((elem = context.getElementById(m))) {
														// Support: IE, Opera, Webkit
														// TODO: identify versions
														// getElementById can match elements by name instead of ID
														if (elem.id === m) {
															results.push(elem);
															return results;
														}
													} else {
														return results;
													}

													// Element context
												} else {
													// Support: IE, Opera, Webkit
													// TODO: identify versions
													// getElementById can match elements by name instead of ID
													if (
														newContext &&
														(elem = newContext.getElementById(m)) &&
														contains(context, elem) &&
														elem.id === m
													) {
														results.push(elem);
														return results;
													}
												}

												// Type selector
											} else if (match[2]) {
												push.apply(results, context.getElementsByTagName(selector));
												return results;

												// Class selector
											} else if (
												(m = match[3]) &&
												support.getElementsByClassName &&
												context.getElementsByClassName
											) {
												push.apply(results, context.getElementsByClassName(m));
												return results;
											}
										}

										// Take advantage of querySelectorAll
										if (
											support.qsa &&
											!nonnativeSelectorCache[selector + ' '] &&
											(!rbuggyQSA || !rbuggyQSA.test(selector)) &&
											// Support: IE 8 only
											// Exclude object elements
											(nodeType !== 1 || context.nodeName.toLowerCase() !== 'object')
										) {
											newSelector = selector;
											newContext = context;

											// qSA considers elements outside a scoping root when evaluating child or
											// descendant combinators, which is not what we want.
											// In such cases, we work around the behavior by prefixing every selector in the
											// list with an ID selector referencing the scope context.
											// The technique has to be used as well when a leading combinator is used
											// as such selectors are not recognized by querySelectorAll.
											// Thanks to Andrew Dupont for this technique.
											if (
												nodeType === 1 &&
												(rdescend.test(selector) || rcombinators.test(selector))
											) {
												// Expand context for sibling selectors
												newContext =
													(rsibling.test(selector) && testContext(context.parentNode)) || context;

												// We can use :scope instead of the ID hack if the browser
												// supports it & if we're not changing the context.
												if (newContext !== context || !support.scope) {
													// Capture the context ID, setting it first if necessary
													if ((nid = context.getAttribute('id'))) {
														nid = nid.replace(rcssescape, fcssescape);
													} else {
														context.setAttribute('id', (nid = expando));
													}
												}

												// Prefix every selector in the list
												groups = tokenize(selector);
												i = groups.length;
												while (i--) {
													groups[i] = (nid ? '#' + nid : ':scope') + ' ' + toSelector(groups[i]);
												}
												newSelector = groups.join(',');
											}

											try {
												push.apply(results, newContext.querySelectorAll(newSelector));
												return results;
											} catch (qsaError) {
												nonnativeSelectorCache(selector, true);
											} finally {
												if (nid === expando) {
													context.removeAttribute('id');
												}
											}
										}
									}
								}

								// All others
								return select(selector.replace(rtrim, '$1'), context, results, seed);
							}

							/**
							 * Create key-value caches of limited size
							 * @returns {function(string, object)} Returns the Object data after storing it on itself with
							 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
							 *	deleting the oldest entry
							 */
							function createCache() {
								var keys = [];

								function cache(key, value) {
									// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
									if (keys.push(key + ' ') > Expr.cacheLength) {
										// Only keep the most recent entries
										delete cache[keys.shift()];
									}
									return (cache[key + ' '] = value);
								}
								return cache;
							}

							/**
							 * Mark a function for special use by Sizzle
							 * @param {Function} fn The function to mark
							 */
							function markFunction(fn) {
								fn[expando] = true;
								return fn;
							}

							/**
							 * Support testing using an element
							 * @param {Function} fn Passed the created element and returns a boolean result
							 */
							function assert(fn) {
								var el = document.createElement('fieldset');

								try {
									return !!fn(el);
								} catch (e) {
									return false;
								} finally {
									// Remove from its parent by default
									if (el.parentNode) {
										el.parentNode.removeChild(el);
									}

									// release memory in IE
									el = null;
								}
							}

							/**
							 * Adds the same handler for all of the specified attrs
							 * @param {String} attrs Pipe-separated list of attributes
							 * @param {Function} handler The method that will be applied
							 */
							function addHandle(attrs, handler) {
								var arr = attrs.split('|'),
									i = arr.length;

								while (i--) {
									Expr.attrHandle[arr[i]] = handler;
								}
							}

							/**
							 * Checks document order of two siblings
							 * @param {Element} a
							 * @param {Element} b
							 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
							 */
							function siblingCheck(a, b) {
								var cur = b && a,
									diff =
										cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;

								// Use IE sourceIndex if available on both nodes
								if (diff) {
									return diff;
								}

								// Check if b follows a
								if (cur) {
									while ((cur = cur.nextSibling)) {
										if (cur === b) {
											return -1;
										}
									}
								}

								return a ? 1 : -1;
							}

							/**
							 * Returns a function to use in pseudos for input types
							 * @param {String} type
							 */
							function createInputPseudo(type) {
								return function (elem) {
									var name = elem.nodeName.toLowerCase();
									return name === 'input' && elem.type === type;
								};
							}

							/**
							 * Returns a function to use in pseudos for buttons
							 * @param {String} type
							 */
							function createButtonPseudo(type) {
								return function (elem) {
									var name = elem.nodeName.toLowerCase();
									return (name === 'input' || name === 'button') && elem.type === type;
								};
							}

							/**
							 * Returns a function to use in pseudos for :enabled/:disabled
							 * @param {Boolean} disabled true for :disabled; false for :enabled
							 */
							function createDisabledPseudo(disabled) {
								// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
								return function (elem) {
									// Only certain elements can match :enabled or :disabled
									// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
									// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
									if ('form' in elem) {
										// Check for inherited disabledness on relevant non-disabled elements:
										// * listed form-associated elements in a disabled fieldset
										//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
										//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
										// * option elements in a disabled optgroup
										//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
										// All such elements have a "form" property.
										if (elem.parentNode && elem.disabled === false) {
											// Option elements defer to a parent optgroup if present
											if ('label' in elem) {
												if ('label' in elem.parentNode) {
													return elem.parentNode.disabled === disabled;
												} else {
													return elem.disabled === disabled;
												}
											}

											// Support: IE 6 - 11
											// Use the isDisabled shortcut property to check for disabled fieldset ancestors
											return (
												elem.isDisabled === disabled ||
												// Where there is no isDisabled, check manually
												/* jshint -W018 */
												(elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled)
											);
										}

										return elem.disabled === disabled;

										// Try to winnow out elements that can't be disabled before trusting the disabled property.
										// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
										// even exist on them, let alone have a boolean value.
									} else if ('label' in elem) {
										return elem.disabled === disabled;
									}

									// Remaining elements are neither :enabled nor :disabled
									return false;
								};
							}

							/**
							 * Returns a function to use in pseudos for positionals
							 * @param {Function} fn
							 */
							function createPositionalPseudo(fn) {
								return markFunction(function (argument) {
									argument = +argument;
									return markFunction(function (seed, matches) {
										var j,
											matchIndexes = fn([], seed.length, argument),
											i = matchIndexes.length;

										// Match elements found at the specified indexes
										while (i--) {
											if (seed[(j = matchIndexes[i])]) {
												seed[j] = !(matches[j] = seed[j]);
											}
										}
									});
								});
							}

							/**
							 * Checks a node for validity as a Sizzle context
							 * @param {Element|Object=} context
							 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
							 */
							function testContext(context) {
								return context && typeof context.getElementsByTagName !== 'undefined' && context;
							}

							// Expose support vars for convenience
							support = Sizzle.support = {};

							/**
							 * Detects XML nodes
							 * @param {Element|Object} elem An element or a document
							 * @returns {Boolean} True iff elem is a non-HTML XML node
							 */
							isXML = Sizzle.isXML = function (elem) {
								var namespace = elem.namespaceURI,
									docElem = (elem.ownerDocument || elem).documentElement;

								// Support: IE <=8
								// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
								// https://bugs.jquery.com/ticket/4833
								return !rhtml.test(namespace || (docElem && docElem.nodeName) || 'HTML');
							};

							/**
							 * Sets document-related variables once based on the current document
							 * @param {Element|Object} [doc] An element or document object to use to set the document
							 * @returns {Object} Returns the current document
							 */
							setDocument = Sizzle.setDocument = function (node) {
								var hasCompare,
									subWindow,
									doc = node ? node.ownerDocument || node : preferredDoc;

								// Return early if doc is invalid or already selected
								// Support: IE 11+, Edge 17 - 18+
								// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
								// two documents; shallow comparisons work.
								// eslint-disable-next-line eqeqeq
								if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {
									return document;
								}

								// Update global variables
								document = doc;
								docElem = document.documentElement;
								documentIsHTML = !isXML(document);

								// Support: IE 9 - 11+, Edge 12 - 18+
								// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
								// Support: IE 11+, Edge 17 - 18+
								// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
								// two documents; shallow comparisons work.
								// eslint-disable-next-line eqeqeq
								if (
									preferredDoc != document &&
									(subWindow = document.defaultView) &&
									subWindow.top !== subWindow
								) {
									// Support: IE 11, Edge
									if (subWindow.addEventListener) {
										subWindow.addEventListener('unload', unloadHandler, false);

										// Support: IE 9 - 10 only
									} else if (subWindow.attachEvent) {
										subWindow.attachEvent('onunload', unloadHandler);
									}
								}

								// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
								// Safari 4 - 5 only, Opera <=11.6 - 12.x only
								// IE/Edge & older browsers don't support the :scope pseudo-class.
								// Support: Safari 6.0 only
								// Safari 6.0 supports :scope but it's an alias of :root there.
								support.scope = assert(function (el) {
									docElem.appendChild(el).appendChild(document.createElement('div'));
									return (
										typeof el.querySelectorAll !== 'undefined' &&
										!el.querySelectorAll(':scope fieldset div').length
									);
								});

								/* Attributes
	---------------------------------------------------------------------- */

								// Support: IE<8
								// Verify that getAttribute really returns attributes and not properties
								// (excepting IE8 booleans)
								support.attributes = assert(function (el) {
									el.className = 'i';
									return !el.getAttribute('className');
								});

								/* getElement(s)By*
	---------------------------------------------------------------------- */

								// Check if getElementsByTagName("*") returns only elements
								support.getElementsByTagName = assert(function (el) {
									el.appendChild(document.createComment(''));
									return !el.getElementsByTagName('*').length;
								});

								// Support: IE<9
								support.getElementsByClassName = rnative.test(document.getElementsByClassName);

								// Support: IE<10
								// Check if getElementById returns elements by name
								// The broken getElementById methods don't pick up programmatically-set names,
								// so use a roundabout getElementsByName test
								support.getById = assert(function (el) {
									docElem.appendChild(el).id = expando;
									return !document.getElementsByName || !document.getElementsByName(expando).length;
								});

								// ID filter and find
								if (support.getById) {
									Expr.filter['ID'] = function (id) {
										var attrId = id.replace(runescape, funescape);
										return function (elem) {
											return elem.getAttribute('id') === attrId;
										};
									};
									Expr.find['ID'] = function (id, context) {
										if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
											var elem = context.getElementById(id);
											return elem ? [elem] : [];
										}
									};
								} else {
									Expr.filter['ID'] = function (id) {
										var attrId = id.replace(runescape, funescape);
										return function (elem) {
											var node =
												typeof elem.getAttributeNode !== 'undefined' && elem.getAttributeNode('id');
											return node && node.value === attrId;
										};
									};

									// Support: IE 6 - 7 only
									// getElementById is not reliable as a find shortcut
									Expr.find['ID'] = function (id, context) {
										if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
											var node,
												i,
												elems,
												elem = context.getElementById(id);

											if (elem) {
												// Verify the id attribute
												node = elem.getAttributeNode('id');
												if (node && node.value === id) {
													return [elem];
												}

												// Fall back on getElementsByName
												elems = context.getElementsByName(id);
												i = 0;
												while ((elem = elems[i++])) {
													node = elem.getAttributeNode('id');
													if (node && node.value === id) {
														return [elem];
													}
												}
											}

											return [];
										}
									};
								}

								// Tag
								Expr.find['TAG'] = support.getElementsByTagName
									? function (tag, context) {
											if (typeof context.getElementsByTagName !== 'undefined') {
												return context.getElementsByTagName(tag);

												// DocumentFragment nodes don't have gEBTN
											} else if (support.qsa) {
												return context.querySelectorAll(tag);
											}
									  }
									: function (tag, context) {
											var elem,
												tmp = [],
												i = 0,
												// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
												results = context.getElementsByTagName(tag);

											// Filter out possible comments
											if (tag === '*') {
												while ((elem = results[i++])) {
													if (elem.nodeType === 1) {
														tmp.push(elem);
													}
												}

												return tmp;
											}
											return results;
									  };

								// Class
								Expr.find['CLASS'] =
									support.getElementsByClassName &&
									function (className, context) {
										if (typeof context.getElementsByClassName !== 'undefined' && documentIsHTML) {
											return context.getElementsByClassName(className);
										}
									};

								/* QSA/matchesSelector
	---------------------------------------------------------------------- */

								// QSA and matchesSelector support

								// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
								rbuggyMatches = [];

								// qSa(:focus) reports false when true (Chrome 21)
								// We allow this because of a bug in IE8/9 that throws an error
								// whenever `document.activeElement` is accessed on an iframe
								// So, we allow :focus to pass through QSA all the time to avoid the IE error
								// See https://bugs.jquery.com/ticket/13378
								rbuggyQSA = [];

								if ((support.qsa = rnative.test(document.querySelectorAll))) {
									// Build QSA regex
									// Regex strategy adopted from Diego Perini
									assert(function (el) {
										var input;

										// Select is set to empty string on purpose
										// This is to test IE's treatment of not explicitly
										// setting a boolean content attribute,
										// since its presence should be enough
										// https://bugs.jquery.com/ticket/12359
										docElem.appendChild(el).innerHTML =
											"<a id='" +
											expando +
											"'></a>" +
											"<select id='" +
											expando +
											"-\r\\' msallowcapture=''>" +
											"<option selected=''></option></select>";

										// Support: IE8, Opera 11-12.16
										// Nothing should be selected when empty strings follow ^= or $= or *=
										// The test attribute must be unknown in Opera but "safe" for WinRT
										// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
										if (el.querySelectorAll("[msallowcapture^='']").length) {
											rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
										}

										// Support: IE8
										// Boolean attributes and "value" are not treated correctly
										if (!el.querySelectorAll('[selected]').length) {
											rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
										}

										// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
										if (!el.querySelectorAll('[id~=' + expando + '-]').length) {
											rbuggyQSA.push('~=');
										}

										// Support: IE 11+, Edge 15 - 18+
										// IE 11/Edge don't find elements on a `[name='']` query in some cases.
										// Adding a temporary attribute to the document before the selection works
										// around the issue.
										// Interestingly, IE 10 & older don't seem to have the issue.
										input = document.createElement('input');
										input.setAttribute('name', '');
										el.appendChild(input);
										if (!el.querySelectorAll("[name='']").length) {
											rbuggyQSA.push(
												'\\[' +
													whitespace +
													'*name' +
													whitespace +
													'*=' +
													whitespace +
													'*(?:\'\'|"")'
											);
										}

										// Webkit/Opera - :checked should return selected option elements
										// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
										// IE8 throws error here and will not see later tests
										if (!el.querySelectorAll(':checked').length) {
											rbuggyQSA.push(':checked');
										}

										// Support: Safari 8+, iOS 8+
										// https://bugs.webkit.org/show_bug.cgi?id=136851
										// In-page `selector#id sibling-combinator selector` fails
										if (!el.querySelectorAll('a#' + expando + '+*').length) {
											rbuggyQSA.push('.#.+[+~]');
										}

										// Support: Firefox <=3.6 - 5 only
										// Old Firefox doesn't throw on a badly-escaped identifier.
										el.querySelectorAll('\\\f');
										rbuggyQSA.push('[\\r\\n\\f]');
									});

									assert(function (el) {
										el.innerHTML =
											"<a href='' disabled='disabled'></a>" +
											"<select disabled='disabled'><option/></select>";

										// Support: Windows 8 Native Apps
										// The type and name attributes are restricted during .innerHTML assignment
										var input = document.createElement('input');
										input.setAttribute('type', 'hidden');
										el.appendChild(input).setAttribute('name', 'D');

										// Support: IE8
										// Enforce case-sensitivity of name attribute
										if (el.querySelectorAll('[name=d]').length) {
											rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=');
										}

										// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
										// IE8 throws error here and will not see later tests
										if (el.querySelectorAll(':enabled').length !== 2) {
											rbuggyQSA.push(':enabled', ':disabled');
										}

										// Support: IE9-11+
										// IE's :disabled selector does not pick up the children of disabled fieldsets
										docElem.appendChild(el).disabled = true;
										if (el.querySelectorAll(':disabled').length !== 2) {
											rbuggyQSA.push(':enabled', ':disabled');
										}

										// Support: Opera 10 - 11 only
										// Opera 10-11 does not throw on post-comma invalid pseudos
										el.querySelectorAll('*,:x');
										rbuggyQSA.push(',.*:');
									});
								}

								if (
									(support.matchesSelector = rnative.test(
										(matches =
											docElem.matches ||
											docElem.webkitMatchesSelector ||
											docElem.mozMatchesSelector ||
											docElem.oMatchesSelector ||
											docElem.msMatchesSelector)
									))
								) {
									assert(function (el) {
										// Check to see if it's possible to do matchesSelector
										// on a disconnected node (IE 9)
										support.disconnectedMatch = matches.call(el, '*');

										// This should fail with an exception
										// Gecko does not error, returns false instead
										matches.call(el, "[s!='']:x");
										rbuggyMatches.push('!=', pseudos);
									});
								}

								rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
								rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));

								/* Contains
	---------------------------------------------------------------------- */
								hasCompare = rnative.test(docElem.compareDocumentPosition);

								// Element contains another
								// Purposefully self-exclusive
								// As in, an element does not contain itself
								contains =
									hasCompare || rnative.test(docElem.contains)
										? function (a, b) {
												var adown = a.nodeType === 9 ? a.documentElement : a,
													bup = b && b.parentNode;
												return (
													a === bup ||
													!!(
														bup &&
														bup.nodeType === 1 &&
														(adown.contains
															? adown.contains(bup)
															: a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16)
													)
												);
										  }
										: function (a, b) {
												if (b) {
													while ((b = b.parentNode)) {
														if (b === a) {
															return true;
														}
													}
												}
												return false;
										  };

								/* Sorting
	---------------------------------------------------------------------- */

								// Document order sorting
								sortOrder = hasCompare
									? function (a, b) {
											// Flag for duplicate removal
											if (a === b) {
												hasDuplicate = true;
												return 0;
											}

											// Sort on method existence if only one input has compareDocumentPosition
											var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
											if (compare) {
												return compare;
											}

											// Calculate position if both inputs belong to the same document
											// Support: IE 11+, Edge 17 - 18+
											// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
											// two documents; shallow comparisons work.
											// eslint-disable-next-line eqeqeq
											compare =
												(a.ownerDocument || a) == (b.ownerDocument || b)
													? a.compareDocumentPosition(b)
													: // Otherwise we know they are disconnected
													  1;

											// Disconnected nodes
											if (
												compare & 1 ||
												(!support.sortDetached && b.compareDocumentPosition(a) === compare)
											) {
												// Choose the first element that is related to our preferred document
												// Support: IE 11+, Edge 17 - 18+
												// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
												// two documents; shallow comparisons work.
												// eslint-disable-next-line eqeqeq
												if (
													a == document ||
													(a.ownerDocument == preferredDoc && contains(preferredDoc, a))
												) {
													return -1;
												}

												// Support: IE 11+, Edge 17 - 18+
												// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
												// two documents; shallow comparisons work.
												// eslint-disable-next-line eqeqeq
												if (
													b == document ||
													(b.ownerDocument == preferredDoc && contains(preferredDoc, b))
												) {
													return 1;
												}

												// Maintain original order
												return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
											}

											return compare & 4 ? -1 : 1;
									  }
									: function (a, b) {
											// Exit early if the nodes are identical
											if (a === b) {
												hasDuplicate = true;
												return 0;
											}

											var cur,
												i = 0,
												aup = a.parentNode,
												bup = b.parentNode,
												ap = [a],
												bp = [b];

											// Parentless nodes are either documents or disconnected
											if (!aup || !bup) {
												// Support: IE 11+, Edge 17 - 18+
												// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
												// two documents; shallow comparisons work.
												/* eslint-disable eqeqeq */
												return a == document
													? -1
													: b == document
													? 1
													: /* eslint-enable eqeqeq */
													aup
													? -1
													: bup
													? 1
													: sortInput
													? indexOf(sortInput, a) - indexOf(sortInput, b)
													: 0;

												// If the nodes are siblings, we can do a quick check
											} else if (aup === bup) {
												return siblingCheck(a, b);
											}

											// Otherwise we need full lists of their ancestors for comparison
											cur = a;
											while ((cur = cur.parentNode)) {
												ap.unshift(cur);
											}
											cur = b;
											while ((cur = cur.parentNode)) {
												bp.unshift(cur);
											}

											// Walk down the tree looking for a discrepancy
											while (ap[i] === bp[i]) {
												i++;
											}

											return i
												? // Do a sibling check if the nodes have a common ancestor
												  siblingCheck(ap[i], bp[i])
												: // Otherwise nodes in our document sort first
												// Support: IE 11+, Edge 17 - 18+
												// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
												// two documents; shallow comparisons work.
												/* eslint-disable eqeqeq */
												ap[i] == preferredDoc
												? -1
												: bp[i] == preferredDoc
												? 1
												: /* eslint-enable eqeqeq */
												  0;
									  };

								return document;
							};

							Sizzle.matches = function (expr, elements) {
								return Sizzle(expr, null, null, elements);
							};

							Sizzle.matchesSelector = function (elem, expr) {
								setDocument(elem);

								if (
									support.matchesSelector &&
									documentIsHTML &&
									!nonnativeSelectorCache[expr + ' '] &&
									(!rbuggyMatches || !rbuggyMatches.test(expr)) &&
									(!rbuggyQSA || !rbuggyQSA.test(expr))
								) {
									try {
										var ret = matches.call(elem, expr);

										// IE 9's matchesSelector returns false on disconnected nodes
										if (
											ret ||
											support.disconnectedMatch ||
											// As well, disconnected nodes are said to be in a document
											// fragment in IE 9
											(elem.document && elem.document.nodeType !== 11)
										) {
											return ret;
										}
									} catch (e) {
										nonnativeSelectorCache(expr, true);
									}
								}

								return Sizzle(expr, document, null, [elem]).length > 0;
							};

							Sizzle.contains = function (context, elem) {
								// Set document vars if needed
								// Support: IE 11+, Edge 17 - 18+
								// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
								// two documents; shallow comparisons work.
								// eslint-disable-next-line eqeqeq
								if ((context.ownerDocument || context) != document) {
									setDocument(context);
								}
								return contains(context, elem);
							};

							Sizzle.attr = function (elem, name) {
								// Set document vars if needed
								// Support: IE 11+, Edge 17 - 18+
								// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
								// two documents; shallow comparisons work.
								// eslint-disable-next-line eqeqeq
								if ((elem.ownerDocument || elem) != document) {
									setDocument(elem);
								}

								var fn = Expr.attrHandle[name.toLowerCase()],
									// Don't get fooled by Object.prototype properties (jQuery #13807)
									val =
										fn && hasOwn.call(Expr.attrHandle, name.toLowerCase())
											? fn(elem, name, !documentIsHTML)
											: undefined;

								return val !== undefined
									? val
									: support.attributes || !documentIsHTML
									? elem.getAttribute(name)
									: (val = elem.getAttributeNode(name)) && val.specified
									? val.value
									: null;
							};

							Sizzle.escape = function (sel) {
								return (sel + '').replace(rcssescape, fcssescape);
							};

							Sizzle.error = function (msg) {
								throw new Error('Syntax error, unrecognized expression: ' + msg);
							};

							/**
							 * Document sorting and removing duplicates
							 * @param {ArrayLike} results
							 */
							Sizzle.uniqueSort = function (results) {
								var elem,
									duplicates = [],
									j = 0,
									i = 0;

								// Unless we *know* we can detect duplicates, assume their presence
								hasDuplicate = !support.detectDuplicates;
								sortInput = !support.sortStable && results.slice(0);
								results.sort(sortOrder);

								if (hasDuplicate) {
									while ((elem = results[i++])) {
										if (elem === results[i]) {
											j = duplicates.push(i);
										}
									}
									while (j--) {
										results.splice(duplicates[j], 1);
									}
								}

								// Clear input after sorting to release objects
								// See https://github.com/jquery/sizzle/pull/225
								sortInput = null;

								return results;
							};

							/**
							 * Utility function for retrieving the text value of an array of DOM nodes
							 * @param {Array|Element} elem
							 */
							getText = Sizzle.getText = function (elem) {
								var node,
									ret = '',
									i = 0,
									nodeType = elem.nodeType;

								if (!nodeType) {
									// If no nodeType, this is expected to be an array
									while ((node = elem[i++])) {
										// Do not traverse comment nodes
										ret += getText(node);
									}
								} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
									// Use textContent for elements
									// innerText usage removed for consistency of new lines (jQuery #11153)
									if (typeof elem.textContent === 'string') {
										return elem.textContent;
									} else {
										// Traverse its children
										for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
											ret += getText(elem);
										}
									}
								} else if (nodeType === 3 || nodeType === 4) {
									return elem.nodeValue;
								}

								// Do not include comment or processing instruction nodes

								return ret;
							};

							Expr = Sizzle.selectors = {
								// Can be adjusted by the user
								cacheLength: 50,

								createPseudo: markFunction,

								match: matchExpr,

								attrHandle: {},

								find: {},

								relative: {
									'>': { dir: 'parentNode', first: true },
									' ': { dir: 'parentNode' },
									'+': { dir: 'previousSibling', first: true },
									'~': { dir: 'previousSibling' }
								},

								preFilter: {
									ATTR: function (match) {
										match[1] = match[1].replace(runescape, funescape);

										// Move the given value to match[3] whether quoted or unquoted
										match[3] = (match[3] || match[4] || match[5] || '').replace(
											runescape,
											funescape
										);

										if (match[2] === '~=') {
											match[3] = ' ' + match[3] + ' ';
										}

										return match.slice(0, 4);
									},

									CHILD: function (match) {
										/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
										match[1] = match[1].toLowerCase();

										if (match[1].slice(0, 3) === 'nth') {
											// nth-* requires argument
											if (!match[3]) {
												Sizzle.error(match[0]);
											}

											// numeric x and y parameters for Expr.filter.CHILD
											// remember that false/true cast respectively to 0/1
											match[4] = +(match[4]
												? match[5] + (match[6] || 1)
												: 2 * (match[3] === 'even' || match[3] === 'odd'));
											match[5] = +(match[7] + match[8] || match[3] === 'odd');

											// other types prohibit arguments
										} else if (match[3]) {
											Sizzle.error(match[0]);
										}

										return match;
									},

									PSEUDO: function (match) {
										var excess,
											unquoted = !match[6] && match[2];

										if (matchExpr['CHILD'].test(match[0])) {
											return null;
										}

										// Accept quoted arguments as-is
										if (match[3]) {
											match[2] = match[4] || match[5] || '';

											// Strip excess characters from unquoted arguments
										} else if (
											unquoted &&
											rpseudo.test(unquoted) &&
											// Get excess from tokenize (recursively)
											(excess = tokenize(unquoted, true)) &&
											// advance to the next closing parenthesis
											(excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)
										) {
											// excess is a negative index
											match[0] = match[0].slice(0, excess);
											match[2] = unquoted.slice(0, excess);
										}

										// Return only captures needed by the pseudo filter method (type and argument)
										return match.slice(0, 3);
									}
								},

								filter: {
									TAG: function (nodeNameSelector) {
										var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
										return nodeNameSelector === '*'
											? function () {
													return true;
											  }
											: function (elem) {
													return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
											  };
									},

									CLASS: function (className) {
										var pattern = classCache[className + ' '];

										return (
											pattern ||
											((pattern = new RegExp(
												'(^|' + whitespace + ')' + className + '(' + whitespace + '|$)'
											)) &&
												classCache(className, function (elem) {
													return pattern.test(
														(typeof elem.className === 'string' && elem.className) ||
															(typeof elem.getAttribute !== 'undefined' &&
																elem.getAttribute('class')) ||
															''
													);
												}))
										);
									},

									ATTR: function (name, operator, check) {
										return function (elem) {
											var result = Sizzle.attr(elem, name);

											if (result == null) {
												return operator === '!=';
											}
											if (!operator) {
												return true;
											}

											result += '';

											/* eslint-disable max-len */

											return operator === '='
												? result === check
												: operator === '!='
												? result !== check
												: operator === '^='
												? check && result.indexOf(check) === 0
												: operator === '*='
												? check && result.indexOf(check) > -1
												: operator === '$='
												? check && result.slice(-check.length) === check
												: operator === '~='
												? (' ' + result.replace(rwhitespace, ' ') + ' ').indexOf(check) > -1
												: operator === '|='
												? result === check || result.slice(0, check.length + 1) === check + '-'
												: false;
											/* eslint-enable max-len */
										};
									},

									CHILD: function (type, what, _argument, first, last) {
										var simple = type.slice(0, 3) !== 'nth',
											forward = type.slice(-4) !== 'last',
											ofType = what === 'of-type';

										return first === 1 && last === 0
											? // Shortcut for :nth-*(n)
											  function (elem) {
													return !!elem.parentNode;
											  }
											: function (elem, _context, xml) {
													var cache,
														uniqueCache,
														outerCache,
														node,
														nodeIndex,
														start,
														dir = simple !== forward ? 'nextSibling' : 'previousSibling',
														parent = elem.parentNode,
														name = ofType && elem.nodeName.toLowerCase(),
														useCache = !xml && !ofType,
														diff = false;

													if (parent) {
														// :(first|last|only)-(child|of-type)
														if (simple) {
															while (dir) {
																node = elem;
																while ((node = node[dir])) {
																	if (
																		ofType
																			? node.nodeName.toLowerCase() === name
																			: node.nodeType === 1
																	) {
																		return false;
																	}
																}

																// Reverse direction for :only-* (if we haven't yet done so)
																start = dir = type === 'only' && !start && 'nextSibling';
															}
															return true;
														}

														start = [forward ? parent.firstChild : parent.lastChild];

														// non-xml :nth-child(...) stores cache data on `parent`
														if (forward && useCache) {
															// Seek `elem` from a previously-cached index

															// ...in a gzip-friendly way
															node = parent;
															outerCache = node[expando] || (node[expando] = {});

															// Support: IE <9 only
															// Defend against cloned attroperties (jQuery gh-1709)
															uniqueCache =
																outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

															cache = uniqueCache[type] || [];
															nodeIndex = cache[0] === dirruns && cache[1];
															diff = nodeIndex && cache[2];
															node = nodeIndex && parent.childNodes[nodeIndex];

															while (
																(node =
																	(++nodeIndex && node && node[dir]) ||
																	// Fallback to seeking `elem` from the start
																	(diff = nodeIndex = 0) ||
																	start.pop())
															) {
																// When found, cache indexes on `parent` and break
																if (node.nodeType === 1 && ++diff && node === elem) {
																	uniqueCache[type] = [dirruns, nodeIndex, diff];
																	break;
																}
															}
														} else {
															// Use previously-cached element index if available
															if (useCache) {
																// ...in a gzip-friendly way
																node = elem;
																outerCache = node[expando] || (node[expando] = {});

																// Support: IE <9 only
																// Defend against cloned attroperties (jQuery gh-1709)
																uniqueCache =
																	outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

																cache = uniqueCache[type] || [];
																nodeIndex = cache[0] === dirruns && cache[1];
																diff = nodeIndex;
															}

															// xml :nth-child(...)
															// or :nth-last-child(...) or :nth(-last)?-of-type(...)
															if (diff === false) {
																// Use the same loop as above to seek `elem` from the start
																while (
																	(node =
																		(++nodeIndex && node && node[dir]) ||
																		(diff = nodeIndex = 0) ||
																		start.pop())
																) {
																	if (
																		(ofType
																			? node.nodeName.toLowerCase() === name
																			: node.nodeType === 1) &&
																		++diff
																	) {
																		// Cache the index of each encountered element
																		if (useCache) {
																			outerCache = node[expando] || (node[expando] = {});

																			// Support: IE <9 only
																			// Defend against cloned attroperties (jQuery gh-1709)
																			uniqueCache =
																				outerCache[node.uniqueID] ||
																				(outerCache[node.uniqueID] = {});

																			uniqueCache[type] = [dirruns, diff];
																		}

																		if (node === elem) {
																			break;
																		}
																	}
																}
															}
														}

														// Incorporate the offset, then check against cycle size
														diff -= last;
														return diff === first || (diff % first === 0 && diff / first >= 0);
													}
											  };
									},

									PSEUDO: function (pseudo, argument) {
										// pseudo-class names are case-insensitive
										// http://www.w3.org/TR/selectors/#pseudo-classes
										// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
										// Remember that setFilters inherits from pseudos
										var args,
											fn =
												Expr.pseudos[pseudo] ||
												Expr.setFilters[pseudo.toLowerCase()] ||
												Sizzle.error('unsupported pseudo: ' + pseudo);

										// The user may use createPseudo to indicate that
										// arguments are needed to create the filter function
										// just as Sizzle does
										if (fn[expando]) {
											return fn(argument);
										}

										// But maintain support for old signatures
										if (fn.length > 1) {
											args = [pseudo, pseudo, '', argument];
											return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase())
												? markFunction(function (seed, matches) {
														var idx,
															matched = fn(seed, argument),
															i = matched.length;
														while (i--) {
															idx = indexOf(seed, matched[i]);
															seed[idx] = !(matches[idx] = matched[i]);
														}
												  })
												: function (elem) {
														return fn(elem, 0, args);
												  };
										}

										return fn;
									}
								},

								pseudos: {
									// Potentially complex pseudos
									not: markFunction(function (selector) {
										// Trim the selector passed to compile
										// to avoid treating leading and trailing
										// spaces as combinators
										var input = [],
											results = [],
											matcher = compile(selector.replace(rtrim, '$1'));

										return matcher[expando]
											? markFunction(function (seed, matches, _context, xml) {
													var elem,
														unmatched = matcher(seed, null, xml, []),
														i = seed.length;

													// Match elements unmatched by `matcher`
													while (i--) {
														if ((elem = unmatched[i])) {
															seed[i] = !(matches[i] = elem);
														}
													}
											  })
											: function (elem, _context, xml) {
													input[0] = elem;
													matcher(input, null, xml, results);

													// Don't keep the element (issue #299)
													input[0] = null;
													return !results.pop();
											  };
									}),

									has: markFunction(function (selector) {
										return function (elem) {
											return Sizzle(selector, elem).length > 0;
										};
									}),

									contains: markFunction(function (text) {
										text = text.replace(runescape, funescape);
										return function (elem) {
											return (elem.textContent || getText(elem)).indexOf(text) > -1;
										};
									}),

									// "Whether an element is represented by a :lang() selector
									// is based solely on the element's language value
									// being equal to the identifier C,
									// or beginning with the identifier C immediately followed by "-".
									// The matching of C against the element's language value is performed case-insensitively.
									// The identifier C does not have to be a valid language name."
									// http://www.w3.org/TR/selectors/#lang-pseudo
									lang: markFunction(function (lang) {
										// lang value must be a valid identifier
										if (!ridentifier.test(lang || '')) {
											Sizzle.error('unsupported lang: ' + lang);
										}
										lang = lang.replace(runescape, funescape).toLowerCase();
										return function (elem) {
											var elemLang;
											do {
												if (
													(elemLang = documentIsHTML
														? elem.lang
														: elem.getAttribute('xml:lang') || elem.getAttribute('lang'))
												) {
													elemLang = elemLang.toLowerCase();
													return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
												}
											} while ((elem = elem.parentNode) && elem.nodeType === 1);
											return false;
										};
									}),

									// Miscellaneous
									target: function (elem) {
										var hash = window.location && window.location.hash;
										return hash && hash.slice(1) === elem.id;
									},

									root: function (elem) {
										return elem === docElem;
									},

									focus: function (elem) {
										return (
											elem === document.activeElement &&
											(!document.hasFocus || document.hasFocus()) &&
											!!(elem.type || elem.href || ~elem.tabIndex)
										);
									},

									// Boolean properties
									enabled: createDisabledPseudo(false),
									disabled: createDisabledPseudo(true),

									checked: function (elem) {
										// In CSS3, :checked should return both checked and selected elements
										// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
										var nodeName = elem.nodeName.toLowerCase();
										return (
											(nodeName === 'input' && !!elem.checked) ||
											(nodeName === 'option' && !!elem.selected)
										);
									},

									selected: function (elem) {
										// Accessing this property makes selected-by-default
										// options in Safari work properly
										if (elem.parentNode) {
											// eslint-disable-next-line no-unused-expressions
											elem.parentNode.selectedIndex;
										}

										return elem.selected === true;
									},

									// Contents
									empty: function (elem) {
										// http://www.w3.org/TR/selectors/#empty-pseudo
										// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
										//   but not by others (comment: 8; processing instruction: 7; etc.)
										// nodeType < 6 works because attributes (2) do not appear as children
										for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
											if (elem.nodeType < 6) {
												return false;
											}
										}
										return true;
									},

									parent: function (elem) {
										return !Expr.pseudos['empty'](elem);
									},

									// Element/input types
									header: function (elem) {
										return rheader.test(elem.nodeName);
									},

									input: function (elem) {
										return rinputs.test(elem.nodeName);
									},

									button: function (elem) {
										var name = elem.nodeName.toLowerCase();
										return (name === 'input' && elem.type === 'button') || name === 'button';
									},

									text: function (elem) {
										var attr;
										return (
											elem.nodeName.toLowerCase() === 'input' &&
											elem.type === 'text' &&
											// Support: IE<8
											// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
											((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text')
										);
									},

									// Position-in-collection
									first: createPositionalPseudo(function () {
										return [0];
									}),

									last: createPositionalPseudo(function (_matchIndexes, length) {
										return [length - 1];
									}),

									eq: createPositionalPseudo(function (_matchIndexes, length, argument) {
										return [argument < 0 ? argument + length : argument];
									}),

									even: createPositionalPseudo(function (matchIndexes, length) {
										var i = 0;
										for (; i < length; i += 2) {
											matchIndexes.push(i);
										}
										return matchIndexes;
									}),

									odd: createPositionalPseudo(function (matchIndexes, length) {
										var i = 1;
										for (; i < length; i += 2) {
											matchIndexes.push(i);
										}
										return matchIndexes;
									}),

									lt: createPositionalPseudo(function (matchIndexes, length, argument) {
										var i =
											argument < 0 ? argument + length : argument > length ? length : argument;
										for (; --i >= 0; ) {
											matchIndexes.push(i);
										}
										return matchIndexes;
									}),

									gt: createPositionalPseudo(function (matchIndexes, length, argument) {
										var i = argument < 0 ? argument + length : argument;
										for (; ++i < length; ) {
											matchIndexes.push(i);
										}
										return matchIndexes;
									})
								}
							};

							Expr.pseudos['nth'] = Expr.pseudos['eq'];

							// Add button/input type pseudos
							for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
								Expr.pseudos[i] = createInputPseudo(i);
							}
							for (i in { submit: true, reset: true }) {
								Expr.pseudos[i] = createButtonPseudo(i);
							}

							// Easy API for creating new setFilters
							function setFilters() {}
							setFilters.prototype = Expr.filters = Expr.pseudos;
							Expr.setFilters = new setFilters();

							tokenize = Sizzle.tokenize = function (selector, parseOnly) {
								var matched,
									match,
									tokens,
									type,
									soFar,
									groups,
									preFilters,
									cached = tokenCache[selector + ' '];

								if (cached) {
									return parseOnly ? 0 : cached.slice(0);
								}

								soFar = selector;
								groups = [];
								preFilters = Expr.preFilter;

								while (soFar) {
									// Comma and first run
									if (!matched || (match = rcomma.exec(soFar))) {
										if (match) {
											// Don't consume trailing commas as valid
											soFar = soFar.slice(match[0].length) || soFar;
										}
										groups.push((tokens = []));
									}

									matched = false;

									// Combinators
									if ((match = rcombinators.exec(soFar))) {
										matched = match.shift();
										tokens.push({
											value: matched,

											// Cast descendant combinators to space
											type: match[0].replace(rtrim, ' ')
										});
										soFar = soFar.slice(matched.length);
									}

									// Filters
									for (type in Expr.filter) {
										if (
											(match = matchExpr[type].exec(soFar)) &&
											(!preFilters[type] || (match = preFilters[type](match)))
										) {
											matched = match.shift();
											tokens.push({
												value: matched,
												type: type,
												matches: match
											});
											soFar = soFar.slice(matched.length);
										}
									}

									if (!matched) {
										break;
									}
								}

								// Return the length of the invalid excess
								// if we're just parsing
								// Otherwise, throw an error or return tokens
								return parseOnly
									? soFar.length
									: soFar
									? Sizzle.error(selector)
									: // Cache the tokens
									  tokenCache(selector, groups).slice(0);
							};

							function toSelector(tokens) {
								var i = 0,
									len = tokens.length,
									selector = '';
								for (; i < len; i++) {
									selector += tokens[i].value;
								}
								return selector;
							}

							function addCombinator(matcher, combinator, base) {
								var dir = combinator.dir,
									skip = combinator.next,
									key = skip || dir,
									checkNonElements = base && key === 'parentNode',
									doneName = done++;

								return combinator.first
									? // Check against closest ancestor/preceding element
									  function (elem, context, xml) {
											while ((elem = elem[dir])) {
												if (elem.nodeType === 1 || checkNonElements) {
													return matcher(elem, context, xml);
												}
											}
											return false;
									  }
									: // Check against all ancestor/preceding elements
									  function (elem, context, xml) {
											var oldCache,
												uniqueCache,
												outerCache,
												newCache = [dirruns, doneName];

											// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
											if (xml) {
												while ((elem = elem[dir])) {
													if (elem.nodeType === 1 || checkNonElements) {
														if (matcher(elem, context, xml)) {
															return true;
														}
													}
												}
											} else {
												while ((elem = elem[dir])) {
													if (elem.nodeType === 1 || checkNonElements) {
														outerCache = elem[expando] || (elem[expando] = {});

														// Support: IE <9 only
														// Defend against cloned attroperties (jQuery gh-1709)
														uniqueCache =
															outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

														if (skip && skip === elem.nodeName.toLowerCase()) {
															elem = elem[dir] || elem;
														} else if (
															(oldCache = uniqueCache[key]) &&
															oldCache[0] === dirruns &&
															oldCache[1] === doneName
														) {
															// Assign to newCache so results back-propagate to previous elements
															return (newCache[2] = oldCache[2]);
														} else {
															// Reuse newcache so results back-propagate to previous elements
															uniqueCache[key] = newCache;

															// A match means we're done; a fail means we have to keep checking
															if ((newCache[2] = matcher(elem, context, xml))) {
																return true;
															}
														}
													}
												}
											}
											return false;
									  };
							}

							function elementMatcher(matchers) {
								return matchers.length > 1
									? function (elem, context, xml) {
											var i = matchers.length;
											while (i--) {
												if (!matchers[i](elem, context, xml)) {
													return false;
												}
											}
											return true;
									  }
									: matchers[0];
							}

							function multipleContexts(selector, contexts, results) {
								var i = 0,
									len = contexts.length;
								for (; i < len; i++) {
									Sizzle(selector, contexts[i], results);
								}
								return results;
							}

							function condense(unmatched, map, filter, context, xml) {
								var elem,
									newUnmatched = [],
									i = 0,
									len = unmatched.length,
									mapped = map != null;

								for (; i < len; i++) {
									if ((elem = unmatched[i])) {
										if (!filter || filter(elem, context, xml)) {
											newUnmatched.push(elem);
											if (mapped) {
												map.push(i);
											}
										}
									}
								}

								return newUnmatched;
							}

							function setMatcher(
								preFilter,
								selector,
								matcher,
								postFilter,
								postFinder,
								postSelector
							) {
								if (postFilter && !postFilter[expando]) {
									postFilter = setMatcher(postFilter);
								}
								if (postFinder && !postFinder[expando]) {
									postFinder = setMatcher(postFinder, postSelector);
								}
								return markFunction(function (seed, results, context, xml) {
									var temp,
										i,
										elem,
										preMap = [],
										postMap = [],
										preexisting = results.length,
										// Get initial elements from seed or context
										elems =
											seed ||
											multipleContexts(selector || '*', context.nodeType ? [context] : context, []),
										// Prefilter to get matcher input, preserving a map for seed-results synchronization
										matcherIn =
											preFilter && (seed || !selector)
												? condense(elems, preMap, preFilter, context, xml)
												: elems,
										matcherOut = matcher
											? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
											  postFinder || (seed ? preFilter : preexisting || postFilter)
												? // ...intermediate processing is necessary
												  []
												: // ...otherwise use results directly
												  results
											: matcherIn;

									// Find primary matches
									if (matcher) {
										matcher(matcherIn, matcherOut, context, xml);
									}

									// Apply postFilter
									if (postFilter) {
										temp = condense(matcherOut, postMap);
										postFilter(temp, [], context, xml);

										// Un-match failing elements by moving them back to matcherIn
										i = temp.length;
										while (i--) {
											if ((elem = temp[i])) {
												matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
											}
										}
									}

									if (seed) {
										if (postFinder || preFilter) {
											if (postFinder) {
												// Get the final matcherOut by condensing this intermediate into postFinder contexts
												temp = [];
												i = matcherOut.length;
												while (i--) {
													if ((elem = matcherOut[i])) {
														// Restore matcherIn since elem is not yet a final match
														temp.push((matcherIn[i] = elem));
													}
												}
												postFinder(null, (matcherOut = []), temp, xml);
											}

											// Move matched elements from seed to results to keep them synchronized
											i = matcherOut.length;
											while (i--) {
												if (
													(elem = matcherOut[i]) &&
													(temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1
												) {
													seed[temp] = !(results[temp] = elem);
												}
											}
										}

										// Add elements to results, through postFinder if defined
									} else {
										matcherOut = condense(
											matcherOut === results
												? matcherOut.splice(preexisting, matcherOut.length)
												: matcherOut
										);
										if (postFinder) {
											postFinder(null, results, matcherOut, xml);
										} else {
											push.apply(results, matcherOut);
										}
									}
								});
							}

							function matcherFromTokens(tokens) {
								var checkContext,
									matcher,
									j,
									len = tokens.length,
									leadingRelative = Expr.relative[tokens[0].type],
									implicitRelative = leadingRelative || Expr.relative[' '],
									i = leadingRelative ? 1 : 0,
									// The foundational matcher ensures that elements are reachable from top-level context(s)
									matchContext = addCombinator(
										function (elem) {
											return elem === checkContext;
										},
										implicitRelative,
										true
									),
									matchAnyContext = addCombinator(
										function (elem) {
											return indexOf(checkContext, elem) > -1;
										},
										implicitRelative,
										true
									),
									matchers = [
										function (elem, context, xml) {
											var ret =
												(!leadingRelative && (xml || context !== outermostContext)) ||
												((checkContext = context).nodeType
													? matchContext(elem, context, xml)
													: matchAnyContext(elem, context, xml));

											// Avoid hanging onto element (issue #299)
											checkContext = null;
											return ret;
										}
									];

								for (; i < len; i++) {
									if ((matcher = Expr.relative[tokens[i].type])) {
										matchers = [addCombinator(elementMatcher(matchers), matcher)];
									} else {
										matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

										// Return special upon seeing a positional matcher
										if (matcher[expando]) {
											// Find the next relative operator (if any) for proper handling
											j = ++i;
											for (; j < len; j++) {
												if (Expr.relative[tokens[j].type]) {
													break;
												}
											}
											return setMatcher(
												i > 1 && elementMatcher(matchers),
												i > 1 &&
													toSelector(
														// If the preceding token was a descendant combinator, insert an implicit any-element `*`
														tokens
															.slice(0, i - 1)
															.concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })
													).replace(rtrim, '$1'),
												matcher,
												i < j && matcherFromTokens(tokens.slice(i, j)),
												j < len && matcherFromTokens((tokens = tokens.slice(j))),
												j < len && toSelector(tokens)
											);
										}
										matchers.push(matcher);
									}
								}

								return elementMatcher(matchers);
							}

							function matcherFromGroupMatchers(elementMatchers, setMatchers) {
								var bySet = setMatchers.length > 0,
									byElement = elementMatchers.length > 0,
									superMatcher = function (seed, context, xml, results, outermost) {
										var elem,
											j,
											matcher,
											matchedCount = 0,
											i = '0',
											unmatched = seed && [],
											setMatched = [],
											contextBackup = outermostContext,
											// We must always have either seed elements or outermost context
											elems = seed || (byElement && Expr.find['TAG']('*', outermost)),
											// Use integer dirruns iff this is the outermost matcher
											dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
											len = elems.length;

										if (outermost) {
											// Support: IE 11+, Edge 17 - 18+
											// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
											// two documents; shallow comparisons work.
											// eslint-disable-next-line eqeqeq
											outermostContext = context == document || context || outermost;
										}

										// Add elements passing elementMatchers directly to results
										// Support: IE<9, Safari
										// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
										for (; i !== len && (elem = elems[i]) != null; i++) {
											if (byElement && elem) {
												j = 0;

												// Support: IE 11+, Edge 17 - 18+
												// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
												// two documents; shallow comparisons work.
												// eslint-disable-next-line eqeqeq
												if (!context && elem.ownerDocument != document) {
													setDocument(elem);
													xml = !documentIsHTML;
												}
												while ((matcher = elementMatchers[j++])) {
													if (matcher(elem, context || document, xml)) {
														results.push(elem);
														break;
													}
												}
												if (outermost) {
													dirruns = dirrunsUnique;
												}
											}

											// Track unmatched elements for set filters
											if (bySet) {
												// They will have gone through all possible matchers
												if ((elem = !matcher && elem)) {
													matchedCount--;
												}

												// Lengthen the array for every element, matched or not
												if (seed) {
													unmatched.push(elem);
												}
											}
										}

										// `i` is now the count of elements visited above, and adding it to `matchedCount`
										// makes the latter nonnegative.
										matchedCount += i;

										// Apply set filters to unmatched elements
										// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
										// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
										// no element matchers and no seed.
										// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
										// case, which will result in a "00" `matchedCount` that differs from `i` but is also
										// numerically zero.
										if (bySet && i !== matchedCount) {
											j = 0;
											while ((matcher = setMatchers[j++])) {
												matcher(unmatched, setMatched, context, xml);
											}

											if (seed) {
												// Reintegrate element matches to eliminate the need for sorting
												if (matchedCount > 0) {
													while (i--) {
														if (!(unmatched[i] || setMatched[i])) {
															setMatched[i] = pop.call(results);
														}
													}
												}

												// Discard index placeholder values to get only actual matches
												setMatched = condense(setMatched);
											}

											// Add matches to results
											push.apply(results, setMatched);

											// Seedless set matches succeeding multiple successful matchers stipulate sorting
											if (
												outermost &&
												!seed &&
												setMatched.length > 0 &&
												matchedCount + setMatchers.length > 1
											) {
												Sizzle.uniqueSort(results);
											}
										}

										// Override manipulation of globals by nested matchers
										if (outermost) {
											dirruns = dirrunsUnique;
											outermostContext = contextBackup;
										}

										return unmatched;
									};

								return bySet ? markFunction(superMatcher) : superMatcher;
							}

							compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
								var i,
									setMatchers = [],
									elementMatchers = [],
									cached = compilerCache[selector + ' '];

								if (!cached) {
									// Generate a function of recursive functions that can be used to check each element
									if (!match) {
										match = tokenize(selector);
									}
									i = match.length;
									while (i--) {
										cached = matcherFromTokens(match[i]);
										if (cached[expando]) {
											setMatchers.push(cached);
										} else {
											elementMatchers.push(cached);
										}
									}

									// Cache the compiled function
									cached = compilerCache(
										selector,
										matcherFromGroupMatchers(elementMatchers, setMatchers)
									);

									// Save selector and tokenization
									cached.selector = selector;
								}
								return cached;
							};

							/**
							 * A low-level selection function that works with Sizzle's compiled
							 *  selector functions
							 * @param {String|Function} selector A selector or a pre-compiled
							 *  selector function built with Sizzle.compile
							 * @param {Element} context
							 * @param {Array} [results]
							 * @param {Array} [seed] A set of elements to match against
							 */
							select = Sizzle.select = function (selector, context, results, seed) {
								var i,
									tokens,
									token,
									type,
									find,
									compiled = typeof selector === 'function' && selector,
									match = !seed && tokenize((selector = compiled.selector || selector));

								results = results || [];

								// Try to minimize operations if there is only one selector in the list and no seed
								// (the latter of which guarantees us context)
								if (match.length === 1) {
									// Reduce context if the leading compound selector is an ID
									tokens = match[0] = match[0].slice(0);
									if (
										tokens.length > 2 &&
										(token = tokens[0]).type === 'ID' &&
										context.nodeType === 9 &&
										documentIsHTML &&
										Expr.relative[tokens[1].type]
									) {
										context = (Expr.find['ID'](
											token.matches[0].replace(runescape, funescape),
											context
										) || [])[0];
										if (!context) {
											return results;

											// Precompiled matchers will still verify ancestry, so step up a level
										} else if (compiled) {
											context = context.parentNode;
										}

										selector = selector.slice(tokens.shift().value.length);
									}

									// Fetch a seed set for right-to-left matching
									i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
									while (i--) {
										token = tokens[i];

										// Abort if we hit a combinator
										if (Expr.relative[(type = token.type)]) {
											break;
										}
										if ((find = Expr.find[type])) {
											// Search, expanding context for leading sibling combinators
											if (
												(seed = find(
													token.matches[0].replace(runescape, funescape),
													(rsibling.test(tokens[0].type) && testContext(context.parentNode)) ||
														context
												))
											) {
												// If seed is empty or no tokens remain, we can return early
												tokens.splice(i, 1);
												selector = seed.length && toSelector(tokens);
												if (!selector) {
													push.apply(results, seed);
													return results;
												}

												break;
											}
										}
									}
								}

								// Compile and execute a filtering function if one is not provided
								// Provide `match` to avoid retokenization if we modified the selector above
								(compiled || compile(selector, match))(
									seed,
									context,
									!documentIsHTML,
									results,
									!context ||
										(rsibling.test(selector) && testContext(context.parentNode)) ||
										context
								);
								return results;
							};

							// One-time assignments

							// Sort stability
							support.sortStable = expando.split('').sort(sortOrder).join('') === expando;

							// Support: Chrome 14-35+
							// Always assume duplicates if they aren't passed to the comparison function
							support.detectDuplicates = !!hasDuplicate;

							// Initialize against the default document
							setDocument();

							// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
							// Detached nodes confoundingly follow *each other*
							support.sortDetached = assert(function (el) {
								// Should return 1, but returns 4 (following)
								return el.compareDocumentPosition(document.createElement('fieldset')) & 1;
							});

							// Support: IE<8
							// Prevent attribute/property "interpolation"
							// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
							if (
								!assert(function (el) {
									el.innerHTML = "<a href='#'></a>";
									return el.firstChild.getAttribute('href') === '#';
								})
							) {
								addHandle('type|href|height|width', function (elem, name, isXML) {
									if (!isXML) {
										return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
									}
								});
							}

							// Support: IE<9
							// Use defaultValue in place of getAttribute("value")
							if (
								!support.attributes ||
								!assert(function (el) {
									el.innerHTML = '<input/>';
									el.firstChild.setAttribute('value', '');
									return el.firstChild.getAttribute('value') === '';
								})
							) {
								addHandle('value', function (elem, _name, isXML) {
									if (!isXML && elem.nodeName.toLowerCase() === 'input') {
										return elem.defaultValue;
									}
								});
							}

							// Support: IE<9
							// Use getAttributeNode to fetch booleans when getAttribute lies
							if (
								!assert(function (el) {
									return el.getAttribute('disabled') == null;
								})
							) {
								addHandle(booleans, function (elem, name, isXML) {
									var val;
									if (!isXML) {
										return elem[name] === true
											? name.toLowerCase()
											: (val = elem.getAttributeNode(name)) && val.specified
											? val.value
											: null;
									}
								});
							}

							return Sizzle;
						})(window);

					jQuery.find = Sizzle;
					jQuery.expr = Sizzle.selectors;

					// Deprecated
					jQuery.expr[':'] = jQuery.expr.pseudos;
					jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
					jQuery.text = Sizzle.getText;
					jQuery.isXMLDoc = Sizzle.isXML;
					jQuery.contains = Sizzle.contains;
					jQuery.escapeSelector = Sizzle.escape;

					var dir = function (elem, dir, until) {
						var matched = [],
							truncate = until !== undefined;

						while ((elem = elem[dir]) && elem.nodeType !== 9) {
							if (elem.nodeType === 1) {
								if (truncate && jQuery(elem).is(until)) {
									break;
								}
								matched.push(elem);
							}
						}
						return matched;
					};

					var siblings = function (n, elem) {
						var matched = [];

						for (; n; n = n.nextSibling) {
							if (n.nodeType === 1 && n !== elem) {
								matched.push(n);
							}
						}

						return matched;
					};

					var rneedsContext = jQuery.expr.match.needsContext;

					function nodeName(elem, name) {
						return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
					}
					var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

					// Implement the identical functionality for filter and not
					function winnow(elements, qualifier, not) {
						if (isFunction(qualifier)) {
							return jQuery.grep(elements, function (elem, i) {
								return !!qualifier.call(elem, i, elem) !== not;
							});
						}

						// Single element
						if (qualifier.nodeType) {
							return jQuery.grep(elements, function (elem) {
								return (elem === qualifier) !== not;
							});
						}

						// Arraylike of elements (jQuery, arguments, Array)
						if (typeof qualifier !== 'string') {
							return jQuery.grep(elements, function (elem) {
								return indexOf.call(qualifier, elem) > -1 !== not;
							});
						}

						// Filtered directly for both simple and complex selectors
						return jQuery.filter(qualifier, elements, not);
					}

					jQuery.filter = function (expr, elems, not) {
						var elem = elems[0];

						if (not) {
							expr = ':not(' + expr + ')';
						}

						if (elems.length === 1 && elem.nodeType === 1) {
							return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
						}

						return jQuery.find.matches(
							expr,
							jQuery.grep(elems, function (elem) {
								return elem.nodeType === 1;
							})
						);
					};

					jQuery.fn.extend({
						find: function (selector) {
							var i,
								ret,
								len = this.length,
								self = this;

							if (typeof selector !== 'string') {
								return this.pushStack(
									jQuery(selector).filter(function () {
										for (i = 0; i < len; i++) {
											if (jQuery.contains(self[i], this)) {
												return true;
											}
										}
									})
								);
							}

							ret = this.pushStack([]);

							for (i = 0; i < len; i++) {
								jQuery.find(selector, self[i], ret);
							}

							return len > 1 ? jQuery.uniqueSort(ret) : ret;
						},
						filter: function (selector) {
							return this.pushStack(winnow(this, selector || [], false));
						},
						not: function (selector) {
							return this.pushStack(winnow(this, selector || [], true));
						},
						is: function (selector) {
							return !!winnow(
								this,

								// If this is a positional/relative selector, check membership in the returned set
								// so $("p:first").is("p:last") won't return true for a doc with two "p".
								typeof selector === 'string' && rneedsContext.test(selector)
									? jQuery(selector)
									: selector || [],
								false
							).length;
						}
					});

					// Initialize a jQuery object

					// A central reference to the root jQuery(document)
					var rootjQuery,
						// A simple way to check for HTML strings
						// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
						// Strict HTML recognition (#11290: must start with <)
						// Shortcut simple #id case for speed
						rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
						init = (jQuery.fn.init = function (selector, context, root) {
							var match, elem;

							// HANDLE: $(""), $(null), $(undefined), $(false)
							if (!selector) {
								return this;
							}

							// Method init() accepts an alternate rootjQuery
							// so migrate can support jQuery.sub (gh-2101)
							root = root || rootjQuery;

							// Handle HTML strings
							if (typeof selector === 'string') {
								if (
									selector[0] === '<' &&
									selector[selector.length - 1] === '>' &&
									selector.length >= 3
								) {
									// Assume that strings that start and end with <> are HTML and skip the regex check
									match = [null, selector, null];
								} else {
									match = rquickExpr.exec(selector);
								}

								// Match html or make sure no context is specified for #id
								if (match && (match[1] || !context)) {
									// HANDLE: $(html) -> $(array)
									if (match[1]) {
										context = context instanceof jQuery ? context[0] : context;

										// Option to run scripts is true for back-compat
										// Intentionally let the error be thrown if parseHTML is not present
										jQuery.merge(
											this,
											jQuery.parseHTML(
												match[1],
												context && context.nodeType ? context.ownerDocument || context : document,
												true
											)
										);

										// HANDLE: $(html, props)
										if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
											for (match in context) {
												// Properties of context are called as methods if possible
												if (isFunction(this[match])) {
													this[match](context[match]);

													// ...and otherwise set as attributes
												} else {
													this.attr(match, context[match]);
												}
											}
										}

										return this;

										// HANDLE: $(#id)
									} else {
										elem = document.getElementById(match[2]);

										if (elem) {
											// Inject the element directly into the jQuery object
											this[0] = elem;
											this.length = 1;
										}
										return this;
									}

									// HANDLE: $(expr, $(...))
								} else if (!context || context.jquery) {
									return (context || root).find(selector);

									// HANDLE: $(expr, context)
									// (which is just equivalent to: $(context).find(expr)
								} else {
									return this.constructor(context).find(selector);
								}

								// HANDLE: $(DOMElement)
							} else if (selector.nodeType) {
								this[0] = selector;
								this.length = 1;
								return this;

								// HANDLE: $(function)
								// Shortcut for document ready
							} else if (isFunction(selector)) {
								return root.ready !== undefined
									? root.ready(selector)
									: // Execute immediately if ready is not present
									  selector(jQuery);
							}

							return jQuery.makeArray(selector, this);
						});

					// Give the init function the jQuery prototype for later instantiation
					init.prototype = jQuery.fn;

					// Initialize central reference
					rootjQuery = jQuery(document);

					var rparentsprev = /^(?:parents|prev(?:Until|All))/,
						// Methods guaranteed to produce a unique set when starting from a unique set
						guaranteedUnique = {
							children: true,
							contents: true,
							next: true,
							prev: true
						};

					jQuery.fn.extend({
						has: function (target) {
							var targets = jQuery(target, this),
								l = targets.length;

							return this.filter(function () {
								var i = 0;
								for (; i < l; i++) {
									if (jQuery.contains(this, targets[i])) {
										return true;
									}
								}
							});
						},

						closest: function (selectors, context) {
							var cur,
								i = 0,
								l = this.length,
								matched = [],
								targets = typeof selectors !== 'string' && jQuery(selectors);

							// Positional selectors never match, since there's no _selection_ context
							if (!rneedsContext.test(selectors)) {
								for (; i < l; i++) {
									for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
										// Always skip document fragments
										if (
											cur.nodeType < 11 &&
											(targets
												? targets.index(cur) > -1
												: // Don't pass non-elements to Sizzle
												  cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))
										) {
											matched.push(cur);
											break;
										}
									}
								}
							}

							return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
						},

						// Determine the position of an element within the set
						index: function (elem) {
							// No argument, return index in parent
							if (!elem) {
								return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
							}

							// Index in selector
							if (typeof elem === 'string') {
								return indexOf.call(jQuery(elem), this[0]);
							}

							// Locate the position of the desired element
							return indexOf.call(
								this,

								// If it receives a jQuery object, the first element is used
								elem.jquery ? elem[0] : elem
							);
						},

						add: function (selector, context) {
							return this.pushStack(
								jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context)))
							);
						},

						addBack: function (selector) {
							return this.add(
								selector == null ? this.prevObject : this.prevObject.filter(selector)
							);
						}
					});

					function sibling(cur, dir) {
						while ((cur = cur[dir]) && cur.nodeType !== 1) {}
						return cur;
					}

					jQuery.each(
						{
							parent: function (elem) {
								var parent = elem.parentNode;
								return parent && parent.nodeType !== 11 ? parent : null;
							},
							parents: function (elem) {
								return dir(elem, 'parentNode');
							},
							parentsUntil: function (elem, _i, until) {
								return dir(elem, 'parentNode', until);
							},
							next: function (elem) {
								return sibling(elem, 'nextSibling');
							},
							prev: function (elem) {
								return sibling(elem, 'previousSibling');
							},
							nextAll: function (elem) {
								return dir(elem, 'nextSibling');
							},
							prevAll: function (elem) {
								return dir(elem, 'previousSibling');
							},
							nextUntil: function (elem, _i, until) {
								return dir(elem, 'nextSibling', until);
							},
							prevUntil: function (elem, _i, until) {
								return dir(elem, 'previousSibling', until);
							},
							siblings: function (elem) {
								return siblings((elem.parentNode || {}).firstChild, elem);
							},
							children: function (elem) {
								return siblings(elem.firstChild);
							},
							contents: function (elem) {
								if (
									elem.contentDocument != null &&
									// Support: IE 11+
									// <object> elements with no `data` attribute has an object
									// `contentDocument` with a `null` prototype.
									getProto(elem.contentDocument)
								) {
									return elem.contentDocument;
								}

								// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
								// Treat the template element as a regular one in browsers that
								// don't support it.
								if (nodeName(elem, 'template')) {
									elem = elem.content || elem;
								}

								return jQuery.merge([], elem.childNodes);
							}
						},
						function (name, fn) {
							jQuery.fn[name] = function (until, selector) {
								var matched = jQuery.map(this, fn, until);

								if (name.slice(-5) !== 'Until') {
									selector = until;
								}

								if (selector && typeof selector === 'string') {
									matched = jQuery.filter(selector, matched);
								}

								if (this.length > 1) {
									// Remove duplicates
									if (!guaranteedUnique[name]) {
										jQuery.uniqueSort(matched);
									}

									// Reverse order for parents* and prev-derivatives
									if (rparentsprev.test(name)) {
										matched.reverse();
									}
								}

								return this.pushStack(matched);
							};
						}
					);
					var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;

					// Convert String-formatted options into Object-formatted ones
					function createOptions(options) {
						var object = {};
						jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
							object[flag] = true;
						});
						return object;
					}

					/*
					 * Create a callback list using the following parameters:
					 *
					 *	options: an optional list of space-separated options that will change how
					 *			the callback list behaves or a more traditional option object
					 *
					 * By default a callback list will act like an event callback list and can be
					 * "fired" multiple times.
					 *
					 * Possible options:
					 *
					 *	once:			will ensure the callback list can only be fired once (like a Deferred)
					 *
					 *	memory:			will keep track of previous values and will call any callback added
					 *					after the list has been fired right away with the latest "memorized"
					 *					values (like a Deferred)
					 *
					 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
					 *
					 *	stopOnFalse:	interrupt callings when a callback returns false
					 *
					 */
					jQuery.Callbacks = function (options) {
						// Convert options from String-formatted to Object-formatted if needed
						// (we check in cache first)
						options =
							typeof options === 'string' ? createOptions(options) : jQuery.extend({}, options);

						var // Flag to know if list is currently firing
							firing,
							// Last fire value for non-forgettable lists
							memory,
							// Flag to know if list was already fired
							fired,
							// Flag to prevent firing
							locked,
							// Actual callback list
							list = [],
							// Queue of execution data for repeatable lists
							queue = [],
							// Index of currently firing callback (modified by add/remove as needed)
							firingIndex = -1,
							// Fire callbacks
							fire = function () {
								// Enforce single-firing
								locked = locked || options.once;

								// Execute callbacks for all pending executions,
								// respecting firingIndex overrides and runtime changes
								fired = firing = true;
								for (; queue.length; firingIndex = -1) {
									memory = queue.shift();
									while (++firingIndex < list.length) {
										// Run callback and check for early termination
										if (
											list[firingIndex].apply(memory[0], memory[1]) === false &&
											options.stopOnFalse
										) {
											// Jump to end and forget the data so .add doesn't re-fire
											firingIndex = list.length;
											memory = false;
										}
									}
								}

								// Forget the data if we're done with it
								if (!options.memory) {
									memory = false;
								}

								firing = false;

								// Clean up if we're done firing for good
								if (locked) {
									// Keep an empty list if we have data for future add calls
									if (memory) {
										list = [];

										// Otherwise, this object is spent
									} else {
										list = '';
									}
								}
							},
							// Actual Callbacks object
							self = {
								// Add a callback or a collection of callbacks to the list
								add: function () {
									if (list) {
										// If we have memory from a past run, we should fire after adding
										if (memory && !firing) {
											firingIndex = list.length - 1;
											queue.push(memory);
										}

										(function add(args) {
											jQuery.each(args, function (_, arg) {
												if (isFunction(arg)) {
													if (!options.unique || !self.has(arg)) {
														list.push(arg);
													}
												} else if (arg && arg.length && toType(arg) !== 'string') {
													// Inspect recursively
													add(arg);
												}
											});
										})(arguments);

										if (memory && !firing) {
											fire();
										}
									}
									return this;
								},

								// Remove a callback from the list
								remove: function () {
									jQuery.each(arguments, function (_, arg) {
										var index;
										while ((index = jQuery.inArray(arg, list, index)) > -1) {
											list.splice(index, 1);

											// Handle firing indexes
											if (index <= firingIndex) {
												firingIndex--;
											}
										}
									});
									return this;
								},

								// Check if a given callback is in the list.
								// If no argument is given, return whether or not list has callbacks attached.
								has: function (fn) {
									return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
								},

								// Remove all callbacks from the list
								empty: function () {
									if (list) {
										list = [];
									}
									return this;
								},

								// Disable .fire and .add
								// Abort any current/pending executions
								// Clear all callbacks and values
								disable: function () {
									locked = queue = [];
									list = memory = '';
									return this;
								},
								disabled: function () {
									return !list;
								},

								// Disable .fire
								// Also disable .add unless we have memory (since it would have no effect)
								// Abort any pending executions
								lock: function () {
									locked = queue = [];
									if (!memory && !firing) {
										list = memory = '';
									}
									return this;
								},
								locked: function () {
									return !!locked;
								},

								// Call all callbacks with the given context and arguments
								fireWith: function (context, args) {
									if (!locked) {
										args = args || [];
										args = [context, args.slice ? args.slice() : args];
										queue.push(args);
										if (!firing) {
											fire();
										}
									}
									return this;
								},

								// Call all the callbacks with the given arguments
								fire: function () {
									self.fireWith(this, arguments);
									return this;
								},

								// To know if the callbacks have already been called at least once
								fired: function () {
									return !!fired;
								}
							};

						return self;
					};

					function Identity(v) {
						return v;
					}
					function Thrower(ex) {
						throw ex;
					}

					function adoptValue(value, resolve, reject, noValue) {
						var method;

						try {
							// Check for promise aspect first to privilege synchronous behavior
							if (value && isFunction((method = value.promise))) {
								method.call(value).done(resolve).fail(reject);

								// Other thenables
							} else if (value && isFunction((method = value.then))) {
								method.call(value, resolve, reject);

								// Other non-thenables
							} else {
								// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
								// * false: [ value ].slice( 0 ) => resolve( value )
								// * true: [ value ].slice( 1 ) => resolve()
								resolve.apply(undefined, [value].slice(noValue));
							}

							// For Promises/A+, convert exceptions into rejections
							// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
							// Deferred#then to conditionally suppress rejection.
						} catch (value) {
							// Support: Android 4.0 only
							// Strict mode functions invoked without .call/.apply get global-object context
							reject.apply(undefined, [value]);
						}
					}

					jQuery.extend({
						Deferred: function (func) {
							var tuples = [
									// action, add listener, callbacks,
									// ... .then handlers, argument index, [final state]
									['notify', 'progress', jQuery.Callbacks('memory'), jQuery.Callbacks('memory'), 2],
									[
										'resolve',
										'done',
										jQuery.Callbacks('once memory'),
										jQuery.Callbacks('once memory'),
										0,
										'resolved'
									],
									[
										'reject',
										'fail',
										jQuery.Callbacks('once memory'),
										jQuery.Callbacks('once memory'),
										1,
										'rejected'
									]
								],
								state = 'pending',
								promise = {
									state: function () {
										return state;
									},
									always: function () {
										deferred.done(arguments).fail(arguments);
										return this;
									},
									catch: function (fn) {
										return promise.then(null, fn);
									},

									// Keep pipe for back-compat
									pipe: function (/* fnDone, fnFail, fnProgress */) {
										var fns = arguments;

										return jQuery
											.Deferred(function (newDefer) {
												jQuery.each(tuples, function (_i, tuple) {
													// Map tuples (progress, done, fail) to arguments (done, fail, progress)
													var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];

													// deferred.progress(function() { bind to newDefer or newDefer.notify })
													// deferred.done(function() { bind to newDefer or newDefer.resolve })
													// deferred.fail(function() { bind to newDefer or newDefer.reject })
													deferred[tuple[1]](function () {
														var returned = fn && fn.apply(this, arguments);
														if (returned && isFunction(returned.promise)) {
															returned
																.promise()
																.progress(newDefer.notify)
																.done(newDefer.resolve)
																.fail(newDefer.reject);
														} else {
															newDefer[tuple[0] + 'With'](this, fn ? [returned] : arguments);
														}
													});
												});
												fns = null;
											})
											.promise();
									},
									then: function (onFulfilled, onRejected, onProgress) {
										var maxDepth = 0;
										function resolve(depth, deferred, handler, special) {
											return function () {
												var that = this,
													args = arguments,
													mightThrow = function () {
														var returned, then;

														// Support: Promises/A+ section 2.3.3.3.3
														// https://promisesaplus.com/#point-59
														// Ignore double-resolution attempts
														if (depth < maxDepth) {
															return;
														}

														returned = handler.apply(that, args);

														// Support: Promises/A+ section 2.3.1
														// https://promisesaplus.com/#point-48
														if (returned === deferred.promise()) {
															throw new TypeError('Thenable self-resolution');
														}

														// Support: Promises/A+ sections 2.3.3.1, 3.5
														// https://promisesaplus.com/#point-54
														// https://promisesaplus.com/#point-75
														// Retrieve `then` only once
														then =
															returned &&
															// Support: Promises/A+ section 2.3.4
															// https://promisesaplus.com/#point-64
															// Only check objects and functions for thenability
															(typeof returned === 'object' || typeof returned === 'function') &&
															returned.then;

														// Handle a returned thenable
														if (isFunction(then)) {
															// Special processors (notify) just wait for resolution
															if (special) {
																then.call(
																	returned,
																	resolve(maxDepth, deferred, Identity, special),
																	resolve(maxDepth, deferred, Thrower, special)
																);

																// Normal processors (resolve) also hook into progress
															} else {
																// ...and disregard older resolution values
																maxDepth++;

																then.call(
																	returned,
																	resolve(maxDepth, deferred, Identity, special),
																	resolve(maxDepth, deferred, Thrower, special),
																	resolve(maxDepth, deferred, Identity, deferred.notifyWith)
																);
															}

															// Handle all other returned values
														} else {
															// Only substitute handlers pass on context
															// and multiple values (non-spec behavior)
															if (handler !== Identity) {
																that = undefined;
																args = [returned];
															}

															// Process the value(s)
															// Default process is resolve
															(special || deferred.resolveWith)(that, args);
														}
													},
													// Only normal processors (resolve) catch and reject exceptions
													process = special
														? mightThrow
														: function () {
																try {
																	mightThrow();
																} catch (e) {
																	if (jQuery.Deferred.exceptionHook) {
																		jQuery.Deferred.exceptionHook(e, process.stackTrace);
																	}

																	// Support: Promises/A+ section 2.3.3.3.4.1
																	// https://promisesaplus.com/#point-61
																	// Ignore post-resolution exceptions
																	if (depth + 1 >= maxDepth) {
																		// Only substitute handlers pass on context
																		// and multiple values (non-spec behavior)
																		if (handler !== Thrower) {
																			that = undefined;
																			args = [e];
																		}

																		deferred.rejectWith(that, args);
																	}
																}
														  };

												// Support: Promises/A+ section 2.3.3.3.1
												// https://promisesaplus.com/#point-57
												// Re-resolve promises immediately to dodge false rejection from
												// subsequent errors
												if (depth) {
													process();
												} else {
													// Call an optional hook to record the stack, in case of exception
													// since it's otherwise lost when execution goes async
													if (jQuery.Deferred.getStackHook) {
														process.stackTrace = jQuery.Deferred.getStackHook();
													}
													window.setTimeout(process);
												}
											};
										}

										return jQuery
											.Deferred(function (newDefer) {
												// progress_handlers.add( ... )
												tuples[0][3].add(
													resolve(
														0,
														newDefer,
														isFunction(onProgress) ? onProgress : Identity,
														newDefer.notifyWith
													)
												);

												// fulfilled_handlers.add( ... )
												tuples[1][3].add(
													resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)
												);

												// rejected_handlers.add( ... )
												tuples[2][3].add(
													resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower)
												);
											})
											.promise();
									},

									// Get a promise for this deferred
									// If obj is provided, the promise aspect is added to the object
									promise: function (obj) {
										return obj != null ? jQuery.extend(obj, promise) : promise;
									}
								},
								deferred = {};

							// Add list-specific methods
							jQuery.each(tuples, function (i, tuple) {
								var list = tuple[2],
									stateString = tuple[5];

								// promise.progress = list.add
								// promise.done = list.add
								// promise.fail = list.add
								promise[tuple[1]] = list.add;

								// Handle state
								if (stateString) {
									list.add(
										function () {
											// state = "resolved" (i.e., fulfilled)
											// state = "rejected"
											state = stateString;
										},

										// rejected_callbacks.disable
										// fulfilled_callbacks.disable
										tuples[3 - i][2].disable,

										// rejected_handlers.disable
										// fulfilled_handlers.disable
										tuples[3 - i][3].disable,

										// progress_callbacks.lock
										tuples[0][2].lock,

										// progress_handlers.lock
										tuples[0][3].lock
									);
								}

								// progress_handlers.fire
								// fulfilled_handlers.fire
								// rejected_handlers.fire
								list.add(tuple[3].fire);

								// deferred.notify = function() { deferred.notifyWith(...) }
								// deferred.resolve = function() { deferred.resolveWith(...) }
								// deferred.reject = function() { deferred.rejectWith(...) }
								deferred[tuple[0]] = function () {
									deferred[tuple[0] + 'With'](this === deferred ? undefined : this, arguments);
									return this;
								};

								// deferred.notifyWith = list.fireWith
								// deferred.resolveWith = list.fireWith
								// deferred.rejectWith = list.fireWith
								deferred[tuple[0] + 'With'] = list.fireWith;
							});

							// Make the deferred a promise
							promise.promise(deferred);

							// Call given func if any
							if (func) {
								func.call(deferred, deferred);
							}

							// All done!
							return deferred;
						},

						// Deferred helper
						when: function (singleValue) {
							var // count of uncompleted subordinates
								remaining = arguments.length,
								// count of unprocessed arguments
								i = remaining,
								// subordinate fulfillment data
								resolveContexts = Array(i),
								resolveValues = slice.call(arguments),
								// the master Deferred
								master = jQuery.Deferred(),
								// subordinate callback factory
								updateFunc = function (i) {
									return function (value) {
										resolveContexts[i] = this;
										resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
										if (!--remaining) {
											master.resolveWith(resolveContexts, resolveValues);
										}
									};
								};

							// Single- and empty arguments are adopted like Promise.resolve
							if (remaining <= 1) {
								adoptValue(
									singleValue,
									master.done(updateFunc(i)).resolve,
									master.reject,
									!remaining
								);

								// Use .then() to unwrap secondary thenables (cf. gh-3000)
								if (
									master.state() === 'pending' ||
									isFunction(resolveValues[i] && resolveValues[i].then)
								) {
									return master.then();
								}
							}

							// Multiple arguments are aggregated like Promise.all array elements
							while (i--) {
								adoptValue(resolveValues[i], updateFunc(i), master.reject);
							}

							return master.promise();
						}
					});

					// These usually indicate a programmer mistake during development,
					// warn about them ASAP rather than swallowing them by default.
					var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

					jQuery.Deferred.exceptionHook = function (error, stack) {
						// Support: IE 8 - 9 only
						// Console exists when dev tools are open, which can happen at any time
						if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
							window.console.warn(
								'jQuery.Deferred exception: ' + error.message,
								error.stack,
								stack
							);
						}
					};

					jQuery.readyException = function (error) {
						window.setTimeout(function () {
							throw error;
						});
					};

					// The deferred used on DOM ready
					var readyList = jQuery.Deferred();

					jQuery.fn.ready = function (fn) {
						readyList
							.then(fn)

							// Wrap jQuery.readyException in a function so that the lookup
							// happens at the time of error handling instead of callback
							// registration.
							.catch(function (error) {
								jQuery.readyException(error);
							});

						return this;
					};

					jQuery.extend({
						// Is the DOM ready to be used? Set to true once it occurs.
						isReady: false,

						// A counter to track how many items to wait for before
						// the ready event fires. See #6781
						readyWait: 1,

						// Handle when the DOM is ready
						ready: function (wait) {
							// Abort if there are pending holds or we're already ready
							if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
								return;
							}

							// Remember that the DOM is ready
							jQuery.isReady = true;

							// If a normal DOM Ready event fired, decrement, and wait if need be
							if (wait !== true && --jQuery.readyWait > 0) {
								return;
							}

							// If there are functions bound, to execute
							readyList.resolveWith(document, [jQuery]);
						}
					});

					jQuery.ready.then = readyList.then;

					// The ready event handler and self cleanup method
					function completed() {
						document.removeEventListener('DOMContentLoaded', completed);
						window.removeEventListener('load', completed);
						jQuery.ready();
					}

					// Catch cases where $(document).ready() is called
					// after the browser event has already occurred.
					// Support: IE <=9 - 10 only
					// Older IE sometimes signals "interactive" too soon
					if (
						document.readyState === 'complete' ||
						(document.readyState !== 'loading' && !document.documentElement.doScroll)
					) {
						// Handle it asynchronously to allow scripts the opportunity to delay ready
						window.setTimeout(jQuery.ready);
					} else {
						// Use the handy event callback
						document.addEventListener('DOMContentLoaded', completed);

						// A fallback to window.onload, that will always work
						window.addEventListener('load', completed);
					}

					// Multifunctional method to get and set values of a collection
					// The value/s can optionally be executed if it's a function
					var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
						var i = 0,
							len = elems.length,
							bulk = key == null;

						// Sets many values
						if (toType(key) === 'object') {
							chainable = true;
							for (i in key) {
								access(elems, fn, i, key[i], true, emptyGet, raw);
							}

							// Sets one value
						} else if (value !== undefined) {
							chainable = true;

							if (!isFunction(value)) {
								raw = true;
							}

							if (bulk) {
								// Bulk operations run against the entire set
								if (raw) {
									fn.call(elems, value);
									fn = null;

									// ...except when executing function values
								} else {
									bulk = fn;
									fn = function (elem, _key, value) {
										return bulk.call(jQuery(elem), value);
									};
								}
							}

							if (fn) {
								for (; i < len; i++) {
									fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
								}
							}
						}

						if (chainable) {
							return elems;
						}

						// Gets
						if (bulk) {
							return fn.call(elems);
						}

						return len ? fn(elems[0], key) : emptyGet;
					};

					// Matches dashed string for camelizing
					var rmsPrefix = /^-ms-/,
						rdashAlpha = /-([a-z])/g;

					// Used by camelCase as callback to replace()
					function fcamelCase(_all, letter) {
						return letter.toUpperCase();
					}

					// Convert dashed to camelCase; used by the css and data modules
					// Support: IE <=9 - 11, Edge 12 - 15
					// Microsoft forgot to hump their vendor prefix (#9572)
					function camelCase(string) {
						return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
					}
					var acceptData = function (owner) {
						// Accepts only:
						//  - Node
						//    - Node.ELEMENT_NODE
						//    - Node.DOCUMENT_NODE
						//  - Object
						//    - Any
						return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
					};

					function Data() {
						this.expando = jQuery.expando + Data.uid++;
					}

					Data.uid = 1;

					Data.prototype = {
						cache: function (owner) {
							// Check if the owner object already has a cache
							var value = owner[this.expando];

							// If not, create one
							if (!value) {
								value = {};

								// We can accept data for non-element nodes in modern browsers,
								// but we should not, see #8335.
								// Always return an empty object.
								if (acceptData(owner)) {
									// If it is a node unlikely to be stringify-ed or looped over
									// use plain assignment
									if (owner.nodeType) {
										owner[this.expando] = value;

										// Otherwise secure it in a non-enumerable property
										// configurable must be true to allow the property to be
										// deleted when data is removed
									} else {
										Object.defineProperty(owner, this.expando, {
											value: value,
											configurable: true
										});
									}
								}
							}

							return value;
						},
						set: function (owner, data, value) {
							var prop,
								cache = this.cache(owner);

							// Handle: [ owner, key, value ] args
							// Always use camelCase key (gh-2257)
							if (typeof data === 'string') {
								cache[camelCase(data)] = value;

								// Handle: [ owner, { properties } ] args
							} else {
								// Copy the properties one-by-one to the cache object
								for (prop in data) {
									cache[camelCase(prop)] = data[prop];
								}
							}
							return cache;
						},
						get: function (owner, key) {
							return key === undefined
								? this.cache(owner)
								: // Always use camelCase key (gh-2257)
								  owner[this.expando] && owner[this.expando][camelCase(key)];
						},
						access: function (owner, key, value) {
							// In cases where either:
							//
							//   1. No key was specified
							//   2. A string key was specified, but no value provided
							//
							// Take the "read" path and allow the get method to determine
							// which value to return, respectively either:
							//
							//   1. The entire cache object
							//   2. The data stored at the key
							//
							if (key === undefined || (key && typeof key === 'string' && value === undefined)) {
								return this.get(owner, key);
							}

							// When the key is not a string, or both a key and value
							// are specified, set or extend (existing objects) with either:
							//
							//   1. An object of properties
							//   2. A key and value
							//
							this.set(owner, key, value);

							// Since the "set" path can have two possible entry points
							// return the expected data based on which path was taken[*]
							return value !== undefined ? value : key;
						},
						remove: function (owner, key) {
							var i,
								cache = owner[this.expando];

							if (cache === undefined) {
								return;
							}

							if (key !== undefined) {
								// Support array or space separated string of keys
								if (Array.isArray(key)) {
									// If key is an array of keys...
									// We always set camelCase keys, so remove that.
									key = key.map(camelCase);
								} else {
									key = camelCase(key);

									// If a key with the spaces exists, use it.
									// Otherwise, create an array by matching non-whitespace
									key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
								}

								i = key.length;

								while (i--) {
									delete cache[key[i]];
								}
							}

							// Remove the expando if there's no more data
							if (key === undefined || jQuery.isEmptyObject(cache)) {
								// Support: Chrome <=35 - 45
								// Webkit & Blink performance suffers when deleting properties
								// from DOM nodes, so set to undefined instead
								// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
								if (owner.nodeType) {
									owner[this.expando] = undefined;
								} else {
									delete owner[this.expando];
								}
							}
						},
						hasData: function (owner) {
							var cache = owner[this.expando];
							return cache !== undefined && !jQuery.isEmptyObject(cache);
						}
					};
					var dataPriv = new Data();

					var dataUser = new Data();

					//	Implementation Summary
					//
					//	1. Enforce API surface and semantic compatibility with 1.9.x branch
					//	2. Improve the module's maintainability by reducing the storage
					//		paths to a single mechanism.
					//	3. Use the same single mechanism to support "private" and "user" data.
					//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
					//	5. Avoid exposing implementation details on user objects (eg. expando properties)
					//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

					var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
						rmultiDash = /[A-Z]/g;

					function getData(data) {
						if (data === 'true') {
							return true;
						}

						if (data === 'false') {
							return false;
						}

						if (data === 'null') {
							return null;
						}

						// Only convert to a number if it doesn't change the string
						if (data === +data + '') {
							return +data;
						}

						if (rbrace.test(data)) {
							return JSON.parse(data);
						}

						return data;
					}

					function dataAttr(elem, key, data) {
						var name;

						// If nothing was found internally, try to fetch any
						// data from the HTML5 data-* attribute
						if (data === undefined && elem.nodeType === 1) {
							name = 'data-' + key.replace(rmultiDash, '-$&').toLowerCase();
							data = elem.getAttribute(name);

							if (typeof data === 'string') {
								try {
									data = getData(data);
								} catch (e) {}

								// Make sure we set the data so it isn't changed later
								dataUser.set(elem, key, data);
							} else {
								data = undefined;
							}
						}
						return data;
					}

					jQuery.extend({
						hasData: function (elem) {
							return dataUser.hasData(elem) || dataPriv.hasData(elem);
						},

						data: function (elem, name, data) {
							return dataUser.access(elem, name, data);
						},

						removeData: function (elem, name) {
							dataUser.remove(elem, name);
						},

						// TODO: Now that all calls to _data and _removeData have been replaced
						// with direct calls to dataPriv methods, these can be deprecated.
						_data: function (elem, name, data) {
							return dataPriv.access(elem, name, data);
						},

						_removeData: function (elem, name) {
							dataPriv.remove(elem, name);
						}
					});

					jQuery.fn.extend({
						data: function (key, value) {
							var i,
								name,
								data,
								elem = this[0],
								attrs = elem && elem.attributes;

							// Gets all values
							if (key === undefined) {
								if (this.length) {
									data = dataUser.get(elem);

									if (elem.nodeType === 1 && !dataPriv.get(elem, 'hasDataAttrs')) {
										i = attrs.length;
										while (i--) {
											// Support: IE 11 only
											// The attrs elements can be null (#14894)
											if (attrs[i]) {
												name = attrs[i].name;
												if (name.indexOf('data-') === 0) {
													name = camelCase(name.slice(5));
													dataAttr(elem, name, data[name]);
												}
											}
										}
										dataPriv.set(elem, 'hasDataAttrs', true);
									}
								}

								return data;
							}

							// Sets multiple values
							if (typeof key === 'object') {
								return this.each(function () {
									dataUser.set(this, key);
								});
							}

							return access(
								this,
								function (value) {
									var data;

									// The calling jQuery object (element matches) is not empty
									// (and therefore has an element appears at this[ 0 ]) and the
									// `value` parameter was not undefined. An empty jQuery object
									// will result in `undefined` for elem = this[ 0 ] which will
									// throw an exception if an attempt to read a data cache is made.
									if (elem && value === undefined) {
										// Attempt to get data from the cache
										// The key will always be camelCased in Data
										data = dataUser.get(elem, key);
										if (data !== undefined) {
											return data;
										}

										// Attempt to "discover" the data in
										// HTML5 custom data-* attrs
										data = dataAttr(elem, key);
										if (data !== undefined) {
											return data;
										}

										// We tried really hard, but the data doesn't exist.
										return;
									}

									// Set the data...
									this.each(function () {
										// We always store the camelCased key
										dataUser.set(this, key, value);
									});
								},
								null,
								value,
								arguments.length > 1,
								null,
								true
							);
						},

						removeData: function (key) {
							return this.each(function () {
								dataUser.remove(this, key);
							});
						}
					});

					jQuery.extend({
						queue: function (elem, type, data) {
							var queue;

							if (elem) {
								type = (type || 'fx') + 'queue';
								queue = dataPriv.get(elem, type);

								// Speed up dequeue by getting out quickly if this is just a lookup
								if (data) {
									if (!queue || Array.isArray(data)) {
										queue = dataPriv.access(elem, type, jQuery.makeArray(data));
									} else {
										queue.push(data);
									}
								}
								return queue || [];
							}
						},

						dequeue: function (elem, type) {
							type = type || 'fx';

							var queue = jQuery.queue(elem, type),
								startLength = queue.length,
								fn = queue.shift(),
								hooks = jQuery._queueHooks(elem, type),
								next = function () {
									jQuery.dequeue(elem, type);
								};

							// If the fx queue is dequeued, always remove the progress sentinel
							if (fn === 'inprogress') {
								fn = queue.shift();
								startLength--;
							}

							if (fn) {
								// Add a progress sentinel to prevent the fx queue from being
								// automatically dequeued
								if (type === 'fx') {
									queue.unshift('inprogress');
								}

								// Clear up the last queue stop function
								delete hooks.stop;
								fn.call(elem, next, hooks);
							}

							if (!startLength && hooks) {
								hooks.empty.fire();
							}
						},

						// Not public - generate a queueHooks object, or return the current one
						_queueHooks: function (elem, type) {
							var key = type + 'queueHooks';
							return (
								dataPriv.get(elem, key) ||
								dataPriv.access(elem, key, {
									empty: jQuery.Callbacks('once memory').add(function () {
										dataPriv.remove(elem, [type + 'queue', key]);
									})
								})
							);
						}
					});

					jQuery.fn.extend({
						queue: function (type, data) {
							var setter = 2;

							if (typeof type !== 'string') {
								data = type;
								type = 'fx';
								setter--;
							}

							if (arguments.length < setter) {
								return jQuery.queue(this[0], type);
							}

							return data === undefined
								? this
								: this.each(function () {
										var queue = jQuery.queue(this, type, data);

										// Ensure a hooks for this queue
										jQuery._queueHooks(this, type);

										if (type === 'fx' && queue[0] !== 'inprogress') {
											jQuery.dequeue(this, type);
										}
								  });
						},
						dequeue: function (type) {
							return this.each(function () {
								jQuery.dequeue(this, type);
							});
						},
						clearQueue: function (type) {
							return this.queue(type || 'fx', []);
						},

						// Get a promise resolved when queues of a certain type
						// are emptied (fx is the type by default)
						promise: function (type, obj) {
							var tmp,
								count = 1,
								defer = jQuery.Deferred(),
								elements = this,
								i = this.length,
								resolve = function () {
									if (!--count) {
										defer.resolveWith(elements, [elements]);
									}
								};

							if (typeof type !== 'string') {
								obj = type;
								type = undefined;
							}
							type = type || 'fx';

							while (i--) {
								tmp = dataPriv.get(elements[i], type + 'queueHooks');
								if (tmp && tmp.empty) {
									count++;
									tmp.empty.add(resolve);
								}
							}
							resolve();
							return defer.promise(obj);
						}
					});
					var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;

					var rcssNum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i');

					var cssExpand = ['Top', 'Right', 'Bottom', 'Left'];

					var documentElement = document.documentElement;

					var isAttached = function (elem) {
							return jQuery.contains(elem.ownerDocument, elem);
						},
						composed = { composed: true };

					// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
					// Check attachment across shadow DOM boundaries when possible (gh-3504)
					// Support: iOS 10.0-10.2 only
					// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
					// leading to errors. We need to check for `getRootNode`.
					if (documentElement.getRootNode) {
						isAttached = function (elem) {
							return (
								jQuery.contains(elem.ownerDocument, elem) ||
								elem.getRootNode(composed) === elem.ownerDocument
							);
						};
					}
					var isHiddenWithinTree = function (elem, el) {
						// isHiddenWithinTree might be called from jQuery#filter function;
						// in that case, element will be second argument
						elem = el || elem;

						// Inline style trumps all
						return (
							elem.style.display === 'none' ||
							(elem.style.display === '' &&
								// Otherwise, check computed style
								// Support: Firefox <=43 - 45
								// Disconnected elements can have computed display: none, so first confirm that elem is
								// in the document.
								isAttached(elem) &&
								jQuery.css(elem, 'display') === 'none')
						);
					};

					function adjustCSS(elem, prop, valueParts, tween) {
						var adjusted,
							scale,
							maxIterations = 20,
							currentValue = tween
								? function () {
										return tween.cur();
								  }
								: function () {
										return jQuery.css(elem, prop, '');
								  },
							initial = currentValue(),
							unit = (valueParts && valueParts[3]) || (jQuery.cssNumber[prop] ? '' : 'px'),
							// Starting value computation is required for potential unit mismatches
							initialInUnit =
								elem.nodeType &&
								(jQuery.cssNumber[prop] || (unit !== 'px' && +initial)) &&
								rcssNum.exec(jQuery.css(elem, prop));

						if (initialInUnit && initialInUnit[3] !== unit) {
							// Support: Firefox <=54
							// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
							initial = initial / 2;

							// Trust units reported by jQuery.css
							unit = unit || initialInUnit[3];

							// Iteratively approximate from a nonzero starting point
							initialInUnit = +initial || 1;

							while (maxIterations--) {
								// Evaluate and update our best guess (doubling guesses that zero out).
								// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
								jQuery.style(elem, prop, initialInUnit + unit);
								if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
									maxIterations = 0;
								}
								initialInUnit = initialInUnit / scale;
							}

							initialInUnit = initialInUnit * 2;
							jQuery.style(elem, prop, initialInUnit + unit);

							// Make sure we update the tween properties later on
							valueParts = valueParts || [];
						}

						if (valueParts) {
							initialInUnit = +initialInUnit || +initial || 0;

							// Apply relative offset (+=/-=) if specified
							adjusted = valueParts[1]
								? initialInUnit + (valueParts[1] + 1) * valueParts[2]
								: +valueParts[2];
							if (tween) {
								tween.unit = unit;
								tween.start = initialInUnit;
								tween.end = adjusted;
							}
						}
						return adjusted;
					}

					var defaultDisplayMap = {};

					function getDefaultDisplay(elem) {
						var temp,
							doc = elem.ownerDocument,
							nodeName = elem.nodeName,
							display = defaultDisplayMap[nodeName];

						if (display) {
							return display;
						}

						temp = doc.body.appendChild(doc.createElement(nodeName));
						display = jQuery.css(temp, 'display');

						temp.parentNode.removeChild(temp);

						if (display === 'none') {
							display = 'block';
						}
						defaultDisplayMap[nodeName] = display;

						return display;
					}

					function showHide(elements, show) {
						var display,
							elem,
							values = [],
							index = 0,
							length = elements.length;

						// Determine new display value for elements that need to change
						for (; index < length; index++) {
							elem = elements[index];
							if (!elem.style) {
								continue;
							}

							display = elem.style.display;
							if (show) {
								// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
								// check is required in this first loop unless we have a nonempty display value (either
								// inline or about-to-be-restored)
								if (display === 'none') {
									values[index] = dataPriv.get(elem, 'display') || null;
									if (!values[index]) {
										elem.style.display = '';
									}
								}
								if (elem.style.display === '' && isHiddenWithinTree(elem)) {
									values[index] = getDefaultDisplay(elem);
								}
							} else {
								if (display !== 'none') {
									values[index] = 'none';

									// Remember what we're overwriting
									dataPriv.set(elem, 'display', display);
								}
							}
						}

						// Set the display of the elements in a second loop to avoid constant reflow
						for (index = 0; index < length; index++) {
							if (values[index] != null) {
								elements[index].style.display = values[index];
							}
						}

						return elements;
					}

					jQuery.fn.extend({
						show: function () {
							return showHide(this, true);
						},
						hide: function () {
							return showHide(this);
						},
						toggle: function (state) {
							if (typeof state === 'boolean') {
								return state ? this.show() : this.hide();
							}

							return this.each(function () {
								if (isHiddenWithinTree(this)) {
									jQuery(this).show();
								} else {
									jQuery(this).hide();
								}
							});
						}
					});
					var rcheckableType = /^(?:checkbox|radio)$/i;

					var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;

					var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;

					(function () {
						var fragment = document.createDocumentFragment(),
							div = fragment.appendChild(document.createElement('div')),
							input = document.createElement('input');

						// Support: Android 4.0 - 4.3 only
						// Check state lost if the name is set (#11217)
						// Support: Windows Web Apps (WWA)
						// `name` and `type` must use .setAttribute for WWA (#14901)
						input.setAttribute('type', 'radio');
						input.setAttribute('checked', 'checked');
						input.setAttribute('name', 't');

						div.appendChild(input);

						// Support: Android <=4.1 only
						// Older WebKit doesn't clone checked state correctly in fragments
						support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

						// Support: IE <=11 only
						// Make sure textarea (and checkbox) defaultValue is properly cloned
						div.innerHTML = '<textarea>x</textarea>';
						support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;

						// Support: IE <=9 only
						// IE <=9 replaces <option> tags with their contents when inserted outside of
						// the select element.
						div.innerHTML = '<option></option>';
						support.option = !!div.lastChild;
					})();

					// We have to close these tags to support XHTML (#13200)
					var wrapMap = {
						// XHTML parsers do not magically insert elements in the
						// same way that tag soup parsers do. So we cannot shorten
						// this by omitting <tbody> or other required elements.
						thead: [1, '<table>', '</table>'],
						col: [2, '<table><colgroup>', '</colgroup></table>'],
						tr: [2, '<table><tbody>', '</tbody></table>'],
						td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],

						_default: [0, '', '']
					};

					wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
					wrapMap.th = wrapMap.td;

					// Support: IE <=9 only
					if (!support.option) {
						wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", '</select>'];
					}

					function getAll(context, tag) {
						// Support: IE <=9 - 11 only
						// Use typeof to avoid zero-argument method invocation on host objects (#15151)
						var ret;

						if (typeof context.getElementsByTagName !== 'undefined') {
							ret = context.getElementsByTagName(tag || '*');
						} else if (typeof context.querySelectorAll !== 'undefined') {
							ret = context.querySelectorAll(tag || '*');
						} else {
							ret = [];
						}

						if (tag === undefined || (tag && nodeName(context, tag))) {
							return jQuery.merge([context], ret);
						}

						return ret;
					}

					// Mark scripts as having already been evaluated
					function setGlobalEval(elems, refElements) {
						var i = 0,
							l = elems.length;

						for (; i < l; i++) {
							dataPriv.set(
								elems[i],
								'globalEval',
								!refElements || dataPriv.get(refElements[i], 'globalEval')
							);
						}
					}

					var rhtml = /<|&#?\w+;/;

					function buildFragment(elems, context, scripts, selection, ignored) {
						var elem,
							tmp,
							tag,
							wrap,
							attached,
							j,
							fragment = context.createDocumentFragment(),
							nodes = [],
							i = 0,
							l = elems.length;

						for (; i < l; i++) {
							elem = elems[i];

							if (elem || elem === 0) {
								// Add nodes directly
								if (toType(elem) === 'object') {
									// Support: Android <=4.0 only, PhantomJS 1 only
									// push.apply(_, arraylike) throws on ancient WebKit
									jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

									// Convert non-html into a text node
								} else if (!rhtml.test(elem)) {
									nodes.push(context.createTextNode(elem));

									// Convert html into DOM nodes
								} else {
									tmp = tmp || fragment.appendChild(context.createElement('div'));

									// Deserialize a standard representation
									tag = (rtagName.exec(elem) || ['', ''])[1].toLowerCase();
									wrap = wrapMap[tag] || wrapMap._default;
									tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

									// Descend through wrappers to the right content
									j = wrap[0];
									while (j--) {
										tmp = tmp.lastChild;
									}

									// Support: Android <=4.0 only, PhantomJS 1 only
									// push.apply(_, arraylike) throws on ancient WebKit
									jQuery.merge(nodes, tmp.childNodes);

									// Remember the top-level container
									tmp = fragment.firstChild;

									// Ensure the created nodes are orphaned (#12392)
									tmp.textContent = '';
								}
							}
						}

						// Remove wrapper from fragment
						fragment.textContent = '';

						i = 0;
						while ((elem = nodes[i++])) {
							// Skip elements already in the context collection (trac-4087)
							if (selection && jQuery.inArray(elem, selection) > -1) {
								if (ignored) {
									ignored.push(elem);
								}
								continue;
							}

							attached = isAttached(elem);

							// Append to fragment
							tmp = getAll(fragment.appendChild(elem), 'script');

							// Preserve script evaluation history
							if (attached) {
								setGlobalEval(tmp);
							}

							// Capture executables
							if (scripts) {
								j = 0;
								while ((elem = tmp[j++])) {
									if (rscriptType.test(elem.type || '')) {
										scripts.push(elem);
									}
								}
							}
						}

						return fragment;
					}

					var rkeyEvent = /^key/,
						rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
						rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

					function returnTrue() {
						return true;
					}

					function returnFalse() {
						return false;
					}

					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous, except when they are no-op.
					// So expect focus to be synchronous when the element is already active,
					// and blur to be synchronous when the element is not already active.
					// (focus and blur are always synchronous in other supported browsers,
					// this just defines when we can count on it).
					function expectSync(elem, type) {
						return (elem === safeActiveElement()) === (type === 'focus');
					}

					// Support: IE <=9 only
					// Accessing document.activeElement can throw unexpectedly
					// https://bugs.jquery.com/ticket/13393
					function safeActiveElement() {
						try {
							return document.activeElement;
						} catch (err) {}
					}

					function on(elem, types, selector, data, fn, one) {
						var origFn, type;

						// Types can be a map of types/handlers
						if (typeof types === 'object') {
							// ( types-Object, selector, data )
							if (typeof selector !== 'string') {
								// ( types-Object, data )
								data = data || selector;
								selector = undefined;
							}
							for (type in types) {
								on(elem, type, selector, data, types[type], one);
							}
							return elem;
						}

						if (data == null && fn == null) {
							// ( types, fn )
							fn = selector;
							data = selector = undefined;
						} else if (fn == null) {
							if (typeof selector === 'string') {
								// ( types, selector, fn )
								fn = data;
								data = undefined;
							} else {
								// ( types, data, fn )
								fn = data;
								data = selector;
								selector = undefined;
							}
						}
						if (fn === false) {
							fn = returnFalse;
						} else if (!fn) {
							return elem;
						}

						if (one === 1) {
							origFn = fn;
							fn = function (event) {
								// Can use an empty set, since event contains the info
								jQuery().off(event);
								return origFn.apply(this, arguments);
							};

							// Use same guid so caller can remove using origFn
							fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
						}
						return elem.each(function () {
							jQuery.event.add(this, types, fn, data, selector);
						});
					}

					/*
					 * Helper functions for managing events -- not part of the public interface.
					 * Props to Dean Edwards' addEvent library for many of the ideas.
					 */
					jQuery.event = {
						global: {},

						add: function (elem, types, handler, data, selector) {
							var handleObjIn,
								eventHandle,
								tmp,
								events,
								t,
								handleObj,
								special,
								handlers,
								type,
								namespaces,
								origType,
								elemData = dataPriv.get(elem);

							// Only attach events to objects that accept data
							if (!acceptData(elem)) {
								return;
							}

							// Caller can pass in an object of custom data in lieu of the handler
							if (handler.handler) {
								handleObjIn = handler;
								handler = handleObjIn.handler;
								selector = handleObjIn.selector;
							}

							// Ensure that invalid selectors throw exceptions at attach time
							// Evaluate against documentElement in case elem is a non-element node (e.g., document)
							if (selector) {
								jQuery.find.matchesSelector(documentElement, selector);
							}

							// Make sure that the handler has a unique ID, used to find/remove it later
							if (!handler.guid) {
								handler.guid = jQuery.guid++;
							}

							// Init the element's event structure and main handler, if this is the first
							if (!(events = elemData.events)) {
								events = elemData.events = Object.create(null);
							}
							if (!(eventHandle = elemData.handle)) {
								eventHandle = elemData.handle = function (e) {
									// Discard the second event of a jQuery.event.trigger() and
									// when an event is called after a page has unloaded
									return typeof jQuery !== 'undefined' && jQuery.event.triggered !== e.type
										? jQuery.event.dispatch.apply(elem, arguments)
										: undefined;
								};
							}

							// Handle multiple events separated by a space
							types = (types || '').match(rnothtmlwhite) || [''];
							t = types.length;
							while (t--) {
								tmp = rtypenamespace.exec(types[t]) || [];
								type = origType = tmp[1];
								namespaces = (tmp[2] || '').split('.').sort();

								// There *must* be a type, no attaching namespace-only handlers
								if (!type) {
									continue;
								}

								// If event changes its type, use the special event handlers for the changed type
								special = jQuery.event.special[type] || {};

								// If selector defined, determine special event api type, otherwise given type
								type = (selector ? special.delegateType : special.bindType) || type;

								// Update special based on newly reset type
								special = jQuery.event.special[type] || {};

								// handleObj is passed to all event handlers
								handleObj = jQuery.extend(
									{
										type: type,
										origType: origType,
										data: data,
										handler: handler,
										guid: handler.guid,
										selector: selector,
										needsContext: selector && jQuery.expr.match.needsContext.test(selector),
										namespace: namespaces.join('.')
									},
									handleObjIn
								);

								// Init the event handler queue if we're the first
								if (!(handlers = events[type])) {
									handlers = events[type] = [];
									handlers.delegateCount = 0;

									// Only use addEventListener if the special events handler returns false
									if (
										!special.setup ||
										special.setup.call(elem, data, namespaces, eventHandle) === false
									) {
										if (elem.addEventListener) {
											elem.addEventListener(type, eventHandle);
										}
									}
								}

								if (special.add) {
									special.add.call(elem, handleObj);

									if (!handleObj.handler.guid) {
										handleObj.handler.guid = handler.guid;
									}
								}

								// Add to the element's handler list, delegates in front
								if (selector) {
									handlers.splice(handlers.delegateCount++, 0, handleObj);
								} else {
									handlers.push(handleObj);
								}

								// Keep track of which events have ever been used, for event optimization
								jQuery.event.global[type] = true;
							}
						},

						// Detach an event or set of events from an element
						remove: function (elem, types, handler, selector, mappedTypes) {
							var j,
								origCount,
								tmp,
								events,
								t,
								handleObj,
								special,
								handlers,
								type,
								namespaces,
								origType,
								elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

							if (!elemData || !(events = elemData.events)) {
								return;
							}

							// Once for each type.namespace in types; type may be omitted
							types = (types || '').match(rnothtmlwhite) || [''];
							t = types.length;
							while (t--) {
								tmp = rtypenamespace.exec(types[t]) || [];
								type = origType = tmp[1];
								namespaces = (tmp[2] || '').split('.').sort();

								// Unbind all events (on this namespace, if provided) for the element
								if (!type) {
									for (type in events) {
										jQuery.event.remove(elem, type + types[t], handler, selector, true);
									}
									continue;
								}

								special = jQuery.event.special[type] || {};
								type = (selector ? special.delegateType : special.bindType) || type;
								handlers = events[type] || [];
								tmp =
									tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');

								// Remove matching events
								origCount = j = handlers.length;
								while (j--) {
									handleObj = handlers[j];

									if (
										(mappedTypes || origType === handleObj.origType) &&
										(!handler || handler.guid === handleObj.guid) &&
										(!tmp || tmp.test(handleObj.namespace)) &&
										(!selector ||
											selector === handleObj.selector ||
											(selector === '**' && handleObj.selector))
									) {
										handlers.splice(j, 1);

										if (handleObj.selector) {
											handlers.delegateCount--;
										}
										if (special.remove) {
											special.remove.call(elem, handleObj);
										}
									}
								}

								// Remove generic event handler if we removed something and no more handlers exist
								// (avoids potential for endless recursion during removal of special event handlers)
								if (origCount && !handlers.length) {
									if (
										!special.teardown ||
										special.teardown.call(elem, namespaces, elemData.handle) === false
									) {
										jQuery.removeEvent(elem, type, elemData.handle);
									}

									delete events[type];
								}
							}

							// Remove data and the expando if it's no longer used
							if (jQuery.isEmptyObject(events)) {
								dataPriv.remove(elem, 'handle events');
							}
						},

						dispatch: function (nativeEvent) {
							var i,
								j,
								ret,
								matched,
								handleObj,
								handlerQueue,
								args = new Array(arguments.length),
								// Make a writable jQuery.Event from the native event object
								event = jQuery.event.fix(nativeEvent),
								handlers = (dataPriv.get(this, 'events') || Object.create(null))[event.type] || [],
								special = jQuery.event.special[event.type] || {};

							// Use the fix-ed jQuery.Event rather than the (read-only) native event
							args[0] = event;

							for (i = 1; i < arguments.length; i++) {
								args[i] = arguments[i];
							}

							event.delegateTarget = this;

							// Call the preDispatch hook for the mapped type, and let it bail if desired
							if (special.preDispatch && special.preDispatch.call(this, event) === false) {
								return;
							}

							// Determine handlers
							handlerQueue = jQuery.event.handlers.call(this, event, handlers);

							// Run delegates first; they may want to stop propagation beneath us
							i = 0;
							while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
								event.currentTarget = matched.elem;

								j = 0;
								while (
									(handleObj = matched.handlers[j++]) &&
									!event.isImmediatePropagationStopped()
								) {
									// If the event is namespaced, then each handler is only invoked if it is
									// specially universal or its namespaces are a superset of the event's.
									if (
										!event.rnamespace ||
										handleObj.namespace === false ||
										event.rnamespace.test(handleObj.namespace)
									) {
										event.handleObj = handleObj;
										event.data = handleObj.data;

										ret = (
											(jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler
										).apply(matched.elem, args);

										if (ret !== undefined) {
											if ((event.result = ret) === false) {
												event.preventDefault();
												event.stopPropagation();
											}
										}
									}
								}
							}

							// Call the postDispatch hook for the mapped type
							if (special.postDispatch) {
								special.postDispatch.call(this, event);
							}

							return event.result;
						},

						handlers: function (event, handlers) {
							var i,
								handleObj,
								sel,
								matchedHandlers,
								matchedSelectors,
								handlerQueue = [],
								delegateCount = handlers.delegateCount,
								cur = event.target;

							// Find delegate handlers
							if (
								delegateCount &&
								// Support: IE <=9
								// Black-hole SVG <use> instance trees (trac-13180)
								cur.nodeType &&
								// Support: Firefox <=42
								// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
								// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
								// Support: IE 11 only
								// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
								!(event.type === 'click' && event.button >= 1)
							) {
								for (; cur !== this; cur = cur.parentNode || this) {
									// Don't check non-elements (#13208)
									// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
									if (cur.nodeType === 1 && !(event.type === 'click' && cur.disabled === true)) {
										matchedHandlers = [];
										matchedSelectors = {};
										for (i = 0; i < delegateCount; i++) {
											handleObj = handlers[i];

											// Don't conflict with Object.prototype properties (#13203)
											sel = handleObj.selector + ' ';

											if (matchedSelectors[sel] === undefined) {
												matchedSelectors[sel] = handleObj.needsContext
													? jQuery(sel, this).index(cur) > -1
													: jQuery.find(sel, this, null, [cur]).length;
											}
											if (matchedSelectors[sel]) {
												matchedHandlers.push(handleObj);
											}
										}
										if (matchedHandlers.length) {
											handlerQueue.push({ elem: cur, handlers: matchedHandlers });
										}
									}
								}
							}

							// Add the remaining (directly-bound) handlers
							cur = this;
							if (delegateCount < handlers.length) {
								handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
							}

							return handlerQueue;
						},

						addProp: function (name, hook) {
							Object.defineProperty(jQuery.Event.prototype, name, {
								enumerable: true,
								configurable: true,

								get: isFunction(hook)
									? function () {
											if (this.originalEvent) {
												return hook(this.originalEvent);
											}
									  }
									: function () {
											if (this.originalEvent) {
												return this.originalEvent[name];
											}
									  },

								set: function (value) {
									Object.defineProperty(this, name, {
										enumerable: true,
										configurable: true,
										writable: true,
										value: value
									});
								}
							});
						},

						fix: function (originalEvent) {
							return originalEvent[jQuery.expando]
								? originalEvent
								: new jQuery.Event(originalEvent);
						},

						special: {
							load: {
								// Prevent triggered image.load events from bubbling to window.load
								noBubble: true
							},
							click: {
								// Utilize native event to ensure correct state for checkable inputs
								setup: function (data) {
									// For mutual compressibility with _default, replace `this` access with a local var.
									// `|| data` is dead code meant only to preserve the variable through minification.
									var el = this || data;

									// Claim the first handler
									if (rcheckableType.test(el.type) && el.click && nodeName(el, 'input')) {
										// dataPriv.set( el, "click", ... )
										leverageNative(el, 'click', returnTrue);
									}

									// Return false to allow normal processing in the caller
									return false;
								},
								trigger: function (data) {
									// For mutual compressibility with _default, replace `this` access with a local var.
									// `|| data` is dead code meant only to preserve the variable through minification.
									var el = this || data;

									// Force setup before triggering a click
									if (rcheckableType.test(el.type) && el.click && nodeName(el, 'input')) {
										leverageNative(el, 'click');
									}

									// Return non-false to allow normal event-path propagation
									return true;
								},

								// For cross-browser consistency, suppress native .click() on links
								// Also prevent it if we're currently inside a leveraged native-event stack
								_default: function (event) {
									var target = event.target;
									return (
										(rcheckableType.test(target.type) &&
											target.click &&
											nodeName(target, 'input') &&
											dataPriv.get(target, 'click')) ||
										nodeName(target, 'a')
									);
								}
							},

							beforeunload: {
								postDispatch: function (event) {
									// Support: Firefox 20+
									// Firefox doesn't alert if the returnValue field is not set.
									if (event.result !== undefined && event.originalEvent) {
										event.originalEvent.returnValue = event.result;
									}
								}
							}
						}
					};

					// Ensure the presence of an event listener that handles manually-triggered
					// synthetic events by interrupting progress until reinvoked in response to
					// *native* events that it fires directly, ensuring that state changes have
					// already occurred before other listeners are invoked.
					function leverageNative(el, type, expectSync) {
						// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
						if (!expectSync) {
							if (dataPriv.get(el, type) === undefined) {
								jQuery.event.add(el, type, returnTrue);
							}
							return;
						}

						// Register the controller as a special universal handler for all event namespaces
						dataPriv.set(el, type, false);
						jQuery.event.add(el, type, {
							namespace: false,
							handler: function (event) {
								var notAsync,
									result,
									saved = dataPriv.get(this, type);

								if (event.isTrigger & 1 && this[type]) {
									// Interrupt processing of the outer synthetic .trigger()ed event
									// Saved data should be false in such cases, but might be a leftover capture object
									// from an async native handler (gh-4350)
									if (!saved.length) {
										// Store arguments for use when handling the inner native event
										// There will always be at least one argument (an event object), so this array
										// will not be confused with a leftover capture object.
										saved = slice.call(arguments);
										dataPriv.set(this, type, saved);

										// Trigger the native event and capture its result
										// Support: IE <=9 - 11+
										// focus() and blur() are asynchronous
										notAsync = expectSync(this, type);
										this[type]();
										result = dataPriv.get(this, type);
										if (saved !== result || notAsync) {
											dataPriv.set(this, type, false);
										} else {
											result = {};
										}
										if (saved !== result) {
											// Cancel the outer synthetic event
											event.stopImmediatePropagation();
											event.preventDefault();
											return result.value;
										}

										// If this is an inner synthetic event for an event with a bubbling surrogate
										// (focus or blur), assume that the surrogate already propagated from triggering the
										// native event and prevent that from happening again here.
										// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
										// bubbling surrogate propagates *after* the non-bubbling base), but that seems
										// less bad than duplication.
									} else if ((jQuery.event.special[type] || {}).delegateType) {
										event.stopPropagation();
									}

									// If this is a native event triggered above, everything is now in order
									// Fire an inner synthetic event with the original arguments
								} else if (saved.length) {
									// ...and capture the result
									dataPriv.set(this, type, {
										value: jQuery.event.trigger(
											// Support: IE <=9 - 11+
											// Extend with the prototype to reset the above stopImmediatePropagation()
											jQuery.extend(saved[0], jQuery.Event.prototype),
											saved.slice(1),
											this
										)
									});

									// Abort handling of the native event
									event.stopImmediatePropagation();
								}
							}
						});
					}

					jQuery.removeEvent = function (elem, type, handle) {
						// This "if" is needed for plain objects
						if (elem.removeEventListener) {
							elem.removeEventListener(type, handle);
						}
					};

					jQuery.Event = function (src, props) {
						// Allow instantiation without the 'new' keyword
						if (!(this instanceof jQuery.Event)) {
							return new jQuery.Event(src, props);
						}

						// Event object
						if (src && src.type) {
							this.originalEvent = src;
							this.type = src.type;

							// Events bubbling up the document may have been marked as prevented
							// by a handler lower down the tree; reflect the correct value.
							this.isDefaultPrevented =
								src.defaultPrevented ||
								(src.defaultPrevented === undefined &&
									// Support: Android <=2.3 only
									src.returnValue === false)
									? returnTrue
									: returnFalse;

							// Create target properties
							// Support: Safari <=6 - 7 only
							// Target should not be a text node (#504, #13143)
							this.target =
								src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;

							this.currentTarget = src.currentTarget;
							this.relatedTarget = src.relatedTarget;

							// Event type
						} else {
							this.type = src;
						}

						// Put explicitly provided properties onto the event object
						if (props) {
							jQuery.extend(this, props);
						}

						// Create a timestamp if incoming event doesn't have one
						this.timeStamp = (src && src.timeStamp) || Date.now();

						// Mark it as fixed
						this[jQuery.expando] = true;
					};

					// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
					// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
					jQuery.Event.prototype = {
						constructor: jQuery.Event,
						isDefaultPrevented: returnFalse,
						isPropagationStopped: returnFalse,
						isImmediatePropagationStopped: returnFalse,
						isSimulated: false,

						preventDefault: function () {
							var e = this.originalEvent;

							this.isDefaultPrevented = returnTrue;

							if (e && !this.isSimulated) {
								e.preventDefault();
							}
						},
						stopPropagation: function () {
							var e = this.originalEvent;

							this.isPropagationStopped = returnTrue;

							if (e && !this.isSimulated) {
								e.stopPropagation();
							}
						},
						stopImmediatePropagation: function () {
							var e = this.originalEvent;

							this.isImmediatePropagationStopped = returnTrue;

							if (e && !this.isSimulated) {
								e.stopImmediatePropagation();
							}

							this.stopPropagation();
						}
					};

					// Includes all common event props including KeyEvent and MouseEvent specific props
					jQuery.each(
						{
							altKey: true,
							bubbles: true,
							cancelable: true,
							changedTouches: true,
							ctrlKey: true,
							detail: true,
							eventPhase: true,
							metaKey: true,
							pageX: true,
							pageY: true,
							shiftKey: true,
							view: true,
							char: true,
							code: true,
							charCode: true,
							key: true,
							keyCode: true,
							button: true,
							buttons: true,
							clientX: true,
							clientY: true,
							offsetX: true,
							offsetY: true,
							pointerId: true,
							pointerType: true,
							screenX: true,
							screenY: true,
							targetTouches: true,
							toElement: true,
							touches: true,

							which: function (event) {
								var button = event.button;

								// Add which for key events
								if (event.which == null && rkeyEvent.test(event.type)) {
									return event.charCode != null ? event.charCode : event.keyCode;
								}

								// Add which for click: 1 === left; 2 === middle; 3 === right
								if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
									if (button & 1) {
										return 1;
									}

									if (button & 2) {
										return 3;
									}

									if (button & 4) {
										return 2;
									}

									return 0;
								}

								return event.which;
							}
						},
						jQuery.event.addProp
					);

					jQuery.each({ focus: 'focusin', blur: 'focusout' }, function (type, delegateType) {
						jQuery.event.special[type] = {
							// Utilize native event if possible so blur/focus sequence is correct
							setup: function () {
								// Claim the first handler
								// dataPriv.set( this, "focus", ... )
								// dataPriv.set( this, "blur", ... )
								leverageNative(this, type, expectSync);

								// Return false to allow normal processing in the caller
								return false;
							},
							trigger: function () {
								// Force setup before trigger
								leverageNative(this, type);

								// Return non-false to allow normal event-path propagation
								return true;
							},

							delegateType: delegateType
						};
					});

					// Create mouseenter/leave events using mouseover/out and event-time checks
					// so that event delegation works in jQuery.
					// Do the same for pointerenter/pointerleave and pointerover/pointerout
					//
					// Support: Safari 7 only
					// Safari sends mouseenter too often; see:
					// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
					// for the description of the bug (it existed in older Chrome versions as well).
					jQuery.each(
						{
							mouseenter: 'mouseover',
							mouseleave: 'mouseout',
							pointerenter: 'pointerover',
							pointerleave: 'pointerout'
						},
						function (orig, fix) {
							jQuery.event.special[orig] = {
								delegateType: fix,
								bindType: fix,

								handle: function (event) {
									var ret,
										target = this,
										related = event.relatedTarget,
										handleObj = event.handleObj;

									// For mouseenter/leave call the handler if related is outside the target.
									// NB: No relatedTarget if the mouse left/entered the browser window
									if (!related || (related !== target && !jQuery.contains(target, related))) {
										event.type = handleObj.origType;
										ret = handleObj.handler.apply(this, arguments);
										event.type = fix;
									}
									return ret;
								}
							};
						}
					);

					jQuery.fn.extend({
						on: function (types, selector, data, fn) {
							return on(this, types, selector, data, fn);
						},
						one: function (types, selector, data, fn) {
							return on(this, types, selector, data, fn, 1);
						},
						off: function (types, selector, fn) {
							var handleObj, type;
							if (types && types.preventDefault && types.handleObj) {
								// ( event )  dispatched jQuery.Event
								handleObj = types.handleObj;
								jQuery(types.delegateTarget).off(
									handleObj.namespace
										? handleObj.origType + '.' + handleObj.namespace
										: handleObj.origType,
									handleObj.selector,
									handleObj.handler
								);
								return this;
							}
							if (typeof types === 'object') {
								// ( types-object [, selector] )
								for (type in types) {
									this.off(type, selector, types[type]);
								}
								return this;
							}
							if (selector === false || typeof selector === 'function') {
								// ( types [, fn] )
								fn = selector;
								selector = undefined;
							}
							if (fn === false) {
								fn = returnFalse;
							}
							return this.each(function () {
								jQuery.event.remove(this, types, fn, selector);
							});
						}
					});

					var // Support: IE <=10 - 11, Edge 12 - 13 only
						// In IE/Edge using regex groups here causes severe slowdowns.
						// See https://connect.microsoft.com/IE/feedback/details/1736512/
						rnoInnerhtml = /<script|<style|<link/i,
						// checked="checked" or checked
						rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
						rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

					// Prefer a tbody over its parent table for containing new rows
					function manipulationTarget(elem, content) {
						if (
							nodeName(elem, 'table') &&
							nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr')
						) {
							return jQuery(elem).children('tbody')[0] || elem;
						}

						return elem;
					}

					// Replace/restore the type attribute of script elements for safe DOM manipulation
					function disableScript(elem) {
						elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type;
						return elem;
					}
					function restoreScript(elem) {
						if ((elem.type || '').slice(0, 5) === 'true/') {
							elem.type = elem.type.slice(5);
						} else {
							elem.removeAttribute('type');
						}

						return elem;
					}

					function cloneCopyEvent(src, dest) {
						var i, l, type, pdataOld, udataOld, udataCur, events;

						if (dest.nodeType !== 1) {
							return;
						}

						// 1. Copy private data: events, handlers, etc.
						if (dataPriv.hasData(src)) {
							pdataOld = dataPriv.get(src);
							events = pdataOld.events;

							if (events) {
								dataPriv.remove(dest, 'handle events');

								for (type in events) {
									for (i = 0, l = events[type].length; i < l; i++) {
										jQuery.event.add(dest, type, events[type][i]);
									}
								}
							}
						}

						// 2. Copy user data
						if (dataUser.hasData(src)) {
							udataOld = dataUser.access(src);
							udataCur = jQuery.extend({}, udataOld);

							dataUser.set(dest, udataCur);
						}
					}

					// Fix IE bugs, see support tests
					function fixInput(src, dest) {
						var nodeName = dest.nodeName.toLowerCase();

						// Fails to persist the checked state of a cloned checkbox or radio button.
						if (nodeName === 'input' && rcheckableType.test(src.type)) {
							dest.checked = src.checked;

							// Fails to return the selected option to the default selected state when cloning options
						} else if (nodeName === 'input' || nodeName === 'textarea') {
							dest.defaultValue = src.defaultValue;
						}
					}

					function domManip(collection, args, callback, ignored) {
						// Flatten any nested arrays
						args = flat(args);

						var fragment,
							first,
							scripts,
							hasScripts,
							node,
							doc,
							i = 0,
							l = collection.length,
							iNoClone = l - 1,
							value = args[0],
							valueIsFunction = isFunction(value);

						// We can't cloneNode fragments that contain checked, in WebKit
						if (
							valueIsFunction ||
							(l > 1 && typeof value === 'string' && !support.checkClone && rchecked.test(value))
						) {
							return collection.each(function (index) {
								var self = collection.eq(index);
								if (valueIsFunction) {
									args[0] = value.call(this, index, self.html());
								}
								domManip(self, args, callback, ignored);
							});
						}

						if (l) {
							fragment = buildFragment(
								args,
								collection[0].ownerDocument,
								false,
								collection,
								ignored
							);
							first = fragment.firstChild;

							if (fragment.childNodes.length === 1) {
								fragment = first;
							}

							// Require either new content or an interest in ignored elements to invoke the callback
							if (first || ignored) {
								scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
								hasScripts = scripts.length;

								// Use the original fragment for the last item
								// instead of the first because it can end up
								// being emptied incorrectly in certain situations (#8070).
								for (; i < l; i++) {
									node = fragment;

									if (i !== iNoClone) {
										node = jQuery.clone(node, true, true);

										// Keep references to cloned scripts for later restoration
										if (hasScripts) {
											// Support: Android <=4.0 only, PhantomJS 1 only
											// push.apply(_, arraylike) throws on ancient WebKit
											jQuery.merge(scripts, getAll(node, 'script'));
										}
									}

									callback.call(collection[i], node, i);
								}

								if (hasScripts) {
									doc = scripts[scripts.length - 1].ownerDocument;

									// Reenable scripts
									jQuery.map(scripts, restoreScript);

									// Evaluate executable scripts on first document insertion
									for (i = 0; i < hasScripts; i++) {
										node = scripts[i];
										if (
											rscriptType.test(node.type || '') &&
											!dataPriv.access(node, 'globalEval') &&
											jQuery.contains(doc, node)
										) {
											if (node.src && (node.type || '').toLowerCase() !== 'module') {
												// Optional AJAX dependency, but won't run scripts if not present
												if (jQuery._evalUrl && !node.noModule) {
													jQuery._evalUrl(
														node.src,
														{
															nonce: node.nonce || node.getAttribute('nonce')
														},
														doc
													);
												}
											} else {
												DOMEval(node.textContent.replace(rcleanScript, ''), node, doc);
											}
										}
									}
								}
							}
						}

						return collection;
					}

					function remove(elem, selector, keepData) {
						var node,
							nodes = selector ? jQuery.filter(selector, elem) : elem,
							i = 0;

						for (; (node = nodes[i]) != null; i++) {
							if (!keepData && node.nodeType === 1) {
								jQuery.cleanData(getAll(node));
							}

							if (node.parentNode) {
								if (keepData && isAttached(node)) {
									setGlobalEval(getAll(node, 'script'));
								}
								node.parentNode.removeChild(node);
							}
						}

						return elem;
					}

					jQuery.extend({
						htmlPrefilter: function (html) {
							return html;
						},

						clone: function (elem, dataAndEvents, deepDataAndEvents) {
							var i,
								l,
								srcElements,
								destElements,
								clone = elem.cloneNode(true),
								inPage = isAttached(elem);

							// Fix IE cloning issues
							if (
								!support.noCloneChecked &&
								(elem.nodeType === 1 || elem.nodeType === 11) &&
								!jQuery.isXMLDoc(elem)
							) {
								// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
								destElements = getAll(clone);
								srcElements = getAll(elem);

								for (i = 0, l = srcElements.length; i < l; i++) {
									fixInput(srcElements[i], destElements[i]);
								}
							}

							// Copy the events from the original to the clone
							if (dataAndEvents) {
								if (deepDataAndEvents) {
									srcElements = srcElements || getAll(elem);
									destElements = destElements || getAll(clone);

									for (i = 0, l = srcElements.length; i < l; i++) {
										cloneCopyEvent(srcElements[i], destElements[i]);
									}
								} else {
									cloneCopyEvent(elem, clone);
								}
							}

							// Preserve script evaluation history
							destElements = getAll(clone, 'script');
							if (destElements.length > 0) {
								setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
							}

							// Return the cloned set
							return clone;
						},

						cleanData: function (elems) {
							var data,
								elem,
								type,
								special = jQuery.event.special,
								i = 0;

							for (; (elem = elems[i]) !== undefined; i++) {
								if (acceptData(elem)) {
									if ((data = elem[dataPriv.expando])) {
										if (data.events) {
											for (type in data.events) {
												if (special[type]) {
													jQuery.event.remove(elem, type);

													// This is a shortcut to avoid jQuery.event.remove's overhead
												} else {
													jQuery.removeEvent(elem, type, data.handle);
												}
											}
										}

										// Support: Chrome <=35 - 45+
										// Assign undefined instead of using delete, see Data#remove
										elem[dataPriv.expando] = undefined;
									}
									if (elem[dataUser.expando]) {
										// Support: Chrome <=35 - 45+
										// Assign undefined instead of using delete, see Data#remove
										elem[dataUser.expando] = undefined;
									}
								}
							}
						}
					});

					jQuery.fn.extend({
						detach: function (selector) {
							return remove(this, selector, true);
						},

						remove: function (selector) {
							return remove(this, selector);
						},

						text: function (value) {
							return access(
								this,
								function (value) {
									return value === undefined
										? jQuery.text(this)
										: this.empty().each(function () {
												if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
													this.textContent = value;
												}
										  });
								},
								null,
								value,
								arguments.length
							);
						},

						append: function () {
							return domManip(this, arguments, function (elem) {
								if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
									var target = manipulationTarget(this, elem);
									target.appendChild(elem);
								}
							});
						},

						prepend: function () {
							return domManip(this, arguments, function (elem) {
								if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
									var target = manipulationTarget(this, elem);
									target.insertBefore(elem, target.firstChild);
								}
							});
						},

						before: function () {
							return domManip(this, arguments, function (elem) {
								if (this.parentNode) {
									this.parentNode.insertBefore(elem, this);
								}
							});
						},

						after: function () {
							return domManip(this, arguments, function (elem) {
								if (this.parentNode) {
									this.parentNode.insertBefore(elem, this.nextSibling);
								}
							});
						},

						empty: function () {
							var elem,
								i = 0;

							for (; (elem = this[i]) != null; i++) {
								if (elem.nodeType === 1) {
									// Prevent memory leaks
									jQuery.cleanData(getAll(elem, false));

									// Remove any remaining nodes
									elem.textContent = '';
								}
							}

							return this;
						},

						clone: function (dataAndEvents, deepDataAndEvents) {
							dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
							deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

							return this.map(function () {
								return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
							});
						},

						html: function (value) {
							return access(
								this,
								function (value) {
									var elem = this[0] || {},
										i = 0,
										l = this.length;

									if (value === undefined && elem.nodeType === 1) {
										return elem.innerHTML;
									}

									// See if we can take a shortcut and just use innerHTML
									if (
										typeof value === 'string' &&
										!rnoInnerhtml.test(value) &&
										!wrapMap[(rtagName.exec(value) || ['', ''])[1].toLowerCase()]
									) {
										value = jQuery.htmlPrefilter(value);

										try {
											for (; i < l; i++) {
												elem = this[i] || {};

												// Remove element nodes and prevent memory leaks
												if (elem.nodeType === 1) {
													jQuery.cleanData(getAll(elem, false));
													elem.innerHTML = value;
												}
											}

											elem = 0;

											// If using innerHTML throws an exception, use the fallback method
										} catch (e) {}
									}

									if (elem) {
										this.empty().append(value);
									}
								},
								null,
								value,
								arguments.length
							);
						},

						replaceWith: function () {
							var ignored = [];

							// Make the changes, replacing each non-ignored context element with the new content
							return domManip(
								this,
								arguments,
								function (elem) {
									var parent = this.parentNode;

									if (jQuery.inArray(this, ignored) < 0) {
										jQuery.cleanData(getAll(this));
										if (parent) {
											parent.replaceChild(elem, this);
										}
									}

									// Force callback invocation
								},
								ignored
							);
						}
					});

					jQuery.each(
						{
							appendTo: 'append',
							prependTo: 'prepend',
							insertBefore: 'before',
							insertAfter: 'after',
							replaceAll: 'replaceWith'
						},
						function (name, original) {
							jQuery.fn[name] = function (selector) {
								var elems,
									ret = [],
									insert = jQuery(selector),
									last = insert.length - 1,
									i = 0;

								for (; i <= last; i++) {
									elems = i === last ? this : this.clone(true);
									jQuery(insert[i])[original](elems);

									// Support: Android <=4.0 only, PhantomJS 1 only
									// .get() because push.apply(_, arraylike) throws on ancient WebKit
									push.apply(ret, elems.get());
								}

								return this.pushStack(ret);
							};
						}
					);
					var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i');

					var getStyles = function (elem) {
						// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
						// IE throws on elements created in popups
						// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
						var view = elem.ownerDocument.defaultView;

						if (!view || !view.opener) {
							view = window;
						}

						return view.getComputedStyle(elem);
					};

					var swap = function (elem, options, callback) {
						var ret,
							name,
							old = {};

						// Remember the old values, and insert the new ones
						for (name in options) {
							old[name] = elem.style[name];
							elem.style[name] = options[name];
						}

						ret = callback.call(elem);

						// Revert the old values
						for (name in options) {
							elem.style[name] = old[name];
						}

						return ret;
					};

					var rboxStyle = new RegExp(cssExpand.join('|'), 'i');

					(function () {
						// Executing both pixelPosition & boxSizingReliable tests require only one layout
						// so they're executed at the same time to save the second computation.
						function computeStyleTests() {
							// This is a singleton, we need to execute it only once
							if (!div) {
								return;
							}

							container.style.cssText =
								'position:absolute;left:-11111px;width:60px;' + 'margin-top:1px;padding:0;border:0';
							div.style.cssText =
								'position:relative;display:block;box-sizing:border-box;overflow:scroll;' +
								'margin:auto;border:1px;padding:1px;' +
								'width:60%;top:1%';
							documentElement.appendChild(container).appendChild(div);

							var divStyle = window.getComputedStyle(div);
							pixelPositionVal = divStyle.top !== '1%';

							// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
							reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;

							// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
							// Some styles come back with percentage values, even though they shouldn't
							div.style.right = '60%';
							pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;

							// Support: IE 9 - 11 only
							// Detect misreporting of content dimensions for box-sizing:border-box elements
							boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;

							// Support: IE 9 only
							// Detect overflow:scroll screwiness (gh-3699)
							// Support: Chrome <=64
							// Don't get tricked when zoom affects offsetWidth (gh-4029)
							div.style.position = 'absolute';
							scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;

							documentElement.removeChild(container);

							// Nullify the div so it wouldn't be stored in the memory and
							// it will also be a sign that checks already performed
							div = null;
						}

						function roundPixelMeasures(measure) {
							return Math.round(parseFloat(measure));
						}

						var pixelPositionVal,
							boxSizingReliableVal,
							scrollboxSizeVal,
							pixelBoxStylesVal,
							reliableTrDimensionsVal,
							reliableMarginLeftVal,
							container = document.createElement('div'),
							div = document.createElement('div');

						// Finish early in limited (non-browser) environments
						if (!div.style) {
							return;
						}

						// Support: IE <=9 - 11 only
						// Style of cloned element affects source element cloned (#8908)
						div.style.backgroundClip = 'content-box';
						div.cloneNode(true).style.backgroundClip = '';
						support.clearCloneStyle = div.style.backgroundClip === 'content-box';

						jQuery.extend(support, {
							boxSizingReliable: function () {
								computeStyleTests();
								return boxSizingReliableVal;
							},
							pixelBoxStyles: function () {
								computeStyleTests();
								return pixelBoxStylesVal;
							},
							pixelPosition: function () {
								computeStyleTests();
								return pixelPositionVal;
							},
							reliableMarginLeft: function () {
								computeStyleTests();
								return reliableMarginLeftVal;
							},
							scrollboxSize: function () {
								computeStyleTests();
								return scrollboxSizeVal;
							},

							// Support: IE 9 - 11+, Edge 15 - 18+
							// IE/Edge misreport `getComputedStyle` of table rows with width/height
							// set in CSS while `offset*` properties report correct values.
							// Behavior in IE 9 is more subtle than in newer versions & it passes
							// some versions of this test; make sure not to make it pass there!
							reliableTrDimensions: function () {
								var table, tr, trChild, trStyle;
								if (reliableTrDimensionsVal == null) {
									table = document.createElement('table');
									tr = document.createElement('tr');
									trChild = document.createElement('div');

									table.style.cssText = 'position:absolute;left:-11111px';
									tr.style.height = '1px';
									trChild.style.height = '9px';

									documentElement.appendChild(table).appendChild(tr).appendChild(trChild);

									trStyle = window.getComputedStyle(tr);
									reliableTrDimensionsVal = parseInt(trStyle.height) > 3;

									documentElement.removeChild(table);
								}
								return reliableTrDimensionsVal;
							}
						});
					})();

					function curCSS(elem, name, computed) {
						var width,
							minWidth,
							maxWidth,
							ret,
							// Support: Firefox 51+
							// Retrieving style before computed somehow
							// fixes an issue with getting wrong values
							// on detached elements
							style = elem.style;

						computed = computed || getStyles(elem);

						// getPropertyValue is needed for:
						//   .css('filter') (IE 9 only, #12537)
						//   .css('--customProperty) (#3144)
						if (computed) {
							ret = computed.getPropertyValue(name) || computed[name];

							if (ret === '' && !isAttached(elem)) {
								ret = jQuery.style(elem, name);
							}

							// A tribute to the "awesome hack by Dean Edwards"
							// Android Browser returns percentage for some values,
							// but width seems to be reliably pixels.
							// This is against the CSSOM draft spec:
							// https://drafts.csswg.org/cssom/#resolved-values
							if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
								// Remember the original values
								width = style.width;
								minWidth = style.minWidth;
								maxWidth = style.maxWidth;

								// Put in the new values to get a computed value out
								style.minWidth = style.maxWidth = style.width = ret;
								ret = computed.width;

								// Revert the changed values
								style.width = width;
								style.minWidth = minWidth;
								style.maxWidth = maxWidth;
							}
						}

						return ret !== undefined
							? // Support: IE <=9 - 11 only
							  // IE returns zIndex value as an integer.
							  ret + ''
							: ret;
					}

					function addGetHookIf(conditionFn, hookFn) {
						// Define the hook, we'll check on the first run if it's really needed.
						return {
							get: function () {
								if (conditionFn()) {
									// Hook not needed (or it's not possible to use it due
									// to missing dependency), remove it.
									delete this.get;
									return;
								}

								// Hook needed; redefine it so that the support test is not executed again.
								return (this.get = hookFn).apply(this, arguments);
							}
						};
					}

					var cssPrefixes = ['Webkit', 'Moz', 'ms'],
						emptyStyle = document.createElement('div').style,
						vendorProps = {};

					// Return a vendor-prefixed property or undefined
					function vendorPropName(name) {
						// Check for vendor prefixed names
						var capName = name[0].toUpperCase() + name.slice(1),
							i = cssPrefixes.length;

						while (i--) {
							name = cssPrefixes[i] + capName;
							if (name in emptyStyle) {
								return name;
							}
						}
					}

					// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
					function finalPropName(name) {
						var final = jQuery.cssProps[name] || vendorProps[name];

						if (final) {
							return final;
						}
						if (name in emptyStyle) {
							return name;
						}
						return (vendorProps[name] = vendorPropName(name) || name);
					}

					var // Swappable if display is none or starts with table
						// except "table", "table-cell", or "table-caption"
						// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
						rdisplayswap = /^(none|table(?!-c[ea]).+)/,
						rcustomProp = /^--/,
						cssShow = { position: 'absolute', visibility: 'hidden', display: 'block' },
						cssNormalTransform = {
							letterSpacing: '0',
							fontWeight: '400'
						};

					function setPositiveNumber(_elem, value, subtract) {
						// Any relative (+/-) values have already been
						// normalized at this point
						var matches = rcssNum.exec(value);
						return matches
							? // Guard against undefined "subtract", e.g., when used as in cssHooks
							  Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || 'px')
							: value;
					}

					function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
						var i = dimension === 'width' ? 1 : 0,
							extra = 0,
							delta = 0;

						// Adjustment may not be necessary
						if (box === (isBorderBox ? 'border' : 'content')) {
							return 0;
						}

						for (; i < 4; i += 2) {
							// Both box models exclude margin
							if (box === 'margin') {
								delta += jQuery.css(elem, box + cssExpand[i], true, styles);
							}

							// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
							if (!isBorderBox) {
								// Add padding
								delta += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);

								// For "border" or "margin", add border
								if (box !== 'padding') {
									delta += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);

									// But still keep track of it otherwise
								} else {
									extra += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
								}

								// If we get here with a border-box (content + padding + border), we're seeking "content" or
								// "padding" or "margin"
							} else {
								// For "content", subtract padding
								if (box === 'content') {
									delta -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
								}

								// For "content" or "padding", subtract border
								if (box !== 'margin') {
									delta -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
								}
							}
						}

						// Account for positive content-box scroll gutter when requested by providing computedVal
						if (!isBorderBox && computedVal >= 0) {
							// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
							// Assuming integer scroll gutter, subtract the rest and round down
							delta +=
								Math.max(
									0,
									Math.ceil(
										elem['offset' + dimension[0].toUpperCase() + dimension.slice(1)] -
											computedVal -
											delta -
											extra -
											0.5

										// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
										// Use an explicit zero to avoid NaN (gh-3964)
									)
								) || 0;
						}

						return delta;
					}

					function getWidthOrHeight(elem, dimension, extra) {
						// Start with computed style
						var styles = getStyles(elem),
							// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
							// Fake content-box until we know it's needed to know the true value.
							boxSizingNeeded = !support.boxSizingReliable() || extra,
							isBorderBox =
								boxSizingNeeded && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box',
							valueIsBorderBox = isBorderBox,
							val = curCSS(elem, dimension, styles),
							offsetProp = 'offset' + dimension[0].toUpperCase() + dimension.slice(1);

						// Support: Firefox <=54
						// Return a confounding non-pixel value or feign ignorance, as appropriate.
						if (rnumnonpx.test(val)) {
							if (!extra) {
								return val;
							}
							val = 'auto';
						}

						// Support: IE 9 - 11 only
						// Use offsetWidth/offsetHeight for when box sizing is unreliable.
						// In those cases, the computed value can be trusted to be border-box.
						if (
							((!support.boxSizingReliable() && isBorderBox) ||
								// Support: IE 10 - 11+, Edge 15 - 18+
								// IE/Edge misreport `getComputedStyle` of table rows with width/height
								// set in CSS while `offset*` properties report correct values.
								// Interestingly, in some cases IE 9 doesn't suffer from this issue.
								(!support.reliableTrDimensions() && nodeName(elem, 'tr')) ||
								// Fall back to offsetWidth/offsetHeight when value is "auto"
								// This happens for inline elements with no explicit setting (gh-3571)
								val === 'auto' ||
								// Support: Android <=4.1 - 4.3 only
								// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
								(!parseFloat(val) && jQuery.css(elem, 'display', false, styles) === 'inline')) &&
							// Make sure the element is visible & connected
							elem.getClientRects().length
						) {
							isBorderBox = jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';

							// Where available, offsetWidth/offsetHeight approximate border box dimensions.
							// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
							// retrieved value as a content box dimension.
							valueIsBorderBox = offsetProp in elem;
							if (valueIsBorderBox) {
								val = elem[offsetProp];
							}
						}

						// Normalize "" and auto
						val = parseFloat(val) || 0;

						// Adjust for the element's box model
						return (
							val +
							boxModelAdjustment(
								elem,
								dimension,
								extra || (isBorderBox ? 'border' : 'content'),
								valueIsBorderBox,
								styles,

								// Provide the current computed size to request scroll gutter calculation (gh-3589)
								val
							) +
							'px'
						);
					}

					jQuery.extend({
						// Add in style property hooks for overriding the default
						// behavior of getting and setting a style property
						cssHooks: {
							opacity: {
								get: function (elem, computed) {
									if (computed) {
										// We should always get a number back from opacity
										var ret = curCSS(elem, 'opacity');
										return ret === '' ? '1' : ret;
									}
								}
							}
						},

						// Don't automatically add "px" to these possibly-unitless properties
						cssNumber: {
							animationIterationCount: true,
							columnCount: true,
							fillOpacity: true,
							flexGrow: true,
							flexShrink: true,
							fontWeight: true,
							gridArea: true,
							gridColumn: true,
							gridColumnEnd: true,
							gridColumnStart: true,
							gridRow: true,
							gridRowEnd: true,
							gridRowStart: true,
							lineHeight: true,
							opacity: true,
							order: true,
							orphans: true,
							widows: true,
							zIndex: true,
							zoom: true
						},

						// Add in properties whose names you wish to fix before
						// setting or getting the value
						cssProps: {},

						// Get and set the style property on a DOM Node
						style: function (elem, name, value, extra) {
							// Don't set styles on text and comment nodes
							if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
								return;
							}

							// Make sure that we're working with the right name
							var ret,
								type,
								hooks,
								origName = camelCase(name),
								isCustomProp = rcustomProp.test(name),
								style = elem.style;

							// Make sure that we're working with the right name. We don't
							// want to query the value if it is a CSS custom property
							// since they are user-defined.
							if (!isCustomProp) {
								name = finalPropName(origName);
							}

							// Gets hook for the prefixed version, then unprefixed version
							hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

							// Check if we're setting a value
							if (value !== undefined) {
								type = typeof value;

								// Convert "+=" or "-=" to relative numbers (#7345)
								if (type === 'string' && (ret = rcssNum.exec(value)) && ret[1]) {
									value = adjustCSS(elem, name, ret);

									// Fixes bug #9237
									type = 'number';
								}

								// Make sure that null and NaN values aren't set (#7116)
								if (value == null || value !== value) {
									return;
								}

								// If a number was passed in, add the unit (except for certain CSS properties)
								// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
								// "px" to a few hardcoded values.
								if (type === 'number' && !isCustomProp) {
									value += (ret && ret[3]) || (jQuery.cssNumber[origName] ? '' : 'px');
								}

								// background-* props affect original clone's values
								if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
									style[name] = 'inherit';
								}

								// If a hook was provided, use that value, otherwise just set the specified value
								if (
									!hooks ||
									!('set' in hooks) ||
									(value = hooks.set(elem, value, extra)) !== undefined
								) {
									if (isCustomProp) {
										style.setProperty(name, value);
									} else {
										style[name] = value;
									}
								}
							} else {
								// If a hook was provided get the non-computed value from there
								if (
									hooks &&
									'get' in hooks &&
									(ret = hooks.get(elem, false, extra)) !== undefined
								) {
									return ret;
								}

								// Otherwise just get the value from the style object
								return style[name];
							}
						},

						css: function (elem, name, extra, styles) {
							var val,
								num,
								hooks,
								origName = camelCase(name),
								isCustomProp = rcustomProp.test(name);

							// Make sure that we're working with the right name. We don't
							// want to modify the value if it is a CSS custom property
							// since they are user-defined.
							if (!isCustomProp) {
								name = finalPropName(origName);
							}

							// Try prefixed name followed by the unprefixed name
							hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

							// If a hook was provided get the computed value from there
							if (hooks && 'get' in hooks) {
								val = hooks.get(elem, true, extra);
							}

							// Otherwise, if a way to get the computed value exists, use that
							if (val === undefined) {
								val = curCSS(elem, name, styles);
							}

							// Convert "normal" to computed value
							if (val === 'normal' && name in cssNormalTransform) {
								val = cssNormalTransform[name];
							}

							// Make numeric if forced or a qualifier was provided and val looks numeric
							if (extra === '' || extra) {
								num = parseFloat(val);
								return extra === true || isFinite(num) ? num || 0 : val;
							}

							return val;
						}
					});

					jQuery.each(['height', 'width'], function (_i, dimension) {
						jQuery.cssHooks[dimension] = {
							get: function (elem, computed, extra) {
								if (computed) {
									// Certain elements can have dimension info if we invisibly show them
									// but it must have a current display style that would benefit
									return rdisplayswap.test(jQuery.css(elem, 'display')) &&
										// Support: Safari 8+
										// Table columns in Safari have non-zero offsetWidth & zero
										// getBoundingClientRect().width unless display is changed.
										// Support: IE <=11 only
										// Running getBoundingClientRect on a disconnected node
										// in IE throws an error.
										(!elem.getClientRects().length || !elem.getBoundingClientRect().width)
										? swap(elem, cssShow, function () {
												return getWidthOrHeight(elem, dimension, extra);
										  })
										: getWidthOrHeight(elem, dimension, extra);
								}
							},

							set: function (elem, value, extra) {
								var matches,
									styles = getStyles(elem),
									// Only read styles.position if the test has a chance to fail
									// to avoid forcing a reflow.
									scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === 'absolute',
									// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
									boxSizingNeeded = scrollboxSizeBuggy || extra,
									isBorderBox =
										boxSizingNeeded &&
										jQuery.css(elem, 'boxSizing', false, styles) === 'border-box',
									subtract = extra
										? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles)
										: 0;

								// Account for unreliable border-box dimensions by comparing offset* to computed and
								// faking a content-box to get border and padding (gh-3699)
								if (isBorderBox && scrollboxSizeBuggy) {
									subtract -= Math.ceil(
										elem['offset' + dimension[0].toUpperCase() + dimension.slice(1)] -
											parseFloat(styles[dimension]) -
											boxModelAdjustment(elem, dimension, 'border', false, styles) -
											0.5
									);
								}

								// Convert to pixels if value adjustment is needed
								if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || 'px') !== 'px') {
									elem.style[dimension] = value;
									value = jQuery.css(elem, dimension);
								}

								return setPositiveNumber(elem, value, subtract);
							}
						};
					});

					jQuery.cssHooks.marginLeft = addGetHookIf(
						support.reliableMarginLeft,
						function (elem, computed) {
							if (computed) {
								return (
									(parseFloat(curCSS(elem, 'marginLeft')) ||
										elem.getBoundingClientRect().left -
											swap(elem, { marginLeft: 0 }, function () {
												return elem.getBoundingClientRect().left;
											})) + 'px'
								);
							}
						}
					);

					// These hooks are used by animate to expand properties
					jQuery.each(
						{
							margin: '',
							padding: '',
							border: 'Width'
						},
						function (prefix, suffix) {
							jQuery.cssHooks[prefix + suffix] = {
								expand: function (value) {
									var i = 0,
										expanded = {},
										// Assumes a single number if not a string
										parts = typeof value === 'string' ? value.split(' ') : [value];

									for (; i < 4; i++) {
										expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
									}

									return expanded;
								}
							};

							if (prefix !== 'margin') {
								jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
							}
						}
					);

					jQuery.fn.extend({
						css: function (name, value) {
							return access(
								this,
								function (elem, name, value) {
									var styles,
										len,
										map = {},
										i = 0;

									if (Array.isArray(name)) {
										styles = getStyles(elem);
										len = name.length;

										for (; i < len; i++) {
											map[name[i]] = jQuery.css(elem, name[i], false, styles);
										}

										return map;
									}

									return value !== undefined
										? jQuery.style(elem, name, value)
										: jQuery.css(elem, name);
								},
								name,
								value,
								arguments.length > 1
							);
						}
					});

					function Tween(elem, options, prop, end, easing) {
						return new Tween.prototype.init(elem, options, prop, end, easing);
					}
					jQuery.Tween = Tween;

					Tween.prototype = {
						constructor: Tween,
						init: function (elem, options, prop, end, easing, unit) {
							this.elem = elem;
							this.prop = prop;
							this.easing = easing || jQuery.easing._default;
							this.options = options;
							this.start = this.now = this.cur();
							this.end = end;
							this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
						},
						cur: function () {
							var hooks = Tween.propHooks[this.prop];

							return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
						},
						run: function (percent) {
							var eased,
								hooks = Tween.propHooks[this.prop];

							if (this.options.duration) {
								this.pos = eased = jQuery.easing[this.easing](
									percent,
									this.options.duration * percent,
									0,
									1,
									this.options.duration
								);
							} else {
								this.pos = eased = percent;
							}
							this.now = (this.end - this.start) * eased + this.start;

							if (this.options.step) {
								this.options.step.call(this.elem, this.now, this);
							}

							if (hooks && hooks.set) {
								hooks.set(this);
							} else {
								Tween.propHooks._default.set(this);
							}
							return this;
						}
					};

					Tween.prototype.init.prototype = Tween.prototype;

					Tween.propHooks = {
						_default: {
							get: function (tween) {
								var result;

								// Use a property on the element directly when it is not a DOM element,
								// or when there is no matching style property that exists.
								if (
									tween.elem.nodeType !== 1 ||
									(tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null)
								) {
									return tween.elem[tween.prop];
								}

								// Passing an empty string as a 3rd parameter to .css will automatically
								// attempt a parseFloat and fallback to a string if the parse fails.
								// Simple values such as "10px" are parsed to Float;
								// complex values such as "rotate(1rad)" are returned as-is.
								result = jQuery.css(tween.elem, tween.prop, '');

								// Empty strings, null, undefined and "auto" are converted to 0.
								return !result || result === 'auto' ? 0 : result;
							},
							set: function (tween) {
								// Use step hook for back compat.
								// Use cssHook if its there.
								// Use .style if available and use plain properties where available.
								if (jQuery.fx.step[tween.prop]) {
									jQuery.fx.step[tween.prop](tween);
								} else if (
									tween.elem.nodeType === 1 &&
									(jQuery.cssHooks[tween.prop] ||
										tween.elem.style[finalPropName(tween.prop)] != null)
								) {
									jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
								} else {
									tween.elem[tween.prop] = tween.now;
								}
							}
						}
					};

					// Support: IE <=9 only
					// Panic based approach to setting things on disconnected nodes
					Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
						set: function (tween) {
							if (tween.elem.nodeType && tween.elem.parentNode) {
								tween.elem[tween.prop] = tween.now;
							}
						}
					};

					jQuery.easing = {
						linear: function (p) {
							return p;
						},
						swing: function (p) {
							return 0.5 - Math.cos(p * Math.PI) / 2;
						},
						_default: 'swing'
					};

					jQuery.fx = Tween.prototype.init;

					// Back compat <1.8 extension point
					jQuery.fx.step = {};

					var fxNow,
						inProgress,
						rfxtypes = /^(?:toggle|show|hide)$/,
						rrun = /queueHooks$/;

					function schedule() {
						if (inProgress) {
							if (document.hidden === false && window.requestAnimationFrame) {
								window.requestAnimationFrame(schedule);
							} else {
								window.setTimeout(schedule, jQuery.fx.interval);
							}

							jQuery.fx.tick();
						}
					}

					// Animations created synchronously will run synchronously
					function createFxNow() {
						window.setTimeout(function () {
							fxNow = undefined;
						});
						return (fxNow = Date.now());
					}

					// Generate parameters to create a standard animation
					function genFx(type, includeWidth) {
						var which,
							i = 0,
							attrs = { height: type };

						// If we include width, step value is 1 to do all cssExpand values,
						// otherwise step value is 2 to skip over Left and Right
						includeWidth = includeWidth ? 1 : 0;
						for (; i < 4; i += 2 - includeWidth) {
							which = cssExpand[i];
							attrs['margin' + which] = attrs['padding' + which] = type;
						}

						if (includeWidth) {
							attrs.opacity = attrs.width = type;
						}

						return attrs;
					}

					function createTween(value, prop, animation) {
						var tween,
							collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners['*']),
							index = 0,
							length = collection.length;
						for (; index < length; index++) {
							if ((tween = collection[index].call(animation, prop, value))) {
								// We're done with this property
								return tween;
							}
						}
					}

					function defaultPrefilter(elem, props, opts) {
						var prop,
							value,
							toggle,
							hooks,
							oldfire,
							propTween,
							restoreDisplay,
							display,
							isBox = 'width' in props || 'height' in props,
							anim = this,
							orig = {},
							style = elem.style,
							hidden = elem.nodeType && isHiddenWithinTree(elem),
							dataShow = dataPriv.get(elem, 'fxshow');

						// Queue-skipping animations hijack the fx hooks
						if (!opts.queue) {
							hooks = jQuery._queueHooks(elem, 'fx');
							if (hooks.unqueued == null) {
								hooks.unqueued = 0;
								oldfire = hooks.empty.fire;
								hooks.empty.fire = function () {
									if (!hooks.unqueued) {
										oldfire();
									}
								};
							}
							hooks.unqueued++;

							anim.always(function () {
								// Ensure the complete handler is called before this completes
								anim.always(function () {
									hooks.unqueued--;
									if (!jQuery.queue(elem, 'fx').length) {
										hooks.empty.fire();
									}
								});
							});
						}

						// Detect show/hide animations
						for (prop in props) {
							value = props[prop];
							if (rfxtypes.test(value)) {
								delete props[prop];
								toggle = toggle || value === 'toggle';
								if (value === (hidden ? 'hide' : 'show')) {
									// Pretend to be hidden if this is a "show" and
									// there is still data from a stopped show/hide
									if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
										hidden = true;

										// Ignore all other no-op show/hide data
									} else {
										continue;
									}
								}
								orig[prop] = (dataShow && dataShow[prop]) || jQuery.style(elem, prop);
							}
						}

						// Bail out if this is a no-op like .hide().hide()
						propTween = !jQuery.isEmptyObject(props);
						if (!propTween && jQuery.isEmptyObject(orig)) {
							return;
						}

						// Restrict "overflow" and "display" styles during box animations
						if (isBox && elem.nodeType === 1) {
							// Support: IE <=9 - 11, Edge 12 - 15
							// Record all 3 overflow attributes because IE does not infer the shorthand
							// from identically-valued overflowX and overflowY and Edge just mirrors
							// the overflowX value there.
							opts.overflow = [style.overflow, style.overflowX, style.overflowY];

							// Identify a display type, preferring old show/hide data over the CSS cascade
							restoreDisplay = dataShow && dataShow.display;
							if (restoreDisplay == null) {
								restoreDisplay = dataPriv.get(elem, 'display');
							}
							display = jQuery.css(elem, 'display');
							if (display === 'none') {
								if (restoreDisplay) {
									display = restoreDisplay;
								} else {
									// Get nonempty value(s) by temporarily forcing visibility
									showHide([elem], true);
									restoreDisplay = elem.style.display || restoreDisplay;
									display = jQuery.css(elem, 'display');
									showHide([elem]);
								}
							}

							// Animate inline elements as inline-block
							if (display === 'inline' || (display === 'inline-block' && restoreDisplay != null)) {
								if (jQuery.css(elem, 'float') === 'none') {
									// Restore the original display value at the end of pure show/hide animations
									if (!propTween) {
										anim.done(function () {
											style.display = restoreDisplay;
										});
										if (restoreDisplay == null) {
											display = style.display;
											restoreDisplay = display === 'none' ? '' : display;
										}
									}
									style.display = 'inline-block';
								}
							}
						}

						if (opts.overflow) {
							style.overflow = 'hidden';
							anim.always(function () {
								style.overflow = opts.overflow[0];
								style.overflowX = opts.overflow[1];
								style.overflowY = opts.overflow[2];
							});
						}

						// Implement show/hide animations
						propTween = false;
						for (prop in orig) {
							// General show/hide setup for this element animation
							if (!propTween) {
								if (dataShow) {
									if ('hidden' in dataShow) {
										hidden = dataShow.hidden;
									}
								} else {
									dataShow = dataPriv.access(elem, 'fxshow', { display: restoreDisplay });
								}

								// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
								if (toggle) {
									dataShow.hidden = !hidden;
								}

								// Show elements before animating them
								if (hidden) {
									showHide([elem], true);
								}

								/* eslint-disable no-loop-func */

								anim.done(function () {
									/* eslint-enable no-loop-func */

									// The final step of a "hide" animation is actually hiding the element
									if (!hidden) {
										showHide([elem]);
									}
									dataPriv.remove(elem, 'fxshow');
									for (prop in orig) {
										jQuery.style(elem, prop, orig[prop]);
									}
								});
							}

							// Per-property setup
							propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
							if (!(prop in dataShow)) {
								dataShow[prop] = propTween.start;
								if (hidden) {
									propTween.end = propTween.start;
									propTween.start = 0;
								}
							}
						}
					}

					function propFilter(props, specialEasing) {
						var index, name, easing, value, hooks;

						// camelCase, specialEasing and expand cssHook pass
						for (index in props) {
							name = camelCase(index);
							easing = specialEasing[name];
							value = props[index];
							if (Array.isArray(value)) {
								easing = value[1];
								value = props[index] = value[0];
							}

							if (index !== name) {
								props[name] = value;
								delete props[index];
							}

							hooks = jQuery.cssHooks[name];
							if (hooks && 'expand' in hooks) {
								value = hooks.expand(value);
								delete props[name];

								// Not quite $.extend, this won't overwrite existing keys.
								// Reusing 'index' because we have the correct "name"
								for (index in value) {
									if (!(index in props)) {
										props[index] = value[index];
										specialEasing[index] = easing;
									}
								}
							} else {
								specialEasing[name] = easing;
							}
						}
					}

					function Animation(elem, properties, options) {
						var result,
							stopped,
							index = 0,
							length = Animation.prefilters.length,
							deferred = jQuery.Deferred().always(function () {
								// Don't match elem in the :animated selector
								delete tick.elem;
							}),
							tick = function () {
								if (stopped) {
									return false;
								}
								var currentTime = fxNow || createFxNow(),
									remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
									// Support: Android 2.3 only
									// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
									temp = remaining / animation.duration || 0,
									percent = 1 - temp,
									index = 0,
									length = animation.tweens.length;

								for (; index < length; index++) {
									animation.tweens[index].run(percent);
								}

								deferred.notifyWith(elem, [animation, percent, remaining]);

								// If there's more to do, yield
								if (percent < 1 && length) {
									return remaining;
								}

								// If this was an empty animation, synthesize a final progress notification
								if (!length) {
									deferred.notifyWith(elem, [animation, 1, 0]);
								}

								// Resolve the animation and report its conclusion
								deferred.resolveWith(elem, [animation]);
								return false;
							},
							animation = deferred.promise({
								elem: elem,
								props: jQuery.extend({}, properties),
								opts: jQuery.extend(
									true,
									{
										specialEasing: {},
										easing: jQuery.easing._default
									},
									options
								),
								originalProperties: properties,
								originalOptions: options,
								startTime: fxNow || createFxNow(),
								duration: options.duration,
								tweens: [],
								createTween: function (prop, end) {
									var tween = jQuery.Tween(
										elem,
										animation.opts,
										prop,
										end,
										animation.opts.specialEasing[prop] || animation.opts.easing
									);
									animation.tweens.push(tween);
									return tween;
								},
								stop: function (gotoEnd) {
									var index = 0,
										// If we are going to the end, we want to run all the tweens
										// otherwise we skip this part
										length = gotoEnd ? animation.tweens.length : 0;
									if (stopped) {
										return this;
									}
									stopped = true;
									for (; index < length; index++) {
										animation.tweens[index].run(1);
									}

									// Resolve when we played the last frame; otherwise, reject
									if (gotoEnd) {
										deferred.notifyWith(elem, [animation, 1, 0]);
										deferred.resolveWith(elem, [animation, gotoEnd]);
									} else {
										deferred.rejectWith(elem, [animation, gotoEnd]);
									}
									return this;
								}
							}),
							props = animation.props;

						propFilter(props, animation.opts.specialEasing);

						for (; index < length; index++) {
							result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
							if (result) {
								if (isFunction(result.stop)) {
									jQuery._queueHooks(animation.elem, animation.opts.queue).stop =
										result.stop.bind(result);
								}
								return result;
							}
						}

						jQuery.map(props, createTween, animation);

						if (isFunction(animation.opts.start)) {
							animation.opts.start.call(elem, animation);
						}

						// Attach callbacks from options
						animation
							.progress(animation.opts.progress)
							.done(animation.opts.done, animation.opts.complete)
							.fail(animation.opts.fail)
							.always(animation.opts.always);

						jQuery.fx.timer(
							jQuery.extend(tick, {
								elem: elem,
								anim: animation,
								queue: animation.opts.queue
							})
						);

						return animation;
					}

					jQuery.Animation = jQuery.extend(Animation, {
						tweeners: {
							'*': [
								function (prop, value) {
									var tween = this.createTween(prop, value);
									adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
									return tween;
								}
							]
						},

						tweener: function (props, callback) {
							if (isFunction(props)) {
								callback = props;
								props = ['*'];
							} else {
								props = props.match(rnothtmlwhite);
							}

							var prop,
								index = 0,
								length = props.length;

							for (; index < length; index++) {
								prop = props[index];
								Animation.tweeners[prop] = Animation.tweeners[prop] || [];
								Animation.tweeners[prop].unshift(callback);
							}
						},

						prefilters: [defaultPrefilter],

						prefilter: function (callback, prepend) {
							if (prepend) {
								Animation.prefilters.unshift(callback);
							} else {
								Animation.prefilters.push(callback);
							}
						}
					});

					jQuery.speed = function (speed, easing, fn) {
						var opt =
							speed && typeof speed === 'object'
								? jQuery.extend({}, speed)
								: {
										complete: fn || (!fn && easing) || (isFunction(speed) && speed),
										duration: speed,
										easing: (fn && easing) || (easing && !isFunction(easing) && easing)
								  };

						// Go to the end state if fx are off
						if (jQuery.fx.off) {
							opt.duration = 0;
						} else {
							if (typeof opt.duration !== 'number') {
								if (opt.duration in jQuery.fx.speeds) {
									opt.duration = jQuery.fx.speeds[opt.duration];
								} else {
									opt.duration = jQuery.fx.speeds._default;
								}
							}
						}

						// Normalize opt.queue - true/undefined/null -> "fx"
						if (opt.queue == null || opt.queue === true) {
							opt.queue = 'fx';
						}

						// Queueing
						opt.old = opt.complete;

						opt.complete = function () {
							if (isFunction(opt.old)) {
								opt.old.call(this);
							}

							if (opt.queue) {
								jQuery.dequeue(this, opt.queue);
							}
						};

						return opt;
					};

					jQuery.fn.extend({
						fadeTo: function (speed, to, easing, callback) {
							// Show any hidden elements after setting opacity to 0
							return (
								this.filter(isHiddenWithinTree)
									.css('opacity', 0)
									.show()

									// Animate to the value specified
									.end()
									.animate({ opacity: to }, speed, easing, callback)
							);
						},
						animate: function (prop, speed, easing, callback) {
							var empty = jQuery.isEmptyObject(prop),
								optall = jQuery.speed(speed, easing, callback),
								doAnimation = function () {
									// Operate on a copy of prop so per-property easing won't be lost
									var anim = Animation(this, jQuery.extend({}, prop), optall);

									// Empty animations, or finishing resolves immediately
									if (empty || dataPriv.get(this, 'finish')) {
										anim.stop(true);
									}
								};
							doAnimation.finish = doAnimation;

							return empty || optall.queue === false
								? this.each(doAnimation)
								: this.queue(optall.queue, doAnimation);
						},
						stop: function (type, clearQueue, gotoEnd) {
							var stopQueue = function (hooks) {
								var stop = hooks.stop;
								delete hooks.stop;
								stop(gotoEnd);
							};

							if (typeof type !== 'string') {
								gotoEnd = clearQueue;
								clearQueue = type;
								type = undefined;
							}
							if (clearQueue) {
								this.queue(type || 'fx', []);
							}

							return this.each(function () {
								var dequeue = true,
									index = type != null && type + 'queueHooks',
									timers = jQuery.timers,
									data = dataPriv.get(this);

								if (index) {
									if (data[index] && data[index].stop) {
										stopQueue(data[index]);
									}
								} else {
									for (index in data) {
										if (data[index] && data[index].stop && rrun.test(index)) {
											stopQueue(data[index]);
										}
									}
								}

								for (index = timers.length; index--; ) {
									if (
										timers[index].elem === this &&
										(type == null || timers[index].queue === type)
									) {
										timers[index].anim.stop(gotoEnd);
										dequeue = false;
										timers.splice(index, 1);
									}
								}

								// Start the next in the queue if the last step wasn't forced.
								// Timers currently will call their complete callbacks, which
								// will dequeue but only if they were gotoEnd.
								if (dequeue || !gotoEnd) {
									jQuery.dequeue(this, type);
								}
							});
						},
						finish: function (type) {
							if (type !== false) {
								type = type || 'fx';
							}
							return this.each(function () {
								var index,
									data = dataPriv.get(this),
									queue = data[type + 'queue'],
									hooks = data[type + 'queueHooks'],
									timers = jQuery.timers,
									length = queue ? queue.length : 0;

								// Enable finishing flag on private data
								data.finish = true;

								// Empty the queue first
								jQuery.queue(this, type, []);

								if (hooks && hooks.stop) {
									hooks.stop.call(this, true);
								}

								// Look for any active animations, and finish them
								for (index = timers.length; index--; ) {
									if (timers[index].elem === this && timers[index].queue === type) {
										timers[index].anim.stop(true);
										timers.splice(index, 1);
									}
								}

								// Look for any animations in the old queue and finish them
								for (index = 0; index < length; index++) {
									if (queue[index] && queue[index].finish) {
										queue[index].finish.call(this);
									}
								}

								// Turn off finishing flag
								delete data.finish;
							});
						}
					});

					jQuery.each(['toggle', 'show', 'hide'], function (_i, name) {
						var cssFn = jQuery.fn[name];
						jQuery.fn[name] = function (speed, easing, callback) {
							return speed == null || typeof speed === 'boolean'
								? cssFn.apply(this, arguments)
								: this.animate(genFx(name, true), speed, easing, callback);
						};
					});

					// Generate shortcuts for custom animations
					jQuery.each(
						{
							slideDown: genFx('show'),
							slideUp: genFx('hide'),
							slideToggle: genFx('toggle'),
							fadeIn: { opacity: 'show' },
							fadeOut: { opacity: 'hide' },
							fadeToggle: { opacity: 'toggle' }
						},
						function (name, props) {
							jQuery.fn[name] = function (speed, easing, callback) {
								return this.animate(props, speed, easing, callback);
							};
						}
					);

					jQuery.timers = [];
					jQuery.fx.tick = function () {
						var timer,
							i = 0,
							timers = jQuery.timers;

						fxNow = Date.now();

						for (; i < timers.length; i++) {
							timer = timers[i];

							// Run the timer and safely remove it when done (allowing for external removal)
							if (!timer() && timers[i] === timer) {
								timers.splice(i--, 1);
							}
						}

						if (!timers.length) {
							jQuery.fx.stop();
						}
						fxNow = undefined;
					};

					jQuery.fx.timer = function (timer) {
						jQuery.timers.push(timer);
						jQuery.fx.start();
					};

					jQuery.fx.interval = 13;
					jQuery.fx.start = function () {
						if (inProgress) {
							return;
						}

						inProgress = true;
						schedule();
					};

					jQuery.fx.stop = function () {
						inProgress = null;
					};

					jQuery.fx.speeds = {
						slow: 600,
						fast: 200,

						// Default speed
						_default: 400
					};

					// Based off of the plugin by Clint Helfers, with permission.
					// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
					jQuery.fn.delay = function (time, type) {
						time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
						type = type || 'fx';

						return this.queue(type, function (next, hooks) {
							var timeout = window.setTimeout(next, time);
							hooks.stop = function () {
								window.clearTimeout(timeout);
							};
						});
					};

					(function () {
						var input = document.createElement('input'),
							select = document.createElement('select'),
							opt = select.appendChild(document.createElement('option'));

						input.type = 'checkbox';

						// Support: Android <=4.3 only
						// Default value for a checkbox should be "on"
						support.checkOn = input.value !== '';

						// Support: IE <=11 only
						// Must access selectedIndex to make default options select
						support.optSelected = opt.selected;

						// Support: IE <=11 only
						// An input loses its value after becoming a radio
						input = document.createElement('input');
						input.value = 't';
						input.type = 'radio';
						support.radioValue = input.value === 't';
					})();

					var boolHook,
						attrHandle = jQuery.expr.attrHandle;

					jQuery.fn.extend({
						attr: function (name, value) {
							return access(this, jQuery.attr, name, value, arguments.length > 1);
						},

						removeAttr: function (name) {
							return this.each(function () {
								jQuery.removeAttr(this, name);
							});
						}
					});

					jQuery.extend({
						attr: function (elem, name, value) {
							var ret,
								hooks,
								nType = elem.nodeType;

							// Don't get/set attributes on text, comment and attribute nodes
							if (nType === 3 || nType === 8 || nType === 2) {
								return;
							}

							// Fallback to prop when attributes are not supported
							if (typeof elem.getAttribute === 'undefined') {
								return jQuery.prop(elem, name, value);
							}

							// Attribute hooks are determined by the lowercase version
							// Grab necessary hook if one is defined
							if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
								hooks =
									jQuery.attrHooks[name.toLowerCase()] ||
									(jQuery.expr.match.bool.test(name) ? boolHook : undefined);
							}

							if (value !== undefined) {
								if (value === null) {
									jQuery.removeAttr(elem, name);
									return;
								}

								if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
									return ret;
								}

								elem.setAttribute(name, value + '');
								return value;
							}

							if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
								return ret;
							}

							ret = jQuery.find.attr(elem, name);

							// Non-existent attributes return null, we normalize to undefined
							return ret == null ? undefined : ret;
						},

						attrHooks: {
							type: {
								set: function (elem, value) {
									if (!support.radioValue && value === 'radio' && nodeName(elem, 'input')) {
										var val = elem.value;
										elem.setAttribute('type', value);
										if (val) {
											elem.value = val;
										}
										return value;
									}
								}
							}
						},

						removeAttr: function (elem, value) {
							var name,
								i = 0,
								// Attribute names can contain non-HTML whitespace characters
								// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
								attrNames = value && value.match(rnothtmlwhite);

							if (attrNames && elem.nodeType === 1) {
								while ((name = attrNames[i++])) {
									elem.removeAttribute(name);
								}
							}
						}
					});

					// Hooks for boolean attributes
					boolHook = {
						set: function (elem, value, name) {
							if (value === false) {
								// Remove boolean attributes when set to false
								jQuery.removeAttr(elem, name);
							} else {
								elem.setAttribute(name, name);
							}
							return name;
						}
					};

					jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (_i, name) {
						var getter = attrHandle[name] || jQuery.find.attr;

						attrHandle[name] = function (elem, name, isXML) {
							var ret,
								handle,
								lowercaseName = name.toLowerCase();

							if (!isXML) {
								// Avoid an infinite loop by temporarily removing this function from the getter
								handle = attrHandle[lowercaseName];
								attrHandle[lowercaseName] = ret;
								ret = getter(elem, name, isXML) != null ? lowercaseName : null;
								attrHandle[lowercaseName] = handle;
							}
							return ret;
						};
					});

					var rfocusable = /^(?:input|select|textarea|button)$/i,
						rclickable = /^(?:a|area)$/i;

					jQuery.fn.extend({
						prop: function (name, value) {
							return access(this, jQuery.prop, name, value, arguments.length > 1);
						},

						removeProp: function (name) {
							return this.each(function () {
								delete this[jQuery.propFix[name] || name];
							});
						}
					});

					jQuery.extend({
						prop: function (elem, name, value) {
							var ret,
								hooks,
								nType = elem.nodeType;

							// Don't get/set properties on text, comment and attribute nodes
							if (nType === 3 || nType === 8 || nType === 2) {
								return;
							}

							if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
								// Fix name and attach hooks
								name = jQuery.propFix[name] || name;
								hooks = jQuery.propHooks[name];
							}

							if (value !== undefined) {
								if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
									return ret;
								}

								return (elem[name] = value);
							}

							if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
								return ret;
							}

							return elem[name];
						},

						propHooks: {
							tabIndex: {
								get: function (elem) {
									// Support: IE <=9 - 11 only
									// elem.tabIndex doesn't always return the
									// correct value when it hasn't been explicitly set
									// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
									// Use proper attribute retrieval(#12072)
									var tabindex = jQuery.find.attr(elem, 'tabindex');

									if (tabindex) {
										return parseInt(tabindex, 10);
									}

									if (
										rfocusable.test(elem.nodeName) ||
										(rclickable.test(elem.nodeName) && elem.href)
									) {
										return 0;
									}

									return -1;
								}
							}
						},

						propFix: {
							for: 'htmlFor',
							class: 'className'
						}
					});

					// Support: IE <=11 only
					// Accessing the selectedIndex property
					// forces the browser to respect setting selected
					// on the option
					// The getter ensures a default option is selected
					// when in an optgroup
					// eslint rule "no-unused-expressions" is disabled for this code
					// since it considers such accessions noop
					if (!support.optSelected) {
						jQuery.propHooks.selected = {
							get: function (elem) {
								/* eslint no-unused-expressions: "off" */

								var parent = elem.parentNode;
								if (parent && parent.parentNode) {
									parent.parentNode.selectedIndex;
								}
								return null;
							},
							set: function (elem) {
								/* eslint no-unused-expressions: "off" */

								var parent = elem.parentNode;
								if (parent) {
									parent.selectedIndex;

									if (parent.parentNode) {
										parent.parentNode.selectedIndex;
									}
								}
							}
						};
					}

					jQuery.each(
						[
							'tabIndex',
							'readOnly',
							'maxLength',
							'cellSpacing',
							'cellPadding',
							'rowSpan',
							'colSpan',
							'useMap',
							'frameBorder',
							'contentEditable'
						],
						function () {
							jQuery.propFix[this.toLowerCase()] = this;
						}
					);

					// Strip and collapse whitespace according to HTML spec
					// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
					function stripAndCollapse(value) {
						var tokens = value.match(rnothtmlwhite) || [];
						return tokens.join(' ');
					}

					function getClass(elem) {
						return (elem.getAttribute && elem.getAttribute('class')) || '';
					}

					function classesToArray(value) {
						if (Array.isArray(value)) {
							return value;
						}
						if (typeof value === 'string') {
							return value.match(rnothtmlwhite) || [];
						}
						return [];
					}

					jQuery.fn.extend({
						addClass: function (value) {
							var classes,
								elem,
								cur,
								curValue,
								clazz,
								j,
								finalValue,
								i = 0;

							if (isFunction(value)) {
								return this.each(function (j) {
									jQuery(this).addClass(value.call(this, j, getClass(this)));
								});
							}

							classes = classesToArray(value);

							if (classes.length) {
								while ((elem = this[i++])) {
									curValue = getClass(elem);
									cur = elem.nodeType === 1 && ' ' + stripAndCollapse(curValue) + ' ';

									if (cur) {
										j = 0;
										while ((clazz = classes[j++])) {
											if (cur.indexOf(' ' + clazz + ' ') < 0) {
												cur += clazz + ' ';
											}
										}

										// Only assign if different to avoid unneeded rendering.
										finalValue = stripAndCollapse(cur);
										if (curValue !== finalValue) {
											elem.setAttribute('class', finalValue);
										}
									}
								}
							}

							return this;
						},

						removeClass: function (value) {
							var classes,
								elem,
								cur,
								curValue,
								clazz,
								j,
								finalValue,
								i = 0;

							if (isFunction(value)) {
								return this.each(function (j) {
									jQuery(this).removeClass(value.call(this, j, getClass(this)));
								});
							}

							if (!arguments.length) {
								return this.attr('class', '');
							}

							classes = classesToArray(value);

							if (classes.length) {
								while ((elem = this[i++])) {
									curValue = getClass(elem);

									// This expression is here for better compressibility (see addClass)
									cur = elem.nodeType === 1 && ' ' + stripAndCollapse(curValue) + ' ';

									if (cur) {
										j = 0;
										while ((clazz = classes[j++])) {
											// Remove *all* instances
											while (cur.indexOf(' ' + clazz + ' ') > -1) {
												cur = cur.replace(' ' + clazz + ' ', ' ');
											}
										}

										// Only assign if different to avoid unneeded rendering.
										finalValue = stripAndCollapse(cur);
										if (curValue !== finalValue) {
											elem.setAttribute('class', finalValue);
										}
									}
								}
							}

							return this;
						},

						toggleClass: function (value, stateVal) {
							var type = typeof value,
								isValidValue = type === 'string' || Array.isArray(value);

							if (typeof stateVal === 'boolean' && isValidValue) {
								return stateVal ? this.addClass(value) : this.removeClass(value);
							}

							if (isFunction(value)) {
								return this.each(function (i) {
									jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
								});
							}

							return this.each(function () {
								var className, i, self, classNames;

								if (isValidValue) {
									// Toggle individual class names
									i = 0;
									self = jQuery(this);
									classNames = classesToArray(value);

									while ((className = classNames[i++])) {
										// Check each className given, space separated list
										if (self.hasClass(className)) {
											self.removeClass(className);
										} else {
											self.addClass(className);
										}
									}

									// Toggle whole class name
								} else if (value === undefined || type === 'boolean') {
									className = getClass(this);
									if (className) {
										// Store className if set
										dataPriv.set(this, '__className__', className);
									}

									// If the element has a class name or if we're passed `false`,
									// then remove the whole classname (if there was one, the above saved it).
									// Otherwise bring back whatever was previously saved (if anything),
									// falling back to the empty string if nothing was stored.
									if (this.setAttribute) {
										this.setAttribute(
											'class',
											className || value === false ? '' : dataPriv.get(this, '__className__') || ''
										);
									}
								}
							});
						},

						hasClass: function (selector) {
							var className,
								elem,
								i = 0;

							className = ' ' + selector + ' ';
							while ((elem = this[i++])) {
								if (
									elem.nodeType === 1 &&
									(' ' + stripAndCollapse(getClass(elem)) + ' ').indexOf(className) > -1
								) {
									return true;
								}
							}

							return false;
						}
					});

					var rreturn = /\r/g;

					jQuery.fn.extend({
						val: function (value) {
							var hooks,
								ret,
								valueIsFunction,
								elem = this[0];

							if (!arguments.length) {
								if (elem) {
									hooks =
										jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

									if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
										return ret;
									}

									ret = elem.value;

									// Handle most common string cases
									if (typeof ret === 'string') {
										return ret.replace(rreturn, '');
									}

									// Handle cases where value is null/undef or number
									return ret == null ? '' : ret;
								}

								return;
							}

							valueIsFunction = isFunction(value);

							return this.each(function (i) {
								var val;

								if (this.nodeType !== 1) {
									return;
								}

								if (valueIsFunction) {
									val = value.call(this, i, jQuery(this).val());
								} else {
									val = value;
								}

								// Treat null/undefined as ""; convert numbers to string
								if (val == null) {
									val = '';
								} else if (typeof val === 'number') {
									val += '';
								} else if (Array.isArray(val)) {
									val = jQuery.map(val, function (value) {
										return value == null ? '' : value + '';
									});
								}

								hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

								// If set returns undefined, fall back to normal setting
								if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
									this.value = val;
								}
							});
						}
					});

					jQuery.extend({
						valHooks: {
							option: {
								get: function (elem) {
									var val = jQuery.find.attr(elem, 'value');
									return val != null
										? val
										: // Support: IE <=10 - 11 only
										  // option.text throws exceptions (#14686, #14858)
										  // Strip and collapse whitespace
										  // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
										  stripAndCollapse(jQuery.text(elem));
								}
							},
							select: {
								get: function (elem) {
									var value,
										option,
										i,
										options = elem.options,
										index = elem.selectedIndex,
										one = elem.type === 'select-one',
										values = one ? null : [],
										max = one ? index + 1 : options.length;

									if (index < 0) {
										i = max;
									} else {
										i = one ? index : 0;
									}

									// Loop through all the selected options
									for (; i < max; i++) {
										option = options[i];

										// Support: IE <=9 only
										// IE8-9 doesn't update selected after form reset (#2551)
										if (
											(option.selected || i === index) &&
											// Don't return options that are disabled or in a disabled optgroup
											!option.disabled &&
											(!option.parentNode.disabled || !nodeName(option.parentNode, 'optgroup'))
										) {
											// Get the specific value for the option
											value = jQuery(option).val();

											// We don't need an array for one selects
											if (one) {
												return value;
											}

											// Multi-Selects return an array
											values.push(value);
										}
									}

									return values;
								},

								set: function (elem, value) {
									var optionSet,
										option,
										options = elem.options,
										values = jQuery.makeArray(value),
										i = options.length;

									while (i--) {
										option = options[i];

										/* eslint-disable no-cond-assign */

										if (
											(option.selected =
												jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1)
										) {
											optionSet = true;
										}

										/* eslint-enable no-cond-assign */
									}

									// Force browsers to behave consistently when non-matching value is set
									if (!optionSet) {
										elem.selectedIndex = -1;
									}
									return values;
								}
							}
						}
					});

					// Radios and checkboxes getter/setter
					jQuery.each(['radio', 'checkbox'], function () {
						jQuery.valHooks[this] = {
							set: function (elem, value) {
								if (Array.isArray(value)) {
									return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
								}
							}
						};
						if (!support.checkOn) {
							jQuery.valHooks[this].get = function (elem) {
								return elem.getAttribute('value') === null ? 'on' : elem.value;
							};
						}
					});

					// Return jQuery for attributes-only inclusion

					support.focusin = 'onfocusin' in window;

					var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
						stopPropagationCallback = function (e) {
							e.stopPropagation();
						};

					jQuery.extend(jQuery.event, {
						trigger: function (event, data, elem, onlyHandlers) {
							var i,
								cur,
								tmp,
								bubbleType,
								ontype,
								handle,
								special,
								lastElement,
								eventPath = [elem || document],
								type = hasOwn.call(event, 'type') ? event.type : event,
								namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];

							cur = lastElement = tmp = elem = elem || document;

							// Don't do events on text and comment nodes
							if (elem.nodeType === 3 || elem.nodeType === 8) {
								return;
							}

							// focus/blur morphs to focusin/out; ensure we're not firing them right now
							if (rfocusMorph.test(type + jQuery.event.triggered)) {
								return;
							}

							if (type.indexOf('.') > -1) {
								// Namespaced trigger; create a regexp to match event type in handle()
								namespaces = type.split('.');
								type = namespaces.shift();
								namespaces.sort();
							}
							ontype = type.indexOf(':') < 0 && 'on' + type;

							// Caller can pass in a jQuery.Event object, Object, or just an event type string
							event = event[jQuery.expando]
								? event
								: new jQuery.Event(type, typeof event === 'object' && event);

							// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
							event.isTrigger = onlyHandlers ? 2 : 3;
							event.namespace = namespaces.join('.');
							event.rnamespace = event.namespace
								? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)')
								: null;

							// Clean up the event in case it is being reused
							event.result = undefined;
							if (!event.target) {
								event.target = elem;
							}

							// Clone any incoming data and prepend the event, creating the handler arg list
							data = data == null ? [event] : jQuery.makeArray(data, [event]);

							// Allow special events to draw outside the lines
							special = jQuery.event.special[type] || {};
							if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
								return;
							}

							// Determine event propagation path in advance, per W3C events spec (#9951)
							// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
							if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
								bubbleType = special.delegateType || type;
								if (!rfocusMorph.test(bubbleType + type)) {
									cur = cur.parentNode;
								}
								for (; cur; cur = cur.parentNode) {
									eventPath.push(cur);
									tmp = cur;
								}

								// Only add window if we got to document (e.g., not plain obj or detached DOM)
								if (tmp === (elem.ownerDocument || document)) {
									eventPath.push(tmp.defaultView || tmp.parentWindow || window);
								}
							}

							// Fire handlers on the event path
							i = 0;
							while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
								lastElement = cur;
								event.type = i > 1 ? bubbleType : special.bindType || type;

								// jQuery handler
								handle =
									(dataPriv.get(cur, 'events') || Object.create(null))[event.type] &&
									dataPriv.get(cur, 'handle');
								if (handle) {
									handle.apply(cur, data);
								}

								// Native handler
								handle = ontype && cur[ontype];
								if (handle && handle.apply && acceptData(cur)) {
									event.result = handle.apply(cur, data);
									if (event.result === false) {
										event.preventDefault();
									}
								}
							}
							event.type = type;

							// If nobody prevented the default action, do it now
							if (!onlyHandlers && !event.isDefaultPrevented()) {
								if (
									(!special._default || special._default.apply(eventPath.pop(), data) === false) &&
									acceptData(elem)
								) {
									// Call a native DOM method on the target with the same name as the event.
									// Don't do default actions on window, that's where global variables be (#6170)
									if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
										// Don't re-trigger an onFOO event when we call its FOO() method
										tmp = elem[ontype];

										if (tmp) {
											elem[ontype] = null;
										}

										// Prevent re-triggering of the same event, since we already bubbled it above
										jQuery.event.triggered = type;

										if (event.isPropagationStopped()) {
											lastElement.addEventListener(type, stopPropagationCallback);
										}

										elem[type]();

										if (event.isPropagationStopped()) {
											lastElement.removeEventListener(type, stopPropagationCallback);
										}

										jQuery.event.triggered = undefined;

										if (tmp) {
											elem[ontype] = tmp;
										}
									}
								}
							}

							return event.result;
						},

						// Piggyback on a donor event to simulate a different one
						// Used only for `focus(in | out)` events
						simulate: function (type, elem, event) {
							var e = jQuery.extend(new jQuery.Event(), event, {
								type: type,
								isSimulated: true
							});

							jQuery.event.trigger(e, null, elem);
						}
					});

					jQuery.fn.extend({
						trigger: function (type, data) {
							return this.each(function () {
								jQuery.event.trigger(type, data, this);
							});
						},
						triggerHandler: function (type, data) {
							var elem = this[0];
							if (elem) {
								return jQuery.event.trigger(type, data, elem, true);
							}
						}
					});

					// Support: Firefox <=44
					// Firefox doesn't have focus(in | out) events
					// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
					//
					// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
					// focus(in | out) events fire after focus & blur events,
					// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
					// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
					if (!support.focusin) {
						jQuery.each({ focus: 'focusin', blur: 'focusout' }, function (orig, fix) {
							// Attach a single capturing handler on the document while someone wants focusin/focusout
							var handler = function (event) {
								jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
							};

							jQuery.event.special[fix] = {
								setup: function () {
									// Handle: regular nodes (via `this.ownerDocument`), window
									// (via `this.document`) & document (via `this`).
									var doc = this.ownerDocument || this.document || this,
										attaches = dataPriv.access(doc, fix);

									if (!attaches) {
										doc.addEventListener(orig, handler, true);
									}
									dataPriv.access(doc, fix, (attaches || 0) + 1);
								},
								teardown: function () {
									var doc = this.ownerDocument || this.document || this,
										attaches = dataPriv.access(doc, fix) - 1;

									if (!attaches) {
										doc.removeEventListener(orig, handler, true);
										dataPriv.remove(doc, fix);
									} else {
										dataPriv.access(doc, fix, attaches);
									}
								}
							};
						});
					}
					var location = window.location;

					var nonce = { guid: Date.now() };

					var rquery = /\?/;

					// Cross-browser xml parsing
					jQuery.parseXML = function (data) {
						var xml;
						if (!data || typeof data !== 'string') {
							return null;
						}

						// Support: IE 9 - 11 only
						// IE throws on parseFromString with invalid input.
						try {
							xml = new window.DOMParser().parseFromString(data, 'text/xml');
						} catch (e) {
							xml = undefined;
						}

						if (!xml || xml.getElementsByTagName('parsererror').length) {
							jQuery.error('Invalid XML: ' + data);
						}
						return xml;
					};

					var rbracket = /\[\]$/,
						rCRLF = /\r?\n/g,
						rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
						rsubmittable = /^(?:input|select|textarea|keygen)/i;

					function buildParams(prefix, obj, traditional, add) {
						var name;

						if (Array.isArray(obj)) {
							// Serialize array item.
							jQuery.each(obj, function (i, v) {
								if (traditional || rbracket.test(prefix)) {
									// Treat each array item as a scalar.
									add(prefix, v);
								} else {
									// Item is non-scalar (array or object), encode its numeric index.
									buildParams(
										prefix + '[' + (typeof v === 'object' && v != null ? i : '') + ']',
										v,
										traditional,
										add
									);
								}
							});
						} else if (!traditional && toType(obj) === 'object') {
							// Serialize object item.
							for (name in obj) {
								buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
							}
						} else {
							// Serialize scalar item.
							add(prefix, obj);
						}
					}

					// Serialize an array of form elements or a set of
					// key/values into a query string
					jQuery.param = function (a, traditional) {
						var prefix,
							s = [],
							add = function (key, valueOrFunction) {
								// If value is a function, invoke it and use its return value
								var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;

								s[s.length] =
									encodeURIComponent(key) + '=' + encodeURIComponent(value == null ? '' : value);
							};

						if (a == null) {
							return '';
						}

						// If an array was passed in, assume that it is an array of form elements.
						if (Array.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
							// Serialize the form elements
							jQuery.each(a, function () {
								add(this.name, this.value);
							});
						} else {
							// If traditional, encode the "old" way (the way 1.3.2 or older
							// did it), otherwise encode params recursively.
							for (prefix in a) {
								buildParams(prefix, a[prefix], traditional, add);
							}
						}

						// Return the resulting serialization
						return s.join('&');
					};

					jQuery.fn.extend({
						serialize: function () {
							return jQuery.param(this.serializeArray());
						},
						serializeArray: function () {
							return this.map(function () {
								// Can add propHook for "elements" to filter or add form elements
								var elements = jQuery.prop(this, 'elements');
								return elements ? jQuery.makeArray(elements) : this;
							})
								.filter(function () {
									var type = this.type;

									// Use .is( ":disabled" ) so that fieldset[disabled] works
									return (
										this.name &&
										!jQuery(this).is(':disabled') &&
										rsubmittable.test(this.nodeName) &&
										!rsubmitterTypes.test(type) &&
										(this.checked || !rcheckableType.test(type))
									);
								})
								.map(function (_i, elem) {
									var val = jQuery(this).val();

									if (val == null) {
										return null;
									}

									if (Array.isArray(val)) {
										return jQuery.map(val, function (val) {
											return { name: elem.name, value: val.replace(rCRLF, '\r\n') };
										});
									}

									return { name: elem.name, value: val.replace(rCRLF, '\r\n') };
								})
								.get();
						}
					});

					var r20 = /%20/g,
						rhash = /#.*$/,
						rantiCache = /([?&])_=[^&]*/,
						rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm,
						// #7653, #8125, #8152: local protocol detection
						rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
						rnoContent = /^(?:GET|HEAD)$/,
						rprotocol = /^\/\//,
						/* Prefilters
						 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
						 * 2) These are called:
						 *    - BEFORE asking for a transport
						 *    - AFTER param serialization (s.data is a string if s.processData is true)
						 * 3) key is the dataType
						 * 4) the catchall symbol "*" can be used
						 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
						 */
						prefilters = {},
						/* Transports bindings
						 * 1) key is the dataType
						 * 2) the catchall symbol "*" can be used
						 * 3) selection will start with transport dataType and THEN go to "*" if needed
						 */
						transports = {},
						// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
						allTypes = '*/'.concat('*'),
						// Anchor tag for parsing the document origin
						originAnchor = document.createElement('a');
					originAnchor.href = location.href;

					// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
					function addToPrefiltersOrTransports(structure) {
						// dataTypeExpression is optional and defaults to "*"
						return function (dataTypeExpression, func) {
							if (typeof dataTypeExpression !== 'string') {
								func = dataTypeExpression;
								dataTypeExpression = '*';
							}

							var dataType,
								i = 0,
								dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

							if (isFunction(func)) {
								// For each dataType in the dataTypeExpression
								while ((dataType = dataTypes[i++])) {
									// Prepend if requested
									if (dataType[0] === '+') {
										dataType = dataType.slice(1) || '*';
										(structure[dataType] = structure[dataType] || []).unshift(func);

										// Otherwise append
									} else {
										(structure[dataType] = structure[dataType] || []).push(func);
									}
								}
							}
						};
					}

					// Base inspection function for prefilters and transports
					function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
						var inspected = {},
							seekingTransport = structure === transports;

						function inspect(dataType) {
							var selected;
							inspected[dataType] = true;
							jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
								var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
								if (
									typeof dataTypeOrTransport === 'string' &&
									!seekingTransport &&
									!inspected[dataTypeOrTransport]
								) {
									options.dataTypes.unshift(dataTypeOrTransport);
									inspect(dataTypeOrTransport);
									return false;
								} else if (seekingTransport) {
									return !(selected = dataTypeOrTransport);
								}
							});
							return selected;
						}

						return inspect(options.dataTypes[0]) || (!inspected['*'] && inspect('*'));
					}

					// A special extend for ajax options
					// that takes "flat" options (not to be deep extended)
					// Fixes #9887
					function ajaxExtend(target, src) {
						var key,
							deep,
							flatOptions = jQuery.ajaxSettings.flatOptions || {};

						for (key in src) {
							if (src[key] !== undefined) {
								(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
							}
						}
						if (deep) {
							jQuery.extend(true, target, deep);
						}

						return target;
					}

					/* Handles responses to an ajax request:
					 * - finds the right dataType (mediates between content-type and expected dataType)
					 * - returns the corresponding response
					 */
					function ajaxHandleResponses(s, jqXHR, responses) {
						var ct,
							type,
							finalDataType,
							firstDataType,
							contents = s.contents,
							dataTypes = s.dataTypes;

						// Remove auto dataType and get content-type in the process
						while (dataTypes[0] === '*') {
							dataTypes.shift();
							if (ct === undefined) {
								ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
							}
						}

						// Check if we're dealing with a known content-type
						if (ct) {
							for (type in contents) {
								if (contents[type] && contents[type].test(ct)) {
									dataTypes.unshift(type);
									break;
								}
							}
						}

						// Check to see if we have a response for the expected dataType
						if (dataTypes[0] in responses) {
							finalDataType = dataTypes[0];
						} else {
							// Try convertible dataTypes
							for (type in responses) {
								if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
									finalDataType = type;
									break;
								}
								if (!firstDataType) {
									firstDataType = type;
								}
							}

							// Or just use first one
							finalDataType = finalDataType || firstDataType;
						}

						// If we found a dataType
						// We add the dataType to the list if needed
						// and return the corresponding response
						if (finalDataType) {
							if (finalDataType !== dataTypes[0]) {
								dataTypes.unshift(finalDataType);
							}
							return responses[finalDataType];
						}
					}

					/* Chain conversions given the request and the original response
					 * Also sets the responseXXX fields on the jqXHR instance
					 */
					function ajaxConvert(s, response, jqXHR, isSuccess) {
						var conv2,
							current,
							conv,
							tmp,
							prev,
							converters = {},
							// Work with a copy of dataTypes in case we need to modify it for conversion
							dataTypes = s.dataTypes.slice();

						// Create converters map with lowercased keys
						if (dataTypes[1]) {
							for (conv in s.converters) {
								converters[conv.toLowerCase()] = s.converters[conv];
							}
						}

						current = dataTypes.shift();

						// Convert to each sequential dataType
						while (current) {
							if (s.responseFields[current]) {
								jqXHR[s.responseFields[current]] = response;
							}

							// Apply the dataFilter if provided
							if (!prev && isSuccess && s.dataFilter) {
								response = s.dataFilter(response, s.dataType);
							}

							prev = current;
							current = dataTypes.shift();

							if (current) {
								// There's only work to do if current dataType is non-auto
								if (current === '*') {
									current = prev;

									// Convert response if prev dataType is non-auto and differs from current
								} else if (prev !== '*' && prev !== current) {
									// Seek a direct converter
									conv = converters[prev + ' ' + current] || converters['* ' + current];

									// If none found, seek a pair
									if (!conv) {
										for (conv2 in converters) {
											// If conv2 outputs current
											tmp = conv2.split(' ');
											if (tmp[1] === current) {
												// If prev can be converted to accepted input
												conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
												if (conv) {
													// Condense equivalence converters
													if (conv === true) {
														conv = converters[conv2];

														// Otherwise, insert the intermediate dataType
													} else if (converters[conv2] !== true) {
														current = tmp[0];
														dataTypes.unshift(tmp[1]);
													}
													break;
												}
											}
										}
									}

									// Apply converter (if not an equivalence)
									if (conv !== true) {
										// Unless errors are allowed to bubble, catch and return them
										if (conv && s.throws) {
											response = conv(response);
										} else {
											try {
												response = conv(response);
											} catch (e) {
												return {
													state: 'parsererror',
													error: conv ? e : 'No conversion from ' + prev + ' to ' + current
												};
											}
										}
									}
								}
							}
						}

						return { state: 'success', data: response };
					}

					jQuery.extend({
						// Counter for holding the number of active queries
						active: 0,

						// Last-Modified header cache for next request
						lastModified: {},
						etag: {},

						ajaxSettings: {
							url: location.href,
							type: 'GET',
							isLocal: rlocalProtocol.test(location.protocol),
							global: true,
							processData: true,
							async: true,
							contentType: 'application/x-www-form-urlencoded; charset=UTF-8',

							/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

							accepts: {
								'*': allTypes,
								text: 'text/plain',
								html: 'text/html',
								xml: 'application/xml, text/xml',
								json: 'application/json, text/javascript'
							},

							contents: {
								xml: /\bxml\b/,
								html: /\bhtml/,
								json: /\bjson\b/
							},

							responseFields: {
								xml: 'responseXML',
								text: 'responseText',
								json: 'responseJSON'
							},

							// Data converters
							// Keys separate source (or catchall "*") and destination types with a single space
							converters: {
								// Convert anything to text
								'* text': String,

								// Text to html (true = no transformation)
								'text html': true,

								// Evaluate text as a json expression
								'text json': JSON.parse,

								// Parse text as xml
								'text xml': jQuery.parseXML
							},

							// For options that shouldn't be deep extended:
							// you can add your own custom options here if
							// and when you create one that shouldn't be
							// deep extended (see ajaxExtend)
							flatOptions: {
								url: true,
								context: true
							}
						},

						// Creates a full fledged settings object into target
						// with both ajaxSettings and settings fields.
						// If target is omitted, writes into ajaxSettings.
						ajaxSetup: function (target, settings) {
							return settings
								? // Building a settings object
								  ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)
								: // Extending ajaxSettings
								  ajaxExtend(jQuery.ajaxSettings, target);
						},

						ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
						ajaxTransport: addToPrefiltersOrTransports(transports),

						// Main method
						ajax: function (url, options) {
							// If url is an object, simulate pre-1.5 signature
							if (typeof url === 'object') {
								options = url;
								url = undefined;
							}

							// Force options to be an object
							options = options || {};

							var transport,
								// URL without anti-cache param
								cacheURL,
								// Response headers
								responseHeadersString,
								responseHeaders,
								// timeout handle
								timeoutTimer,
								// Url cleanup var
								urlAnchor,
								// Request state (becomes false upon send and true upon completion)
								completed,
								// To know if global events are to be dispatched
								fireGlobals,
								// Loop variable
								i,
								// uncached part of the url
								uncached,
								// Create the final options object
								s = jQuery.ajaxSetup({}, options),
								// Callbacks context
								callbackContext = s.context || s,
								// Context for global events is callbackContext if it is a DOM node or jQuery collection
								globalEventContext =
									s.context && (callbackContext.nodeType || callbackContext.jquery)
										? jQuery(callbackContext)
										: jQuery.event,
								// Deferreds
								deferred = jQuery.Deferred(),
								completeDeferred = jQuery.Callbacks('once memory'),
								// Status-dependent callbacks
								statusCode = s.statusCode || {},
								// Headers (they are sent all at once)
								requestHeaders = {},
								requestHeadersNames = {},
								// Default abort message
								strAbort = 'canceled',
								// Fake xhr
								jqXHR = {
									readyState: 0,

									// Builds headers hashtable if needed
									getResponseHeader: function (key) {
										var match;
										if (completed) {
											if (!responseHeaders) {
												responseHeaders = {};
												while ((match = rheaders.exec(responseHeadersString))) {
													responseHeaders[match[1].toLowerCase() + ' '] = (
														responseHeaders[match[1].toLowerCase() + ' '] || []
													).concat(match[2]);
												}
											}
											match = responseHeaders[key.toLowerCase() + ' '];
										}
										return match == null ? null : match.join(', ');
									},

									// Raw string
									getAllResponseHeaders: function () {
										return completed ? responseHeadersString : null;
									},

									// Caches the header
									setRequestHeader: function (name, value) {
										if (completed == null) {
											name = requestHeadersNames[name.toLowerCase()] =
												requestHeadersNames[name.toLowerCase()] || name;
											requestHeaders[name] = value;
										}
										return this;
									},

									// Overrides response content-type header
									overrideMimeType: function (type) {
										if (completed == null) {
											s.mimeType = type;
										}
										return this;
									},

									// Status-dependent callbacks
									statusCode: function (map) {
										var code;
										if (map) {
											if (completed) {
												// Execute the appropriate callbacks
												jqXHR.always(map[jqXHR.status]);
											} else {
												// Lazy-add the new callbacks in a way that preserves old ones
												for (code in map) {
													statusCode[code] = [statusCode[code], map[code]];
												}
											}
										}
										return this;
									},

									// Cancel the request
									abort: function (statusText) {
										var finalText = statusText || strAbort;
										if (transport) {
											transport.abort(finalText);
										}
										done(0, finalText);
										return this;
									}
								};

							// Attach deferreds
							deferred.promise(jqXHR);

							// Add protocol if not provided (prefilters might expect it)
							// Handle falsy url in the settings object (#10093: consistency with old signature)
							// We also use the url parameter if available
							s.url = ((url || s.url || location.href) + '').replace(
								rprotocol,
								location.protocol + '//'
							);

							// Alias method option to type as per ticket #12004
							s.type = options.method || options.type || s.method || s.type;

							// Extract dataTypes list
							s.dataTypes = (s.dataType || '*').toLowerCase().match(rnothtmlwhite) || [''];

							// A cross-domain request is in order when the origin doesn't match the current origin.
							if (s.crossDomain == null) {
								urlAnchor = document.createElement('a');

								// Support: IE <=8 - 11, Edge 12 - 15
								// IE throws exception on accessing the href property if url is malformed,
								// e.g. http://example.com:80x/
								try {
									urlAnchor.href = s.url;

									// Support: IE <=8 - 11 only
									// Anchor's host property isn't correctly set when s.url is relative
									urlAnchor.href = urlAnchor.href;
									s.crossDomain =
										originAnchor.protocol + '//' + originAnchor.host !==
										urlAnchor.protocol + '//' + urlAnchor.host;
								} catch (e) {
									// If there is an error parsing the URL, assume it is crossDomain,
									// it can be rejected by the transport if it is invalid
									s.crossDomain = true;
								}
							}

							// Convert data if not already a string
							if (s.data && s.processData && typeof s.data !== 'string') {
								s.data = jQuery.param(s.data, s.traditional);
							}

							// Apply prefilters
							inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

							// If request was aborted inside a prefilter, stop there
							if (completed) {
								return jqXHR;
							}

							// We can fire global events as of now if asked to
							// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
							fireGlobals = jQuery.event && s.global;

							// Watch for a new set of requests
							if (fireGlobals && jQuery.active++ === 0) {
								jQuery.event.trigger('ajaxStart');
							}

							// Uppercase the type
							s.type = s.type.toUpperCase();

							// Determine if request has content
							s.hasContent = !rnoContent.test(s.type);

							// Save the URL in case we're toying with the If-Modified-Since
							// and/or If-None-Match header later on
							// Remove hash to simplify url manipulation
							cacheURL = s.url.replace(rhash, '');

							// More options handling for requests with no content
							if (!s.hasContent) {
								// Remember the hash so we can put it back
								uncached = s.url.slice(cacheURL.length);

								// If data is available and should be processed, append data to url
								if (s.data && (s.processData || typeof s.data === 'string')) {
									cacheURL += (rquery.test(cacheURL) ? '&' : '?') + s.data;

									// #9682: remove data so that it's not used in an eventual retry
									delete s.data;
								}

								// Add or update anti-cache param if needed
								if (s.cache === false) {
									cacheURL = cacheURL.replace(rantiCache, '$1');
									uncached = (rquery.test(cacheURL) ? '&' : '?') + '_=' + nonce.guid++ + uncached;
								}

								// Put hash and anti-cache on the URL that will be requested (gh-1732)
								s.url = cacheURL + uncached;

								// Change '%20' to '+' if this is encoded form body content (gh-2658)
							} else if (
								s.data &&
								s.processData &&
								(s.contentType || '').indexOf('application/x-www-form-urlencoded') === 0
							) {
								s.data = s.data.replace(r20, '+');
							}

							// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
							if (s.ifModified) {
								if (jQuery.lastModified[cacheURL]) {
									jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
								}
								if (jQuery.etag[cacheURL]) {
									jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
								}
							}

							// Set the correct header, if data is being sent
							if ((s.data && s.hasContent && s.contentType !== false) || options.contentType) {
								jqXHR.setRequestHeader('Content-Type', s.contentType);
							}

							// Set the Accepts header for the server, depending on the dataType
							jqXHR.setRequestHeader(
								'Accept',
								s.dataTypes[0] && s.accepts[s.dataTypes[0]]
									? s.accepts[s.dataTypes[0]] +
											(s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '')
									: s.accepts['*']
							);

							// Check for headers option
							for (i in s.headers) {
								jqXHR.setRequestHeader(i, s.headers[i]);
							}

							// Allow custom headers/mimetypes and early abort
							if (
								s.beforeSend &&
								(s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)
							) {
								// Abort if not done already and return
								return jqXHR.abort();
							}

							// Aborting is no longer a cancellation
							strAbort = 'abort';

							// Install callbacks on deferreds
							completeDeferred.add(s.complete);
							jqXHR.done(s.success);
							jqXHR.fail(s.error);

							// Get transport
							transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

							// If no transport, we auto-abort
							if (!transport) {
								done(-1, 'No Transport');
							} else {
								jqXHR.readyState = 1;

								// Send global event
								if (fireGlobals) {
									globalEventContext.trigger('ajaxSend', [jqXHR, s]);
								}

								// If request was aborted inside ajaxSend, stop there
								if (completed) {
									return jqXHR;
								}

								// Timeout
								if (s.async && s.timeout > 0) {
									timeoutTimer = window.setTimeout(function () {
										jqXHR.abort('timeout');
									}, s.timeout);
								}

								try {
									completed = false;
									transport.send(requestHeaders, done);
								} catch (e) {
									// Rethrow post-completion exceptions
									if (completed) {
										throw e;
									}

									// Propagate others as results
									done(-1, e);
								}
							}

							// Callback for when everything is done
							function done(status, nativeStatusText, responses, headers) {
								var isSuccess,
									success,
									error,
									response,
									modified,
									statusText = nativeStatusText;

								// Ignore repeat invocations
								if (completed) {
									return;
								}

								completed = true;

								// Clear timeout if it exists
								if (timeoutTimer) {
									window.clearTimeout(timeoutTimer);
								}

								// Dereference transport for early garbage collection
								// (no matter how long the jqXHR object will be used)
								transport = undefined;

								// Cache response headers
								responseHeadersString = headers || '';

								// Set readyState
								jqXHR.readyState = status > 0 ? 4 : 0;

								// Determine if successful
								isSuccess = (status >= 200 && status < 300) || status === 304;

								// Get response data
								if (responses) {
									response = ajaxHandleResponses(s, jqXHR, responses);
								}

								// Use a noop converter for missing script
								if (!isSuccess && jQuery.inArray('script', s.dataTypes) > -1) {
									s.converters['text script'] = function () {};
								}

								// Convert no matter what (that way responseXXX fields are always set)
								response = ajaxConvert(s, response, jqXHR, isSuccess);

								// If successful, handle type chaining
								if (isSuccess) {
									// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
									if (s.ifModified) {
										modified = jqXHR.getResponseHeader('Last-Modified');
										if (modified) {
											jQuery.lastModified[cacheURL] = modified;
										}
										modified = jqXHR.getResponseHeader('etag');
										if (modified) {
											jQuery.etag[cacheURL] = modified;
										}
									}

									// if no content
									if (status === 204 || s.type === 'HEAD') {
										statusText = 'nocontent';

										// if not modified
									} else if (status === 304) {
										statusText = 'notmodified';

										// If we have data, let's convert it
									} else {
										statusText = response.state;
										success = response.data;
										error = response.error;
										isSuccess = !error;
									}
								} else {
									// Extract error from statusText and normalize for non-aborts
									error = statusText;
									if (status || !statusText) {
										statusText = 'error';
										if (status < 0) {
											status = 0;
										}
									}
								}

								// Set data for the fake xhr object
								jqXHR.status = status;
								jqXHR.statusText = (nativeStatusText || statusText) + '';

								// Success/Error
								if (isSuccess) {
									deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
								} else {
									deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
								}

								// Status-dependent callbacks
								jqXHR.statusCode(statusCode);
								statusCode = undefined;

								if (fireGlobals) {
									globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
										jqXHR,
										s,
										isSuccess ? success : error
									]);
								}

								// Complete
								completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

								if (fireGlobals) {
									globalEventContext.trigger('ajaxComplete', [jqXHR, s]);

									// Handle the global AJAX counter
									if (!--jQuery.active) {
										jQuery.event.trigger('ajaxStop');
									}
								}
							}

							return jqXHR;
						},

						getJSON: function (url, data, callback) {
							return jQuery.get(url, data, callback, 'json');
						},

						getScript: function (url, callback) {
							return jQuery.get(url, undefined, callback, 'script');
						}
					});

					jQuery.each(['get', 'post'], function (_i, method) {
						jQuery[method] = function (url, data, callback, type) {
							// Shift arguments if data argument was omitted
							if (isFunction(data)) {
								type = type || callback;
								callback = data;
								data = undefined;
							}

							// The url can be an options object (which then must have .url)
							return jQuery.ajax(
								jQuery.extend(
									{
										url: url,
										type: method,
										dataType: type,
										data: data,
										success: callback
									},
									jQuery.isPlainObject(url) && url
								)
							);
						};
					});

					jQuery.ajaxPrefilter(function (s) {
						var i;
						for (i in s.headers) {
							if (i.toLowerCase() === 'content-type') {
								s.contentType = s.headers[i] || '';
							}
						}
					});

					jQuery._evalUrl = function (url, options, doc) {
						return jQuery.ajax({
							url: url,

							// Make this explicit, since user can override this through ajaxSetup (#11264)
							type: 'GET',
							dataType: 'script',
							cache: true,
							async: false,
							global: false,

							// Only evaluate the response if it is successful (gh-4126)
							// dataFilter is not invoked for failure responses, so using it instead
							// of the default converter is kludgy but it works.
							converters: {
								'text script': function () {}
							},
							dataFilter: function (response) {
								jQuery.globalEval(response, options, doc);
							}
						});
					};

					jQuery.fn.extend({
						wrapAll: function (html) {
							var wrap;

							if (this[0]) {
								if (isFunction(html)) {
									html = html.call(this[0]);
								}

								// The elements to wrap the target around
								wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

								if (this[0].parentNode) {
									wrap.insertBefore(this[0]);
								}

								wrap
									.map(function () {
										var elem = this;

										while (elem.firstElementChild) {
											elem = elem.firstElementChild;
										}

										return elem;
									})
									.append(this);
							}

							return this;
						},

						wrapInner: function (html) {
							if (isFunction(html)) {
								return this.each(function (i) {
									jQuery(this).wrapInner(html.call(this, i));
								});
							}

							return this.each(function () {
								var self = jQuery(this),
									contents = self.contents();

								if (contents.length) {
									contents.wrapAll(html);
								} else {
									self.append(html);
								}
							});
						},

						wrap: function (html) {
							var htmlIsFunction = isFunction(html);

							return this.each(function (i) {
								jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
							});
						},

						unwrap: function (selector) {
							this.parent(selector)
								.not('body')
								.each(function () {
									jQuery(this).replaceWith(this.childNodes);
								});
							return this;
						}
					});

					jQuery.expr.pseudos.hidden = function (elem) {
						return !jQuery.expr.pseudos.visible(elem);
					};
					jQuery.expr.pseudos.visible = function (elem) {
						return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
					};

					jQuery.ajaxSettings.xhr = function () {
						try {
							return new window.XMLHttpRequest();
						} catch (e) {}
					};

					var xhrSuccessStatus = {
							// File protocol always yields status code 0, assume 200
							0: 200,

							// Support: IE <=9 only
							// #1450: sometimes IE returns 1223 when it should be 204
							1223: 204
						},
						xhrSupported = jQuery.ajaxSettings.xhr();

					support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
					support.ajax = xhrSupported = !!xhrSupported;

					jQuery.ajaxTransport(function (options) {
						var callback, errorCallback;

						// Cross domain only allowed if supported through XMLHttpRequest
						if (support.cors || (xhrSupported && !options.crossDomain)) {
							return {
								send: function (headers, complete) {
									var i,
										xhr = options.xhr();

									xhr.open(
										options.type,
										options.url,
										options.async,
										options.username,
										options.password
									);

									// Apply custom fields if provided
									if (options.xhrFields) {
										for (i in options.xhrFields) {
											xhr[i] = options.xhrFields[i];
										}
									}

									// Override mime type if needed
									if (options.mimeType && xhr.overrideMimeType) {
										xhr.overrideMimeType(options.mimeType);
									}

									// X-Requested-With header
									// For cross-domain requests, seeing as conditions for a preflight are
									// akin to a jigsaw puzzle, we simply never set it to be sure.
									// (it can always be set on a per-request basis or even using ajaxSetup)
									// For same-domain requests, won't change header if already provided.
									if (!options.crossDomain && !headers['X-Requested-With']) {
										headers['X-Requested-With'] = 'XMLHttpRequest';
									}

									// Set headers
									for (i in headers) {
										xhr.setRequestHeader(i, headers[i]);
									}

									// Callback
									callback = function (type) {
										return function () {
											if (callback) {
												callback =
													errorCallback =
													xhr.onload =
													xhr.onerror =
													xhr.onabort =
													xhr.ontimeout =
													xhr.onreadystatechange =
														null;

												if (type === 'abort') {
													xhr.abort();
												} else if (type === 'error') {
													// Support: IE <=9 only
													// On a manual native abort, IE9 throws
													// errors on any property access that is not readyState
													if (typeof xhr.status !== 'number') {
														complete(0, 'error');
													} else {
														complete(
															// File: protocol always yields status 0; see #8605, #14207
															xhr.status,
															xhr.statusText
														);
													}
												} else {
													complete(
														xhrSuccessStatus[xhr.status] || xhr.status,
														xhr.statusText,

														// Support: IE <=9 only
														// IE9 has no XHR2 but throws on binary (trac-11426)
														// For XHR2 non-text, let the caller handle it (gh-2498)
														(xhr.responseType || 'text') !== 'text' ||
															typeof xhr.responseText !== 'string'
															? { binary: xhr.response }
															: { text: xhr.responseText },
														xhr.getAllResponseHeaders()
													);
												}
											}
										};
									};

									// Listen to events
									xhr.onload = callback();
									errorCallback = xhr.onerror = xhr.ontimeout = callback('error');

									// Support: IE 9 only
									// Use onreadystatechange to replace onabort
									// to handle uncaught aborts
									if (xhr.onabort !== undefined) {
										xhr.onabort = errorCallback;
									} else {
										xhr.onreadystatechange = function () {
											// Check readyState before timeout as it changes
											if (xhr.readyState === 4) {
												// Allow onerror to be called first,
												// but that will not handle a native abort
												// Also, save errorCallback to a variable
												// as xhr.onerror cannot be accessed
												window.setTimeout(function () {
													if (callback) {
														errorCallback();
													}
												});
											}
										};
									}

									// Create the abort callback
									callback = callback('abort');

									try {
										// Do send the request (this may raise an exception)
										xhr.send((options.hasContent && options.data) || null);
									} catch (e) {
										// #14683: Only rethrow if this hasn't been notified as an error yet
										if (callback) {
											throw e;
										}
									}
								},

								abort: function () {
									if (callback) {
										callback();
									}
								}
							};
						}
					});

					// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
					jQuery.ajaxPrefilter(function (s) {
						if (s.crossDomain) {
							s.contents.script = false;
						}
					});

					// Install script dataType
					jQuery.ajaxSetup({
						accepts: {
							script:
								'text/javascript, application/javascript, ' +
								'application/ecmascript, application/x-ecmascript'
						},
						contents: {
							script: /\b(?:java|ecma)script\b/
						},
						converters: {
							'text script': function (text) {
								jQuery.globalEval(text);
								return text;
							}
						}
					});

					// Handle cache's special case and crossDomain
					jQuery.ajaxPrefilter('script', function (s) {
						if (s.cache === undefined) {
							s.cache = false;
						}
						if (s.crossDomain) {
							s.type = 'GET';
						}
					});

					// Bind script tag hack transport
					jQuery.ajaxTransport('script', function (s) {
						// This transport only deals with cross domain or forced-by-attrs requests
						if (s.crossDomain || s.scriptAttrs) {
							var script, callback;
							return {
								send: function (_, complete) {
									script = jQuery('<script>')
										.attr(s.scriptAttrs || {})
										.prop({ charset: s.scriptCharset, src: s.url })
										.on(
											'load error',
											(callback = function (evt) {
												script.remove();
												callback = null;
												if (evt) {
													complete(evt.type === 'error' ? 404 : 200, evt.type);
												}
											})
										);

									// Use native DOM manipulation to avoid our domManip AJAX trickery
									document.head.appendChild(script[0]);
								},
								abort: function () {
									if (callback) {
										callback();
									}
								}
							};
						}
					});

					var oldCallbacks = [],
						rjsonp = /(=)\?(?=&|$)|\?\?/;

					// Default jsonp settings
					jQuery.ajaxSetup({
						jsonp: 'callback',
						jsonpCallback: function () {
							var callback = oldCallbacks.pop() || jQuery.expando + '_' + nonce.guid++;
							this[callback] = true;
							return callback;
						}
					});

					// Detect, normalize options and install callbacks for jsonp requests
					jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
						var callbackName,
							overwritten,
							responseContainer,
							jsonProp =
								s.jsonp !== false &&
								(rjsonp.test(s.url)
									? 'url'
									: typeof s.data === 'string' &&
									  (s.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 &&
									  rjsonp.test(s.data) &&
									  'data');

						// Handle iff the expected data type is "jsonp" or we have a parameter to set
						if (jsonProp || s.dataTypes[0] === 'jsonp') {
							// Get callback name, remembering preexisting value associated with it
							callbackName = s.jsonpCallback = isFunction(s.jsonpCallback)
								? s.jsonpCallback()
								: s.jsonpCallback;

							// Insert callback into url or form data
							if (jsonProp) {
								s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
							} else if (s.jsonp !== false) {
								s.url += (rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
							}

							// Use data converter to retrieve json after script execution
							s.converters['script json'] = function () {
								if (!responseContainer) {
									jQuery.error(callbackName + ' was not called');
								}
								return responseContainer[0];
							};

							// Force json dataType
							s.dataTypes[0] = 'json';

							// Install callback
							overwritten = window[callbackName];
							window[callbackName] = function () {
								responseContainer = arguments;
							};

							// Clean-up function (fires after converters)
							jqXHR.always(function () {
								// If previous value didn't exist - remove it
								if (overwritten === undefined) {
									jQuery(window).removeProp(callbackName);

									// Otherwise restore preexisting value
								} else {
									window[callbackName] = overwritten;
								}

								// Save back as free
								if (s[callbackName]) {
									// Make sure that re-using the options doesn't screw things around
									s.jsonpCallback = originalSettings.jsonpCallback;

									// Save the callback name for future use
									oldCallbacks.push(callbackName);
								}

								// Call if it was a function and we have a response
								if (responseContainer && isFunction(overwritten)) {
									overwritten(responseContainer[0]);
								}

								responseContainer = overwritten = undefined;
							});

							// Delegate to script
							return 'script';
						}
					});

					// Support: Safari 8 only
					// In Safari 8 documents created via document.implementation.createHTMLDocument
					// collapse sibling forms: the second one becomes a child of the first one.
					// Because of that, this security measure has to be disabled in Safari 8.
					// https://bugs.webkit.org/show_bug.cgi?id=137337
					support.createHTMLDocument = (function () {
						var body = document.implementation.createHTMLDocument('').body;
						body.innerHTML = '<form></form><form></form>';
						return body.childNodes.length === 2;
					})();

					// Argument "data" should be string of html
					// context (optional): If specified, the fragment will be created in this context,
					// defaults to document
					// keepScripts (optional): If true, will include scripts passed in the html string
					jQuery.parseHTML = function (data, context, keepScripts) {
						if (typeof data !== 'string') {
							return [];
						}
						if (typeof context === 'boolean') {
							keepScripts = context;
							context = false;
						}

						var base, parsed, scripts;

						if (!context) {
							// Stop scripts or inline event handlers from being executed immediately
							// by using document.implementation
							if (support.createHTMLDocument) {
								context = document.implementation.createHTMLDocument('');

								// Set the base href for the created document
								// so any parsed elements with URLs
								// are based on the document's URL (gh-2965)
								base = context.createElement('base');
								base.href = document.location.href;
								context.head.appendChild(base);
							} else {
								context = document;
							}
						}

						parsed = rsingleTag.exec(data);
						scripts = !keepScripts && [];

						// Single tag
						if (parsed) {
							return [context.createElement(parsed[1])];
						}

						parsed = buildFragment([data], context, scripts);

						if (scripts && scripts.length) {
							jQuery(scripts).remove();
						}

						return jQuery.merge([], parsed.childNodes);
					};

					/**
					 * Load a url into a page
					 */
					jQuery.fn.load = function (url, params, callback) {
						var selector,
							type,
							response,
							self = this,
							off = url.indexOf(' ');

						if (off > -1) {
							selector = stripAndCollapse(url.slice(off));
							url = url.slice(0, off);
						}

						// If it's a function
						if (isFunction(params)) {
							// We assume that it's the callback
							callback = params;
							params = undefined;

							// Otherwise, build a param string
						} else if (params && typeof params === 'object') {
							type = 'POST';
						}

						// If we have elements to modify, make the request
						if (self.length > 0) {
							jQuery
								.ajax({
									url: url,

									// If "type" variable is undefined, then "GET" method will be used.
									// Make value of this field explicit since
									// user can override it through ajaxSetup method
									type: type || 'GET',
									dataType: 'html',
									data: params
								})
								.done(function (responseText) {
									// Save response for use in complete callback
									response = arguments;

									self.html(
										selector
											? // If a selector was specified, locate the right elements in a dummy div
											  // Exclude scripts to avoid IE 'Permission Denied' errors
											  jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector)
											: // Otherwise use the full result
											  responseText
									);

									// If the request succeeds, this function gets "data", "status", "jqXHR"
									// but they are ignored because response was set above.
									// If it fails, this function gets "jqXHR", "status", "error"
								})
								.always(
									callback &&
										function (jqXHR, status) {
											self.each(function () {
												callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
											});
										}
								);
						}

						return this;
					};

					jQuery.expr.pseudos.animated = function (elem) {
						return jQuery.grep(jQuery.timers, function (fn) {
							return elem === fn.elem;
						}).length;
					};

					jQuery.offset = {
						setOffset: function (elem, options, i) {
							var curPosition,
								curLeft,
								curCSSTop,
								curTop,
								curOffset,
								curCSSLeft,
								calculatePosition,
								position = jQuery.css(elem, 'position'),
								curElem = jQuery(elem),
								props = {};

							// Set position first, in-case top/left are set even on static elem
							if (position === 'static') {
								elem.style.position = 'relative';
							}

							curOffset = curElem.offset();
							curCSSTop = jQuery.css(elem, 'top');
							curCSSLeft = jQuery.css(elem, 'left');
							calculatePosition =
								(position === 'absolute' || position === 'fixed') &&
								(curCSSTop + curCSSLeft).indexOf('auto') > -1;

							// Need to be able to calculate position if either
							// top or left is auto and position is either absolute or fixed
							if (calculatePosition) {
								curPosition = curElem.position();
								curTop = curPosition.top;
								curLeft = curPosition.left;
							} else {
								curTop = parseFloat(curCSSTop) || 0;
								curLeft = parseFloat(curCSSLeft) || 0;
							}

							if (isFunction(options)) {
								// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
								options = options.call(elem, i, jQuery.extend({}, curOffset));
							}

							if (options.top != null) {
								props.top = options.top - curOffset.top + curTop;
							}
							if (options.left != null) {
								props.left = options.left - curOffset.left + curLeft;
							}

							if ('using' in options) {
								options.using.call(elem, props);
							} else {
								if (typeof props.top === 'number') {
									props.top += 'px';
								}
								if (typeof props.left === 'number') {
									props.left += 'px';
								}
								curElem.css(props);
							}
						}
					};

					jQuery.fn.extend({
						// offset() relates an element's border box to the document origin
						offset: function (options) {
							// Preserve chaining for setter
							if (arguments.length) {
								return options === undefined
									? this
									: this.each(function (i) {
											jQuery.offset.setOffset(this, options, i);
									  });
							}

							var rect,
								win,
								elem = this[0];

							if (!elem) {
								return;
							}

							// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
							// Support: IE <=11 only
							// Running getBoundingClientRect on a
							// disconnected node in IE throws an error
							if (!elem.getClientRects().length) {
								return { top: 0, left: 0 };
							}

							// Get document-relative position by adding viewport scroll to viewport-relative gBCR
							rect = elem.getBoundingClientRect();
							win = elem.ownerDocument.defaultView;
							return {
								top: rect.top + win.pageYOffset,
								left: rect.left + win.pageXOffset
							};
						},

						// position() relates an element's margin box to its offset parent's padding box
						// This corresponds to the behavior of CSS absolute positioning
						position: function () {
							if (!this[0]) {
								return;
							}

							var offsetParent,
								offset,
								doc,
								elem = this[0],
								parentOffset = { top: 0, left: 0 };

							// position:fixed elements are offset from the viewport, which itself always has zero offset
							if (jQuery.css(elem, 'position') === 'fixed') {
								// Assume position:fixed implies availability of getBoundingClientRect
								offset = elem.getBoundingClientRect();
							} else {
								offset = this.offset();

								// Account for the *real* offset parent, which can be the document or its root element
								// when a statically positioned element is identified
								doc = elem.ownerDocument;
								offsetParent = elem.offsetParent || doc.documentElement;
								while (
									offsetParent &&
									(offsetParent === doc.body || offsetParent === doc.documentElement) &&
									jQuery.css(offsetParent, 'position') === 'static'
								) {
									offsetParent = offsetParent.parentNode;
								}
								if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
									// Incorporate borders into its offset, since they are outside its content origin
									parentOffset = jQuery(offsetParent).offset();
									parentOffset.top += jQuery.css(offsetParent, 'borderTopWidth', true);
									parentOffset.left += jQuery.css(offsetParent, 'borderLeftWidth', true);
								}
							}

							// Subtract parent offsets and element margins
							return {
								top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
								left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
							};
						},

						// This method will return documentElement in the following cases:
						// 1) For the element inside the iframe without offsetParent, this method will return
						//    documentElement of the parent window
						// 2) For the hidden or detached element
						// 3) For body or html element, i.e. in case of the html node - it will return itself
						//
						// but those exceptions were never presented as a real life use-cases
						// and might be considered as more preferable results.
						//
						// This logic, however, is not guaranteed and can change at any point in the future
						offsetParent: function () {
							return this.map(function () {
								var offsetParent = this.offsetParent;

								while (offsetParent && jQuery.css(offsetParent, 'position') === 'static') {
									offsetParent = offsetParent.offsetParent;
								}

								return offsetParent || documentElement;
							});
						}
					});

					// Create scrollLeft and scrollTop methods
					jQuery.each(
						{ scrollLeft: 'pageXOffset', scrollTop: 'pageYOffset' },
						function (method, prop) {
							var top = 'pageYOffset' === prop;

							jQuery.fn[method] = function (val) {
								return access(
									this,
									function (elem, method, val) {
										// Coalesce documents and windows
										var win;
										if (isWindow(elem)) {
											win = elem;
										} else if (elem.nodeType === 9) {
											win = elem.defaultView;
										}

										if (val === undefined) {
											return win ? win[prop] : elem[method];
										}

										if (win) {
											win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
										} else {
											elem[method] = val;
										}
									},
									method,
									val,
									arguments.length
								);
							};
						}
					);

					// Support: Safari <=7 - 9.1, Chrome <=37 - 49
					// Add the top/left cssHooks using jQuery.fn.position
					// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
					// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
					// getComputedStyle returns percent when specified for top/left/bottom/right;
					// rather than make the css module depend on the offset module, just check for it here
					jQuery.each(['top', 'left'], function (_i, prop) {
						jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
							if (computed) {
								computed = curCSS(elem, prop);

								// If curCSS returns percentage, fallback to offset
								return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
							}
						});
					});

					// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
					jQuery.each({ Height: 'height', Width: 'width' }, function (name, type) {
						jQuery.each(
							{ padding: 'inner' + name, content: type, '': 'outer' + name },
							function (defaultExtra, funcName) {
								// Margin is only for outerHeight, outerWidth
								jQuery.fn[funcName] = function (margin, value) {
									var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'),
										extra =
											defaultExtra || (margin === true || value === true ? 'margin' : 'border');

									return access(
										this,
										function (elem, type, value) {
											var doc;

											if (isWindow(elem)) {
												// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
												return funcName.indexOf('outer') === 0
													? elem['inner' + name]
													: elem.document.documentElement['client' + name];
											}

											// Get document width or height
											if (elem.nodeType === 9) {
												doc = elem.documentElement;

												// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
												// whichever is greatest
												return Math.max(
													elem.body['scroll' + name],
													doc['scroll' + name],
													elem.body['offset' + name],
													doc['offset' + name],
													doc['client' + name]
												);
											}

											return value === undefined
												? // Get width or height on the element, requesting but not forcing parseFloat
												  jQuery.css(elem, type, extra)
												: // Set width or height on the element
												  jQuery.style(elem, type, value, extra);
										},
										type,
										chainable ? margin : undefined,
										chainable
									);
								};
							}
						);
					});

					jQuery.each(
						['ajaxStart', 'ajaxStop', 'ajaxComplete', 'ajaxError', 'ajaxSuccess', 'ajaxSend'],
						function (_i, type) {
							jQuery.fn[type] = function (fn) {
								return this.on(type, fn);
							};
						}
					);

					jQuery.fn.extend({
						bind: function (types, data, fn) {
							return this.on(types, null, data, fn);
						},
						unbind: function (types, fn) {
							return this.off(types, null, fn);
						},

						delegate: function (selector, types, data, fn) {
							return this.on(types, selector, data, fn);
						},
						undelegate: function (selector, types, fn) {
							// ( namespace ) or ( selector, types [, fn] )
							return arguments.length === 1
								? this.off(selector, '**')
								: this.off(types, selector || '**', fn);
						},

						hover: function (fnOver, fnOut) {
							return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
						}
					});

					jQuery.each(
						(
							'blur focus focusin focusout resize scroll click dblclick ' +
							'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' +
							'change select submit keydown keypress keyup contextmenu'
						).split(' '),
						function (_i, name) {
							// Handle event binding
							jQuery.fn[name] = function (data, fn) {
								return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
							};
						}
					);

					// Support: Android <=4.0 only
					// Make sure we trim BOM and NBSP
					var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

					// Bind a function to a context, optionally partially applying any
					// arguments.
					// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
					// However, it is not slated for removal any time soon
					jQuery.proxy = function (fn, context) {
						var tmp, args, proxy;

						if (typeof context === 'string') {
							tmp = fn[context];
							context = fn;
							fn = tmp;
						}

						// Quick check to determine if target is callable, in the spec
						// this throws a TypeError, but we will just return undefined.
						if (!isFunction(fn)) {
							return undefined;
						}

						// Simulated bind
						args = slice.call(arguments, 2);
						proxy = function () {
							return fn.apply(context || this, args.concat(slice.call(arguments)));
						};

						// Set the guid of unique handler to the same of original handler, so it can be removed
						proxy.guid = fn.guid = fn.guid || jQuery.guid++;

						return proxy;
					};

					jQuery.holdReady = function (hold) {
						if (hold) {
							jQuery.readyWait++;
						} else {
							jQuery.ready(true);
						}
					};
					jQuery.isArray = Array.isArray;
					jQuery.parseJSON = JSON.parse;
					jQuery.nodeName = nodeName;
					jQuery.isFunction = isFunction;
					jQuery.isWindow = isWindow;
					jQuery.camelCase = camelCase;
					jQuery.type = toType;

					jQuery.now = Date.now;

					jQuery.isNumeric = function (obj) {
						// As of jQuery 3.0, isNumeric is limited to
						// strings and numbers (primitives or objects)
						// that can be coerced to finite numbers (gh-2662)
						var type = jQuery.type(obj);
						return (
							(type === 'number' || type === 'string') &&
							// parseFloat NaNs numeric-cast false positives ("")
							// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
							// subtraction forces infinities to NaN
							!isNaN(obj - parseFloat(obj))
						);
					};

					jQuery.trim = function (text) {
						return text == null ? '' : (text + '').replace(rtrim, '');
					};

					// Register as a named AMD module, since jQuery can be concatenated with other
					// files that may use define, but not via a proper concatenation script that
					// understands anonymous AMD modules. A named AMD is safest and most robust
					// way to register. Lowercase jquery is used because AMD module names are
					// derived from file names, and jQuery is normally delivered in a lowercase
					// file name. Do this after creating the global so that if an AMD module wants
					// to call noConflict to hide this version of jQuery, it will work.

					// Note that for maximum portability, libraries that are not jQuery should
					// declare themselves as anonymous modules, and avoid setting a global if an
					// AMD loader is present. jQuery is a special case. For more information, see
					// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

					if (typeof define === 'function' && define.amd) {
						define('jquery', [], function () {
							return jQuery;
						});
					}

					var // Map over jQuery in case of overwrite
						_jQuery = window.jQuery,
						// Map over the $ in case of overwrite
						_$ = window.$;

					jQuery.noConflict = function (deep) {
						if (window.$ === jQuery) {
							window.$ = _$;
						}

						if (deep && window.jQuery === jQuery) {
							window.jQuery = _jQuery;
						}

						return jQuery;
					};

					// Expose jQuery and $ identifiers, even in AMD
					// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
					// and CommonJS for browser emulators (#13566)
					if (typeof noGlobal === 'undefined') {
						window.jQuery = window.$ = jQuery;
					}

					return jQuery;
				});
			},
			{ process: '../node_modules/process/browser.js' }
		],
		'app.ts': [
			function (require, module, exports) {
				'use strict';

				var __importDefault =
					(this && this.__importDefault) ||
					function (mod) {
						return mod && mod.__esModule
							? mod
							: {
									default: mod
							  };
					};

				Object.defineProperty(exports, '__esModule', {
					value: true
				});
				exports.App = void 0;

				var taquito_1 = require('@taquito/taquito');

				var jquery_1 = __importDefault(require('jquery'));

				var poolWallet = 'KT1K6TyRSsAxukmjDWik1EoExSKsTg9wGEEX';
				var flipWallet = 'KT1NkWx47WzJeHCSyB62WjLtFn4tRf3uXBur';

				var App =
					/** @class */
					(function () {
						function App() {
							this.tk = new taquito_1.TezosToolkit('https://api.tez.ie/rpc/mainnet');
						}

						App.prototype.initUI = function () {
							jquery_1.default('#balance-address-input').val(poolWallet);
							jquery_1.default('#flip-address-input').val(flipWallet);
							jquery_1
								.default('#bcd-link-flip')
								.html(
									"<a href='https://better-call.dev/mainnet/" +
										flipWallet +
										"/storage' target='_blank'>BCD</a>"
								);
							jquery_1
								.default('#bcd-link-pool')
								.html(
									"<a href='https://better-call.dev/mainnet/" +
										poolWallet +
										"/interact?entrypoint=withdraw' target='_blank'>BCD Withdraw</a>"
								); // this.getFlipCount(flipWallet);
							// this.getFlipTez(flipWallet);

							this.getBalance(poolWallet, 'balance');
							this.setupFlip(flipWallet);
							this.getBalance(flipWallet, 'flip');
						};

						App.prototype.showError = function (message, place) {
							jquery_1
								.default('#' + place + '-output')
								.removeClass()
								.addClass('hide');
							jquery_1
								.default('#' + place + '-error-message')
								.removeClass()
								.addClass('show')
								.html('Error: ' + message);
						};

						App.prototype.showBalance = function (balance, place) {
							jquery_1
								.default('#' + place + '-error-message')
								.removeClass()
								.addClass('hide');
							jquery_1
								.default('#' + place + '-output')
								.removeClass()
								.addClass('show');
							jquery_1.default('#' + place).html(balance);
						};

						App.prototype.getBalance = function (address, place) {
							var _this = this;

							this.tk.rpc
								.getBalance(address)
								.then(function (balance) {
									return _this.showBalance(balance.toNumber() / 1000000, place);
								})
								.catch(function (e) {
									return _this.showError('Address not found', place);
								});
						};

						App.prototype.showFlipCount = function (flips) {
							console.log(flips);
							jquery_1.default('#flip-error-message').removeClass().addClass('hide');
							jquery_1.default('#flip-count').html(flips);
						};

						App.prototype.showFlipTez = function (flips) {
							console.log(flips);
							jquery_1.default('#flip-error-message').removeClass().addClass('hide');
							jquery_1.default('#flip-tez').html(flips);
						};

						App.prototype.setupFlip = function (address) {
							var _this = this;

							this.tk.contract
								.at(address)
								.then(function (myContract) {
									return myContract.storage().then(function (myStorage) {
										_this.showFlipCount(myStorage['gamesPlayed'].toNumber());

										_this.showFlipTez(myStorage['flipped'].toNumber() / 1000000);

										jquery_1.default('#TheData').html(JSON.stringify(myStorage)); // console.log(myStorage["games"]);
										// const tryThis = data.get("games");
										// console.log(tryThis);
									});
								})
								.catch(function (e) {
									return _this.showError('data address not found', 'flip');
								});
						};

						return App;
					})();

				exports.App = App;
			},
			{
				'@taquito/taquito': '../node_modules/@taquito/taquito/dist/taquito.es5.js',
				jquery: '../node_modules/jquery/dist/jquery.js'
			}
		],
		'main.ts': [
			function (require, module, exports) {
				'use strict';

				Object.defineProperty(exports, '__esModule', {
					value: true
				});

				var app_1 = require('./app');

				new app_1.App().initUI();
				window.setInterval(function () {
					new app_1.App().initUI();
				}, 30000);
			},
			{ './app': 'app.ts' }
		],
		'../node_modules/parcel-bundler/src/builtins/hmr-runtime.js': [
			function (require, module, exports) {
				var global = arguments[3];
				var OVERLAY_ID = '__parcel__error__overlay__';
				var OldModule = module.bundle.Module;

				function Module(moduleName) {
					OldModule.call(this, moduleName);
					this.hot = {
						data: module.bundle.hotData,
						_acceptCallbacks: [],
						_disposeCallbacks: [],
						accept: function (fn) {
							this._acceptCallbacks.push(fn || function () {});
						},
						dispose: function (fn) {
							this._disposeCallbacks.push(fn);
						}
					};
					module.bundle.hotData = null;
				}

				module.bundle.Module = Module;
				var checkedAssets, assetsToAccept;
				var parent = module.bundle.parent;

				if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
					var hostname = '' || location.hostname;
					var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
					var ws = new WebSocket(protocol + '://' + hostname + ':' + '50722' + '/');

					ws.onmessage = function (event) {
						checkedAssets = {};
						assetsToAccept = [];
						var data = JSON.parse(event.data);

						if (data.type === 'update') {
							var handled = false;
							data.assets.forEach(function (asset) {
								if (!asset.isNew) {
									var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

									if (didAccept) {
										handled = true;
									}
								}
							}); // Enable HMR for CSS by default.

							handled =
								handled ||
								data.assets.every(function (asset) {
									return asset.type === 'css' && asset.generated.js;
								});

							if (handled) {
								console.clear();
								data.assets.forEach(function (asset) {
									hmrApply(global.parcelRequire, asset);
								});
								assetsToAccept.forEach(function (v) {
									hmrAcceptRun(v[0], v[1]);
								});
							} else if (location.reload) {
								// `location` global exists in a web worker context but lacks `.reload()` function.
								location.reload();
							}
						}

						if (data.type === 'reload') {
							ws.close();

							ws.onclose = function () {
								location.reload();
							};
						}

						if (data.type === 'error-resolved') {
							console.log('[parcel] ✨ Error resolved');
							removeErrorOverlay();
						}

						if (data.type === 'error') {
							console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
							removeErrorOverlay();
							var overlay = createErrorOverlay(data);
							document.body.appendChild(overlay);
						}
					};
				}

				function removeErrorOverlay() {
					var overlay = document.getElementById(OVERLAY_ID);

					if (overlay) {
						overlay.remove();
					}
				}

				function createErrorOverlay(data) {
					var overlay = document.createElement('div');
					overlay.id = OVERLAY_ID; // html encode message and stack trace

					var message = document.createElement('div');
					var stackTrace = document.createElement('pre');
					message.innerText = data.error.message;
					stackTrace.innerText = data.error.stack;
					overlay.innerHTML =
						'<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' +
						'<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' +
						'<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' +
						'<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' +
						message.innerHTML +
						'</div>' +
						'<pre>' +
						stackTrace.innerHTML +
						'</pre>' +
						'</div>';
					return overlay;
				}

				function getParents(bundle, id) {
					var modules = bundle.modules;

					if (!modules) {
						return [];
					}

					var parents = [];
					var k, d, dep;

					for (k in modules) {
						for (d in modules[k][1]) {
							dep = modules[k][1][d];

							if (dep === id || (Array.isArray(dep) && dep[dep.length - 1] === id)) {
								parents.push(k);
							}
						}
					}

					if (bundle.parent) {
						parents = parents.concat(getParents(bundle.parent, id));
					}

					return parents;
				}

				function hmrApply(bundle, asset) {
					var modules = bundle.modules;

					if (!modules) {
						return;
					}

					if (modules[asset.id] || !bundle.parent) {
						var fn = new Function('require', 'module', 'exports', asset.generated.js);
						asset.isNew = !modules[asset.id];
						modules[asset.id] = [fn, asset.deps];
					} else if (bundle.parent) {
						hmrApply(bundle.parent, asset);
					}
				}

				function hmrAcceptCheck(bundle, id) {
					var modules = bundle.modules;

					if (!modules) {
						return;
					}

					if (!modules[id] && bundle.parent) {
						return hmrAcceptCheck(bundle.parent, id);
					}

					if (checkedAssets[id]) {
						return;
					}

					checkedAssets[id] = true;
					var cached = bundle.cache[id];
					assetsToAccept.push([bundle, id]);

					if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
						return true;
					}

					return getParents(global.parcelRequire, id).some(function (id) {
						return hmrAcceptCheck(global.parcelRequire, id);
					});
				}

				function hmrAcceptRun(bundle, id) {
					var cached = bundle.cache[id];
					bundle.hotData = {};

					if (cached) {
						cached.hot.data = bundle.hotData;
					}

					if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
						cached.hot._disposeCallbacks.forEach(function (cb) {
							cb(bundle.hotData);
						});
					}

					delete bundle.cache[id];
					bundle(id);
					cached = bundle.cache[id];

					if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
						cached.hot._acceptCallbacks.forEach(function (cb) {
							cb();
						});

						return true;
					}
				}
			},
			{}
		]
	},
	{},
	['../node_modules/parcel-bundler/src/builtins/hmr-runtime.js', 'main.ts'],
	null
);
//# sourceMappingURL=/main.c39d6dcf.js.map
